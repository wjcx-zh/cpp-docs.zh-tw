---
title: ARM64 ABI 慣例概觀
ms.date: 03/27/2019
ms.openlocfilehash: bfe55513ffd24175dbe62efc6d5afcfd82f71e4c
ms.sourcegitcommit: 7f378314c5692d897ead10b7f6c96d4cb2abd266
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/27/2020
ms.locfileid: "88972669"
---
# <a name="overview-of-arm64-abi-conventions"></a>ARM64 ABI 慣例概觀

適用于 Windows 的基本應用程式二進位介面 (ABI) 適用于在64位模式的 ARM 處理器上編譯和執行 (ARMv8 或更新的架構) ，大部分的情況下，會遵循 ARM 的標準 AArch64 EABI。 本文將重點放在 EABI 中記載的一些重要假設和變更。 如需32位 ABI 的詳細資訊，請參閱 [ARM abi 慣例總覽](overview-of-arm-abi-conventions.md)。 如需標準 ARM EABI 的詳細資訊，請參閱 [ARM 架構的應用程式二進位介面 (ABI) ](http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.subset.swdev.abi/index.html) (外部連結) 。

## <a name="definitions"></a>定義

隨著64位支援的推出，ARM 定義了數個詞彙：

- **AArch32** –舊版32位指令集架構 (由 ARM 定義的 ISA) ，包括 Thumb 模式執行。
- **AArch64** –新的64位指令集架構 (由 ARM 定義的 ISA) 。
- **ARMv7** –「第7代」 ARM 硬體的規格，其中只包含對 AArch32 的支援。 此版本的 ARM 硬體是第一個支援 ARM 版本的 Windows。
- **ARMv8** –「第8代」 ARM 硬體的規格，其中包含 AArch32 和 AArch64 的支援。

Windows 也會使用下列詞彙：

- **Arm** –指的是32位 arm 架構 (AArch32) ，有時也稱為 arm) 上的 WoA (Windows。
- **ARM32** –與上面的 ARM 相同;為了清楚起見，本檔中使用。
- **ARM64** –指的是64位 ARM 架構 (AArch64) 。 WoA64 沒有這樣的東西。

最後，在參考資料類型時，會參考 ARM 中的下列定義：

- **短向量** -直接在 SIMD 中表示的資料類型，這是8個位元組或16個位元組的元素。 它會對齊其大小（8個位元組或16個位元組），其中每個元素可以是1、2、4或8個位元組。
- **HFA (同質浮點數匯總) ** –具有2到4個相同浮點數成員的資料類型，不論是浮點數或雙精度浮點數。
- **HVA (同質的短向量匯總) ** –具有2到4個相同短向量成員的資料類型。

## <a name="base-requirements"></a>基底需求

ARM64 版本的 Windows presupposes，它會隨時在 ARMv8 或更新的架構上執行。 浮點數和霓虹燈支援都會假設存在於硬體中。

ARMv8 規格會描述 AArch32 和 AArch64 的新的選擇性加密和 CRC 協助程式碼。 支援它們目前是選擇性的，但建議使用。 為了充分利用這些 opcode，應用程式應該先使執行時間檢查是否存在。

## <a name="endianness"></a>位元組序

如同 ARM32 版的 Windows，在 ARM64 視窗上以位元組由小到大模式執行。 在 AArch64 中不支援核心模式的情況下，切換位元組程式性很難達成，因此更容易強制執行。

## <a name="alignment"></a>對齊

在 ARM64 上執行的 Windows 可讓 CPU 硬體以透明的方式處理未對齊的存取。 在 AArch32 的改進中，這項支援現在也適用于所有整數存取 (包括多字存取) 和浮點數存取。

但是，存取未快取的 (裝置) 記憶體仍必須保持一致。 如果程式碼可能會從未快取的記憶體讀取或寫入未對齊的資料，則必須確定對齊所有的存取。

區域變數的預設版面配置對齊：

| 大小 (位元組) | 以位元組為單位的對齊 |
| - | - |
| 1 | 1 |
| 2 | 2 |
| 3、4 | 4 |
| > 4 | 8 |

全域和靜態靜態的預設版面配置對齊：

| 大小 (位元組) | 以位元組為單位的對齊 |
| - | - |
| 1 | 1 |
| 2 - 7 | 4 |
| 8 - 63 | 8 |
| >= 64 | 16 |

## <a name="integer-registers"></a>整數暫存器

AArch64 架構支援32整數暫存器：

| 註冊 | 動態？ | 角色 |
| - | - | - |
| x0 | 動態 | 參數/臨時註冊1，結果暫存器 |
| x1-x7 | 動態 | 參數/臨時暫存器2-8 |
| x8-x15 | 動態 | 臨時暫存器 |
| x16-x17 | 動態 | 內部程序呼叫的臨時暫存器 |
| x18 | 靜態 | 平臺註冊：在核心模式中，指向目前處理器的 KPCR;在使用者模式中，指向 TEB |
| x19-x28 | 靜態 | 臨時暫存器 |
| x29/fp | 靜態 | 框架指標 |
| x30/lr | 靜態 | 連結暫存器 |

您可以透過 x30) 或32位值 (via w0-w30) ，將每個暫存器存取為完整的64位值 (。 32位作業零-將其結果延伸至64位。

如需使用參數暫存器的詳細資訊，請參閱參數傳遞一節。

不同于 AArch32，程式計數器 (電腦) ，而 (SP) 的堆疊指標不是索引的暫存器。 它們的存取方式有所限制。 另請注意，沒有 x31 註冊。 這種編碼是用於特殊用途。

需要 (x29) 的框架指標，才能與 ETW 和其他服務所使用的快速堆疊審核相容。 它必須指向堆疊上先前的 {x29，x30} 配對。

## <a name="floating-pointsimd-registers"></a>浮點數/SIMD 暫存器

AArch64 架構也支援32浮點數/SIMD 暫存器，摘要如下：

| 註冊 | 動態？ | 角色 |
| - | - | - |
| v0 | 動態 | 參數/臨時註冊1，結果暫存器 |
| v1-v7 | 動態 | 參數/臨時暫存器2-8 |
| v8-v15 | 靜態 | 臨時暫存器 (只有低64位不是暫時性的)  |
| v16-v31 | 動態 | 臨時暫存器 |

您可以透過 v0-v31 或 q0-q31) ，以完整的128位 (值存取每個註冊。 您可以透過 d31) 以64位值的形式來存取它， (透過 s0-s31) 的 (32 位值、透過 h0-h31 (以16位值) ，或以8位值 (via B0-b31) 。 小於128位的存取權只會存取完整128位註冊的較低位。 除非另有指定，否則不會保留其餘的位。  (AArch64 與 AArch32 不同，因為較小的暫存器會封裝在較大的暫存器上方。 ) 

浮點數控制項暫存器 (FPCR) 在其中的各種位欄位上有特定需求：

| Bits | 意義 | 動態？ | 角色 |
| - | - | - | - |
| 26 | AHP | 非暫時性 | 替代的半精確度控制項。 |
| 25 | DN | 非暫時性 | 預設的 NaN 模式控制項。 |
| 24 | FZ | 靜態 | 清除為零的模式控制項。 |
| 23-22 | RMode | 靜態 | 舍入模式控制項。 |
| 15、12-8 | IDE/IXE/etc | 非暫時性 | 例外狀況陷阱啟用位，必須一律為0。 |

## <a name="system-registers"></a>系統註冊

如同 AArch32，AArch64 規格提供三個系統控制的「執行緒識別碼」暫存器：

| 註冊 | 角色 |
| - | - |
| TPIDR_EL0 | 保留的。 |
| TPIDRRO_EL0 | 包含目前處理器的 CPU 數目。 |
| TPIDR_EL1 | 指向目前處理器的 KPCR 結構。 |

## <a name="floating-point-exceptions"></a>浮點例外狀況

在 AArch64 系統上，支援 IEEE 浮點例外狀況是選擇性的。 對於具有硬體浮點例外狀況的處理器變體，Windows 核心會以無訊息方式攔截例外狀況，並在 FPCR 暫存器中隱含停用它們。 此陷阱可確保跨處理器變異的標準化行為。 否則，在沒有例外狀況支援的平臺上開發的程式碼，可能會在支援的平臺上執行時發現非預期的例外狀況。

## <a name="parameter-passing"></a>參數傳遞

針對非 variadic 函式，Windows ABI 會遵循 ARM 針對參數傳遞所指定的規則。 這些規則會直接從 AArch64 架構的 Procedure 呼叫標準摘錄：

### <a name="stage-a--initialization"></a>階段 A –初始化

這個階段只會在處理引數開始之前完成一次。

1. 下一個一般用途的註冊編號 (NGRN) 設定為零。

1. 下一個 SIMD 和浮點數暫存器編號 (NSRN) 設定為零。

1. 下一個堆疊引數位址 (NSAA) 會設定為目前的堆疊指標值 (SP) 。

### <a name="stage-b--pre-padding-and-extension-of-arguments"></a>階段 B –引數的預先填入和延伸

針對清單中的每個引數，會套用下列清單中的第一個比對規則。 如果沒有符合的規則，則會使用引數進行未經修改。

1. 如果引數型別是一種複合類型，其大小無法由呼叫端和被呼叫端以靜態方式判斷，則會將引數複製到記憶體，並將該引數取代為複製的指標。  (C/c + + 中沒有這種類型，但它們存在於其他語言或語言延伸模組) 。

1. 如果引數型別是 HFA 或 HVA，則會使用未修改的引數。

1. 如果引數類型是大於16個位元組的複合類型，則會將引數複製到呼叫端所配置的記憶體，並將該引數取代為複製的指標。

1. 如果引數類型是複合類型，則引數的大小會進位到最接近8個位元組的倍數。

### <a name="stage-c--assignment-of-arguments-to-registers-and-stack"></a>階段 C –將引數指派給註冊和堆疊

針對清單中的每個引數，會依序套用下列規則，直到配置引數為止。 將引數指派給暫存器時，註冊中任何未使用的位都有未指定的值。 如果將引數指派給堆疊位置，任何未使用的填補位元組都有未指定的值。

1. 如果引數是半個、單一、雙精度浮點數或最小的向量類型，而且 NSRN 小於8，則引數會配置給 register v NSRN 的最小有效位 \[ 。 NSRN 會以1遞增。 現在已配置引數。

1. 如果引數是 HFA 或 HVA，而且有足夠的未配置 SIMD 和浮點數暫存器 (NSRN + 的成員數目≤ 8) ，則引數會配置給 SIMD 和浮點數暫存器，每個 HFA 或 HVA 的成員都有一個暫存器。 NSRN 會以使用的暫存器數目遞增。 現在已配置引數。

1. 如果引數是 HFA 或 HVA，則 NSRN 設定為8，而且引數的大小會進位到最接近8個位元組的倍數。

1. 如果引數為 HFA、HVA、雙精確度浮點數或短向量類型，則 NSAA 會四捨五入為較大的8或引數類型的自然對齊。

1. 如果引數是半或單精確度浮點數型別，則引數的大小會設定為8個位元組。 效果就像引數已複製到64位暫存器的最小有效位，其餘的位則填滿未指定的值。

1. 如果引數為 HFA、HVA、半個、單一、雙精度浮點數或雙精確度浮點數或短向量類型，則會將引數複製到已調整之 NSAA 的記憶體。 NSAA 會增加引數的大小。 現在已配置引數。

1. 如果引數是整數或指標類型，則引數的大小小於或等於8個位元組，且 NGRN 小於8，則引數會複製到 x NGRN 中最小的有效位 \[ 。 NGRN 會以1遞增。 現在已配置引數。

1. 如果引數的對齊方式為16，則 NGRN 會無條件進位到下一個偶數。

1. 如果引數是整數類資料類型，則引數的大小等於16，且 NGRN 小於7，則會將引數複製到 x \[ NGRN] 和 x \[ NGRN + 1]。 x \[ NGRN] 應包含引數之記憶體標記法中較低的雙字組。 NGRN 會遞增2。 現在已配置引數。

1. 如果引數是複合類型，而且引數的雙字組大小不超過8減去 NGRN，則引數會複製到連續的一般用途暫存器中，從 x \[ NGRN 開始。 傳遞引數的方式就如同它已從雙字組對齊的位址載入暫存器中，並具有適當的 LDR 指令順序，可從記憶體載入連續的暫存器。 此標準未指定任何未使用部分的暫存器內容。 NGRN 會以使用的暫存器數目遞增。 現在已配置引數。

1. NGRN 設定為8。

1. NSAA 會無條件進位到較大的8或引數類型的自然對齊。

1. 如果引數是複合類型，則引數會在已調整的 NSAA 複製到記憶體中。 NSAA 會增加引數的大小。 現在已配置引數。

1. 如果引數的大小小於8個位元組，則引數的大小會設定為8個位元組。 其效果就像是將引數複製到64位暫存器的最小有效位，其餘的位則填滿未指定的值。

1. 引數會在已調整的 NSAA 複製到記憶體。 NSAA 會增加引數的大小。 現在已配置引數。

### <a name="addendum-variadic-functions"></a>附錄： Variadic 函式

採用可變數目引數的函式會以不同于上面的方式處理，如下所示：

1. 所有複合都會視為相同;HFAs 或 Hva 沒有特殊處理。

1. 未使用 SIMD 和浮點數暫存器。

實際上，它與下列規則相同，也就是使用 C. 12 – c. 將引數配置給虛數堆疊，其中堆疊的前64個位元組會載入至 x0 x7，而任何剩餘的堆疊引數都會正常放置。

## <a name="return-values"></a>傳回值

在 x0 中會傳回整數值。

視需要在 s0、d0 或 v0 中傳回浮點值。

HFA 和 HVA 值會適當地在 s0-s3、d0 或 v0-v3 中傳回。

根據值傳回的型別會根據它們是否有特定屬性，以及函式是否為非靜態成員函式，來處理不同的類型。 具有這些屬性的類型。

- 它們是由 c + + 14 標準定義所 *匯總* ，也就是沒有任何使用者提供的函式、私用或受保護的非靜態資料成員、基類和虛擬函式，以及
- 它們具有簡單的複製指派運算子，而且
- 它們具有簡單的函式，

和由非成員函式或靜態成員函式傳回，請使用下列傳回樣式：

- 在 x0 中會傳回小於或等於8個位元組的類型。
- 小於或等於16個位元組的類型會在 x0 和 x1 中傳回，而包含較低順序8個位元組的 x0。
- 針對大於16個位元組的類型，呼叫端應該保留足夠的大小和對齊方式來容納結果的記憶體區塊。 記憶體區塊的位址應該以 x8 的額外引數形式傳遞給函數。 被呼叫端可能會在副程式執行期間的任何時間點修改結果記憶體區塊。 被呼叫端不需要保留儲存在 x8 中的值。

所有其他類型都會使用此慣例：

- 呼叫端應該保留足夠的大小和對齊方式來容納結果的記憶體區塊。 如果 $this 是以 x0 傳遞，則應該將記憶體區塊的位址當作額外的引數傳遞至 x0 中的函數，或為 x1。 被呼叫端可能會在副程式執行期間的任何時間點修改結果記憶體區塊。 被呼叫端會以 x0 傳回記憶體區塊的位址。

## <a name="stack"></a>Stack

在 ARM 所 put 的 ABI 之後，堆疊隨時都必須維持16位元組的對齊。 AArch64 包含的硬體功能，會在 SP 沒有16位元組對齊，且 SP 相對載入或存放區完成時，產生堆疊對齊錯誤。 在任何時候，都已啟用這項功能的 Windows 執行。

配置4k 或更多的堆疊的函式，必須確保最終頁面之前的每個頁面依序觸及。 此動作可確保程式碼無法「超越」 Windows 用來展開堆疊的防護頁面。 這通常是由協助專家完成 `__chkstk` ，其具有自訂呼叫慣例，會將堆疊配置總數除以 x15 中的16。

## <a name="red-zone"></a>紅色區域

目前堆疊指標正下方的16位元組區域會保留供分析和動態修補案例使用。 此區域允許插入的程式碼會在 [sp，#-16] 上儲存兩個暫存器，並暫時使用它們來進行任意用途。 Windows 核心保證在使用者和核心模式中採用例外狀況或中斷時，不會覆寫這16個位元組。

## <a name="kernel-stack"></a>核心堆疊

Windows 中的預設核心模式堆疊是 (24k) 的六個頁面。 在核心模式中特別注意具有大型堆疊緩衝區的函式。 錯誤計時的插斷可能會有很多空間，並建立堆疊異常錯誤檢查。

## <a name="stack-walking"></a>堆疊行走

Windows 中的程式碼會在已啟用框架指標的情況下進行編譯 ([/Oy-](reference/oy-frame-pointer-omission.md)) ，以啟用快速堆疊流覽。 一般而言，x29 (fp) 指向鏈中的下一個連結，也就是 {fp，lr} 組，指出堆疊上先前框架的指標和傳回位址。 建議您也可以使用協力廠商程式碼來啟用框架指標，以提供更好的分析和追蹤。

## <a name="exception-unwinding"></a>例外狀況回溯

在例外狀況處理期間回溯會透過使用回溯程式碼來協助。 回溯程式碼是儲存在可執行檔的 .xdata 區段中的位元組序列。 它們以抽象的方式描述序言和結尾的作業，因此函式序言的影響可以在準備備份至呼叫端的堆疊框架時復原。 如需回溯程式碼的詳細資訊，請參閱 [ARM64 例外狀況處理](arm64-exception-handling.md)。

ARM EABI 也會指定使用回溯程式碼的例外狀況回溯模型。 不過，所呈現的規格不足以在 Windows 中回溯，因此必須處理電腦位於函式序言或結尾中間的情況。

動態產生的程式碼應該透過和相關聯的函式與動態函式資料表一起描述 `RtlAddFunctionTable` ，如此產生的程式碼就可以參與例外狀況處理。

## <a name="cycle-counter"></a>Cycle 計數器

所有的 ARMv8 Cpu 都必須支援迴圈計數器暫存器，也就是 Windows 設定為在任何例外狀況層級（包括使用者模式）可讀取的64位暫存器。 您可以使用程式碼中的 MSR opcode 或 `_ReadStatusReg` c/c + + 程式碼內建，透過特殊的 PMCCNTR_EL0 註冊來存取它。

此處的迴圈計數器是真正的週期計數器，而不是時鐘。 計數頻率會隨著處理器頻率而有所不同。 如果您覺得您必須知道迴圈計數器的頻率，則不應使用迴圈計數器。 相反地，您想要測量應使用的時鐘時間 `QueryPerformanceCounter` 。

## <a name="see-also"></a>另請參閱

[Visual C++ ARM 移轉時常見的問題](common-visual-cpp-arm-migration-issues.md)<br/>
[ARM64 例外狀況處理](arm64-exception-handling.md)
