---
title: x64 堆疊使用方式
ms.date: 12/17/2018
ms.assetid: 383f0072-0438-489f-8829-cca89582408c
ms.openlocfilehash: b1b1e0a8c30d5e24e81372912d5c488efce14841
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 07/27/2020
ms.locfileid: "87218932"
---
# <a name="x64-stack-usage"></a>x64 堆疊使用方式

超出目前 .RSP 位址的所有記憶體都視為 volatile： OS 或偵錯工具可能會在使用者的 debug 會話或中斷處理常式期間覆寫此記憶體。 因此，在嘗試讀取或寫入堆疊框架的值之前，必須一律設定 .RSP。

本節討論本機變數和**alloca**內建函式的堆疊空間配置。

## <a name="stack-allocation"></a>堆疊配置

函式的初構會負責配置本機變數、儲存的暫存器、堆疊參數和暫存器參數的堆疊空間。

參數區域一律會在堆疊底部（即使 `alloca` 使用了），以便在任何函式呼叫期間，一律會與傳回位址相鄰。 它至少包含四個專案，但一定要有足夠的空間來保存任何可能呼叫的函式所需的所有參數。 請注意，即使參數本身永遠不會在堆疊中，還是會配置暫存器參數的空間;被呼叫端保證已配置給其所有參數的空間。 暫存器引數需要 Home 位址，因此如果被呼叫的函式需要取得引數清單（va_list）或個別引數的位址，則會有連續的區域可供使用。 這個區域也提供一個方便的位置，可在 Thunk 執行期間儲存暫存器引數，以及做為偵錯工具選項（例如，如果引數是儲存在初構程式碼中的主位址，則會在進行偵錯工具時容易找到）。 即使被呼叫函式的參數少於4個，這4個堆疊位置實際上是由被呼叫的函式所擁有，而且可供被呼叫的函式用於其他目的，除了儲存參數暫存器值以外。  因此，呼叫端可能不會跨函式呼叫，將資訊儲存在堆疊的這個區域中。

如果在函式中動態配置（ `alloca` ）空間，則必須使用靜態暫存器做為框架指標，以標記堆疊固定部分的基底，而且必須在初構中儲存和初始化暫存器。 請注意，當 `alloca` 使用時，從相同呼叫者對相同被呼叫端的呼叫，其暫存器參數可能會有不同的主位址。

堆疊一律會維持16位元組對齊，但不包括在初構中（例如，推送傳回位址之後），以及在特定框架函式類別的函式[類型](#function-types)中指出的位置除外。

以下是堆疊配置的範例，其中函式 A 會呼叫非分葉函式 B。函式 A 的初構已為堆疊底部的 B 所需的所有暫存器和堆疊參數配置空間。 此呼叫會推送傳回位址和 B 的初構，為其區域變數、非靜態暫存器配置空間，以及呼叫函式所需的空間。 如果 B 使用 `alloca` ，則會在本機變數/靜態暫存器儲存區域和參數堆疊區域之間配置空間。

![AMD 轉換範例](../build/media/vcamd_conv_ex_5.png "AMD 轉換範例")

當函式 B 呼叫另一個函式時，會將傳回位址推送至 RCX 的首頁位址正下方。

## <a name="dynamic-parameter-stack-area-construction"></a>動態參數堆疊區域結構

如果使用框架指標，則會有選項可動態建立參數堆疊區域。 這目前不是在 x64 編譯器中完成。

## <a name="function-types"></a>函式類型

基本上有兩種類型的函數。 需要堆疊框架的函式稱為*框架函數*。 不需要堆疊框架的函式稱為分*葉函數*。

Frame 函數是配置堆疊空間、呼叫其他函式、儲存非靜態暫存器，或使用例外狀況處理的函式。 它也需要函數資料表專案。 框架函數需要初構和終解。 框架函式可以動態配置堆疊空間，並且可以使用框架指標。 Frame 函式具有此呼叫標準的完整功能，其為其處置。

如果框架函式不會呼叫另一個函式，則不需要對齊堆疊（在區段[堆疊配置](#stack-allocation)中參考）。

分葉函數是不需要函式資料表專案的函式。 它無法對任何非靜態暫存器進行變更，包括 RSP，這表示它無法呼叫任何函式或配置堆疊空間。 允許堆疊在執行時保持未對齊。

## <a name="malloc-alignment"></a>malloc 對齊

[malloc](../c-runtime-library/reference/malloc.md)保證會傳回適當對齊的記憶體，以儲存具有基本對齊的任何物件，而且可以符合配置的記憶體數量。 *基本對齊*是指小於或等於執行所支援之最大對齊的對齊方式，而不需要對齊規格。 （在 Visual C++ 中，這是一個 **`double`** 或8個位元組所需的對齊方式。 在以64位平臺為目標的程式碼中，它是16個位元組）。例如，四個位元組的配置會對齊支援任何四位元組或較小物件的界限。

Visual C++ 允許具有*延伸對齊*的類型，也稱為「*過度對齊*」類型。 例如，SSE 型別[__m128](../cpp/m128.md)和、而使用所宣告的型別（ `__m256` `__declspec(align( n ))` 其中 `n` 大於8）具有延伸對齊。 不保證在適合需要延伸對齊之物件的界限上進行記憶體對齊 `malloc` 。 若要為過度對齊的類型配置記憶體，請使用[_aligned_malloc](../c-runtime-library/reference/aligned-malloc.md)和相關的函式。

## <a name="alloca"></a>alloca

[_alloca](../c-runtime-library/reference/alloca.md)必須對齊16位元組，而且還需要使用框架指標。

已配置的堆疊必須在後續所呼叫函式的參數後面包含空格，如[堆疊配置](#stack-allocation)中所述。

## <a name="see-also"></a>另請參閱

[x64 軟體慣例](../build/x64-software-conventions.md)<br/>
[對齊](../cpp/align-cpp.md)<br/>
[__declspec](../cpp/declspec.md)
