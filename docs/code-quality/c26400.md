---
title: C26400
ms.date: 08/02/2017
ms.topic: conceptual
f1_keywords:
- C26400
helpviewer_keywords:
- C26400
ms.assetid: b27e1c6d-8b52-40b3-9760-b93afef19c7a
ms.openlocfilehash: a88eab254921560a3b77869c7c4061562e320836
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 07/27/2020
ms.locfileid: "87202424"
---
# <a name="c26400-no_raw_pointer_assignment"></a>C26400 NO_RAW_POINTER_ASSIGNMENT

這項檢查有助於強制執行*規則。11：絕對不會透過原始指標（t \* ）來傳送擁有權*，這是規則 R 的子集。 *3：原始指標（a T \* ）是非擁有的。* 具體來說，它會在呼叫 operator 時發出警告，將 `new` 其結果儲存在原始指標類型的變數中。 它也會警告函式的呼叫， `gsl::owner<T>` 如果其結果已指派給原始指標，則會傳回。 這裡的想法是，您應該清楚地陳述記憶體資源的擁有權。 如需詳細資訊，請參閱[C++ Core Guidelines](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#r-resource-management)。

若要修正此問題，最簡單的方法是使用宣告（ **`auto`** 如果在變數宣告中立即指派資源）。 如果無法這麼做，則建議使用類型 `gsl::owner<T>` 。 使用運算子初始化的宣告為「擁有者」， **`auto`** **`new`** 因為我們假設任何配置的結果都是隱含的擁有者指標。 我們會將此假設轉移至 **`auto`** 變數，並將其視為 `owner<T>` 。

如果這項檢查旗標呼叫傳回的函 `owner<T>` 式，這可能表示程式碼中有合法的錯誤。 基本上，它會指向程式碼遺漏擁有權的明確概念（也可能是資源本身）的位置。

## <a name="remarks"></a>備註

此規則目前只會檢查本機變數。 如果配置已指派給型式參數、全域變數、類別成員等等，則不會加上旗標。 這類案例的適當涵蓋範圍是未來工作的一部分。

## <a name="example-1-simple-allocation"></a>範例1：簡單配置

```cpp
char *buffer = nullptr;
if (useCache)
    buffer = GetCache();
else
    buffer = new char[bufferSize];  // C26400
```

## <a name="example-2-simple-allocation-fixed-with-gslownert"></a>範例2：簡單配置（已修正 gsl：： owner \<T> ）

```cpp
gsl::owner<char*> buffer = nullptr;
if (useCache)
    buffer = GetCache();
else
    buffer = new char[bufferSize];  // OK

Example 3: Simple allocation (fixed with auto)
auto buffer = useCache ? GetCache() : new char[bufferSize]; // OK
```
