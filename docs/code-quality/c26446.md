---
title: C26446
ms.date: 03/22/2018
ms.topic: reference
f1_keywords:
- C26446
helpviewer_keywords:
- C26446
ms.openlocfilehash: eff94d61f6c792a6ad720a24b049a25d9d354f91
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 07/27/2020
ms.locfileid: "87215071"
---
# <a name="c26446-use_gsl_at"></a>C26446 USE_GSL_AT

偏好使用， `gsl::at()` 而不是取消核取的注標運算子。

C++ Core Guidelines：[界限. 4：不使用不是界限檢查的標準程式庫函式和類型](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#probounds-bounds-safety-profile)。

C++ Core Guidelines 的界限設定檔會藉由避免使用原始指標和未檢查的作業，而嘗試排除不安全的記憶體操作。 若要對緩衝區執行統一範圍檢查的存取，其中一種方式是使用 `gsl::at()` 指導方針支援程式庫中的公用程式。 您也最好依賴 `at()` STL 容器中可用的標準實現。

此規則有助於找出可能透過呼叫 operator] （）來執行未檢查之存取的位置 \[ 。 在大部分情況下，這類呼叫可以輕鬆地由取代 `gsl::at()` 。

- 在注標運算子中使用非常數索引時，會標示具有已知大小之陣列的存取權。 常數索引是由[C26483 STATIC_INDEX_OUT_OF_RANGE](c26483.md)處理。
- 對多載的運算子 [] 呼叫發出警告的邏輯更為複雜：
  - 如果索引不是整數，則會忽略呼叫。 這也會處理標準對應中的索引編制，因為這類運算子中的參數是以傳址方式傳遞。
  - 如果運算子標示為非擲回（藉由使用 **`noexcept`** 、 **throw （）** 或 **`__declspec(nothrow)`** ），則呼叫會加上旗標。 假設注標運算子永遠不會擲回例外狀況，則不會執行範圍檢查，或這些檢查會模糊。
  - 如果運算子未標記為非擲回，則可能會標示其是否來自同時定義了傳統成員函式的 STL 容器 `at()` （這類函式是由簡單名稱比對所偵測）。
  - 規則不會在呼叫標準函式時發出警告 `at()` 。 這些函式是安全的，並以取代它們，因此 `gsl::at()` 不會帶來太大的價值。
- 的索引編制 `std::basic_string_view<>` 並不安全，因此會發出警告。 標準字串視圖可以取代 `gsl::basic_string_span<>` 為，這一律會進行界限檢查。
- 此執行不會考慮使用者程式碼可能在迴圈或分支中的某處進行範圍檢查。 這裡的精確度是針對效能而進行交易。 一般而言，明確範圍檢查通常會取代為更可靠的反覆運算器，或更精確的 for 迴圈增強功能。
