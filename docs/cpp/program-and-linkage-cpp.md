---
title: 轉譯單位和連結（c + +）
ms.date: 12/11/2019
ms.assetid: a6493ba0-24e2-4c89-956e-9da1dea660cb
ms.openlocfilehash: 5a166efc7ae926f6b028c35007b0972d0a652d6d
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 07/27/2020
ms.locfileid: "87227188"
---
# <a name="translation-units-and-linkage"></a>編譯單位和連結

在 c + + 程式中，*符號*（例如變數或函式名稱）可以在其範圍內宣告任意次數，但只能定義一次。 此規則是「一個定義規則」（ODR）。 宣告*會在程式中引進（* 或重新引進）名稱。 *定義*會引進名稱。 如果名稱代表變數，定義會明確地將其初始化。 *函式定義*包含簽章加上函數主體。 類別定義包含類別名稱，後面接著列出所有類別成員的區塊。 （成員函式的主體可以選擇性地分別在另一個檔案中定義）。

下列範例顯示一些宣告：

```cpp
int i;
int f(int x);
class C;
```

下列範例顯示一些定義：

```cpp
int i{42};
int f(int x){ return x * i; }
class C {
public:
   void DoSomething();
};
```

程式是由一個或多個*轉譯單位*所組成。 轉譯單位是由一個執行檔案和它直接或間接包含的所有標頭所組成。 執行檔的副檔名通常是*cpp*或 *.cxx*。 標頭檔的副檔名通常是*h*或*措施*。 每個轉譯單位都是由編譯器獨立編譯。 編譯完成後，連結器會將編譯過的轉譯單位合併成單一*程式*。 違反 ODR 規則通常會顯示為連結器錯誤。 當相同的名稱在不同的轉譯單位中有兩個不同的定義時，就會發生連結器錯誤。

一般來說，讓變數在多個檔案中可見的最佳方式，是將它放在標頭檔中。 然後，在每個需要宣告的*cpp*檔案中加入 #include 指示詞。 藉由新增包含對標頭內容的*防護*，您可以確保它所宣告的名稱只會定義一次。

在 c + + 20 中，[模組](modules-cpp.md)會引進為標頭檔的改良替代方案。

在某些情況下，可能需要在*cpp*檔案中宣告全域變數或類別。 在這些情況下，您需要一種方法來告訴編譯器和連結器名稱有何種*連結*。 連結的類型會指定物件的名稱是否只適用于一個檔案或所有檔案。 連結的概念僅適用于全域名稱。 連結的概念並不適用于在範圍內宣告的名稱。 範圍是由一組括住的大括弧所指定，例如函式或類別定義中的。

## <a name="external-vs-internal-linkage"></a>外部與內部連結

*Free 函數*是在全域或命名空間範圍中定義的函式。 非 const global 變數和 free 函數預設具有*外部連結*;您可以從程式中的任何轉譯單位看到它們。 因此，沒有其他全域物件可以擁有該名稱。 具有*內部連結*或*沒有連結*的符號，只有在宣告它的轉譯單位內才可見。 當名稱具有內部連結時，相同的名稱可能會存在於另一個轉譯單位中。 在類別定義或函式主體內宣告的變數沒有連結。

您可以將全域名稱明確宣告為，以強制使用內部連結 **`static`** 。 這會限制其在宣告時的相同轉譯單位可見度。 在此內容中， **`static`** 表示套用至本機變數時的內容不同。

下列物件預設具有內部連結：

- const 物件
- constexpr 物件
- typedefs
- 命名空間範圍中的靜態物件

若要提供常數物件外部連結，請將它宣告為 **`extern`** ，並將值指派給它：

```cpp
extern const int value = 42;
```

如需詳細資訊，請參閱[extern](extern-cpp.md) 。

## <a name="see-also"></a>另請參閱

[基本概念](../cpp/basic-concepts-cpp.md)
