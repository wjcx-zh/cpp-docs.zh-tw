---
title: 連結器工具錯誤 LNK2001
ms.date: 12/19/2019
f1_keywords:
- LNK2001
helpviewer_keywords:
- LNK2001
ms.assetid: dc1cf267-c984-486c-abd2-fd07c799f7ef
ms.openlocfilehash: 59915b3aa0ad25b5638a43a6d09dccc2b42825ab
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 07/27/2020
ms.locfileid: "87230567"
---
# <a name="linker-tools-error-lnk2001"></a>連結器工具錯誤 LNK2001

> 無法解析的外部符號 "*symbol*"

已編譯的程式碼會對*符號*進行參考或呼叫。 此符號不會定義在連結器所搜尋的任何文件庫或物件檔案中。

此錯誤訊息後面會接著嚴重錯誤[LNK1120](../../error-messages/tool-errors/linker-tools-error-lnk1120.md)。 若要修正錯誤 LNK1120，請先修正所有 LNK2001 和 LNK2019 錯誤。

有許多方法可以取得 LNK2001 錯誤。 這些全都牽涉到連結器無法*解析*的函式或變數*參考*，或尋找的定義。 編譯器可以識別您的程式碼未宣告*符號的時間*，但不會*定義*它的時機。 這是因為定義可能位於不同的原始程式檔或程式庫中。 如果您的程式碼參考符號，但從未定義過，則連結器會產生錯誤。

## <a name="what-is-an-unresolved-external-symbol"></a>什麼是無法解析的外部符號？

*符號*是函數或全域變數的內部名稱。 它是在編譯的物件檔案或程式庫中使用或定義的名稱格式。 全域變數定義于為其配置儲存體的目的檔中。 函式會定義于物件檔案中，其中會放置已編譯器代碼的函式主體。 *外部符號*是一個物件檔案中參考的，但在不同的程式庫或物件檔案中定義。 *匯出的符號*是物件檔案或定義它的程式庫可公開取得的符號。

若要建立應用程式或 DLL，使用的每個符號都必須有定義。 連結器必須針對每個物件檔案所參考的每個外部符號，*解析*或尋找的相符定義。 當連結器無法解析外部符號時，會產生錯誤。 這表示連結器在任何連結的檔案中找不到相符的已匯出符號定義。

## <a name="compilation-and-link-issues"></a>編譯和連結問題

可能會發生此錯誤：

- 當專案遺漏程式庫的參考時（。LIB）或物件（。OBJ）檔案。 若要修正此問題，請將所需程式庫或物件檔案的參考新增至您的專案。 如需詳細資訊，請參閱[lib 檔案做為連結器輸入](../../build/reference/dot-lib-files-as-linker-input.md)。

- 當專案具有程式庫的參考時（。LIB）或物件（。OBJ）檔案，該檔案接著需要另一個程式庫的符號。 即使您未呼叫造成相依性的函式，也可能會發生這種情況。 若要修正此問題，請將另一個程式庫的參考新增至您的專案。 如需詳細資訊，請參閱[瞭解適用于連結的傳統模型：將符號與下一併取得](https://devblogs.microsoft.com/oldnewthing/20130108-00/?p=5623)。

- 如果您使用[/NODEFAULTLIB](../../build/reference/nodefaultlib-ignore-libraries.md)或[/zl](../../build/reference/zl-omit-default-library-name.md)選項，則為。 當您指定這些選項時，除非您明確包含必要的程式碼，否則程式庫不會連結至專案。 若要修正此問題，請明確包含您在連結命令列上使用的所有程式庫。 當您使用這些選項時，如果看到許多遺漏的 CRT 或標準程式庫函式名稱，請在連結中明確包含 CRT 和標準程式庫 Dll 或程式庫檔案。

- 如果您使用 **/clr**選項進行編譯，則為。 可能有遺失的參考 `.cctor` 。 如需如何修正此問題的詳細資訊，請參閱[混合元件的初始化](../../dotnet/initialization-of-mixed-assemblies.md)。

- 如果您在建立應用程式的 debug 版本時連結至發行模式庫。 同樣地，如果您使用 [選項 **/MTd** ] 或 [ **/MDd** ] 或 [定義]， `_DEBUG` 然後連結至發行程式庫，您應該會預期許多可能無法解析的外部應用，還有其他問題。 將發行模式組建與調試程式庫連結也會造成類似的問題。 若要修正此問題，請確定您在您的「偵錯工具」組建中使用「debug 程式庫」，並在零售組建中使用零售程式庫。

- 如果您的程式碼參考某個程式庫版本的符號，但您連結的是不同版本的程式庫。 一般來說，您不能混用針對不同版本編譯器所建立的物件檔案或程式庫。 隨附于某個版本的程式庫可能包含在其他版本所包含的程式庫中找不到的符號。 若要修正此問題，請先建立具有相同編譯器版本的所有目的檔和程式庫，然後再將它們連結在一起。 如需詳細資訊，請參閱[c + + 二進位相容性 2015-2019](../../porting/binary-compat-2015-2017.md)。

- 如果程式庫路徑已過期，則為。 在 [連結**庫**檔案] 選取專案底下， **> [VC + + 目錄**] 對話方塊中的 [工具] > 選項 >，可讓您變更程式庫搜尋順序。 專案的 [屬性頁] 對話方塊中的 [連結器] 資料夾可能也包含可能已過期的路徑。

- 當安裝新的 Windows SDK 時（可能是不同的位置）。 程式庫搜尋順序必須更新為指向新的位置。 一般來說，您應該將新 SDK 的路徑包含和 lib 目錄放在預設的 Visual C++ 位置前面。 此外，包含內嵌路徑的專案仍可能指向有效但過期的舊路徑。 更新安裝至不同位置的新版本所新增的新功能路徑。

- 如果您在命令列中建立，並已建立您自己的環境變數。 確認工具、程式庫和標頭檔的路徑都已移至一致的版本。 如需詳細資訊，請參閱[設定命令列組建的路徑和環境變數。](../../build/setting-the-path-and-environment-variables-for-command-line-builds.md)

## <a name="coding-issues"></a>編碼問題

造成此錯誤的原因可能是：

- 原始程式碼或模組定義（.def）檔案中的大小寫不相符。 例如，如果您將變數命名為 `var1` 一個 c + + 原始程式檔，並嘗試以另一種方式存取它 `VAR1` ，就會產生此錯誤。 若要修正此問題，請使用一致的拼寫和大小寫名稱。

- 使用[函數內嵌](../../error-messages/tool-errors/function-inlining-problems.md)的專案。 當您將函式定義為來源檔案 **`inline`** 中的，而不是在標頭檔中時，就會發生此錯誤。 內嵌函式不能出現在定義它們的原始程式檔外。 若要修正此問題，請在宣告這些函式的標頭中定義內嵌函數。

- 從 c + + 程式呼叫 C 函式，而不使用 `extern "C"` C 函數的宣告。 編譯器會針對 C 和 c + + 程式碼使用不同的內部符號命名慣例。 解析符號時，連結器會尋找內部符號名稱。 若要修正此問題，請使用 c `extern "C"` + + 程式碼中所用 c 函式的所有宣告的包裝函式，這會導致編譯器針對這些符號使用 c 內部命名慣例。 編譯器選項[/tp](../../build/reference/tc-tp-tc-tp-specify-source-file-type.md)和[/tc](../../build/reference/tc-tp-tc-tp-specify-source-file-type.md)會使編譯器分別將檔案編譯為 C + + 或 c，而不論副檔名為何。 這些選項可能會導致內建函式名稱與您所預期的不同。

- 嘗試參考不具有外部連結的函式或資料。 在 c + + 中，內嵌函數和 **`const`** 資料具有內部連結，除非明確指定為 **`extern`** 。 若要修正此問題，請 **`extern`** 在定義原始程式檔外部參考的符號上使用明確宣告。

- 遺漏函式[主體或變數](../../error-messages/tool-errors/missing-function-body-or-variable.md)定義。 當您在程式碼中宣告（但不定義）、變數、函式或類別時，這個錯誤是常見的。 編譯器只需要函式原型或 **`extern`** 變數宣告來產生物件檔案，而不會發生錯誤，但連結器無法解析函數的呼叫或變數的參考，因為沒有任何函式程式碼或變數空間保留。 若要修正此問題，請務必在您連結的原始程式檔或文件庫中定義每個參考的函式和變數。

- 使用傳回和參數類型，或呼叫不符合函式定義中的慣例的函式呼叫。 在 c + + 物件檔中，[名稱裝飾](../../error-messages/tool-errors/name-decoration.md)會將呼叫慣例、類別或命名空間範圍，以及函式的傳回和參數類型編碼。 編碼的字串會成為最後裝飾函式名稱的一部分。 連結器會使用這個名稱來解析或比對函式與其他物件檔案的呼叫。 若要修正此問題，請確定函式宣告、定義和呼叫全都使用相同的範圍、類型和呼叫慣例。

- 當您在類別定義中包含函式原型，但不包含函式[的實](../../error-messages/tool-errors/missing-function-body-or-variable.md)作為時，您呼叫的 c + + 程式碼。 若要修正此問題，請務必提供您所呼叫之所有類別成員的定義。

- 嘗試從抽象基類呼叫純虛擬函式。 純虛擬函式沒有基底類別的實作為。 若要修正此問題，請確定已執行所有已呼叫的虛擬函式。

- 嘗試在該函式的範圍外，使用在函數（[區域變數](../../error-messages/tool-errors/automatic-function-scope-variables.md)）中宣告的變數。 若要修正此問題，請移除不在範圍內之變數的參考，或將變數移至較高的範圍。

- 當您建立 ATL 專案的發行版本時，會產生需要 CRT 啟動程式碼的訊息。 若要修正此問題，請執行下列其中一項動作：

  - `_ATL_MIN_CRT`從預處理器定義清單中移除，以允許包含 CRT 啟動程式碼。 如需詳細資訊，請參閱[一般屬性頁（專案）](../../build/reference/general-property-page-project.md)。

  - 可能的話，請移除需要 CRT 啟始程式碼的 CRT 函式呼叫。 相反地，請使用其 Win32 對等專案。 例如，請使用 `lstrcmp`，而不要使用 `strcmp`。 需要 CRT 啟始程式碼的已知函式，是部分字串和浮點函數。

## <a name="consistency-issues"></a>一致性問題

在編譯器廠商之間，或甚至是相同編譯器的不同版本之間， [c + + 名稱裝飾](../../error-messages/tool-errors/name-decoration.md)目前沒有標準。 以不同編譯器編譯的物件檔可能不會使用相同的命名配置。 連結它們可能會造成錯誤 LNK2001。

在不同模組上[混合內嵌和非內嵌編譯選項](../../error-messages/tool-errors/function-inlining-problems.md)可能會造成 LNK2001。 如果 c + + 程式庫是使用開啟的函式內嵌（**/Ob1**或 **/Ob2**）所建立，但描述函式的對應標頭檔已關閉內嵌（無 **`inline`** 關鍵字），則會發生此錯誤。 若要修正此問題，請在 **`inline`** 您包含在其他原始程式檔中的標頭檔中定義函式。

如果您使用 `#pragma inline_depth` 編譯器指示詞，請確定您已將[值設定為2或更大](../../error-messages/tool-errors/function-inlining-problems.md)，並確定您也使用[/Ob1](../../build/reference/ob-inline-function-expansion.md)或[/Ob2](../../build/reference/ob-inline-function-expansion.md)編譯器選項。

當您建立僅限資源的 DLL 時，如果省略連結選項/NOENTRY，就會發生此錯誤。 若要修正此問題，請將/NOENTRY 選項新增至 link 命令。

如果您在專案中使用不正確的/SUBSYSTEM 或/ENTRY 設定，就會發生這個錯誤。 例如，如果您撰寫主控台應用程式並指定/SUBSYSTEM： WINDOWS，則會產生無法解析的外部錯誤 `WinMain` 。 若要修正此問題，請確定您符合專案類型的選項。 如需這些選項和進入點的詳細資訊，請參閱[/SUBSYSTEM](../../build/reference/subsystem-specify-subsystem.md) and [/ENTRY](../../build/reference/entry-entry-point-symbol.md)連結器選項。

## <a name="exported-def-file-symbol-issues"></a>已匯出 .def 檔案符號問題

找不到在 .def 檔中列出的匯出時，就會發生此錯誤。 這可能是因為匯出不存在、拼寫錯誤，或使用 c + + 裝飾名稱。 .Def 檔案不接受裝飾名稱。 若要修正此問題，請移除不必要的匯出，並使用 `extern "C"` 匯出符號的宣告。

## <a name="use-the-decorated-name-to-find-the-error"></a>使用裝飾名稱來尋找錯誤

C + + 編譯器和連結器使用[名稱裝飾](../../error-messages/tool-errors/name-decoration.md)，亦稱為*名稱重整*。 名稱裝飾會在其符號名稱中編碼變數類型的額外資訊。 函式的符號名稱會將其傳回型別、參數類型、範圍和呼叫慣例編碼。 這個裝飾名稱是連結器搜尋來解析外部符號的符號名稱。

如果函式或變數的宣告與函數或變數的定義不*完全*相符，可能會產生連結錯誤。 這是因為任何差異都會成為要比對之符號名稱的一部分。 即使在呼叫程式碼和定義程式碼中使用相同的標頭檔，也可能會發生此錯誤。 如果您使用不同的編譯器旗標來編譯原始程式檔，可能會發生這種情況。 例如，如果您的程式碼會編譯為使用 **`__vectorcall`** 呼叫慣例，但您連結的是預期用戶端使用預設 **`__cdecl`** 或呼叫慣例來呼叫它的程式庫 **`__fastcall`** 。 在此情況下，符號不相符，因為呼叫慣例不同。

為了協助您找出原因，錯誤訊息會顯示兩個版本的名稱。 它會同時顯示 [易記名稱]、[原始程式碼中使用的名稱] 和 [裝飾名稱] （以括弧括住）。 您不需要知道如何解讀裝飾名稱。 您仍然可以搜尋並與其他裝飾名稱進行比較。 命令列工具可以協助尋找並比較預期的符號名稱和實際的符號名稱：

- DUMPBIN 命令列工具的[/EXPORTS](../../build/reference/dash-exports.md)和[/SYMBOLS](../../build/reference/symbols.md)選項在這裡很有用。 這些檔案可協助您探索哪些符號定義在 .dll 和物件或程式庫檔案中。 您可以使用 [符號] 清單來確認匯出的裝飾名稱符合連結器搜尋的裝飾名稱。

- 在某些情況下，連結器只能報告符號的裝飾名稱。 您可以使用 UNDNAME.EXE 命令列工具來取得裝飾名稱的未修飾形式。

## <a name="additional-resources"></a>其他資源

如需詳細資訊，請參閱 Stack Overflow 問題「未[定義參考/未解析的外部符號錯誤，以及如何修正？](https://stackoverflow.com/q/12573816/2002113)」。
