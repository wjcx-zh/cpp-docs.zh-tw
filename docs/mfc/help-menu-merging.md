---
title: 說明功能表合併
ms.date: 11/04/2016
helpviewer_keywords:
- menus [MFC], merging
- merging Help menus [MFC]
- Help [MFC], for active document containers
ms.assetid: 9d615999-79ba-471a-9288-718f0c903d49
ms.openlocfilehash: 1bd70af6f24ee6f9873b89b2060f4b2d90149c90
ms.sourcegitcommit: c21b05042debc97d14875e019ee9d698691ffc0b
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 06/09/2020
ms.locfileid: "84620136"
---
# <a name="help-menu-merging"></a>說明功能表合併

當物件在容器內處於**作用**中狀態時，OLE 檔的功能表合併通訊協定會提供 [說明] 功能表的 [完全控制] 物件。 因此，除非使用者停用該物件，否則容器的說明主題無法使用。 現用文件內含項目結構會在就地功能表合併的規則展開，讓容器和作用中現用文件共用功能表。 新規則只是額外的慣例，內容是關於哪些元件擁有功能表的哪些部分，以及共用功能表如何建構。

新的慣例很簡單。 在 [活動文檔] 中，[說明] 功能表有兩個最上層功能表**項的組織**方式如下：

`Help`

`Container Help >`

`Object Help    >`

例如，當 Word 區段在 Office 系結器中**作用**時，[說明] 功能表會顯示如下：

`Help`

`Binder Help >`

`Word Help   >`

兩個功能表項目為串聯功能表，其底下容器和物件特有的任何其他功能表項目皆提供給使用者。 這裡顯示的項目視容器和物件而有所不同。

為了建造**這個合併的**[說明] 功能表，現用檔內含專案架構會修改一般的 OLE 檔程式。 根據 OLE 檔，合併的功能表列可以有六個功能表群組，例如 [檔案] **、[****編輯**]、[**容器**]、[**物件**]、[**視窗]**、[說明] **（依該順序）。** 在每個群組中，可以是零或多個功能表。 群組檔案 **、****容器**和視窗屬於容器，而 [**編輯**]、[**物件**] 和 [說明**Help** **]** 群組屬於物件。 當物件要進行功能表合併時，它會建立一個空白的功能表列並且將其傳遞至容器。 然後，容器會藉由呼叫來插入其功能表 `IOleInPlaceFrame::InsertMenus` 。 物件也會傳遞一個結構，其為六個 LONG 值（**OLEMENUGROUPWIDTHS**）的陣列。 在插入功能表之後，容器會標示其每個群組中新增了多少功能表，然後傳回。 接著，物件插入其功能表，並請注意各個容器群組中的功能表計數。 最後，物件會將合併的功能表列和陣列 (包含每個群組中的功能表計數) 傳遞至 OLE，而其會傳回不透明「功能表描述元」控制代碼。 之後，物件會透過，將該控制碼和合併的功能表列傳遞至容器 `IOleInPlaceFrame::SetMenu` 。 此時，容器會顯示合併的功能表列並且將控制代碼傳遞至 OLE，因此 OLE 可以適當分派功能表訊息。

在修改過的使用中的檔案程式中，物件必須先將**OLEMENUGROUPWIDTHS**元素初始化為零，再將其傳遞至容器。 然後，容器會執行一般功能表插入，但有一個例外狀況：容器會插入 [說明 **] 功能表做**為最後一個專案，並在**OLEMENUGROUPWIDTHS**陣列的最後（第6個）專案中儲存1的值（也就是，寬度 [5]，屬於物件的 [說明] 群組）。 此 [說明] 功能表只會有一個**子功能表的**專案，如先前所述，[**容器**說明 >] cascade 功能表。

物件接著會執行其一般功能表插入程式碼，不過在插入其 [說明 **] 功能表之前**，它會檢查**OLEMENUGROUPWIDTHS**陣列的第六個專案。 如果值為1，且最後一個功能表的名稱**是 [說明] （或**適當的當地語系化字串），則物件會插入**其 [** 說明] 功能表，做為容器 [說明 **] 功能表的**子功能表。

物件接著會將**OLEMENUGROUPWIDTHS**的第六個元素設定為零，並將第五個元素遞增一。 這可讓 OLE 知道 [說明] 功能表屬於容器，而對應至**該功能表的**功能表訊息（及其子功能表）應路由至容器。 然後，容器必須負責轉送**WM_INITMENUPOPUP**、 **WM_SELECT**、 **WM_COMMAND**和其他屬於 [說明 **] 功能表之物件部分的功能表**相關訊息。 若要完成此動作，請使用**WM_INITMENU**清除旗標，告知容器使用者是否已導覽至物件的 [說明 **] 功能表。** 然後，容器會監**看 [說明] 功能表上**的 [專案] 或 [結束] **WM_MENUSELECT** ，讓容器不會自行新增。 輸入時，這表示使用者已導覽至 [物件] 功能表，因此容器會在 [物件說明] 功能表中設定 [] 旗標，並使用該旗標的狀態，將任何**WM_MENUSELECT**、 **WM_INITMENUPOPUP**和**WM_COMMAND**訊息以最小的方式轉送至 [物件] 視窗。 （結束時，容器會清除旗標，然後處理這些相同的訊息本身）。容器應該使用從物件的函式傳回的視窗 `IOleInPlaceActiveObejct::GetWindow` 做為這些訊息的目的地。

如果物件在**OLEMENUGROUPWIDTHS**的第六個元素中偵測到零，則會根據一般的 OLE 檔規則繼續進行。 此程式涵蓋的容器會參與 [說明 **] 功能表合併**，以及不會進行的工作。

當物件呼叫時 `IOleInPlaceFrame::SetMenu` ，在顯示合併的功能表列之前，容器會先檢查**Help** [說明] 功能表是否有其他子功能表，以及容器所插入的內容。 若是如此，容器會將其說明功能表留在合併**的功能表列**中。 如果 [說明 **] 功能表沒有其他子功能表，** 容器將會從**合併的功能表列移除其 [** 說明] 功能表。 這個程式會涵蓋參與 [說明 **] 功能表合併**的物件，以及未提供的物件。

最後，當您將功能表反組譯時，物件除了會移除其他插入的功能表以外，也會移除插入的 [說明 **] 功能表。** 當容器移除其功能表時，除了已插入的其他功能表外，還會移除其 [說明 **] 功能表。**

## <a name="see-also"></a>另請參閱

[主動式文件容器](active-document-containers.md)
