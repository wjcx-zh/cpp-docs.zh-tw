---
title: CDC 類別
ms.date: 11/19/2018
f1_keywords:
- CDC
- AFXWIN/CDC
- AFXWIN/CDC::CDC
- AFXWIN/CDC::AbortDoc
- AFXWIN/CDC::AbortPath
- AFXWIN/CDC::AddMetaFileComment
- AFXWIN/CDC::AlphaBlend
- AFXWIN/CDC::AngleArc
- AFXWIN/CDC::Arc
- AFXWIN/CDC::ArcTo
- AFXWIN/CDC::Attach
- AFXWIN/CDC::BeginPath
- AFXWIN/CDC::BitBlt
- AFXWIN/CDC::Chord
- AFXWIN/CDC::CloseFigure
- AFXWIN/CDC::CreateCompatibleDC
- AFXWIN/CDC::CreateDC
- AFXWIN/CDC::CreateIC
- AFXWIN/CDC::DeleteDC
- AFXWIN/CDC::DeleteTempMap
- AFXWIN/CDC::Detach
- AFXWIN/CDC::DPtoHIMETRIC
- AFXWIN/CDC::DPtoLP
- AFXWIN/CDC::Draw3dRect
- AFXWIN/CDC::DrawDragRect
- AFXWIN/CDC::DrawEdge
- AFXWIN/CDC::DrawEscape
- AFXWIN/CDC::DrawFocusRect
- AFXWIN/CDC::DrawFrameControl
- AFXWIN/CDC::DrawIcon
- AFXWIN/CDC::DrawState
- AFXWIN/CDC::DrawText
- AFXWIN/CDC::DrawTextEx
- AFXWIN/CDC::Ellipse
- AFXWIN/CDC::EndDoc
- AFXWIN/CDC::EndPage
- AFXWIN/CDC::EndPath
- AFXWIN/CDC::EnumObjects
- AFXWIN/CDC::Escape
- AFXWIN/CDC::ExcludeClipRect
- AFXWIN/CDC::ExcludeUpdateRgn
- AFXWIN/CDC::ExtFloodFill
- AFXWIN/CDC::ExtTextOut
- AFXWIN/CDC::FillPath
- AFXWIN/CDC::FillRect
- AFXWIN/CDC::FillRgn
- AFXWIN/CDC::FillSolidRect
- AFXWIN/CDC::FlattenPath
- AFXWIN/CDC::FloodFill
- AFXWIN/CDC::FrameRect
- AFXWIN/CDC::FrameRgn
- AFXWIN/CDC::FromHandle
- AFXWIN/CDC::GetArcDirection
- AFXWIN/CDC::GetAspectRatioFilter
- AFXWIN/CDC::GetBkColor
- AFXWIN/CDC::GetBkMode
- AFXWIN/CDC::GetBoundsRect
- AFXWIN/CDC::GetBrushOrg
- AFXWIN/CDC::GetCharABCWidths
- AFXWIN/CDC::GetCharABCWidthsI
- AFXWIN/CDC::GetCharacterPlacement
- AFXWIN/CDC::GetCharWidth
- AFXWIN/CDC::GetCharWidthI
- AFXWIN/CDC::GetClipBox
- AFXWIN/CDC::GetColorAdjustment
- AFXWIN/CDC::GetCurrentBitmap
- AFXWIN/CDC::GetCurrentBrush
- AFXWIN/CDC::GetCurrentFont
- AFXWIN/CDC::GetCurrentPalette
- AFXWIN/CDC::GetCurrentPen
- AFXWIN/CDC::GetCurrentPosition
- AFXWIN/CDC::GetDCBrushColor
- AFXWIN/CDC::GetDCPenColor
- AFXWIN/CDC::GetDeviceCaps
- AFXWIN/CDC::GetFontData
- AFXWIN/CDC::GetFontLanguageInfo
- AFXWIN/CDC::GetGlyphOutline
- AFXWIN/CDC::GetGraphicsMode
- AFXWIN/CDC::GetHalftoneBrush
- AFXWIN/CDC::GetKerningPairs
- AFXWIN/CDC::GetLayout
- AFXWIN/CDC::GetMapMode
- AFXWIN/CDC::GetMiterLimit
- AFXWIN/CDC::GetNearestColor
- AFXWIN/CDC::GetOutlineTextMetrics
- AFXWIN/CDC::GetOutputCharWidth
- AFXWIN/CDC::GetOutputTabbedTextExtent
- AFXWIN/CDC::GetOutputTextExtent
- AFXWIN/CDC::GetOutputTextMetrics
- AFXWIN/CDC::GetPath
- AFXWIN/CDC::GetPixel
- AFXWIN/CDC::GetPolyFillMode
- AFXWIN/CDC::GetROP2
- AFXWIN/CDC::GetSafeHdc
- AFXWIN/CDC::GetStretchBltMode
- AFXWIN/CDC::GetTabbedTextExtent
- AFXWIN/CDC::GetTextAlign
- AFXWIN/CDC::GetTextCharacterExtra
- AFXWIN/CDC::GetTextColor
- AFXWIN/CDC::GetTextExtent
- AFXWIN/CDC::GetTextExtentExPointI
- AFXWIN/CDC::GetTextExtentPointI
- AFXWIN/CDC::GetTextFace
- AFXWIN/CDC::GetTextMetrics
- AFXWIN/CDC::GetViewportExt
- AFXWIN/CDC::GetViewportOrg
- AFXWIN/CDC::GetWindow
- AFXWIN/CDC::GetWindowExt
- AFXWIN/CDC::GetWindowOrg
- AFXWIN/CDC::GetWorldTransform
- AFXWIN/CDC::GradientFill
- AFXWIN/CDC::GrayString
- AFXWIN/CDC::HIMETRICtoDP
- AFXWIN/CDC::HIMETRICtoLP
- AFXWIN/CDC::IntersectClipRect
- AFXWIN/CDC::InvertRect
- AFXWIN/CDC::InvertRgn
- AFXWIN/CDC::IsPrinting
- AFXWIN/CDC::LineTo
- AFXWIN/CDC::LPtoDP
- AFXWIN/CDC::LPtoHIMETRIC
- AFXWIN/CDC::MaskBlt
- AFXWIN/CDC::ModifyWorldTransform
- AFXWIN/CDC::MoveTo
- AFXWIN/CDC::OffsetClipRgn
- AFXWIN/CDC::OffsetViewportOrg
- AFXWIN/CDC::OffsetWindowOrg
- AFXWIN/CDC::PaintRgn
- AFXWIN/CDC::PatBlt
- AFXWIN/CDC::Pie
- AFXWIN/CDC::PlayMetaFile
- AFXWIN/CDC::PlgBlt
- AFXWIN/CDC::PolyBezier
- AFXWIN/CDC::PolyBezierTo
- AFXWIN/CDC::PolyDraw
- AFXWIN/CDC::Polygon
- AFXWIN/CDC::Polyline
- AFXWIN/CDC::PolylineTo
- AFXWIN/CDC::PolyPolygon
- AFXWIN/CDC::PolyPolyline
- AFXWIN/CDC::PtVisible
- AFXWIN/CDC::RealizePalette
- AFXWIN/CDC::Rectangle
- AFXWIN/CDC::RectVisible
- AFXWIN/CDC::ReleaseAttribDC
- AFXWIN/CDC::ReleaseOutputDC
- AFXWIN/CDC::ResetDC
- AFXWIN/CDC::RestoreDC
- AFXWIN/CDC::RoundRect
- AFXWIN/CDC::SaveDC
- AFXWIN/CDC::ScaleViewportExt
- AFXWIN/CDC::ScaleWindowExt
- AFXWIN/CDC::ScrollDC
- AFXWIN/CDC::SelectClipPath
- AFXWIN/CDC::SelectClipRgn
- AFXWIN/CDC::SelectObject
- AFXWIN/CDC::SelectPalette
- AFXWIN/CDC::SelectStockObject
- AFXWIN/CDC::SetAbortProc
- AFXWIN/CDC::SetArcDirection
- AFXWIN/CDC::SetAttribDC
- AFXWIN/CDC::SetBkColor
- AFXWIN/CDC::SetBkMode
- AFXWIN/CDC::SetBoundsRect
- AFXWIN/CDC::SetBrushOrg
- AFXWIN/CDC::SetColorAdjustment
- AFXWIN/CDC::SetDCBrushColor
- AFXWIN/CDC::SetDCPenColor
- AFXWIN/CDC::SetGraphicsMode
- AFXWIN/CDC::SetLayout
- AFXWIN/CDC::SetMapMode
- AFXWIN/CDC::SetMapperFlags
- AFXWIN/CDC::SetMiterLimit
- AFXWIN/CDC::SetOutputDC
- AFXWIN/CDC::SetPixel
- AFXWIN/CDC::SetPixelV
- AFXWIN/CDC::SetPolyFillMode
- AFXWIN/CDC::SetROP2
- AFXWIN/CDC::SetStretchBltMode
- AFXWIN/CDC::SetTextAlign
- AFXWIN/CDC::SetTextCharacterExtra
- AFXWIN/CDC::SetTextColor
- AFXWIN/CDC::SetTextJustification
- AFXWIN/CDC::SetViewportExt
- AFXWIN/CDC::SetViewportOrg
- AFXWIN/CDC::SetWindowExt
- AFXWIN/CDC::SetWindowOrg
- AFXWIN/CDC::SetWorldTransform
- AFXWIN/CDC::StartDoc
- AFXWIN/CDC::StartPage
- AFXWIN/CDC::StretchBlt
- AFXWIN/CDC::StrokeAndFillPath
- AFXWIN/CDC::StrokePath
- AFXWIN/CDC::TabbedTextOut
- AFXWIN/CDC::TextOut
- AFXWIN/CDC::TransparentBlt
- AFXWIN/CDC::UpdateColors
- AFXWIN/CDC::WidenPath
- AFXWIN/CDC::m_hAttribDC
- AFXWIN/CDC::m_hDC
helpviewer_keywords:
- CDC [MFC], CDC
- CDC [MFC], AbortDoc
- CDC [MFC], AbortPath
- CDC [MFC], AddMetaFileComment
- CDC [MFC], AlphaBlend
- CDC [MFC], AngleArc
- CDC [MFC], Arc
- CDC [MFC], ArcTo
- CDC [MFC], Attach
- CDC [MFC], BeginPath
- CDC [MFC], BitBlt
- CDC [MFC], Chord
- CDC [MFC], CloseFigure
- CDC [MFC], CreateCompatibleDC
- CDC [MFC], CreateDC
- CDC [MFC], CreateIC
- CDC [MFC], DeleteDC
- CDC [MFC], DeleteTempMap
- CDC [MFC], Detach
- CDC [MFC], DPtoHIMETRIC
- CDC [MFC], DPtoLP
- CDC [MFC], Draw3dRect
- CDC [MFC], DrawDragRect
- CDC [MFC], DrawEdge
- CDC [MFC], DrawEscape
- CDC [MFC], DrawFocusRect
- CDC [MFC], DrawFrameControl
- CDC [MFC], DrawIcon
- CDC [MFC], DrawState
- CDC [MFC], DrawText
- CDC [MFC], DrawTextEx
- CDC [MFC], Ellipse
- CDC [MFC], EndDoc
- CDC [MFC], EndPage
- CDC [MFC], EndPath
- CDC [MFC], EnumObjects
- CDC [MFC], Escape
- CDC [MFC], ExcludeClipRect
- CDC [MFC], ExcludeUpdateRgn
- CDC [MFC], ExtFloodFill
- CDC [MFC], ExtTextOut
- CDC [MFC], FillPath
- CDC [MFC], FillRect
- CDC [MFC], FillRgn
- CDC [MFC], FillSolidRect
- CDC [MFC], FlattenPath
- CDC [MFC], FloodFill
- CDC [MFC], FrameRect
- CDC [MFC], FrameRgn
- CDC [MFC], FromHandle
- CDC [MFC], GetArcDirection
- CDC [MFC], GetAspectRatioFilter
- CDC [MFC], GetBkColor
- CDC [MFC], GetBkMode
- CDC [MFC], GetBoundsRect
- CDC [MFC], GetBrushOrg
- CDC [MFC], GetCharABCWidths
- CDC [MFC], GetCharABCWidthsI
- CDC [MFC], GetCharacterPlacement
- CDC [MFC], GetCharWidth
- CDC [MFC], GetCharWidthI
- CDC [MFC], GetClipBox
- CDC [MFC], GetColorAdjustment
- CDC [MFC], GetCurrentBitmap
- CDC [MFC], GetCurrentBrush
- CDC [MFC], GetCurrentFont
- CDC [MFC], GetCurrentPalette
- CDC [MFC], GetCurrentPen
- CDC [MFC], GetCurrentPosition
- CDC [MFC], GetDCBrushColor
- CDC [MFC], GetDCPenColor
- CDC [MFC], GetDeviceCaps
- CDC [MFC], GetFontData
- CDC [MFC], GetFontLanguageInfo
- CDC [MFC], GetGlyphOutline
- CDC [MFC], GetGraphicsMode
- CDC [MFC], GetHalftoneBrush
- CDC [MFC], GetKerningPairs
- CDC [MFC], GetLayout
- CDC [MFC], GetMapMode
- CDC [MFC], GetMiterLimit
- CDC [MFC], GetNearestColor
- CDC [MFC], GetOutlineTextMetrics
- CDC [MFC], GetOutputCharWidth
- CDC [MFC], GetOutputTabbedTextExtent
- CDC [MFC], GetOutputTextExtent
- CDC [MFC], GetOutputTextMetrics
- CDC [MFC], GetPath
- CDC [MFC], GetPixel
- CDC [MFC], GetPolyFillMode
- CDC [MFC], GetROP2
- CDC [MFC], GetSafeHdc
- CDC [MFC], GetStretchBltMode
- CDC [MFC], GetTabbedTextExtent
- CDC [MFC], GetTextAlign
- CDC [MFC], GetTextCharacterExtra
- CDC [MFC], GetTextColor
- CDC [MFC], GetTextExtent
- CDC [MFC], GetTextExtentExPointI
- CDC [MFC], GetTextExtentPointI
- CDC [MFC], GetTextFace
- CDC [MFC], GetTextMetrics
- CDC [MFC], GetViewportExt
- CDC [MFC], GetViewportOrg
- CDC [MFC], GetWindow
- CDC [MFC], GetWindowExt
- CDC [MFC], GetWindowOrg
- CDC [MFC], GetWorldTransform
- CDC [MFC], GradientFill
- CDC [MFC], GrayString
- CDC [MFC], HIMETRICtoDP
- CDC [MFC], HIMETRICtoLP
- CDC [MFC], IntersectClipRect
- CDC [MFC], InvertRect
- CDC [MFC], InvertRgn
- CDC [MFC], IsPrinting
- CDC [MFC], LineTo
- CDC [MFC], LPtoDP
- CDC [MFC], LPtoHIMETRIC
- CDC [MFC], MaskBlt
- CDC [MFC], ModifyWorldTransform
- CDC [MFC], MoveTo
- CDC [MFC], OffsetClipRgn
- CDC [MFC], OffsetViewportOrg
- CDC [MFC], OffsetWindowOrg
- CDC [MFC], PaintRgn
- CDC [MFC], PatBlt
- CDC [MFC], Pie
- CDC [MFC], PlayMetaFile
- CDC [MFC], PlgBlt
- CDC [MFC], PolyBezier
- CDC [MFC], PolyBezierTo
- CDC [MFC], PolyDraw
- CDC [MFC], Polygon
- CDC [MFC], Polyline
- CDC [MFC], PolylineTo
- CDC [MFC], PolyPolygon
- CDC [MFC], PolyPolyline
- CDC [MFC], PtVisible
- CDC [MFC], RealizePalette
- CDC [MFC], Rectangle
- CDC [MFC], RectVisible
- CDC [MFC], ReleaseAttribDC
- CDC [MFC], ReleaseOutputDC
- CDC [MFC], ResetDC
- CDC [MFC], RestoreDC
- CDC [MFC], RoundRect
- CDC [MFC], SaveDC
- CDC [MFC], ScaleViewportExt
- CDC [MFC], ScaleWindowExt
- CDC [MFC], ScrollDC
- CDC [MFC], SelectClipPath
- CDC [MFC], SelectClipRgn
- CDC [MFC], SelectObject
- CDC [MFC], SelectPalette
- CDC [MFC], SelectStockObject
- CDC [MFC], SetAbortProc
- CDC [MFC], SetArcDirection
- CDC [MFC], SetAttribDC
- CDC [MFC], SetBkColor
- CDC [MFC], SetBkMode
- CDC [MFC], SetBoundsRect
- CDC [MFC], SetBrushOrg
- CDC [MFC], SetColorAdjustment
- CDC [MFC], SetDCBrushColor
- CDC [MFC], SetDCPenColor
- CDC [MFC], SetGraphicsMode
- CDC [MFC], SetLayout
- CDC [MFC], SetMapMode
- CDC [MFC], SetMapperFlags
- CDC [MFC], SetMiterLimit
- CDC [MFC], SetOutputDC
- CDC [MFC], SetPixel
- CDC [MFC], SetPixelV
- CDC [MFC], SetPolyFillMode
- CDC [MFC], SetROP2
- CDC [MFC], SetStretchBltMode
- CDC [MFC], SetTextAlign
- CDC [MFC], SetTextCharacterExtra
- CDC [MFC], SetTextColor
- CDC [MFC], SetTextJustification
- CDC [MFC], SetViewportExt
- CDC [MFC], SetViewportOrg
- CDC [MFC], SetWindowExt
- CDC [MFC], SetWindowOrg
- CDC [MFC], SetWorldTransform
- CDC [MFC], StartDoc
- CDC [MFC], StartPage
- CDC [MFC], StretchBlt
- CDC [MFC], StrokeAndFillPath
- CDC [MFC], StrokePath
- CDC [MFC], TabbedTextOut
- CDC [MFC], TextOut
- CDC [MFC], TransparentBlt
- CDC [MFC], UpdateColors
- CDC [MFC], WidenPath
- CDC [MFC], m_hAttribDC
- CDC [MFC], m_hDC
ms.assetid: 715b3334-cb2b-4c9c-8067-02eb7c66c8b2
ms.openlocfilehash: 432d560da0ae3459ba43faed9a50b9771b0de5d1
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 07/27/2020
ms.locfileid: "87212549"
---
# <a name="cdc-class"></a>CDC 類別

定義裝置內容物件的類別。

## <a name="syntax"></a>語法

```
class CDC : public CObject
```

## <a name="members"></a>成員

### <a name="public-constructors"></a>公用建構函式

|名稱|說明|
|----------|-----------------|
|[CDC：： CDC](#cdc)|建構 `CDC` 物件。|

### <a name="public-methods"></a>公用方法

|名稱|說明|
|----------|-----------------|
|[CDC：： AbortDoc](#abortdoc)|終止目前的列印工作，清除上次呼叫成員函式之後，應用程式已寫入裝置的所有專案 `StartDoc` 。|
|[CDC：： AbortPath](#abortpath)|關閉並捨棄裝置內容中的任何路徑。|
|[CDC：： AddMetaFileComment](#addmetafilecomment)|將批註從緩衝區複製到指定的增強格式中繼檔。|
|[CDC：： AlphaBlend](#alphablend)|顯示具有透明或半透明圖元的點陣圖。|
|[CDC：： AngleArc](#anglearc)|繪製線段和弧線，並將目前的位置移至弧形的結束點。|
|[CDC：： Arc](#arc)|繪製橢圓形弧線。|
|[CDC：： ArcTo](#arcto)|繪製橢圓形弧線。這個函數類似于 `Arc` ，不同之處在于目前的位置已更新。|
|[CDC：： Attach](#attach)|將 Windows 裝置內容附加到這個 `CDC` 物件。|
|[CDC：： BeginPath](#beginpath)|在裝置內容中開啟路徑括弧。|
|[CDC::BitBlt](#bitblt)|從指定的裝置內容複寫點陣圖。|
|[CDC：：弦](#chord)|繪製弦（封閉的圖形，並以橢圓形和線段的交集來界定）。|
|[CDC：： CloseFigure](#closefigure)|關閉路徑中的已開啟圖形。|
|[CDC：： CreateCompatibleDC](#createcompatibledc)|建立與另一個裝置內容相容的記憶體裝置內容。 您可以使用它在記憶體中準備映射。|
|[CDC：： CreateDC](#createdc)|建立特定裝置的裝置內容。|
|[CDC：： CreateIC](#createic)|建立特定裝置的資訊內容。 這提供快速的方法來取得裝置的相關資訊，而不需建立裝置內容。|
|[CDC：:D eleteDC](#deletedc)|刪除與這個物件相關聯的 Windows 裝置內容 `CDC` 。|
|[CDC：:D eleteTempMap](#deletetempmap)|由 `CWinApp` 閒置時間處理常式呼叫，以刪除所 `CDC` 建立的任何暫存物件 `FromHandle` 。 也會卸離裝置內容。|
|[CDC：:D etach](#detach)|從這個物件卸離 Windows 裝置內容 `CDC` 。|
|[CDC：:D PtoHIMETRIC](#dptohimetric)|將裝置單位轉換成 HIMETRIC 單位。|
|[CDC：:D PtoLP](#dptolp)|將裝置單位轉換成邏輯單元。|
|[CDC：:D raw3dRect](#draw3drect)|繪製三維矩形。|
|[CDC：:D rawDragRect](#drawdragrect)|在拖曳矩形時加以清除和重新繪製。|
|[CDC：:D rawEdge](#drawedge)|繪製矩形的邊緣。|
|[CDC：:D rawEscape](#drawescape)|存取不是透過圖形裝置介面（GDI）直接提供之影片顯示的繪圖功能。|
|[CDC：:D rawFocusRect](#drawfocusrect)|以用來表示焦點的樣式繪製矩形。|
|[CDC：:D rawFrameControl](#drawframecontrol)|繪製框架控制項。|
|[CDC：:D rawIcon](#drawicon)|繪製圖示。|
|[CDC：:D rawState](#drawstate)|顯示影像，並套用視覺效果以指出狀態。|
|[nFormat](#drawtext)|在指定的矩形中繪製格式化的文字。|
|[CDC：:D rawTextEx](#drawtextex)|使用其他格式，在指定的矩形中繪製格式化的文字。|
|[CDC：：橢圓形](#ellipse)|繪製橢圓形。|
|[CDC：： EndDoc](#enddoc)|結束由成員函式啟動的列印工作 `StartDoc` 。|
|[CDC：： EndPage](#endpage)|通知設備磁碟機頁面已結束。|
|[CDC：： EndPath](#endpath)|關閉路徑括弧，並選取括弧所定義的路徑到裝置內容中。|
|[CDC：： EnumObjects](#enumobjects)|列舉裝置內容中可用的畫筆和筆刷。|
|[CDC：： Escape](#escape)|允許應用程式從特定裝置透過 GDI 存取無法直接使用的設備。 也允許存取 Windows escape 函式。 應用程式發出的 Escape 呼叫會轉譯並傳送到設備磁碟機。|
|[CDC：： ExcludeClipRect](#excludecliprect)|建立新的裁剪區域，其中包含減去指定矩形的現有裁剪區域。|
|[CDC：： ExcludeUpdateRgn](#excludeupdatergn)|藉由從裁剪區域排除視窗中的更新區域，防止在視窗的無效區域內繪圖。|
|[CDC：： ExtFloodFill](#extfloodfill)|以目前筆刷填滿區域。 比[CDC：： FloodFill](#floodfill)成員函式提供更大的彈性。|
|[CDC：： ExtTextOut](#exttextout)|使用目前選取的字型，在矩形區域內寫入字元字串。|
|[CDC：： FillPath](#fillpath)|在目前的路徑中關閉任何已開啟的圖形，並使用目前筆刷和多邊形填滿模式來填滿路徑的內部。|
|[CDC：： FillRect](#fillrect)|使用特定筆刷填滿指定的矩形。|
|[CDC：： FillRgn](#fillrgn)|使用指定的筆刷填滿特定區域。|
|[CDC：： FillSolidRect](#fillsolidrect)|以純色填滿矩形。|
|[CDC：： FlattenPath](#flattenpath)|將所選路徑中的任何曲線轉換成目前的裝置內容，然後將每個曲線變成一連串的線條。|
|[CDC：： FloodFill](#floodfill)|以目前筆刷填滿區域。|
|[CDC：： FrameRect](#framerect)|在矩形周圍繪製框線。|
|[CDC：： FrameRgn](#framergn)|使用筆刷在特定區域周圍繪製框線。|
|[CDC：： FromHandle](#fromhandle)|`CDC`當提供裝置內容的控制碼時，傳回物件的指標。 如果 `CDC` 物件沒有附加至控制代碼，會建立並附加暫存 `CDC` 物件。|
|[CDC：： GetArcDirection](#getarcdirection)|傳回裝置內容的目前弧線方向。|
|[CDC：： GetAspectRatioFilter](#getaspectratiofilter)|抓取目前外觀比例篩選的設定。|
|[CDC：： GetBkColor](#getbkcolor)|抓取目前的背景色彩。|
|[CDC：： GetBkMode](#getbkmode)|抓取背景模式。|
|[CDC：： GetBoundsRect](#getboundsrect)|傳回指定之裝置內容的目前累積周框。|
|[CDC：： GetBrushOrg](#getbrushorg)|抓取目前筆刷的原點。|
|[CDC：： GetCharABCWidths](#getcharabcwidths)|從目前的字型，抓取指定範圍內連續字元的寬度（以邏輯單位表示）。|
|[CDC：： GetCharABCWidthsI](#getcharabcwidthsi)|從目前的 TrueType 字型，抓取指定範圍內連續圖像索引的寬度（以邏輯單位表示）。|
|[CDC：： GetCharacterPlacement](#getcharacterplacement)|在字元字串上抓取各種類型的資訊。|
|[CDC：： GetCharWidth](#getcharwidth)|從目前字型抓取指定範圍內連續字元的小數寬度。|
|[CDC：： GetCharWidthI](#getcharwidthi)|從目前字型，抓取指定範圍內連續圖像索引的寬度（以邏輯座標表示）。|
|[CDC：： GetClipBox](#getclipbox)|抓取目前裁剪界限周圍嚴謹周框的維度。|
|[CDC：： GetColorAdjustment](#getcoloradjustment)|抓取裝置內容的色彩調整值。|
|[CDC：： GetCurrentBitmap](#getcurrentbitmap)|傳回目前所選取物件的指標 `CBitmap` 。|
|[CDC：： GetCurrentBrush](#getcurrentbrush)|傳回目前所選取物件的指標 `CBrush` 。|
|[CDC：： GetCurrentFont](#getcurrentfont)|傳回目前所選取物件的指標 `CFont` 。|
|[CDC：： GetCurrentPalette](#getcurrentpalette)|傳回目前所選取物件的指標 `CPalette` 。|
|[CDC：： GetCurrentPen](#getcurrentpen)|傳回目前所選取物件的指標 `CPen` 。|
|[CDC：： GetCurrentPosition](#getcurrentposition)|抓取畫筆的目前位置（以邏輯座標表示）。|
|[CDC：： GetDCBrushColor](#getdcbrushcolor)|擷取目前的筆刷色彩。|
|[CDC：： GetDCPenColor](#getdcpencolor)|擷取目前的畫筆顏色。|
|[CDC：： GetDeviceCaps](#getdevicecaps)|抓取指定之顯示裝置的功能相關特定類型的裝置資訊。|
|[CDC：： GetFontData](#getfontdata)|從可調整的字型檔案抓取字型度量資訊。 要取得的資訊是藉由在字型檔案中指定位移以及要傳回的資訊長度來識別。|
|[CDC：： GetFontLanguageInfo](#getfontlanguageinfo)|針對指定的顯示內容，傳回目前選取之字型的相關資訊。|
|[CDC：： GetGlyphOutline](#getglyphoutline)|針對目前字型中的外框字元，抓取外框曲線或點陣圖。|
|[CDC：： GetGraphicsMode](#getgraphicsmode)|抓取指定裝置內容的目前圖形模式。|
|[CDC：： GetHalftoneBrush](#gethalftonebrush)|抓取半色調筆刷。|
|[CDC：： GetKerningPairs](#getkerningpairs)|針對目前在指定的裝置內容中選取的字型，抓取字元間距配對。|
|[CDC：： GetLayout](#getlayout)|抓取裝置內容（DC）的配置。 版面配置可以是由左至右（預設）或由右至左（鏡像）。|
|[CDC：： GetMapMode](#getmapmode)|抓取目前的對應模式。|
|[CDC：： GetMiterLimit](#getmiterlimit)|傳回裝置內容的斜接限制。|
|[CDC：： GetNearestColor](#getnearestcolor)|將最接近的邏輯色彩，抓取至指定裝置可以代表的指定邏輯色彩。|
|[CDC：： GetOutlineTextMetrics](#getoutlinetextmetrics)|抓取 TrueType 字型的字型度量資訊。|
|[CDC：： GetOutputCharWidth](#getoutputcharwidth)|使用輸出裝置內容，從目前字型的連續字元群組中抓取個別字元的寬度。|
|[CDC：： GetOutputTabbedTextExtent](#getoutputtabbedtextextent)|在輸出裝置內容上，計算字元字串的寬度和高度。|
|[CDC：： GetOutputTextExtent](#getoutputtextextent)|使用目前的字型來決定維度，以計算輸出裝置內容上文字行的寬度和高度。|
|[CDC：： GetOutputTextMetrics](#getoutputtextmetrics)|從輸出裝置內容抓取目前字型的計量。|
|[CDC：： GetPath](#getpath)|抓取定義線條端點的座標，以及在選取至裝置內容的路徑中找到的曲線控制點。|
|[CDC：： GetPixel](#getpixel)|在指定的點上，抓取圖元的 RGB 色彩值。|
|[CDC：： GetPolyFillMode](#getpolyfillmode)|抓取目前的多邊形填滿模式。|
|[CDC：： GetROP2](#getrop2)|抓取目前的繪圖模式。|
|[CDC：： GetSafeHdc](#getsafehdc)|傳回[CDC：： m_hDC](#m_hdc)，輸出裝置內容。|
|[CDC：： GetStretchBltMode](#getstretchbltmode)|抓取目前的點陣圖延展模式。|
|[CDC：： GetTabbedTextExtent](#gettabbedtextextent)|在屬性裝置內容上，計算字元字串的寬度和高度。|
|[CDC：： GetTextAlign](#gettextalign)|抓取文字對齊旗標。|
|[CDC：： GetTextCharacterExtra](#gettextcharacterextra)|抓取 intercharacter 間距量的目前設定。|
|[CDC：： GetTextColor](#gettextcolor)|抓取目前的文字色彩。|
|[CDC：： GetTextExtent](#gettextextent)|使用目前的字型來決定維度，以計算屬性裝置內容上文字行的寬度和高度。|
|[CDC：： GetTextExtentExPointI](#gettextextentexpointi)|抓取指定的字串中，符合指定之空間的字元數，並在陣列中填入每個字元的文字範圍。|
|[CDC：： GetTextExtentPointI](#gettextextentpointi)|抓取指定之圖像索引陣列的寬度和高度。|
|[CDC：： GetTextFace](#gettextface)|將目前字型的字樣名稱複製到緩衝區中，做為以 null 結束的字串。|
|[CDC：： GetTextMetrics](#gettextmetrics)|從屬性裝置內容抓取目前字型的計量。|
|[CDC：： GetViewportExt](#getviewportext)|抓取視口的 x 和 y 範圍。|
|[CDC：： GetViewportOrg](#getviewportorg)|抓取視口原點的 x 和 y 座標。|
|[CDC：： GetWindow](#getwindow)|傳回與顯示裝置內容相關聯的視窗。|
|[CDC：： GetWindowExt](#getwindowext)|抓取相關聯視窗的 x 和 y 範圍。|
|[CDC：： GetWindowOrg](#getwindoworg)|抓取相關聯視窗的原點 x 和 y 座標。|
|[CDC：： GetWorldTransform](#getworldtransform)|抓取目前的世界空間以進行頁面空間轉換。|
|[CDC：： GradientFill](#gradientfill)|以 gradating 色彩填滿矩形和三角形結構。|
|[CDC：： GrayString](#graystring)|在指定的位置繪製暗灰色（灰色）的文字。|
|[CDC：： HIMETRICtoDP](#himetrictodp)|將 HIMETRIC 單位轉換成裝置單位。|
|[CDC：： HIMETRICtoLP](#himetrictolp)|將 HIMETRIC 單位轉換成邏輯單元。|
|[CDC：： IntersectClipRect](#intersectcliprect)|藉由形成目前區域和矩形的交集，建立新的裁剪區域。|
|[CDC：： InvertRect](#invertrect)|反轉矩形的內容。|
|[CDC：： InvertRgn](#invertrgn)|反轉區域中的色彩。|
|[CDC：： IsPrinting](#isprinting)|判斷是否使用裝置內容進行列印。|
|[CDC：： LineTo](#lineto)|從目前的位置繪製一條線，直到某個點為止。|
|[CDC：： LPtoDP](#lptodp)|將邏輯單元轉換成裝置單位。|
|[CDC：： LPtoHIMETRIC](#lptohimetric)|將邏輯單元轉換成 HIMETRIC 單位。|
|[CDC：： MaskBlt](#maskblt)|使用指定的遮罩和點陣運算，結合來源與目的地點陣圖的色彩資料。|
|[CDC：： ModifyWorldTransform](#modifyworldtransform)|使用指定的模式變更裝置內容的世界轉換。|
|[CDC：： MoveTo](#moveto)|移動目前的位置。|
|[CDC：： OffsetClipRgn](#offsetcliprgn)|移動指定裝置的裁剪區域。|
|[CDC：： OffsetViewportOrg](#offsetviewportorg)|修改相對於目前的視口原點座標的位置區原點。|
|[CDC：： OffsetWindowOrg](#offsetwindoworg)|修改相對於目前視窗原點座標的視窗原點。|
|[CDC：:P aintRgn](#paintrgn)|以選取的筆刷填滿區域。|
|[CDC：:P atBlt](#patblt)|建立位模式。|
|[CDC：:P ie](#pie)|繪製餅形的楔形。|
|[CDC：:P layMetaFile](#playmetafile)|在給定的裝置上播放指定之中繼檔的內容。 的增強版本會 `PlayMetaFile` 顯示儲存在指定之增強格式中繼檔中的圖片。 中繼檔可以任意次數播放。|
|[CDC：:P lgBlt](#plgblt)|執行從來源裝置內容中指定矩形到指定裝置內容中的平行四邊形的位區塊傳輸。|
|[CDC：:P olyBezier](#polybezier)|繪製一或多個 Bzier 曲線。 目前的位置不會使用也不會更新。|
|[CDC：:P olyBezierTo](#polybezierto)|繪製一或多個 Bzier 曲線，並將目前的位置移至最後一個 Bzier 曲線的結束點。|
|[CDC：:P olyDraw](#polydraw)|繪製一組線段和 Bzier 曲線。 此函式會更新目前的位置。|
|[CDC：:P olygon](#polygon)|繪製由兩個或多個以線條連接的點（頂點）所組成的多邊形。|
|[CDC：:P olyline](#polyline)|繪製一組連接指定點的線段。|
|[CDC：:P olylineTo](#polylineto)|繪製一或多條直線，並將目前的位置移至最後一行的結束點。|
|[CDC：:P olyPolygon](#polypolygon)|建立兩個或多個使用目前多邊形填滿模式填滿的多邊形。 多邊形可能不相鄰或可能重迭。|
|[CDC：:P olyPolyline](#polypolyline)|繪製多個連接線段的序列。 這個函式不會使用或更新目前的位置。|
|[CDC：:P tVisible](#ptvisible)|指定指定的點是否在裁剪區域內。|
|[CDC：： RealizePalette](#realizepalette)|將目前邏輯調色板中的 [調色板] 專案對應至 [系統] 調色板。|
|[CDC：： Rectangle](#rectangle)|使用目前的畫筆繪製矩形，並使用目前的筆刷將它填滿。|
|[CDC：： RectVisible](#rectvisible)|判斷指定矩形的任何部分是否位於裁剪區域內。|
|[CDC：： ReleaseAttribDC](#releaseattribdc)|版本 `m_hAttribDC` ，屬性裝置內容。|
|[CDC：： ReleaseOutputDC](#releaseoutputdc)|版本 `m_hDC` ，輸出裝置內容。|
|[CDC：： ResetDC](#resetdc)|更新 `m_hAttribDC` 裝置內容。|
|[CDC：： RestoreDC](#restoredc)|將裝置內容還原到與儲存的先前狀態 `SaveDC` 。|
|[CDC：： RoundRect](#roundrect)|使用目前的畫筆繪製具有圓角的矩形，並使用目前的筆刷填滿。|
|[CDC：： SaveDC](#savedc)|儲存裝置內容的目前狀態。|
|[CDC：： ScaleViewportExt](#scaleviewportext)|修改相對於目前值的資料區範圍。|
|[CDC：： ScaleWindowExt](#scalewindowext)|修改相對於目前值的視窗範圍。|
|[CDC：： ScrollDC](#scrolldc)|水準和垂直捲動位的矩形。|
|[CDC：： SelectClipPath](#selectclippath)|選取目前的路徑做為裝置內容的裁剪區域，並使用指定的模式結合新區域與任何現有的裁剪區域。|
|[CDC：： SelectClipRgn](#selectcliprgn)|使用指定的模式，將指定的區域與目前的裁剪區域結合。|
|[CDC::SelectObject](#selectobject)|選取 GDI 繪圖物件（例如畫筆）。|
|[CDC：： SelectPalette](#selectpalette)|選取邏輯調色板。|
|[CDC::SelectStockObject](#selectstockobject)|選取其中一個預先定義的內建畫筆、筆刷或 Windows 提供的字型。|
|[CDC：： SetAbortProc](#setabortproc)|設定程式設計人員所提供的回呼函式，當列印工作必須中止時，Windows 會呼叫該函數。|
|[CDC：： SetArcDirection](#setarcdirection)|設定要用於弧線和矩形函數的繪製方向。|
|[CDC：： SetAttribDC](#setattribdc)|設定 `m_hAttribDC` ，屬性裝置內容。|
|[CDC：： SetBkColor](#setbkcolor)|設定目前的背景色彩。|
|[CDC：： SetBkMode](#setbkmode)|設定背景模式。|
|[CDC：： SetBoundsRect](#setboundsrect)|控制指定裝置內容的周框矩形資訊累計。|
|[CDC：： SetBrushOrg](#setbrushorg)|指定在裝置內容中選取下一個筆刷的原點。|
|[CDC：： SetColorAdjustment](#setcoloradjustment)|使用指定的值，設定裝置內容的色彩調整值。|
|[CDC：： SetDCBrushColor](#setdcbrushcolor)|設定目前的筆刷色彩。|
|[CDC：： SetDCPenColor](#setdcpencolor)|設定目前的畫筆色彩。|
|[CDC：： SetGraphicsMode](#setgraphicsmode)|為指定的裝置內容設定目前的圖形模式。|
|[CDC：： SetLayout](#setlayout)|變更裝置內容（DC）的配置。|
|[CDC：： SetMapMode](#setmapmode)|設定目前的對應模式。|
|[CDC：： SetMapperFlags](#setmapperflags)|改變字型對應工具在將邏輯字型對應至實體字體時所使用的演算法。|
|[CDC：： SetMiterLimit](#setmiterlimit)|設定裝置內容的斜切聯結長度限制。|
|[CDC：： SetOutputDC](#setoutputdc)|設定 `m_hDC` ，輸出裝置內容。|
|[CDC：： Bitmap.setpixel](#setpixel)|將位於指定點的圖元設定為最接近指定之色彩的近似值。|
|[CDC：： SetPixelV](#setpixelv)|將指定座標處的圖元設定為最接近指定之色彩的近似值。 `SetPixelV`的速度較快， `SetPixel` 因為它不需要傳回實際繪製之點的色彩值。|
|[CDC：： SetPolyFillMode](#setpolyfillmode)|設定多邊形填滿模式。|
|[CDC：： SetROP2](#setrop2)|設定目前的繪圖模式。|
|[CDC：： SetStretchBltMode](#setstretchbltmode)|設定點陣圖延展模式。|
|[CDC：： SetTextAlign](#settextalign)|設定文字對齊旗標。|
|[CDC：： SetTextCharacterExtra](#settextcharacterextra)|設定 intercharacter 間距的數量。|
|[CDC：： SetTextColor](#settextcolor)|設定文字色彩。|
|[CDC：： SetTextJustification](#settextjustification)|將空格新增至字串中的分行符號字元。|
|[CDC：： SetViewportExt](#setviewportext)|設定視口的 x 和 y 範圍。|
|[CDC：： SetViewportOrg](#setviewportorg)|設定視口原點。|
|[CDC：： SetWindowExt](#setwindowext)|設定相關聯視窗的 x 和 y 範圍。|
|[CDC：： SetWindowOrg](#setwindoworg)|設定裝置內容的視窗原點。|
|[CDC：： SetWorldTransform](#setworldtransform)|將目前的世界空間設定為頁面空間轉換。|
|[CDC：： StartDoc](#startdoc)|通知設備磁碟機新的列印工作正在啟動。|
|[CDC：： StartPage](#startpage)|通知設備磁碟機新的頁面正在啟動。|
|[CDC：： StretchBlt](#stretchblt)|將點陣圖從來源矩形和裝置移到目的地矩形中，視需要調整或壓縮點陣圖，以符合目的地矩形的尺寸。|
|[CDC：： StrokeAndFillPath](#strokeandfillpath)|關閉路徑中任何已開啟的圖形、使用目前的畫筆來結束路徑的外框，並使用目前的筆刷填滿其內部。|
|[CDC：： StrokePath](#strokepath)|使用目前的畫筆來呈現指定的路徑。|
|[CDC：： TabbedTextOut](#tabbedtextout)|在指定的位置寫入字元字串，將索引標籤擴充至定位點-停止位置的陣列中指定的值。|
|[CDC：： TextOut](#textout)|使用目前選取的字型，在指定的位置寫入字元字串。|
|[CDC：： TransparentBlt](#transparentblt)|將色彩資料的位區塊從指定的來源裝置內容傳輸到目的地裝置內容中，並在傳輸中呈現指定的色彩透明化。|
|[CDC：： UpdateColors](#updatecolors)|以圖元為單位，將工作區中的目前色彩比對系統元件，以更新裝置內容的工作區。|
|[CDC：： WidenPath](#widenpath)|將目前的路徑重新定義為將路徑繪製到裝置內容中時，所要繪製的區域。|

### <a name="public-operators"></a>公用運算子

|名稱|說明|
|----------|-----------------|
|[CDC：： operator HDC](#operator_hdc)|抓取裝置內容的控制碼。|

### <a name="public-data-members"></a>公用資料成員

|名稱|說明|
|----------|-----------------|
|[CDC：： m_hAttribDC](#m_hattribdc)|這個物件所使用的屬性裝置內容 `CDC` 。|
|[CDC：： m_hDC](#m_hdc)|這個物件所使用的輸出裝置內容 `CDC` 。|

## <a name="remarks"></a>備註

`CDC`物件提供成員函式來處理裝置內容，例如顯示或印表機，以及使用與視窗的工作區相關聯之顯示內容的成員。

透過物件的成員函式來執行所有繪製 `CDC` 。 類別提供裝置內容作業的成員函式、使用繪圖工具、型別安全圖形裝置介面（GDI）物件選取專案，以及使用色彩和調色板。 它也提供成員函式，用來取得和設定繪圖屬性、對應、使用視口、使用視窗範圍、轉換座標、使用區域、裁剪、繪製線條，以及繪製簡單圖形、橢圓形和多邊形。 成員函式也會提供用來繪製文字、使用字型、使用印表機的轉義、滾動和播放中繼檔。

若要使用 `CDC` 物件，請加以建立，然後呼叫其成員函式，以平行處理使用裝置內容的 Windows 函式。

> [!NOTE]
> 在 Windows 95/98 底下，所有螢幕座標的限制為16位。 因此， **`int`** 傳遞至成員函式的 `CDC` 必須介於-32768 到32767的範圍內。

針對特定用途，MFC 程式庫提供了數個衍生自的類別 `CDC` 。 `CPaintDC`封裝對和的呼叫 `BeginPaint` `EndPaint` 。 `CClientDC`管理與視窗工作區相關聯的顯示內容。 `CWindowDC`管理與整個視窗相關聯的顯示內容，包括其框架和控制項。 `CMetaFileDC`將裝置內容與中繼檔產生關聯。

`CDC`提供兩個成員函式[GetLayout](#getlayout)和[SetLayout](#setlayout)，用於反轉裝置內容的配置，而不會從視窗繼承其版面配置。 針對文化特性（例如阿拉伯文或希伯來文）撰寫的應用程式需要這種由右至左的方向，其中字元配置不是歐洲標準。

`CDC`包含兩個裝置內容， [m_hDC](#m_hdc)和[m_hAttribDC](#m_hattribdc)，在建立物件時，請 `CDC` 參閱相同的裝置。 `CDC`將所有的輸出 GDI 呼叫導向至 `m_hDC` ，以及大部分的屬性 gdi 呼叫 `m_hAttribDC` 。 （屬性呼叫的範例是 `GetTextColor` ，而 `SetTextColor` 則是輸出呼叫）。

例如，架構會使用這兩個裝置內容來執行 `CMetaFileDC` 物件，以在讀取實體裝置的屬性時將輸出傳送至中繼檔。 預覽列印會以類似的方式在架構中執行。 您也可以在應用程式特定的程式碼中，以類似的方式使用這兩個裝置內容。

有時候，您可能需要和裝置內容中的文字度量資訊 `m_hDC` `m_hAttribDC` 。 下列成對的函式會提供這項功能：

|使用 m_hAttribDC|使用 m_hDC|
|-----------------------|-----------------|
|[GetTextExtent](#gettextextent)|[GetOutputTextExtent](#getoutputtextextent)|
|[GetTabbedTextExtent](#gettabbedtextextent)|[GetOutputTabbedTextExtent](#getoutputtabbedtextextent)|
|[GetTextMetrics](#gettextmetrics)|[GetOutputTextMetrics](#getoutputtextmetrics)|
|[GetCharWidth](#getcharwidth)|[GetOutputCharWidth](#getoutputcharwidth)|

如需的詳細資訊 `CDC` ，請參閱[裝置](../../mfc/device-contexts.md)內容。

## <a name="inheritance-hierarchy"></a>繼承階層架構

[CObject](../../mfc/reference/cobject-class.md)

`CDC`

## <a name="requirements"></a>需求

**標題:** afxwin.h

## <a name="cdcabortdoc"></a><a name="abortdoc"></a>CDC：： AbortDoc

終止目前的列印工作，並在上次呼叫[StartDoc](#startdoc)成員函式之後，清除應用程式已寫入裝置的所有專案。

```
int AbortDoc();
```

### <a name="return-value"></a>傳回值

如果成功，則為大於或等於0的值; 如果發生錯誤，則為負值。 下列清單顯示常見的錯誤值及其意義：

- SP_ERROR 一般錯誤。

- 目前沒有足夠的磁碟空間可用來進行多工緩衝處理，而且沒有其他空間可以使用。 SP_OUTOFDISK

- SP_OUTOFMEMORY 沒有足夠的記憶體可用於進行多工緩衝處理。

- SP_USERABORT 使用者已透過「列印管理員」終止作業。

### <a name="remarks"></a>備註

此成員函式會取代 ABORTDOC 印表機 escape。

`AbortDoc`應該用來終止下列各項：

- 未使用[SetAbortProc](#setabortproc)指定 abort 函數的列印工作。

- 尚未到達第一個 NEWFRAME 或 NEXTBAND escape 呼叫的列印工作。

如果應用程式遇到列印錯誤或已取消的列印工作，則不能嘗試使用類別的[EndDoc](#enddoc)或成員函式來終止作業 `AbortDoc` `CDC` 。 GDI 會在傳回錯誤值之前自動終止作業。

如果應用程式顯示允許使用者取消列印工作的對話方塊，則在終結對話方塊之前，它必須 `AbortDoc` 先呼叫。

如果使用列印管理員來啟動列印工作，則呼叫會 `AbortDoc` 清除整個多工緩衝處理作業—印表機不會收到任何內容。 如果未使用列印管理員來啟動列印工作，則可能會在呼叫之前將資料傳送至印表機 `AbortDoc` 。 在此情況下，印表機驅動程式會重設印表機（可能的話）並關閉列印工作。

### <a name="example"></a>範例

  請參閱[CDC：： StartDoc](#startdoc)的範例。

## <a name="cdcabortpath"></a><a name="abortpath"></a>CDC：： AbortPath

關閉並捨棄裝置內容中的任何路徑。

```
BOOL AbortPath();
```

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

如果裝置內容中有開啟的路徑括弧，則會關閉路徑括弧，並捨棄路徑。 如果裝置內容中有關閉的路徑，則會捨棄該路徑。

## <a name="cdcaddmetafilecomment"></a><a name="addmetafilecomment"></a>CDC：： AddMetaFileComment

將批註從緩衝區複製到指定的增強格式中繼檔。

```
BOOL AddMetaFileComment(
    UINT nDataSize,
    const BYTE* pCommentData);
```

### <a name="parameters"></a>參數

*nDataSize*<br/>
指定批註緩衝區的長度（以位元組為單位）。

*pCommentData*<br/>
指向包含批註的緩衝區。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

批註可能包含任何私人資訊，例如圖片的來源和建立日期。 批註應該以應用程式簽章開頭，後面接著資料。 批註不應包含特定位置的資料。 特定位置的資料會指定記錄的位置，而且不應該包含，因為一個中繼檔可能會內嵌在另一個中繼檔中。 此函式只能與增強型中繼檔搭配使用。

## <a name="cdcalphablend"></a><a name="alphablend"></a>CDC：： AlphaBlend

呼叫這個成員函式，以顯示具有透明或半透明圖元的點陣圖。

```
BOOL AlphaBlend(
    int xDest,
    int yDest,
    int nDestWidth,
    int nDestHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    int nSrcWidth,
    int nSrcHeight,
    BLENDFUNCTION blend);
```

### <a name="parameters"></a>參數

*xDest*<br/>
指定目的地矩形左上角的 x 座標（以邏輯單位表示）。

*yDest*<br/>
指定目的地矩形左上角的 y 座標（以邏輯單位表示）。

*nDestWidth*<br/>
指定目的地矩形的寬度（以邏輯單位表示）。

*nDestHeight*<br/>
指定目的地矩形的高度（以邏輯單位表示）。

*pSrcDC*<br/>
來源裝置內容的指標。

*xSrc*<br/>
指定來源矩形左上角的 x 座標（以邏輯單位表示）。

*ySrc*<br/>
指定來源矩形左上角的 y 座標（以邏輯單位表示）。

*nSrcWidth*<br/>
指定來源矩形的寬度（以邏輯單位表示）。

*nSrcHeight*<br/>
指定來源矩形的高度（以邏輯單位表示）。

*組合*<br/>
指定[BLENDFUNCTION](/windows/win32/api/wingdi/ns-wingdi-blendfunction)結構。

### <a name="return-value"></a>傳回值

如果成功，則為 TRUE，否則為 FALSE。

### <a name="remarks"></a>備註

如需詳細資訊，請參閱 Windows SDK 中的[AlphaBlend](/windows/win32/api/wingdi/nf-wingdi-alphablend) 。

## <a name="cdcanglearc"></a><a name="anglearc"></a>CDC：： AngleArc

繪製線段和弧線。

```
BOOL AngleArc(
    int x,
    int y,
    int nRadius,
    float fStartAngle,
    float fSweepAngle);
```

### <a name="parameters"></a>參數

*x*<br/>
指定圓形中心的邏輯 x 座標。

*y*<br/>
指定圓形中心的邏輯 y 座標。

*nRadius*<br/>
以邏輯單元指定圓形的半徑。 這個值必須是正數。

*fStartAngle*<br/>
指定相對於 X 軸的開始角度（以度為單位）。

*fSweepAngle*<br/>
指定相對於開始角度的掃描角度（以度為單位）。

### <a name="return-value"></a>傳回值

如果成功則為非零；否則為 0。

### <a name="remarks"></a>備註

從目前位置到弧線開頭繪製的線段。弧線會沿著圓形的周長繪製，並具有指定的半徑和中心。 弧線的長度是由指定的開始和掃描角度所定義。

`AngleArc`將目前的位置移至弧形的結束點。根據目前的轉換和對應模式，這個函數所繪製的弧線可能會顯示為橢圓形。 繪製弧線之前，此函式會從目前的位置繪製線段到弧線的開頭。繪製弧線的方式，是在指定的中心點周圍，以指定的半徑來建立一個假想圓圈。 弧線的起點是藉由從圓形的 X 軸逆時針測量開始角度的度數來決定。 結束點的計算方式類似，是從起點測量到掃描角度的度數數目。

如果掃描角度大於360度，則會多次掃描弧線。 此函式會使用目前的畫筆繪製線條。 此圖不會填滿。

## <a name="cdcarc"></a><a name="arc"></a>CDC：： Arc

繪製橢圓形弧線。

```
BOOL Arc(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4);

BOOL Arc(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```

### <a name="parameters"></a>參數

*x1*<br/>
指定周框左上角的 x 座標（以邏輯單位表示）。

*y1*<br/>
指定周框左上角的 y 座標（以邏輯單位表示）。

*x2*<br/>
指定周框右下角的 x 座標（以邏輯單位表示）。

*y2*<br/>
指定周框右下角的 y 座標（以邏輯單位表示）。

*x3*<br/>
指定定義弧形起點的點 x 座標（以邏輯單位表示）。 這點不一定要完全落在弧線上。

*y3*<br/>
指定定義弧線起點之點的 y 座標（以邏輯單位表示）。 這點不一定要完全落在弧線上。

*四*<br/>
指定定義弧形端點之點的 x 座標（以邏輯單位表示）。 這點不一定要完全落在弧線上。

*y4*<br/>
指定定義弧線端點之點的 y 座標（以邏輯單位表示）。 這點不一定要完全落在弧線上。

*lpRect*<br/>
指定周框（以邏輯單位表示）。 您可以針對這個參數傳遞 LPRECT 或[CRect](../../atl-mfc-shared/reference/crect-class.md)物件。

*ptStart*<br/>
指定定義弧線起點的點 x 和 y 座標（以邏輯單位表示）。 這點不一定要完全落在弧線上。您可以針對這個參數傳遞[POINT](/windows/win32/api/windef/ns-windef-point)結構或[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)物件。

*ptEnd*<br/>
指定點的 x 和 y 座標，以定義弧線的結束點（以邏輯單位表示）。 這點不一定要完全落在弧線上。您可以傳遞 `POINT` 此參數的結構或 `CPoint` 物件。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

使用函數繪製的弧線，是由指定周框所定義的橢圓形區段。

弧線的實際起點是從周框矩形中央繪製的射線，到指定的起點與橢圓形的相交點。 弧線的實際結束點是指從周框的中心開始繪製的光線點，而曲線是由指定的結束點與橢圓形相交。 弧線會以逆時針方向繪製。 由於弧線不是封閉的圖形，因此不會填滿。 矩形的寬度和高度必須大於2個單位且小於32767個單位。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCDocView#29](../../mfc/codesnippet/cpp/cdc-class_1.cpp)]

## <a name="cdcarcto"></a><a name="arcto"></a>CDC：： ArcTo

繪製橢圓形弧線。

```
BOOL ArcTo(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4);

BOOL ArcTo(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```

### <a name="parameters"></a>參數

*x1*<br/>
指定周框左上角的 x 座標（以邏輯單位表示）。

*y1*<br/>
指定周框左上角的 y 座標（以邏輯單位表示）。

*x2*<br/>
指定周框右下角的 x 座標（以邏輯單位表示）。

*y2*<br/>
指定周框右下角的 y 座標（以邏輯單位表示）。

*x3*<br/>
指定定義弧形起點的點 x 座標（以邏輯單位表示）。 這點不一定要完全落在弧線上。

*y3*<br/>
指定定義弧線起點之點的 y 座標（以邏輯單位表示）。 這點不一定要完全落在弧線上。

*四*<br/>
指定定義弧形端點之點的 x 座標（以邏輯單位表示）。 這點不一定要完全落在弧線上。

*y4*<br/>
指定定義弧線端點之點的 y 座標（以邏輯單位表示）。 這點不一定要完全落在弧線上。

*lpRect*<br/>
指定周框（以邏輯單位表示）。 您可以針對這個參數傳遞[矩形](/windows/win32/api/windef/ns-windef-rect)資料結構或[CRect](../../atl-mfc-shared/reference/crect-class.md)物件的指標。

*ptStart*<br/>
指定定義弧線起點的點 x 和 y 座標（以邏輯單位表示）。 這點不一定要完全落在弧線上。您可以針對這個參數傳遞[POINT](/windows/win32/api/windef/ns-windef-point)資料結構或[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)物件。

*ptEnd*<br/>
指定點的 x 和 y 座標，以定義弧線的結束點（以邏輯單位表示）。 這點不一定要完全落在弧線上。您可以 `POINT` 針對這個參數傳遞資料結構或 `CPoint` 物件。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

這個函數類似于 `CDC::Arc` ，不同之處在于目前的位置已更新。 點（ *x1*、 *y1*）和（ *x2*， *y2*）會指定周框。 由指定周框所形成的橢圓形，會定義弧線的曲線。弧線會從周框的中央矩形開始，以逆時針方式（預設的弧線方向）延伸至（ *x3*， *y3*）。 弧線會結束，從周框的中心到（ *x4*， *y4*）將星形線與星形相交。 如果起始點和結束點相同，則會繪製完整的橢圓形。

線條會從目前的位置繪製到弧線的起始點。如果沒有發生錯誤，則會將目前的位置設為弧線的結束點。使用目前的畫筆繪製弧線;它不會填滿。

## <a name="cdcattach"></a><a name="attach"></a>CDC：： Attach

使用此成員函式將*hDC*附加至 `CDC` 物件。

```
BOOL Attach(HDC hDC);
```

### <a name="parameters"></a>參數

*hDC*<br/>
Windows 裝置內容。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

*HDC*會同時儲存在 `m_hDC` 、輸出裝置內容，以及中 `m_hAttribDC` 的屬性裝置內容中。

## <a name="cdcbeginpath"></a><a name="beginpath"></a>CDC：： BeginPath

在裝置內容中開啟路徑括弧。

```
BOOL BeginPath();
```

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

在路徑括弧開啟之後，應用程式就可以開始呼叫 GDI 繪圖函式，以定義位於路徑中的點。 應用程式可以藉由呼叫成員函式來關閉開啟的路徑括弧 `EndPath` 。 當應用程式呼叫時 `BeginPath` ，會捨棄任何先前的路徑。

如需在路徑中定義點的繪圖函數清單，請參閱 Windows SDK 中的[BeginPath](/windows/win32/api/wingdi/nf-wingdi-beginpath) 。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCDocView#30](../../mfc/codesnippet/cpp/cdc-class_2.cpp)]

## <a name="cdcbitblt"></a><a name="bitblt"></a>CDC：： BitBlt

將點陣圖從來源裝置內容複寫到這個目前的裝置內容。

```
BOOL BitBlt(
    int x,
    int y,
    int nWidth,
    int nHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    DWORD dwRop);
```

### <a name="parameters"></a>參數

*x*<br/>
指定目的地矩形左上角的邏輯 x 座標。

*y*<br/>
指定目的地矩形左上角的邏輯 y 座標。

*nWidth*<br/>
指定目的地矩形和來源點陣圖的寬度（以邏輯單位表示）。

*nHeight*<br/>
指定目的地矩形和來源點陣圖的高度（以邏輯單位表示）。

*pSrcDC*<br/>
`CDC`物件的指標，識別要將點陣圖複製到其中的裝置內容。 如果*dwRop*指定不包含來源的點陣作業，它必須是 Null。

*xSrc*<br/>
指定來源點陣圖左上角的邏輯 x 座標。

*ySrc*<br/>
指定來源點陣圖左上角的邏輯 y 座標。

*dwRop*<br/>
指定待執行的點陣作業。 「點陣作業碼」（operation）程式碼定義 GDI 如何結合包含目前筆刷、可能來源點陣圖和目的地點陣圖的輸出運算色彩。 如需*dwRop*的點陣作業碼清單及其描述，請參閱 Windows SDK 中的[BitBlt](/windows/win32/api/wingdi/nf-wingdi-bitblt)

如需點陣作業程式碼的完整清單，請參閱關於 Windows SDK 中的點陣作業程式[代碼](/windows/win32/gdi/raster-operation-codes)。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

應用程式可以將視窗或用戶端區域對齊位元組界限，以確保 `BitBlt` 作業發生在位元組對齊的矩形上。 （當您註冊視窗類別時，請設定 CS_BYTEALIGNWINDOW 或 CS_BYTEALIGNCLIENT 旗標）。

`BitBlt`對位元組對齊矩形的作業，會比 `BitBlt` 未對齊位元組的矩形上的運算快很多。 如果您想要指定類別樣式（例如您自己的裝置內容的位元組對齊），就必須註冊視窗類別，而不是依賴 Microsoft Foundation 類別來為您執行此動作。 使用全域函數[AfxRegisterWndClass](../../mfc/reference/application-information-and-management.md#afxregisterwndclass)。

GDI 會使用目的地裝置內容，以及使用來源裝置內容一次來轉換*nWidth*和*nHeight*。 如果產生的範圍不符，GDI 會使用 Windows 函式， `StretchBlt` 視需要壓縮或延展來源點陣圖。

如果 [目的地]、[來源] 和 [模式] 點陣圖的色彩格式不相同，則函式會 `BitBlt` 將來源和模式點陣圖轉換成符合目的地。 目的地點陣圖的前景和背景色彩會在轉換中使用。

當函式 `BitBlt` 將單色點陣圖轉換成色彩時，會將白色位（1）設定為背景色彩，並將黑色位（0）設為前景色彩。 系統會使用目的地裝置內容的前景和背景色彩。 若要將色彩轉換成單色，請 `BitBlt` 將符合背景色彩的圖元設定為白色，並將其他所有圖元設定為黑色。 `BitBlt`使用 [色彩] 裝置內容的前景和背景色彩，從 [色彩] 轉換為 [單色]。

請注意，並非所有的裝置內容都支援 `BitBlt` 。 若要檢查指定的裝置內容是否支援 `BitBlt` ，請使用 `GetDeviceCaps` 成員函式，並指定 RASTERCAPS 索引。

### <a name="example"></a>範例

  請參閱[CDC：： CreateCompatibleDC](#createcompatibledc)的範例。

## <a name="cdccdc"></a><a name="cdc"></a>CDC：： CDC

建構 `CDC` 物件。

```
CDC();
```

## <a name="cdcchord"></a><a name="chord"></a>CDC：：弦

繪製弦（封閉的圖形，並以橢圓形和線段的交集來界定）。

```
BOOL Chord(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4);

BOOL Chord(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```

### <a name="parameters"></a>參數

*x1*<br/>
指定弦周框矩形左上角的 x 座標（以邏輯單位表示）。

*y1*<br/>
指定弦周框矩形左上角的 y 座標（以邏輯單位表示）。

*x2*<br/>
指定弦周框矩形右下角的 x 座標（以邏輯單位表示）。

*y2*<br/>
指定弦周框矩形右下角的 y 座標（以邏輯單位表示）。

*x3*<br/>
指定定義弦起點之點的 x 座標（以邏輯單位表示）。

*y3*<br/>
指定定義弦起點（以邏輯單位表示）之點的 y 座標。

*四*<br/>
指定定義弦端點之點的 x 座標（以邏輯單位表示）。

*y4*<br/>
指定定義弦端點之點的 y 座標（以邏輯單位表示）。

*lpRect*<br/>
指定周框（以邏輯單位表示）。 您可以針對這個參數傳遞 LPRECT 或[CRect](../../atl-mfc-shared/reference/crect-class.md)物件。

*ptStart*<br/>
指定定義弦起點（以邏輯單位表示）之點的 x 和 y 座標。 這點不一定要剛好落在弦上。 您可以傳遞 `POINT` 此參數的結構或 `CPoint` 物件。

*ptEnd*<br/>
指定定義弦結束點（以邏輯單位表示）之點的 x 和 y 座標。 這點不一定要剛好落在弦上。 您可以針對這個參數傳遞[POINT](/windows/win32/api/windef/ns-windef-point)結構或[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)物件。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

（ *X1*、 *y1*）和（ *x2*， *y2*）參數會分別指定矩形的左上角和右下角，並將橢圓形做為弦的一部分。 （ *X3*， *y3*）和（ *x4*， *y4*）參數會指定與橢圓形相交之線條的端點。 使用選取的畫筆繪製弦，並使用選取的筆刷填滿。

函式所繪製的圖表 `Chord` 會延伸至，但不包含右和下座標。 這表示圖形的高度是*y2*  -  *y1* ，而圖的寬度是*x2*  -  *x1*。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCDocView#31](../../mfc/codesnippet/cpp/cdc-class_3.cpp)]

## <a name="cdcclosefigure"></a><a name="closefigure"></a>CDC：： CloseFigure

關閉路徑中的已開啟圖形。

```
BOOL CloseFigure();
```

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

函式會藉由繪製從目前位置到圖表第一個點的線條（通常是最新的成員函式呼叫所指定的點）來關閉圖表 `MoveTo` ，並使用「線條聯結」樣式來連接這些線條。 如果使用成員函式 `LineTo` （而非）來關閉圖表 `CloseFigure` ，則會使用 end caps 來建立角落，而不是聯結。 `CloseFigure`只有在裝置內容中有開啟的路徑括弧時，才應該呼叫。

路徑中的圖表是開啟的，除非使用此函式明確地關閉。 （即使圖表的目前點和起點相同，也可以開啟圖形）。在啟動新的圖表之後，加入至路徑的任何線條或曲線 `CloseFigure` 。

## <a name="cdccreatecompatibledc"></a><a name="createcompatibledc"></a>CDC：： CreateCompatibleDC

建立與*pDC*所指定裝置相容的記憶體裝置內容。

```
BOOL CreateCompatibleDC(CDC* pDC);
```

### <a name="parameters"></a>參數

*pDC*<br/>
裝置內容的指標。 如果*pDC*是 Null，此函式會建立與系統顯示相容的記憶體裝置內容。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

記憶體裝置內容是表示顯示介面的記憶體區塊。 在將映射複製到相容裝置的實際裝置介面之前，它可以用來準備記憶體中的影像。

建立記憶體裝置內容時，GDI 會自動為其選取1個單色的內建點陣圖。 只有在已建立點陣圖並選取到該內容時，GDI 輸出函式才能用於記憶體裝置內容。

此函式只能用來為支援點陣作業的裝置建立相容的裝置內容。 如需裝置內容之間的位區塊傳輸相關資訊，請參閱[CDC：： BitBlt](#bitblt)成員函式。 若要判斷裝置內容是否支援點陣作業，請參閱成員函式中的 RC_BITBLT 點陣功能 `CDC::GetDeviceCaps` 。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCDocView#32](../../mfc/codesnippet/cpp/cdc-class_4.cpp)]

## <a name="cdccreatedc"></a><a name="createdc"></a>CDC：： CreateDC

為指定的裝置建立裝置內容。

```
BOOL CreateDC(
    LPCTSTR lpszDriverName,
    LPCTSTR lpszDeviceName,
    LPCTSTR lpszOutput,
    const void* lpInitData);
```

### <a name="parameters"></a>參數

*lpszDriverName*<br/>
指向以 null 終止的字串，指定設備磁碟機的檔案名（不含副檔名）（例如，"EPSON"）。 您也可以傳遞 `CString` 此參數的物件。

*lpszDeviceName*<br/>
指向以 null 終止的字串，指定要支援的特定裝置名稱（例如，"EPSON FX-80"）。 如果模組支援一個以上的裝置，則會使用*lpszDeviceName*參數。 您也可以傳遞 `CString` 此參數的物件。

*lpszOutput*<br/>
指向以 null 終止的字串，指定實體輸出媒體（檔案或輸出埠）的檔案或裝置名稱。 您也可以傳遞 `CString` 此參數的物件。

*lpInitData*<br/>
指向結構， `DEVMODE` 其中包含設備磁碟機的裝置特定初始化資料。 Windows 函式會針對指定的裝置，抓取已 `DocumentProperties` 填入的這個結構。 如果設備磁碟機要使用使用者透過 [控制台] 所指定的預設初始化（如果有的話），則*lpInitData*參數必須是 Null。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

列印。如果使用[DEVMODE](/windows/win32/api/wingdi/ns-wingdi-devmodea)結構，則需要 H 標頭檔。

裝置名稱會遵循下列慣例：結尾冒號（:)建議使用，但選用。 Windows 會將終止冒號，使以冒號結尾的裝置名稱對應至相同名稱的相同埠，而不含冒號。 驅動程式和埠名稱不得包含開頭或尾端空格。 GDI 輸出函數不能與資訊內容搭配使用。

## <a name="cdccreateic"></a><a name="createic"></a>CDC：： CreateIC

為指定的裝置建立資訊內容。

```
BOOL CreateIC(
    LPCTSTR lpszDriverName,
    LPCTSTR lpszDeviceName,
    LPCTSTR lpszOutput,
    const void* lpInitData);
```

### <a name="parameters"></a>參數

*lpszDriverName*<br/>
指向以 null 終止的字串，指定設備磁碟機的檔案名（不含副檔名）（例如，"EPSON"）。 您可以傳遞 `CString` 此參數的物件。

*lpszDeviceName*<br/>
指向以 null 終止的字串，指定要支援的特定裝置名稱（例如，"EPSON FX-80"）。 如果模組支援一個以上的裝置，則會使用*lpszDeviceName*參數。 您可以傳遞 `CString` 此參數的物件。

*lpszOutput*<br/>
指向以 null 終止的字串，指定實體輸出媒體（檔案或埠）的檔案或裝置名稱。 您可以傳遞 `CString` 此參數的物件。

*lpInitData*<br/>
指向設備磁碟機的裝置特定初始化資料。 如果設備磁碟機要使用使用者透過 [控制台] 所指定的預設初始化（如果有的話），則*lpInitData*參數必須是 Null。 `CreateDC`如需裝置特定初始化的資料格式，請參閱。

### <a name="return-value"></a>傳回值

如果成功則為非零；否則為 0。

### <a name="remarks"></a>備註

資訊內容提供快速的方式來取得裝置的相關資訊，而不需建立裝置內容。

裝置名稱會遵循下列慣例：結尾冒號（:)建議使用，但選用。 Windows 會將終止冒號，使以冒號結尾的裝置名稱對應至相同名稱的相同埠，而不含冒號。 驅動程式和埠名稱不得包含開頭或尾端空格。 GDI 輸出函數不能與資訊內容搭配使用。

## <a name="cdcdeletedc"></a><a name="deletedc"></a>CDC：:D eleteDC

一般而言，請勿呼叫此函式;此函式會為您執行此動作。

```
BOOL DeleteDC();
```

### <a name="return-value"></a>傳回值

如果函式順利完成，則為非零;否則為0。

### <a name="remarks"></a>備註

成員函式 `DeleteDC` 會刪除 `m_hDC` 目前物件中與相關聯的 Windows 裝置內容 `CDC` 。 如果此 `CDC` 物件是指定裝置的最後一個使用中裝置內容，則會通知裝置，並釋放裝置所使用的所有存放裝置和系統資源。

`DeleteDC`如果物件已選取到裝置內容中，應用程式就不應呼叫。 物件必須先從裝置內容中選取，然後才會被刪除。

應用程式不能刪除其控制碼是藉由呼叫[CWnd：： GetDC](../../mfc/reference/cwnd-class.md#getdc)所取得的裝置內容。 相反地，它必須呼叫[CWnd：： ReleaseDC](../../mfc/reference/cwnd-class.md#releasedc)來釋放裝置內容。 提供[CClientDC](../../mfc/reference/cclientdc-class.md)和[CWindowDC](../../mfc/reference/cwindowdc-class.md)類別來包裝這種功能。

函式 `DeleteDC` 通常用來刪除使用[CreateDC](#createdc)、 [CreateIC](#createic)或[CreateCompatibleDC](#createcompatibledc)所建立的裝置內容。

### <a name="example"></a>範例

  請參閱[CPrintDialog：： GetPrinterDC](../../mfc/reference/cprintdialog-class.md#getprinterdc)的範例。

## <a name="cdcdeletetempmap"></a><a name="deletetempmap"></a>CDC：:D eleteTempMap

由 `CWinApp` 閒置時間處理常式自動呼叫， `DeleteTempMap` 會刪除所建立的任何暫存 `CDC` 物件，但不 `FromHandle` 會摧毀 `hDC` 與物件暫時相關聯的裝置內容控制碼 `CDC` 。

```
static void PASCAL DeleteTempMap();
```

## <a name="cdcdetach"></a><a name="detach"></a>CDC：:D etach

呼叫此函式可 `m_hDC` 從物件卸離（輸出裝置內容） `CDC` ，並將 `m_hDC` 和都設定 `m_hAttribDC` 為 Null。

```
HDC Detach();
```

### <a name="return-value"></a>傳回值

Windows 裝置內容。

## <a name="cdcdptohimetric"></a><a name="dptohimetric"></a>CDC：:D PtoHIMETRIC

當您將 HIMETRIC 大小授與 OLE，並將圖元轉換成 HIMETRIC 時，請使用此函式。

```cpp
void DPtoHIMETRIC(LPSIZE lpSize) const;
```

### <a name="parameters"></a>參數

*lpSize*<br/>
指向[大小](/windows/win32/api/windef/ns-windef-size)結構或[CSize](../../atl-mfc-shared/reference/csize-class.md)物件。

### <a name="remarks"></a>備註

如果裝置內容物件的對應模式是 MM_LOENGLISH、MM_HIENGLISH、MM_LOMETRIC 或 MM_HIMETRIC，則轉換是以實體英寸的圖元數為基礎。 如果對應模式是其他不受限制的模式之一（例如 MM_TEXT），則轉換會以邏輯英寸的圖元數為基礎。

## <a name="cdcdptolp"></a><a name="dptolp"></a>CDC：:D PtoLP

將裝置單位轉換成邏輯單元。

```cpp
void DPtoLP(
    LPPOINT lpPoints,
    int nCount = 1) const;

void DPtoLP(LPRECT lpRect) const;
void DPtoLP(LPSIZE lpSize) const;
```

### <a name="parameters"></a>參數

*lpPoints*<br/>
指向[點](/windows/win32/api/windef/ns-windef-point)結構或[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)物件的陣列。

*nCount*<br/>
陣列中的點數目。

*lpRect*<br/>
指向[RECT](/windows/win32/api/windef/ns-windef-rect)結構或[CRect](../../atl-mfc-shared/reference/crect-class.md)物件。 此參數用於將一個矩形從裝置點轉換為邏輯點的簡單案例。

*lpSize*<br/>
指向[大小](/windows/win32/api/windef/ns-windef-size)結構或[CSize](../../atl-mfc-shared/reference/csize-class.md)物件。

### <a name="remarks"></a>備註

函式會將裝置座標系統中的每個點或大小維度的座標組應到 GDI 的邏輯座標系統。 轉換取決於目前的對應模式，以及裝置的視窗和視口的來源和範圍設定。

## <a name="cdcdraw3drect"></a><a name="draw3drect"></a>CDC：:D raw3dRect

呼叫這個成員函式可繪製三維矩形。

```cpp
void Draw3dRect(
    LPCRECT lpRect,
    COLORREF clrTopLeft,
    COLORREF clrBottomRight);

void Draw3dRect(
    int x,
    int y,
    int cx,
    int cy,
    COLORREF clrTopLeft,
    COLORREF clrBottomRight);
```

### <a name="parameters"></a>參數

*lpRect*<br/>
指定周框（以邏輯單位表示）。 您可以針對這個參數傳遞[RECT](/windows/win32/api/windef/ns-windef-rect)結構或[CRect](../../atl-mfc-shared/reference/crect-class.md)物件的指標。

*clrTopLeft*<br/>
指定立體矩形的頂端和左側色彩。

*clrBottomRight*<br/>
指定三維矩形底部和右側的色彩。

*x*<br/>
指定三維矩形之左上角的邏輯 x 座標。

*y*<br/>
指定三維矩形之左上角的邏輯 y 座標。

*cx*<br/>
指定三維矩形的寬度。

*cy*<br/>
指定三維矩形的高度。

### <a name="remarks"></a>備註

矩形會以*clrTopLeft*所指定色彩中的左上方和左側繪製，並以*clrBottomRight*所指定的色彩向右下方。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCDocView#33](../../mfc/codesnippet/cpp/cdc-class_5.cpp)]

## <a name="cdcdrawdragrect"></a><a name="drawdragrect"></a>CDC：:D rawDragRect

重複呼叫這個成員函式，以重繪拖曳矩形。

```cpp
void DrawDragRect(
    LPCRECT lpRect,
    SIZE size,
    LPCRECT lpRectLast,
    SIZE sizeLast,
    CBrush* pBrush = NULL,
    CBrush* pBrushLast = NULL);
```

### <a name="parameters"></a>參數

*lpRect*<br/>
指向[RECT](/windows/win32/api/windef/ns-windef-rect)結構或[CRect](../../atl-mfc-shared/reference/crect-class.md)物件，指定矩形的邏輯座標，在此案例中為要重繪之矩形的結束位置。

*size*<br/>
指定從外部框線的左上角位移到矩形內部框線的左上角（也就是框線的粗細）的距離。

*lpRectLast*<br/>
指向[RECT](/windows/win32/api/windef/ns-windef-rect)結構或[CRect](../../atl-mfc-shared/reference/crect-class.md)物件，指定矩形位置的邏輯座標（在此案例中為要重繪之矩形的原始位置）。

*sizeLast*<br/>
指定要重繪之原始矩形左上角的外框左邊界位移（也就是框線的粗細），從外部框線的左上角。

*pBrush*<br/>
筆刷物件的指標。 設定為 Null 以使用預設的半色調筆刷。

*pBrushLast*<br/>
所使用之最後一個筆刷物件的指標。 設定為 Null 以使用預設的半色調筆刷。

### <a name="remarks"></a>備註

在您取樣滑鼠位置時，在迴圈中呼叫它，以提供視覺效果的意見反應。 當您呼叫時 `DrawDragRect` ，會清除前一個矩形並繪製新的矩形。 例如，當使用者在螢幕上拖曳矩形時， `DrawDragRect` 將會清除原始矩形，並在其新位置中重新繪製新的矩形。 根據預設，會 `DrawDragRect` 使用半色調筆刷來繪製矩形以消除閃爍，並建立順暢移動矩形的外觀。

第一次呼叫時 `DrawDragRect` ， *lpRectLast*參數應該是 Null。

## <a name="cdcdrawedge"></a><a name="drawedge"></a>CDC：:D rawEdge

呼叫這個成員函式，以繪製指定類型和樣式之矩形的邊緣。

```
BOOL DrawEdge(
    LPRECT lpRect,
    UINT nEdge,
    UINT nFlags);
```

### <a name="parameters"></a>參數

*lpRect*<br/>
`RECT`結構的指標，其中包含矩形的邏輯座標。

*nEdge*<br/>
指定要繪製的內部和外部邊緣類型。 這個參數必須是一個內部框線旗標和一個外框旗標的組合。 如需參數類型的資料表，請參閱 Windows SDK 中的[DrawEdge](/windows/win32/api/winuser/nf-winuser-drawedge) 。

*nFlags*<br/>
指定要繪製之框線類型的旗標。 如需參數值的資料表，請參閱 `DrawEdge` Windows SDK 中的。 若為對角線，BF_RECT 旗標會指定矩形參數所系結之向量的結束點。

### <a name="return-value"></a>傳回值

如果成功則為非零；否則為 0。

## <a name="cdcdrawescape"></a><a name="drawescape"></a>CDC：:D rawEscape

存取不是透過圖形裝置介面（GDI）直接提供之影片顯示的繪圖功能。

```
int DrawEscape(
    int nEscape,
    int nInputSize,
    LPCSTR lpszInputData);
```

### <a name="parameters"></a>參數

*nEscape*<br/>
指定要執行的 escape 函數。

*nInputSize*<br/>
指定*lpszInputData*參數所指向的資料位元組數目。

*lpszInputData*<br/>
指向指定之轉義所需的輸入結構。

### <a name="return-value"></a>傳回值

指定函數的結果。 如果成功，則大於零，但 QUERYESCSUPPORT 繪製 escape 只會檢查是否有執行;如果未執行 escape，則為零;如果發生錯誤，則小於零。

### <a name="remarks"></a>備註

當應用程式呼叫時 `DrawEscape` ， *NInputSize*和*lpszInputData*所識別的資料會直接傳遞至指定的顯示驅動程式。

## <a name="cdcdrawfocusrect"></a><a name="drawfocusrect"></a>CDC：:D rawFocusRect

在用來表示矩形具有焦點的樣式中繪製矩形。

```cpp
void DrawFocusRect(LPCRECT lpRect);
```

### <a name="parameters"></a>參數

*lpRect*<br/>
指向[矩形結構或](/windows/win32/api/windef/ns-windef-rect) [CRect](../../atl-mfc-shared/reference/crect-class.md)物件，指定要繪製之矩形的邏輯座標。

### <a name="remarks"></a>備註

因為這是布林 XOR 函式，所以第二次使用相同的矩形呼叫此函式會從顯示中移除矩形。 無法滾動此函式所繪製的矩形。 若要滾動包含此函式所繪製之矩形的區域，請先呼叫 `DrawFocusRect` 以從顯示中移除矩形，然後捲動區域，再 `DrawFocusRect` 重新呼叫以在新的位置繪製矩形。

> [!CAUTION]
> `DrawFocusRect`僅適用于 MM_TEXT 模式。 在其他模式中，此函式不會正確繪製焦點矩形，但不會傳回錯誤值。

## <a name="cdcdrawframecontrol"></a><a name="drawframecontrol"></a>CDC：:D rawFrameControl

呼叫這個成員函式，以繪製指定類型和樣式的框架控制項。

```
BOOL DrawFrameControl(
    LPRECT lpRect,
    UINT nType,
    UINT nState);
```

### <a name="parameters"></a>參數

*lpRect*<br/>
`RECT`結構的指標，其中包含矩形的邏輯座標。

*nType*<br/>
指定要繪製之框架控制項的類型。 如需此參數的可能值清單，請參閱 Windows SDK 中[DrawFrameControl](/windows/win32/api/winuser/nf-winuser-drawframecontrol)的*uType*參數。

*nState*<br/>
指定框架控制項的初始狀態。 可以是 Windows SDK 中的*uState*參數所描述的一或多個值 `DrawFrameControl` 。 使用 [ *nState* ] 值 DFCS_ADJUSTRECT 來調整周框矩形，以排除 [推播] 按鈕的周圍邊緣。

### <a name="return-value"></a>傳回值

如果成功則為非零；否則為 0。

### <a name="remarks"></a>備註

在幾種情況下， *nState*取決於*nType*參數。 下列清單顯示四個*nType*值和*nState*之間的關聯性：

- DFC_BUTTON

  - DFCS_BUTTON3STATE 三狀態按鈕

  - DFCS_BUTTONCHECK 核取方塊

  - DFCS_BUTTONPUSH 按下按鈕

  - DFCS_BUTTONRADIO] 選項按鈕

  - 選項按鈕的 DFCS_BUTTONRADIOIMAGE 影像（非方形需求影像）

  - 選項按鈕的 DFCS_BUTTONRADIOMASK Mask （非方形需要 mask）

- DFC_CAPTION

  - DFCS_CAPTIONCLOSE 關閉] 按鈕

  - DFCS_CAPTIONHELP 說明] 按鈕

  - DFCS_CAPTIONMAX 最大化按鈕

  - DFCS_CAPTIONMIN 最小化按鈕

  - DFCS_CAPTIONRESTORE 還原] 按鈕

- DFC_MENU

  - DFCS_MENUARROW 子功能表箭號

  - DFCS_MENUBULLET 專案符號

  - DFCS_MENUCHECK 核取記號

- DFC_SCROLL

  - DFCS_SCROLLCOMBOBOX 下拉式方塊捲軸

  - 捲軸的 DFCS_SCROLLDOWN 向下箭號

  - 捲軸的 DFCS_SCROLLLEFT 向左鍵

  - 捲軸 DFCS_SCROLLRIGHT 向右箭號

  - 視窗右下角的 DFCS_SCROLLSIZEGRIP 大小底框

  - DFCS_SCROLLUP 捲軸的向上箭號

### <a name="example"></a>範例

這段程式碼會在視窗的右下角繪製大小控制夾。 這適用于對話方塊的 `OnPaint` 處理常式，其沒有樣式，而且通常不包含其他控制項（例如狀態列），可能會讓它成為大小控制器。

[!code-cpp[NVC_MFCDocView#34](../../mfc/codesnippet/cpp/cdc-class_6.cpp)]

## <a name="cdcdrawicon"></a><a name="drawicon"></a>CDC：:D rawIcon

在目前物件所代表的裝置上繪製圖示 `CDC` 。

```
BOOL DrawIcon(
    int x,
    int y,
    HICON hIcon);

BOOL DrawIcon(
    POINT point,
    HICON hIcon);
```

### <a name="parameters"></a>參數

*x*<br/>
指定圖示左上角的邏輯 x 座標。

*y*<br/>
指定圖示左上角的邏輯 y 座標。

*hIcon*<br/>
識別要繪製之圖示的控制碼。

*此處*<br/>
指定圖示左上角的邏輯 x 和 y 座標。 您可以針對這個參數傳遞[POINT](/windows/win32/api/windef/ns-windef-point)結構或[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)物件。

### <a name="return-value"></a>傳回值

如果函式順利完成，則為非零;否則為0。

### <a name="remarks"></a>備註

函式會將圖示的左上角放在*x*和*y*所指定的位置。 此位置受限於裝置內容的目前對應模式。

先前必須使用、或函數載入圖示資源 `CWinApp::LoadIcon` `CWinApp::LoadStandardIcon` `CWinApp::LoadOEMIcon` 。 `MM_TEXT`使用此函式之前，必須先選取對應模式。

### <a name="example"></a>範例

  請參閱[CWnd：： IsIconic](../../mfc/reference/cwnd-class.md#isiconic)的範例。

## <a name="cdcdrawstate"></a><a name="drawstate"></a>CDC：:D rawState

呼叫此成員函式以顯示影像，並套用視覺效果以指出狀態，例如停用或預設狀態。

> [!NOTE]
> 針對 DSS_NORMAL 以外的所有*nFlag*狀態，會在套用視覺效果之前，將影像轉換為單色。

```
BOOL DrawState(
    CPoint pt,
    CSize size,
    HBITMAP hBitmap,
    UINT nFlags,
    HBRUSH hBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    CBitmap* pBitmap,
    UINT nFlags,
    CBrush* pBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    HICON hIcon,
    UINT nFlags,
    HBRUSH hBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    HICON hIcon,
    UINT nFlags,
    CBrush* pBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    LPCTSTR lpszText,
    UINT nFlags,
    BOOL bPrefixText = TRUE,
    int nTextLen = 0,
    HBRUSH hBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    LPCTSTR lpszText,
    UINT nFlags,
    BOOL bPrefixText = TRUE,
    int nTextLen = 0,
    CBrush* pBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    DRAWSTATEPROC lpDrawProc,
    LPARAM lData,
    UINT nFlags,
    HBRUSH hBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    DRAWSTATEPROC lpDrawProc,
    LPARAM lData,
    UINT nFlags,
    CBrush* pBrush = NULL);
```

### <a name="parameters"></a>參數

*pt*<br/>
指定映射的位置。

*size*<br/>
指定影像的大小。

*hBitmap*<br/>
點陣圖的控制碼。

*nFlags*<br/>
指定映射類型和狀態的旗標。 如需可能的*nFlags*類型和狀態，請參閱 Windows SDK 中的[DrawState](/windows/win32/api/winuser/nf-winuser-drawstatew) 。

*hBrush*<br/>
筆刷的控制碼。

*pBitmap*<br/>
CBitmap 物件的指標。

*pBrush*<br/>
CBrush 物件的指標。

*hIcon*<br/>
圖示的控制代碼。

*lpszText*<br/>
文字的指標。

*bPrefixText*<br/>
可能包含快速鍵助憶鍵的文字。 *LData*參數會指定字串的位址，而*nTextLen*參數會指定長度。 如果*nTextLen*為0，則會假設字串是以 null 結束。

*nTextLen*<br/>
*LpszText*所指向的文字字串長度。 如果*nTextLen*為0，則會假設字串是以 null 結束。

*lpDrawProc*<br/>
用來呈現影像之回呼函式的指標。 如果*nFlags*中的影像類型 DST_COMPLEX，則需要此參數。 這是選擇性的，如果影像類型是 DST_TEXT，則可以是 Null。 對於所有其他映射類型，則會忽略這個參數。 如需回呼函數的詳細資訊，請參閱 Windows SDK 中的[DrawStateProc](/windows/win32/api/winuser/nc-winuser-drawstateproc)函數。

*lData*<br/>
指定影像的相關資訊。 這個參數的意義取決於影像類型。

### <a name="return-value"></a>傳回值

如果成功則為非零；否則為 0。

## <a name="cdcdrawtext"></a><a name="drawtext"></a>CDC：:D rawText

呼叫這個成員函式以格式化指定矩形中的文字。 若要指定其他格式化選項，請使用[CDC：:D rawtextex](#drawtextex)。

```
virtual int DrawText(
    LPCTSTR lpszString,
    int nCount,
    LPRECT lpRect,
    UINT nFormat);

int DrawText(
    const CString& str,
    LPRECT lpRect,
    UINT nFormat);
```

### <a name="parameters"></a>參數

*lpszString*<br/>
指向要繪製的字串。 如果*nCount*為-1，則字串必須是以 null 結束。

*nCount*<br/>
指定字串中的字元數。 如果*nCount*為-1，則會假設*lpszString*是以 null 結束之字串的長指標，並 `DrawText` 自動計算字元計數。

*lpRect*<br/>
指向[RECT](/windows/win32/api/windef/ns-windef-rect)結構或[CRect](../../atl-mfc-shared/reference/crect-class.md)物件，其中包含要格式化文字的矩形（以邏輯座標表示）。

*字串*<br/>
[CString](../../atl-mfc-shared/reference/cstringt-class.md)物件，其中包含要繪製的指定字元。

*nFormat*<br/>
指定格式化文字的方法。 它可以是在 Windows SDK 的[DrawText](/windows/win32/api/winuser/nf-winuser-drawtext)中，針對*uFormat*參數所描述之值的任何組合。 （使用位 OR 運算子結合）：

> [!NOTE]
> 某些*uFormat*旗標組合可能會導致修改傳遞的字串。 使用具有 DT_END_ELLIPSIS 或 DT_PATH_ELLIPSIS 的 DT_MODIFYSTRING 可能會導致修改字串，而造成覆寫中的判斷提示 `CString` 。 DT_CALCRECT、DT_EXTERNALLEADING、DT_INTERNAL、DT_NOCLIP 和 DT_NOPREFIX 的值不能與 DT_TABSTOP 值搭配使用。

### <a name="return-value"></a>傳回值

如果函式成功，則為文字的高度。

### <a name="remarks"></a>備註

它會藉由將索引標籤擴充至適當的空間來格式化文字，將文字對齊指定矩形的左邊、右邊或中央，並將文字分解成符合指定矩形的行。 格式的類型是由*nFormat*所指定。

此成員函式會使用裝置內容的選取字型、文字色彩和背景色彩來繪製文字。 除非使用 DT_NOCLIP 格式，否則會 `DrawText` 裁剪文字，讓文字不會出現在指定的矩形外。 除非指定了 DT_SINGLELINE 格式，否則所有格式都會假設有多行。

如果選取的字型對指定的矩形而言太大，則成員函式不 `DrawText` 會嘗試替換成較小的字型。

如果指定了 DT_CALCRECT 旗標， *lpRect*所指定的矩形就會更新，以反映繪製文字所需的寬度和高度。

如果已設定 TA_UPDATECP 文字對齊旗標（請參閱[CDC：： SetTextAlign](#settextalign)）， `DrawText` 將會顯示從目前位置開始的文字，而不是在指定矩形的左邊。 `DrawText`當已設定 TA_UPDATECP 旗標時（亦即，DT_WORDBREAK 旗標不會有任何作用），將不會將文字換行。

文字色彩可能是由[CDC：： SetTextColor](#settextcolor)所設定。

## <a name="cdcdrawtextex"></a><a name="drawtextex"></a>CDC：:D rawTextEx

格式化指定矩形中的文字。

```
virtual int DrawTextEx(
    LPTSTR lpszString,
    int nCount,
    LPRECT lpRect,
    UINT nFormat,
    LPDRAWTEXTPARAMS lpDTParams);

int DrawTextEx(
    const CString& str,
    LPRECT lpRect,
    UINT nFormat,
    LPDRAWTEXTPARAMS lpDTParams);
```

### <a name="parameters"></a>參數

*lpszString*<br/>
指向要繪製的字串。 如果*nCount*為-1，則字串必須為 null 終止。

*nCount*<br/>
指定字串中的字元數。 如果*nCount*為-1，則會假設*lpszString*是以 null 結束之字串的長指標，並 `DrawText` 自動計算字元計數。

*lpRect*<br/>
指向[RECT](/windows/win32/api/windef/ns-windef-rect)結構或[CRect](../../atl-mfc-shared/reference/crect-class.md)物件，其中包含要格式化文字的矩形（以邏輯座標表示）。

*字串*<br/>
[CString](../../atl-mfc-shared/reference/cstringt-class.md)物件，其中包含要繪製的指定字元。

*nFormat*<br/>
指定格式化文字的方法。 它可以是在 Windows SDK 的[DrawText](/windows/win32/api/winuser/nf-winuser-drawtext)中，針對*uFormat*參數所描述之值的任何組合。 （使用位**or**運算子結合）：

> [!NOTE]
> 某些*uFormat*旗標組合可能會導致修改傳遞的字串。 使用具有 DT_END_ELLIPSIS 或 DT_PATH_ELLIPSIS 的 DT_MODIFYSTRING 可能會導致修改字串，而造成覆寫中的判斷提示 `CString` 。 DT_CALCRECT、DT_EXTERNALLEADING、DT_INTERNAL、DT_NOCLIP 和 DT_NOPREFIX 的值不能與 DT_TABSTOP 值搭配使用。

*lpDTParams*<br/>
指定其他格式化選項之[DRAWTEXTPARAMS](/windows/win32/api/winuser/ns-winuser-drawtextparams)結構的指標。 這個參數可以是 Null。

### <a name="remarks"></a>備註

它會藉由將索引標籤擴充至適當的空間來格式化文字，將文字對齊指定矩形的左邊、右邊或中央，並將文字分解成符合指定矩形的行。 格式的類型是由*nFormat*和*lpDTParams*所指定。 如需詳細資訊，請參閱 Windows SDK 中的[CDC：:D rawtext](#drawtext)和[DrawTextEx](/windows/win32/api/winuser/nf-winuser-drawtextexw) 。

文字色彩可能是由[CDC：： SetTextColor](#settextcolor)所設定。

## <a name="cdcellipse"></a><a name="ellipse"></a>CDC：：橢圓形

繪製橢圓形。

```
BOOL Ellipse(
    int x1,
    int y1,
    int x2,
    int y2);

BOOL Ellipse(LPCRECT lpRect);
```

### <a name="parameters"></a>參數

*x1*<br/>
指定橢圓形周框左上角的邏輯 x 座標。

*y1*<br/>
指定橢圓形周框左上角的邏輯 y 座標。

*x2*<br/>
指定橢圓形周框的右下角邏輯 x 座標。

*y2*<br/>
指定橢圓形周框的右下角邏輯 y 座標。

*lpRect*<br/>
指定橢圓形的周框。 您也可以傳遞此參數的[CRect](../../atl-mfc-shared/reference/crect-class.md)物件。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

橢圓形的中心是由*x1*、 *y1*、 *x2*和*y2*或*lpRect*所指定的周框中央。 橢圓形會以目前的畫筆繪製，而其內部會填滿目前的筆刷。

此函式所繪製的圖表會延伸至，但不包括右和下座標。 這表示圖形的高度是*y2*  -  *y1* ，而圖的寬度是*x2*  -  *x1*。

如果周框矩形的寬度或高度為0，則不會繪製任何橢圓形。

## <a name="cdcenddoc"></a><a name="enddoc"></a>CDC：： EndDoc

結束呼叫[StartDoc](#startdoc)成員函式所啟動的列印工作。

```
int EndDoc();
```

### <a name="return-value"></a>傳回值

如果函式成功，則大於或等於0，如果發生錯誤，則為負數值。

### <a name="remarks"></a>備註

此成員函式會取代 ENDDOC 印表機 escape，而且應該在完成列印工作成功之後立即呼叫。

如果應用程式遇到列印錯誤或已取消的列印工作，則不能嘗試使用 `EndDoc` 或[AbortDoc](#abortdoc)來終止作業。 GDI 會在傳回錯誤值之前自動終止作業。

此函式不應在中繼檔內使用。

### <a name="example"></a>範例

  請參閱[CDC：： StartDoc](#startdoc)的範例。

## <a name="cdcendpage"></a><a name="endpage"></a>CDC：： EndPage

通知裝置應用程式已完成寫入頁面。

```
int EndPage();
```

### <a name="return-value"></a>傳回值

如果函式成功，則大於或等於0，如果發生錯誤，則為負數值。

### <a name="remarks"></a>備註

此成員函式通常用來指示設備磁碟機前進到新的頁面。

此成員函式會取代 NEWFRAME 印表機 escape。 不同于 NEWFRAME，在列印頁面之後，一律會呼叫這個函式。

### <a name="example"></a>範例

  請參閱[CDC：： StartDoc](#startdoc)的範例。

## <a name="cdcendpath"></a><a name="endpath"></a>CDC：： EndPath

關閉路徑括弧，並選取括弧所定義的路徑到裝置內容中。

```
BOOL EndPath();
```

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="example"></a>範例

  請參閱[CDC：： BeginPath](#beginpath)的範例。

## <a name="cdcenumobjects"></a><a name="enumobjects"></a>CDC：： EnumObjects

列舉裝置內容中可用的畫筆和筆刷。

```
int EnumObjects(
    int nObjectType,
    int (CALLBACK* lpfn)(
    LPVOID,
    LPARAM),
    LPARAM lpData);
```

### <a name="parameters"></a>參數

*nObjectType*<br/>
指定物件類型。 它可以有 OBJ_BRUSH 或 OBJ_PEN 的值。

*lpfn*<br/>
這是應用程式提供的回呼函式的進程實例位址。 請參閱下面的「備註」一節。

*lpData*<br/>
指向應用程式提供的資料。 資料會與物件資訊一起傳遞至回呼函數。

### <a name="return-value"></a>傳回值

指定[回呼函數](callback-functions-used-by-mfc.md#enum_objects)傳回的最後一個值。 其意義是使用者定義的。

### <a name="remarks"></a>備註

針對給定類型的每個物件，會使用該物件的資訊來呼叫您傳遞的回呼函式。 系統會呼叫回呼函數，直到沒有其他物件或回呼函式傳回0為止。

請注意，Microsoft Visual C++ 的新功能可讓您使用一般函數做為傳遞至的函式 `EnumObjects` 。 傳遞給的位址 `EnumObjects` 是以**EXPORT**和 Pascal 呼叫慣例匯出之函式的指標。 在保護模式應用程式中，您不需要使用 Windows MakeProcInstance 函式來建立此函式，或在搭配 FreeProcInstance Windows 函式使用之後釋放函式。

您也不需要在應用程式的模組定義檔中**匯出 export 語句中**的函數名稱。 您可以改用**EXPORT**函數修飾詞，如下所示：

**INT 回呼匯出**AFunction **（LPSTR**， **LPSTR）;**

讓編譯器以名稱發出適當的匯出記錄，而不需要加上別名。 這適用于大部分的需求。 在某些特殊情況下（例如，依序數匯出函式或將匯出設為別名），您仍然需要在模組定義檔中使用**export 語句。**

在編譯 Microsoft Foundation 程式時，您通常會使用/GA 和/GEs 編譯器選項。 /Gw 編譯器選項不會與 Microsoft Foundation 類別搭配使用。 （如果您使用 Windows 函式 `MakeProcInstance` ，則必須明確地將傳回的函式指標從 FARPROC 轉換為此 API 所需的類型）。回呼登錄介面現在是型別安全的（您必須傳入函式指標，指向特定回呼的正確函式類型）。

另請注意，在回到 Windows 之前，所有回呼函式都必須先將 Microsoft Foundation 例外狀況設陷，因為例外狀況無法跨回呼界限擲回。 如需例外狀況的詳細資訊，請參閱[例外](../../mfc/exception-handling-in-mfc.md)狀況一文。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCDocView#35](../../mfc/codesnippet/cpp/cdc-class_7.cpp)]

## <a name="cdcescape"></a><a name="escape"></a>CDC：： Escape

這個成員函式幾乎已過時，可用於 Win32 程式設計。

```
virtual int Escape(
    int nEscape,
    int nCount,
    LPCSTR lpszInData,
    LPVOID lpOutData);

int Escape(
    int nEscape,
    int nInputSize,
    LPCSTR lpszInputData,
    int nOutputSize,
    LPSTR lpszOutputData);
```

### <a name="parameters"></a>參數

*nEscape*<br/>
指定要執行的 escape 函數。

如需完整的 escape 函式清單，請參閱 Windows SDK 中的[escape](/windows/win32/api/wingdi/nf-wingdi-escape) 。

*nCount*<br/>
指定*lpszInData*所指向的資料位元組數目。

*lpszInData*<br/>
指向此 escape 所需的輸入資料結構。

*lpOutData*<br/>
指向要接收此 escape 輸出的結構。 如果沒有傳回任何資料， *lpOutData*參數會是 Null。

*nInputSize*<br/>
指定*lpszInputData*參數所指向的資料位元組數目。

*lpszInputData*<br/>
指向指定之轉義所需的輸入結構。

*nOutputSize*<br/>
指定*lpszOutputData*參數所指向的資料位元組數目。

*lpszOutputData*<br/>
指向接收此 escape 輸出的結構。 如果沒有傳回任何資料，這個參數應該是 Null。

### <a name="return-value"></a>傳回值

如果函式成功，則會傳回正值，但 QUERYESCSUPPORT escape 除外，只會檢查是否有執行。 如果未執行 escape，則會傳回零。 如果發生錯誤，則會傳回負數值。 以下是常見的錯誤值：

- SP_ERROR 一般錯誤。

- 目前沒有足夠的磁碟空間可用來進行多工緩衝處理，而且沒有其他空間可以使用。 SP_OUTOFDISK

- SP_OUTOFMEMORY 沒有足夠的記憶體可用於進行多工緩衝處理。

- SP_USERABORT 使用者已透過「列印管理員」結束作業。

### <a name="remarks"></a>備註

在原始印表機的轉義中，Win32 應用程式只支援 QUERYESCSUPPORT。 所有其他印表機的轉義都已過時，而且僅支援與16位應用程式相容。

針對 Win32 程式設計， `CDC` 現在提供六個成員函式來取代其對應的印表機轉義：

- [CDC：： AbortDoc](#abortdoc)

- [CDC：： EndDoc](#enddoc)

- [CDC：： EndPage](#endpage)

- [CDC：： SetAbortProc](#setabortproc)

- [CDC：： StartDoc](#startdoc)

- [CDC：： StartPage](#startpage)

此外， [CDC：： GetDeviceCaps](#getdevicecaps)支援取代其他印表機轉義的 Win32 索引。 如需詳細資訊，請參閱 Windows SDK 中的[GetDeviceCaps](/windows/win32/api/wingdi/nf-wingdi-getdevicecaps) 。

此成員函式可讓應用程式存取無法透過 GDI 直接取得之特定裝置的功能。

如果您的應用程式使用預先定義的轉義值，請使用第一個版本。 如果您的應用程式定義了私用的轉義值，請使用第二個版本。 如需第二個版本的詳細資訊，請參閱 Windows SDK 中的[ExtEscape](/windows/win32/api/wingdi/nf-wingdi-extescape) 。

## <a name="cdcexcludecliprect"></a><a name="excludecliprect"></a>CDC：： ExcludeClipRect

建立新的裁剪區域，其中包含減去指定矩形的現有裁剪區域。

```
int ExcludeClipRect(
    int x1,
    int y1,
    int x2,
    int y2);

int ExcludeClipRect(LPCRECT lpRect);
```

### <a name="parameters"></a>參數

*x1*<br/>
指定矩形左上角的邏輯 x 座標。

*y1*<br/>
指定矩形左上角的邏輯 y 座標。

*x2*<br/>
指定矩形右下角的邏輯 x 座標。

*y2*<br/>
指定矩形右下角的邏輯 y 座標。

*lpRect*<br/>
指定矩形。 也可以是 `CRect` 物件。

### <a name="return-value"></a>傳回值

指定新裁剪區域的類型。 可以是下列其中任何一個值：

- COMPLEXREGION 區域具有重迭的框線。

- 錯誤：未建立任何區域。

- NullREGION 區域是空的。

- SIMPLEREGION 區域沒有重迭的框線。

### <a name="remarks"></a>備註

由*x2*x1 的絕對值所指定之矩形的寬度，  -  *x1*不得超過32767個單位。 這項限制也適用于矩形的高度。

## <a name="cdcexcludeupdatergn"></a><a name="excludeupdatergn"></a>CDC：： ExcludeUpdateRgn

藉由從與物件相關聯的裁剪區域排除視窗中的更新區域，防止在視窗的無效區域內繪圖 `CDC` 。

```
int ExcludeUpdateRgn(CWnd* pWnd);
```

### <a name="parameters"></a>參數

*pWnd*<br/>
指向要更新其視窗的視窗物件。

### <a name="return-value"></a>傳回值

排除區域的類型。 它可以是下列任何一個值：

- COMPLEXREGION 區域具有重迭的框線。

- 錯誤：未建立任何區域。

- NullREGION 區域是空的。

- SIMPLEREGION 區域沒有重迭的框線。

## <a name="cdcextfloodfill"></a><a name="extfloodfill"></a>CDC：： ExtFloodFill

以目前筆刷填滿顯示介面的區域。

```
BOOL ExtFloodFill(
    int x,
    int y,
    COLORREF crColor,
    UINT nFillType);
```

### <a name="parameters"></a>參數

*x*<br/>
指定填滿開始之點的邏輯 x 座標。

*y*<br/>
指定填滿開始之點的邏輯 y 座標。

*crColor*<br/>
指定要填入的界限或區域的色彩。 *CrColor*的解讀取決於*nFillType*的值。

*nFillType*<br/>
指定要執行之洪水填滿的類型。 它必須是下列值之一：

- FLOODFILLBORDER 填滿區域會受到*crColor*所指定的色彩所限制。 這個樣式與所執行的填滿相同 `FloodFill` 。

- FLOODFILLSURFACE 填滿區域是由*crColor*所指定的色彩所定義。 只要遇到色彩，填滿就會繼續向外擴展所有方向。 此樣式適用于使用多顏色邊界填滿區域。

### <a name="return-value"></a>傳回值

如果函式成功，則為非零;如果填滿無法完成，則為 0; 如果指定的點具有由*crColor*指定的界限色彩（如果已要求 FLOODFILLBORDER），則為; 如果指定的點沒有*crColor*所指定的色彩（如果已要求 FLOODFILLSURFACE），或如果該點在裁剪區域之外，則為。

### <a name="remarks"></a>備註

這個成員函式提供的彈性高於 `FloodFill` ，因為您可以在*nFillType*中指定填滿類型。

如果*nFillType*設定為 FLOODFILLBORDER，則會假設該區域是由*crColor*所指定的色彩完全限定。 函式會從*x*和*y*指定的點開始，並將所有方向填滿色彩界限。

如果*nFillType*設定為 FLOODFILLSURFACE，函式就會從*x*和*y*指定的點開始，並繼續進行所有的方向，並填滿包含*crColor*所指定之色彩的所有相鄰區域。

僅限於支援點陣顯示技術支援的記憶體裝置內容和裝置 `ExtFloodFill` 。 如需詳細資訊，請參閱[GetDeviceCaps](#getdevicecaps)成員函式。

## <a name="cdcexttextout"></a><a name="exttextout"></a>CDC：： ExtTextOut

呼叫這個成員函式，以使用目前選取的字型，在矩形區域內寫入字元字串。

```
virtual BOOL ExtTextOut(
    int x,
    int y,
    UINT nOptions,
    LPCRECT lpRect,
    LPCTSTR lpszString,
    UINT nCount,
    LPINT lpDxWidths);

BOOL ExtTextOut(
    int x,
    int y,
    UINT nOptions,
    LPCRECT lpRect,
    const CString& str,
    LPINT lpDxWidths);
```

### <a name="parameters"></a>參數

*x*<br/>
針對指定之字串中的第一個字元，指定字元資料格的邏輯 x 座標。

*y*<br/>
針對指定之字串中的第一個字元，指定字元資料格頂端的邏輯 y 座標。

*nOptions*<br/>
指定矩形類型。 這個參數可以是其中一個、兩個或兩者都不是下列值：

- ETO_CLIPPED 指定將文字裁剪成矩形。

- ETO_OPAQUE 指定目前的背景色彩填滿矩形。 （您可以使用[SetBkColor](#setbkcolor)和[GetBkColor](#getbkcolor)成員函式來設定及查詢目前的背景色彩）。

*lpRect*<br/>
指向決定矩形維度的[矩形](/windows/win32/api/windef/ns-windef-rect)結構。 這個參數可以是 Null。 您也可以傳遞此參數的[CRect](../../atl-mfc-shared/reference/crect-class.md)物件。

*lpszString*<br/>
指向要繪製的指定字元字串。 您也可以傳遞此參數的[CString](../../atl-mfc-shared/reference/cstringt-class.md)物件。

*nCount*<br/>
指定字串中的字元數。

*lpDxWidths*<br/>
指向值的陣列，指出相鄰字元資料格來源之間的距離。 例如， *lpDxWidths*[ *i*] 邏輯單元會分隔字元資料格的來源*i*和字元資料格*i* + 1。 如果*lpDxWidths*為 Null，則會 `ExtTextOut` 使用字元之間的預設間距。

*字串*<br/>
`CString`物件，包含要繪製的指定字元。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

矩形區域可以是不透明的（以目前的背景色彩填滿），而且可以是裁剪區域。

如果*nOptions*為0，而*lpRect*為 Null，則函式會將文字寫入裝置內容，而不使用矩形區域。 根據預設，函式不會使用或更新目前的位置。 如果應用程式在呼叫時需要更新目前的位置 `ExtTextOut` ，應用程式可以呼叫成員函式 `CDC` [SetTextAlign](#settextalign) ，並將*nFlags*設為 TA_UPDATECP。 設定此旗標時，Windows 會在後續呼叫時忽略*x*和*y* ， `ExtTextOut` 並改為使用目前的位置。 當應用程式使用 TA_UPDATECP 來更新目前的位置時， `ExtTextOut` 會將目前的位置設定為上一行文字的結尾，或設為*lpDxWidths*所指向之陣列最後一個元素所指定的位置（以較大者為准）。

## <a name="cdcfillpath"></a><a name="fillpath"></a>CDC：： FillPath

在目前的路徑中關閉任何已開啟的圖形，並使用目前筆刷和多邊形填滿模式來填滿路徑的內部。

```
BOOL FillPath();
```

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

填入內部之後，會從裝置內容中捨棄路徑。

## <a name="cdcfillrect"></a><a name="fillrect"></a>CDC：： FillRect

呼叫這個成員函式，以使用指定的筆刷來填滿指定的矩形。

```cpp
void FillRect(
    LPCRECT lpRect,
    CBrush* pBrush);
```

### <a name="parameters"></a>參數

*lpRect*<br/>
指向包含要填滿之矩形邏輯座標的[矩形](/windows/win32/api/windef/ns-windef-rect)結構。 您也可以傳遞此參數的[CRect](../../atl-mfc-shared/reference/crect-class.md)物件。

*pBrush*<br/>
識別用來填滿矩形的筆刷。

### <a name="remarks"></a>備註

函式會填滿完整的矩形，包括左邊和上框線，但不會填滿右邊和下框線。

您必須使用[CBrush](../../mfc/reference/cbrush-class.md)成員函式[CreateHatchBrush](../../mfc/reference/cbrush-class.md#createhatchbrush)、 [CreatePatternBrush](../../mfc/reference/cbrush-class.md#createpatternbrush)和[CreateSolidBrush](../../mfc/reference/cbrush-class.md#createsolidbrush)來建立筆刷，或由 `GetStockObject` Windows 函數抓取。

填滿指定的矩形時，不 `FillRect` 會包含矩形的右邊和右下方。 無論目前的對應模式為何，GDI 都會將矩形填滿，但不包括右資料行和底部資料列。 `FillRect`比較 `top` `bottom` 指定矩形的、、 `left` 和 `right` 成員的值。 如果 `bottom` 小於或等於 `top` ，或如果 `right` 小於或等於 `left` ，則不會繪製矩形。

`FillRect`類似于[CDC：： FillSolidRect](#fillsolidrect);不過，會 `FillRect` 採用筆刷，因此可以用來填滿純色、遞色、影線筆刷或圖樣的矩形。 `FillSolidRect`只使用純色（以 COLORREF 參數表示）。 `FillRect`通常比更慢 `FillSolidRect` 。

## <a name="cdcfillrgn"></a><a name="fillrgn"></a>CDC：： FillRgn

使用*pBrush*所指定的筆刷，填滿*pRgn*所指定的區域。

```
BOOL FillRgn(
    CRgn* pRgn,
    CBrush* pBrush);
```

### <a name="parameters"></a>參數

*pRgn*<br/>
要填入之區域的指標。 給定區域的座標是以邏輯單元指定。

*pBrush*<br/>
識別要用來填滿區域的筆刷。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

筆刷必須使用所要抓取的成員函式、、或來建立 `CBrush` `CreateHatchBrush` `CreatePatternBrush` `CreateSolidBrush` `GetStockObject` 。

### <a name="example"></a>範例

  請參閱[CRgn：： CreateRoundRectRgn](../../mfc/reference/crgn-class.md#createroundrectrgn)的範例。

## <a name="cdcfillsolidrect"></a><a name="fillsolidrect"></a>CDC：： FillSolidRect

呼叫這個成員函式，以指定的純色填滿給定的矩形。

```cpp
void FillSolidRect(
    LPCRECT lpRect,
    COLORREF clr);

void FillSolidRect(
    int x,
    int y,
    int cx,
    int cy,
    COLORREF clr);
```

### <a name="parameters"></a>參數

*lpRect*<br/>
指定周框（以邏輯單位表示）。 您可以傳遞[矩形](/windows/win32/api/windef/ns-windef-rect)資料結構的指標或 `CRect` 此參數的物件。

*clr*指定要用來填滿矩形的色彩。

*x*<br/>
指定矩形左上角的邏輯 x 座標。

*y*<br/>
指定目的地矩形左上角的邏輯 y 座標。

*cx*<br/>
指定矩形的寬度。

*cy*<br/>
指定矩形的高度。

### <a name="remarks"></a>備註

`FillSolidRect`非常類似[CDC：： FillRect](#fillrect);不過， `FillSolidRect` 只會使用純色（以 COLORREF 參數表示），而會 `FillRect` 採用筆刷，因此可以用來填滿具有純色、遞色、影線筆刷或圖樣的矩形。 `FillSolidRect`通常速度比更快 `FillRect` 。

> [!NOTE]
> 當您呼叫時， `FillSolidRect` 背景色彩（先前使用[SetBkColor](#setbkcolor)設定）會設定為*clr*所指示的色彩。

## <a name="cdcflattenpath"></a><a name="flattenpath"></a>CDC：： FlattenPath

將所選路徑中的任何曲線轉換成目前的裝置內容，然後將每個曲線變成一連串的線條。

```
BOOL FlattenPath();
```

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

## <a name="cdcfloodfill"></a><a name="floodfill"></a>CDC：： FloodFill

以目前筆刷填滿顯示介面的區域。

```
BOOL FloodFill(
    int x,
    int y,
    COLORREF crColor);
```

### <a name="parameters"></a>參數

*x*<br/>
指定填滿開始之點的邏輯 x 座標。

*y*<br/>
指定填滿開始之點的邏輯 y 座標。

*crColor*<br/>
指定界限的色彩。

### <a name="return-value"></a>傳回值

如果函式成功，則為非零;否則，如果無法完成填滿，則會傳回0，指定的點具有*crColor*所指定的界限色彩，或點位於裁剪區域外部。

### <a name="remarks"></a>備註

區域會假設為*crColor*所指定的界限。 函式會從 `FloodFill` *x*和*y*所指定的點開始，並在色彩界限的所有方向繼續進行。

只有記憶體裝置內容和支援點陣顯示技術的裝置支援成員函式 `FloodFill` 。 如需 RC_BITBLT 功能的相關資訊，請參閱成員函式 `GetDeviceCaps` 。

函式 `ExtFloodFill` 提供類似的功能，但有更大的彈性。

## <a name="cdcframerect"></a><a name="framerect"></a>CDC：： FrameRect

在*lpRect*所指定的矩形周圍繪製框線。

```cpp
void FrameRect(
    LPCRECT lpRect,
    CBrush* pBrush);
```

### <a name="parameters"></a>參數

*lpRect*<br/>
指向[RECT](/windows/win32/api/windef/ns-windef-rect)結構或[CRect](../../atl-mfc-shared/reference/crect-class.md)物件，其中包含矩形左上角和右下角的邏輯座標。 您也可以傳遞 `CRect` 此參數的物件。

*pBrush*<br/>
識別要用於框架矩形的筆刷。

### <a name="remarks"></a>備註

函式會使用指定的筆刷繪製框線。 框線的寬度和高度一律為1個邏輯單元。

如果矩形的 `bottom` 座標小於或等於 `top` ，或如果 `right` 小於或等於 `left` ，則不會繪製矩形。

繪製的框線與 `FrameRect` 使用相同座標的成員函式所繪製的框線位於相同位置 `Rectangle` （如果 `Rectangle` 使用的畫筆為1個邏輯單位）。 矩形的內部不會填滿 `FrameRect` 。

## <a name="cdcframergn"></a><a name="framergn"></a>CDC：： FrameRgn

使用*pBrush*所指定的筆刷，在*pRgn*所指定的區域周圍繪製框線。

```
BOOL FrameRgn(
    CRgn* pRgn,
    CBrush* pBrush,
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>參數

*pRgn*<br/>
指向 `CRgn` 物件，識別要以框線括住的區域。 給定區域的座標是以邏輯單元指定。

*pBrush*<br/>
指向 `CBrush` 物件，識別要用來繪製框線的筆刷。

*nWidth*<br/>
以裝置單位的垂直筆刷筆觸，指定框線的寬度。

*nHeight*<br/>
指定裝置單位中水準筆刷筆劃的框線高度。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="example"></a>範例

  請參閱[CRgn：： CombineRgn](../../mfc/reference/crgn-class.md#combinergn)的範例。

## <a name="cdcfromhandle"></a><a name="fromhandle"></a>CDC：： FromHandle

`CDC`當提供裝置內容的控制碼時，傳回物件的指標。

```
static CDC* PASCAL FromHandle(HDC hDC);
```

### <a name="parameters"></a>參數

*hDC*<br/>
包含 Windows 裝置內容的控制碼。

### <a name="return-value"></a>傳回值

指標可能是暫時性的，不應儲存在立即可用的範圍外。

### <a name="remarks"></a>備註

如果 `CDC` 物件沒有附加至控制代碼，會建立並附加暫存 `CDC` 物件。

### <a name="example"></a>範例

  請參閱[CPrintDialog：： GetPrinterDC](../../mfc/reference/cprintdialog-class.md#getprinterdc)的範例。

## <a name="cdcgetarcdirection"></a><a name="getarcdirection"></a>CDC：： GetArcDirection

傳回裝置內容的目前弧線方向。

```
int GetArcDirection() const;
```

### <a name="return-value"></a>傳回值

如果成功，則指定目前的弧線方向。 以下是有效的傳回值：

- 以逆時針繪製 AD_COUNTERCLOCKWISE 弧形和矩形。

- 以順時針方向繪製 AD_CLOCKWISE 弧形和矩形。

如果發生錯誤，則傳回值為零。

### <a name="remarks"></a>備註

弧線和矩形函式使用弧線方向。

## <a name="cdcgetaspectratiofilter"></a><a name="getaspectratiofilter"></a>CDC：： GetAspectRatioFilter

抓取目前外觀比例篩選的設定。

```
CSize GetAspectRatioFilter() const;
```

### <a name="return-value"></a>傳回值

`CSize`物件，代表目前外觀比例篩選所使用的長寬比。

### <a name="remarks"></a>備註

長寬比是由裝置的圖元寬度和高度所形成的比例。 裝置外觀比例的相關資訊會用於建立、選取及顯示字型。 Windows 提供特殊的篩選準則（外觀比例篩選），可從所有可用的字型選取專為特定外觀比例而設計的字型。 篩選會使用成員函式所指定的長寬比 `SetMapperFlags` 。

## <a name="cdcgetbkcolor"></a><a name="getbkcolor"></a>CDC：： GetBkColor

傳回目前的背景色彩。

```
COLORREF GetBkColor() const;
```

### <a name="return-value"></a>傳回值

RGB 色彩值。

### <a name="remarks"></a>備註

如果背景模式不透明，系統會使用背景色彩來填滿樣式線條中的間距、筆刷中的影線線之間的間距，以及字元儲存格中的背景。 當您在色彩和單色裝置內容之間轉換點陣圖時，系統也會使用背景色彩。

## <a name="cdcgetbkmode"></a><a name="getbkmode"></a>CDC：： GetBkMode

傳回背景模式。

```
int GetBkMode() const;
```

### <a name="return-value"></a>傳回值

目前的背景模式，可能是不透明或透明的。

### <a name="remarks"></a>備註

背景模式定義系統是否在繪製文字、陰影筆刷或任何非實線的畫筆樣式之前，先移除繪圖介面上的現有背景色彩。

## <a name="cdcgetboundsrect"></a><a name="getboundsrect"></a>CDC：： GetBoundsRect

傳回指定之裝置內容的目前累積周框。

```
UINT GetBoundsRect(
    LPRECT lpRectBounds,
    UINT flags);
```

### <a name="parameters"></a>參數

*lpRectBounds*<br/>
指向將會接收目前周框的緩衝區。 矩形會以邏輯座標傳回。

*flags*<br/>
指定是否要在傳回周框後將其清除。 此參數應為零，或設定為下列值：

- DCB_RESET 會強制在傳回周框後將其清除。

### <a name="return-value"></a>傳回值

如果函式成功，則指定周框的目前狀態。 它可以是下列值的組合：

- 發生 DCB_ACCUMULATE 周框矩形累積。

- DCB_RESET 周框是空的。

- DCB_SET 周框不是空的。

- DCB_ENABLE 周框累積已開啟。

- DCB_DISABLE 周框累積已關閉。

## <a name="cdcgetbrushorg"></a><a name="getbrushorg"></a>CDC：： GetBrushOrg

抓取目前為裝置內容選取之筆刷的來源（以裝置為單位）。

```
CPoint GetBrushOrg() const;
```

### <a name="return-value"></a>傳回值

筆刷的目前來源（以裝置為單位），表示為[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)物件。

### <a name="remarks"></a>備註

初始筆刷原點是在工作區的（0，0）。 傳回值會在裝置單位中指定與桌面視窗原點相關的這個點。

## <a name="cdcgetcharacterplacement"></a><a name="getcharacterplacement"></a>CDC：： GetCharacterPlacement

在字元字串上抓取各種類型的資訊。

```
DWORD GetCharacterPlacement(
    LPCTSTR lpString,
    int nCount,
    int nMaxExtent,
    LPGCP_RESULTS lpResults,
    DWORD dwFlags) const;

DWORD GetCharacterPlacement(
    CString& str,
    int nMaxExtent,
    LPGCP_RESULTS lpResults,
    DWORD dwFlags) const;
```

### <a name="parameters"></a>參數

*lpString*<br/>
要處理之字元字串的指標。

*nCount*<br/>
指定字串的長度。 就 ANSI 版本而言，它是位元組計數，而 Unicode 函式則是字數統計。 如需詳細資訊，請參閱[GetCharacterPlacement](/windows/win32/api/wingdi/nf-wingdi-getcharacterplacementw)。

*nMaxExtent*<br/>
指定處理字串的最大範圍（以邏輯單位表示）。 如果已處理，則會忽略此範圍的字元。 任何必要排序或圖像陣列的計算只適用于包含的字元。 只有在*dwFlags*參數中指定了 GCP_MAXEXTENT 值時，才會使用這個參數。 當函式處理輸入字串時，只有在總範圍尚未超過最大值時，才會將每個字元和其範圍加入至輸出、範圍和其他陣列。 一旦達到限制，處理就會停止。

*lpResults*<br/>
接收函數結果之[GCP_Results](/windows/win32/api/wingdi/ns-wingdi-gcp_resultsw)結構的指標。

*dwFlags*<br/>
指定如何將字串處理成必要的陣列。 這個參數可以是[GetCharacterPlacement](/windows/win32/api/wingdi/nf-wingdi-getcharacterplacementw)主題的*dwFlags*一節中所列的一或多個值。

*字串*<br/>
要處理之[CString](../../atl-mfc-shared/reference/cstringt-class.md)物件的指標。

### <a name="return-value"></a>傳回值

如果函式成功，則傳回值會是字串的寬度和高度（以邏輯單位表示）。

如果此函式失敗，則傳回值為零。

### <a name="remarks"></a>備註

此成員函式會模擬函數[GetCharacterPlacement](/windows/win32/api/wingdi/nf-wingdi-getcharacterplacementw)的功能，如 Windows SDK 中所述。

## <a name="cdcgetcharabcwidths"></a><a name="getcharabcwidths"></a>CDC：： GetCharABCWidths

從目前的 TrueType 字型，抓取指定範圍內連續字元的寬度。

```
BOOL GetCharABCWidths(
    UINT nFirstChar,
    UINT nLastChar,
    LPABC lpabc) const;

BOOL GetCharABCWidths(
    UINT nFirstChar,
    UINT nLastChar,
    LPABCFLOAT lpABCF) const;
```

### <a name="parameters"></a>參數

*nFirstChar*<br/>
指定目前字型中，字元寬度所傳回之字元範圍中的第一個字元。

*nLastChar*<br/>
指定目前字型中字元寬度所傳回的最後一個字元。

*lpabc*<br/>
指向[ABC](/windows/win32/api/wingdi/ns-wingdi-abc)結構的陣列，當函式傳回時，會接收字元寬度。 此陣列至少必須包含多個 `ABC` 結構，因為*NFirstChar*和*nLastChar*參數所指定的範圍中有個字元。

*lpABCF*<br/>
指向應用程式提供的緩衝區，其中包含要在函式傳回時接收字元寬度的[ABCFLOAT](/windows/win32/api/wingdi/ns-wingdi-abcfloat)結構陣列。 此函式所傳回的寬度為 IEEE 浮點格式。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

寬度會以邏輯單元傳回。 此函式只會在 TrueType 字型中成功。

在選取特定的點大小之後，TrueType 轉譯器會提供 "ABC" 字元間距。 「A」間距是在放置圖像之前，加入至目前位置的距離。 "B" 間距是圖像黑色部分的寬度。 "C" 間距會加入至目前的位置，以考慮字元右邊的空白字元。 Total advanced width 是由 A + B + C 所提供。

當成員函式抓取 `GetCharABCWidths` 字元的負值 "A" 或 "C" 寬度時，該字元會包含 underhangs 或 overhangs。

若要將 ABC 寬度轉換成字型設計單位，應用程式應該建立高度（如 LOGFONT 結構的成員中所指定）的字型， `lfHeight` 等於[LOGFONT](/windows/win32/api/wingdi/ns-wingdi-logfontw) `ntmSizeEM` [NEWTEXTMETRIC](/windows/win32/api/wingdi/ns-wingdi-newtextmetricw)結構的成員中所儲存的值。 （您 `ntmSizeEM` 可以藉由呼叫[EnumFontFamilies](/windows/win32/api/wingdi/nf-wingdi-enumfontfamiliesw) Windows 函數來抓取成員的值）。

預設字元的 ABC 寬度會用於目前所選字型範圍以外的字元。

若要取得非 TrueType 字型中的字元寬度，應用程式應該使用[GetCharWidth](/windows/win32/api/wingdi/nf-wingdi-getcharwidthw) Windows 函式。

## <a name="cdcgetcharabcwidthsi"></a><a name="getcharabcwidthsi"></a>CDC：： GetCharABCWidthsI

從目前的 TrueType 字型，抓取指定範圍內連續圖像索引的寬度（以邏輯單位表示）。

```
BOOL GetCharABCWidthsI(
    UINT giFirst,
    UINT cgi,
    LPWORD pgi,
    LPABC lpabc) const;
```

### <a name="parameters"></a>參數

*giFirst*<br/>
指定目前字型的連續圖像索引群組中的第一個字元索引。 只有在*pgi*參數為 Null 時，才會使用這個參數。

*cgi*<br/>
指定字元索引的數目。

*pgi*<br/>
包含圖像索引之陣列的指標。 如果值為 Null，則會改用*giFirst*參數。 *Cgi*參數會指定此陣列中的字元索引數目。

*lpabc*<br/>
接收字元寬度的[ABC](/windows/win32/api/wingdi/ns-wingdi-abc)結構陣列的指標。 此陣列所包含的結構，必須與 cgi 參數所指定的圖像索引數目至少相同 `ABC` 。 *cgi*

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

此成員函式會模擬函數[GetCharABCWidthsI](/windows/win32/api/wingdi/nf-wingdi-getcharabcwidthsi)的功能，如 Windows SDK 中所述。

## <a name="cdcgetcharwidth"></a><a name="getcharwidth"></a>CDC：： GetCharWidth

使用輸入裝置內容，從目前字型的連續字元群組中抓取個別字元的寬度 `m_hAttribDC` 。

```
BOOL GetCharWidth(
    UINT nFirstChar,
    UINT nLastChar,
    LPINT lpBuffer) const;

BOOL GetCharWidth(
    UINT nFirstChar,
    UINT nLastChar,
    float* lpFloatBuffer) const;
```

### <a name="parameters"></a>參數

*nFirstChar*<br/>
指定目前字型中，連續字元群組中的第一個字元。

*nLastChar*<br/>
指定目前字型中連續字元群組的最後一個字元。

*lpBuffer*<br/>
指向會接收目前字型中連續字元群組之寬度值的緩衝區。

*lpFloatBuffer*<br/>
指向要接收字元寬度的緩衝區。 傳回的寬度為32位 IEEE 浮點格式。 （寬度會沿著字元的基底行來測量）。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

例如，如果*nFirstChar*識別字母 ' a '，而*nLastChar*識別字母 ' z '，則函數會抓取所有小寫字元的寬度。

函式會將值儲存在*lpBuffer*所指向的緩衝區中。 這個緩衝區必須夠大，才能容納所有寬度。 也就是說，在此範例中，至少必須有26個專案。

如果在特定字型中不存在連續字元群組中的字元，則會將預設字元的寬度值指派給它。

## <a name="cdcgetcharwidthi"></a><a name="getcharwidthi"></a>CDC：： GetCharWidthI

從目前字型，抓取指定範圍內連續圖像索引的寬度（以邏輯座標表示）。

```
BOOL GetCharWidthI(
    UINT giFirst,
    UINT cgi,
    LPWORD pgi,
    LPINT lpBuffer) const;
```

### <a name="parameters"></a>參數

*giFirst*<br/>
指定目前字型的連續圖像索引群組中的第一個字元索引。 只有在*pgi*參數為 Null 時，才會使用這個參數。

*cgi*<br/>
指定字元索引的數目。

*pgi*<br/>
包含圖像索引之陣列的指標。 如果值為 Null，則會改用*giFirst*參數。 *Cgi*參數會指定此陣列中的字元索引數目。

*lpBuffer*<br/>
接收寬度之緩衝區的指標。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

此成員函式會模擬函數[GetCharWidthI](/windows/win32/api/wingdi/nf-wingdi-getcharwidthi)的功能，如 Windows SDK 中所述。

## <a name="cdcgetclipbox"></a><a name="getclipbox"></a>CDC：： GetClipBox

抓取目前裁剪界限周圍嚴謹周框的維度。

```
virtual int GetClipBox(LPRECT lpRect) const;
```

### <a name="parameters"></a>參數

*lpRect*<br/>
指向用來接收矩形維度的[RECT](/windows/win32/api/windef/ns-windef-rect)結構或[CRect](../../atl-mfc-shared/reference/crect-class.md)物件。

### <a name="return-value"></a>傳回值

裁剪區域的類型。 可以是下列其中任何一個值：

- COMPLEXREGION 裁剪區域具有重迭的框線。

- 錯誤裝置內容無效。

- NullREGION 裁剪區域是空的。

- SIMPLEREGION 裁剪區域沒有重迭的框線。

### <a name="remarks"></a>備註

維度會複製到*lpRect*所指向的緩衝區。

## <a name="cdcgetcoloradjustment"></a><a name="getcoloradjustment"></a>CDC：： GetColorAdjustment

抓取裝置內容的色彩調整值。

```
BOOL GetColorAdjustment(LPCOLORADJUSTMENT lpColorAdjust) const;
```

### <a name="parameters"></a>參數

*lpColorAdjust*<br/>
指向[COLORADJUSTMENT](/windows/win32/api/wingdi/ns-wingdi-coloradjustment)資料結構，以接收色彩調整值。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

## <a name="cdcgetcurrentbitmap"></a><a name="getcurrentbitmap"></a>CDC：： GetCurrentBitmap

傳回目前所選取物件的指標 `CBitmap` 。

```
CBitmap* GetCurrentBitmap() const;
```

### <a name="return-value"></a>傳回值

`CBitmap`如果成功，則為物件的指標; 否則為 Null。

### <a name="remarks"></a>備註

這個成員函式可能會傳回暫存物件。

## <a name="cdcgetcurrentbrush"></a><a name="getcurrentbrush"></a>CDC：： GetCurrentBrush

傳回目前所選取物件的指標 `CBrush` 。

```
CBrush* GetCurrentBrush() const;
```

### <a name="return-value"></a>傳回值

`CBrush`如果成功，則為物件的指標; 否則為 Null。

### <a name="remarks"></a>備註

這個成員函式可能會傳回暫存物件。

## <a name="cdcgetcurrentfont"></a><a name="getcurrentfont"></a>CDC：： GetCurrentFont

傳回目前所選取物件的指標 `CFont` 。

```
CFont* GetCurrentFont() const;
```

### <a name="return-value"></a>傳回值

`CFont`如果成功，則為物件的指標; 否則為 Null。

### <a name="remarks"></a>備註

這個成員函式可能會傳回暫存物件。

## <a name="cdcgetcurrentpalette"></a><a name="getcurrentpalette"></a>CDC：： GetCurrentPalette

傳回目前所選取物件的指標 `CPalette` 。

```
CPalette* GetCurrentPalette() const;
```

### <a name="return-value"></a>傳回值

`CPalette`如果成功，則為物件的指標; 否則為 Null。

### <a name="remarks"></a>備註

這個成員函式可能會傳回暫存物件。

## <a name="cdcgetcurrentpen"></a><a name="getcurrentpen"></a>CDC：： GetCurrentPen

傳回目前所選取物件的指標 `CPen` 。

```
CPen* GetCurrentPen() const;
```

### <a name="return-value"></a>傳回值

`CPen`如果成功，則為物件的指標; 否則為 Null。

### <a name="remarks"></a>備註

這個成員函式可能會傳回暫存物件。

## <a name="cdcgetcurrentposition"></a><a name="getcurrentposition"></a>CDC：： GetCurrentPosition

抓取目前的位置（以邏輯座標表示）。

```
CPoint GetCurrentPosition() const;
```

### <a name="return-value"></a>傳回值

做為物件的目前位置 `CPoint` 。

### <a name="remarks"></a>備註

目前的位置可以使用成員函式來設定 `MoveTo` 。

## <a name="cdcgetdcbrushcolor"></a><a name="getdcbrushcolor"></a>CDC：： GetDCBrushColor

擷取目前的筆刷色彩。

```
COLORREF GetDCBrushColor() const;
```

### <a name="return-value"></a>傳回值

如果函式成功，則傳回值是目前筆刷色彩的[COLORREF](/windows/win32/gdi/colorref)值。

如果函式失敗，則傳回值是 CLR_INVALID。

### <a name="remarks"></a>備註

此成員函式會模擬函數[GetDCBrushColor](/windows/win32/api/wingdi/nf-wingdi-getdcbrushcolor)的功能，如 Windows SDK 中所述。

## <a name="cdcgetdcpencolor"></a><a name="getdcpencolor"></a>CDC：： GetDCPenColor

擷取目前的畫筆顏色。

```
COLORREF GetDCPenColor() const;
```

### <a name="return-value"></a>傳回值

如果函式成功，則傳回值是目前畫筆色彩的[COLORREF](/windows/win32/gdi/colorref)值。

如果函式失敗，則傳回值是 CLR_INVALID。

### <a name="remarks"></a>備註

此成員函式會利用 Win32 函數[GetDCPenColor](/windows/win32/api/wingdi/nf-wingdi-getdcpencolor)，如 Windows SDK 中所述。

## <a name="cdcgetdevicecaps"></a><a name="getdevicecaps"></a>CDC：： GetDeviceCaps

抓取有關顯示裝置的各種裝置特定資訊。

```
int GetDeviceCaps(int nIndex) const;
```

### <a name="parameters"></a>參數

*nIndex*<br/>
指定要傳回的資訊類型。 如需值清單，請參閱 Windows SDK 中的[GetDeviceCaps](/windows/win32/api/wingdi/nf-wingdi-getdevicecaps) 。

### <a name="return-value"></a>傳回值

如果函式成功，則為要求的功能的值。

### <a name="example"></a>範例

  請參閱[CPrintDialog：： GetDefaults](../../mfc/reference/cprintdialog-class.md#getdefaults)的範例。

## <a name="cdcgetfontdata"></a><a name="getfontdata"></a>CDC：： GetFontData

從可調整的字型檔案抓取字型度量資訊。

```
DWORD GetFontData(
    DWORD dwTable,
    DWORD dwOffset,
    LPVOID lpData,
    DWORD cbData) const;
```

### <a name="parameters"></a>參數

*dwTable*<br/>
指定要傳回之度量資料表的名稱。 這個參數可以是 Microsoft Corporation 發佈的 TrueType 字型檔案規格中記載的其中一個計量表。 如果此參數為0，則會從字型檔案的開頭開始抓取資訊。

*dwOffset*<br/>
指定要開始抓取資訊之資料表開頭的位移。 如果此參數為0，則會從*dwTable*參數所指定的資料表開頭開始抓取資訊。 如果這個值大於或等於資料表的大小，則會傳回 `GetFontData` 0。

*lpData*<br/>
指向將接收字型資訊的緩衝區。 如果這個值是 Null，此函式會傳回*dwTable*參數中指定之字型資料所需的緩衝區大小。

*cbData*<br/>
指定要抓取之資訊的長度（以位元組為單位）。 如果此參數為0，則會傳回 `GetFontData` *dwTable*參數中指定的資料大小。

### <a name="return-value"></a>傳回值

當函式成功時，指定*lpData*所指向的緩衝區中傳回的位元組數目;否則為-1。

### <a name="remarks"></a>備註

要取得的資訊是藉由在字型檔案中指定位移以及要傳回的資訊長度來識別。

應用程式有時可以使用成員函式 `GetFontData` 來儲存 TrueType 字型與檔。 若要這樣做，應用程式會決定是否可以內嵌字型，然後抓取整個字型檔案，為*dwTable*、 *dwOffset*和*cbData*參數指定0。

應用程式可以藉由檢查 OUTLINETEXTMETRIC 結構的成員，來判斷字型是否可以內嵌 `otmfsType` 。 [OUTLINETEXTMETRIC](/windows/win32/api/wingdi/ns-wingdi-outlinetextmetricw) 如果設定了的位 1 `otmfsType` ，字型就不允許內嵌。 如果位1是清除的，則字型可以內嵌。 如果設定了位2，內嵌就是唯讀的。

如果應用程式嘗試使用此函式來抓取非 TrueType 字型的資訊，此成員函 `GetFontData` 式會傳回-1。

## <a name="cdcgetfontlanguageinfo"></a><a name="getfontlanguageinfo"></a>CDC：： GetFontLanguageInfo

針對指定的顯示內容，傳回目前選取之字型的相關資訊。

```
DWORD GetFontLanguageInfo() const;
```

### <a name="return-value"></a>傳回值

傳回值會識別目前選取之字型的特性。 如需可能值的完整清單，請參閱[GetFontLanguageInfo](/windows/win32/api/wingdi/nf-wingdi-getfontlanguageinfo)。

### <a name="remarks"></a>備註

此成員函式會模擬函數[GetFontLanguageInfo](/windows/win32/api/wingdi/nf-wingdi-getfontlanguageinfo)的功能，如 Windows SDK 中所述。

## <a name="cdcgetglyphoutline"></a><a name="getglyphoutline"></a>CDC：： GetGlyphOutline

針對目前字型中的外框字元，抓取外框曲線或點陣圖。

```
DWORD GetGlyphOutline(
    UINT nChar,
    UINT nFormat,
    LPGLYPHMETRICS lpgm,
    DWORD cbBuffer,
    LPVOID lpBuffer,
    const MAT2* lpmat2) const;
```

### <a name="parameters"></a>參數

*nChar*<br/>
指定要傳回信息的字元。

*nFormat*<br/>
指定函數用來傳回信息的格式。 它可以是下列其中一個值，或0：

|值|意義|
|-----------|-------------|
|GGO_BITMAP|傳回字型點陣圖。 當函式傳回時， *lpBuffer*所指向的緩衝區會包含1位的每圖元點陣圖，其資料列會在雙字邊界上開始。|
|GGO_NATIVE|使用裝置單位，以轉譯器的原生格式傳回曲線資料點。 當指定這個值時，會忽略*lpmat2*中指定的任何轉換。|

當*nFormat*的值為0時，此函式會填滿[GLYPHMETRICS](/windows/win32/api/wingdi/ns-wingdi-glyphmetrics)結構，但不會傳回字元外框資料。

*lpgm*<br/>
指向 GLYPHMETRICS 結構，描述字元儲存格中的字型位置。

*cbBuffer*<br/>
指定函數複製外框字元資訊的緩衝區大小。 如果這個值是0，而且*nFormat*參數是 GGO_BITMAP 或 GGO_NATIVE 值，則函數會傳回所需的緩衝區大小。

*lpBuffer*<br/>
指向函式將外框字元的相關資訊複製到其中的緩衝區。 如果*nFormat*指定 GGO_NATIVE 值，則會以 TTPOLYGONHEADER 和 TTPOLYCURVE 結構的形式複製資訊。 如果這個值是 Null，而*nFormat*是 GGO_BITMAP 或 GGO_NATIVE 值，則函數會傳回所需的緩衝區大小。

*lpmat2*<br/>
指向[MAT2](/windows/win32/api/wingdi/ns-wingdi-mat2)結構，其中包含字元的轉換矩陣。 即使為*nFormat*指定了 GGO_NATIVE 值，此參數也不可以是 Null。

### <a name="return-value"></a>傳回值

如果*cbBuffer*為0或*lpBuffer*為 Null 時，所抓取之資訊所需的緩衝區大小（以位元組為單位）。 否則，如果函式成功，則為正值，如果發生錯誤，則為-1。

### <a name="remarks"></a>備註

應用程式可以藉由在*lpmat2*所指向的結構中指定2到2的轉換矩陣，來旋轉以點陣圖格式抓取的字元。

圖像大綱會以一系列的輪廓傳回。 每個輪廓都是由[TTPOLYGONHEADER](/windows/win32/api/wingdi/ns-wingdi-ttpolygonheader)結構所定義，後面接著 `TTPOLYCURVE` 所需的結構數目來描述它。 所有點都會以[POINTFX](/windows/win32/api/wingdi/ns-wingdi-pointfx)結構的形式傳回，並代表絕對位置，而不是相對移動。 TTPOLYGONHEADER 結構的成員所提供的起點 `pfxStart` 是[TTPOLYGONHEADER](/windows/win32/api/wingdi/ns-wingdi-ttpolygonheader)開始輪廓的點。 後面的[TTPOLYCURVE](/windows/win32/api/wingdi/ns-wingdi-ttpolycurve)結構可以是折線記錄或曲線記錄。 折線記錄是一系列的點;在點之間繪製的線條會描述字元的外框。 曲線記錄代表 TrueType 使用的二次方曲線（也就是二次 b-曲線）。

## <a name="cdcgetgraphicsmode"></a><a name="getgraphicsmode"></a>CDC：： GetGraphicsMode

抓取指定裝置內容的目前圖形模式。

```
int GetGraphicsMode() const;
```

### <a name="return-value"></a>傳回值

傳回成功時的目前圖形模式。 如需這個方法可以傳回的值清單，請參閱[GetGraphicsMode](/windows/win32/api/wingdi/nf-wingdi-getgraphicsmode)。

失敗時傳回0。

若要取得延伸錯誤資訊，請呼叫[GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror)。

### <a name="remarks"></a>備註

這個方法會包裝 Windows GDI 函數[GetGraphicsMode](/windows/win32/api/wingdi/nf-wingdi-getgraphicsmode)。

## <a name="cdcgethalftonebrush"></a><a name="gethalftonebrush"></a>CDC：： GetHalftoneBrush

呼叫這個成員函式以抓取半色調筆刷。

```
static CBrush* PASCAL GetHalftoneBrush();
```

### <a name="return-value"></a>傳回值

如果成功，則為物件的指標 `CBrush` ; 否則為 Null。

### <a name="remarks"></a>備註

「半色調筆刷」會顯示色彩為前景和背景色彩的圖元，以建立遞色圖樣。 以下是半色調筆刷所建立之遞色圖樣的範例。

![遞色畫筆筆劃的詳細資料](../../mfc/reference/media/vc318s1.gif "遞色畫筆筆劃的詳細資料")

## <a name="cdcgetkerningpairs"></a><a name="getkerningpairs"></a>CDC：： GetKerningPairs

針對目前在指定的裝置內容中選取的字型，抓取字元間距配對。

```
int GetKerningPairs(
    int nPairs,
    LPKERNINGPAIR lpkrnpair) const;
```

### <a name="parameters"></a>參數

*nPairs*<br/>
指定*lpkrnpair*所指向的[KERNINGPAIR](/windows/win32/api/wingdi/ns-wingdi-kerningpair)結構數目。 函式不會複製比*nPairs*所指定更多的字偶間距組合。

*lpkrnpair*<br/>
指向結構的陣列，當函式傳回 `KERNINGPAIR` 時，會接收字元間距配對。 此陣列至少必須包含*nPairs*所指定的多個結構。 如果這個參數是 Null，此函式會傳回字型的字偶間距配對總數。

### <a name="return-value"></a>傳回值

如果函式成功，則指定已抓取的字偶間距配對數目，或字型中的字偶間距配對總數。 如果函式失敗，或沒有字型的字偶間距配對，則會傳回零。

## <a name="cdcgetlayout"></a><a name="getlayout"></a>CDC：： GetLayout

呼叫這個成員函式，以判斷裝置內容的文字和圖形版面配置，例如印表機或中繼檔。

```
DWORD GetLayout() const;
```

### <a name="return-value"></a>傳回值

如果成功，則為目前裝置內容的版面配置旗標。 否則，GDI_ERROR。 如需延伸錯誤資訊，請呼叫[GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror)。 如需版面配置旗標的清單，請參閱[CDC：： SetLayout](#setlayout)。

### <a name="remarks"></a>備註

預設版面配置由左至右。

## <a name="cdcgetmapmode"></a><a name="getmapmode"></a>CDC：： GetMapMode

抓取目前的對應模式。

```
int GetMapMode() const;
```

### <a name="return-value"></a>傳回值

對應模式。

### <a name="remarks"></a>備註

如需對應模式的說明，請參閱成員函式 `SetMapMode` 。

> [!NOTE]
> 如果您呼叫[SetLayout](#setlayout)來將 DC 變更為由右至左配置，則 `SetLayout` 會自動將對應模式變更為 MM_ISOTROPIC。 因此，任何後續的呼叫 `GetMapMode` 都會傳回 MM_ISOTROPIC。

## <a name="cdcgetmiterlimit"></a><a name="getmiterlimit"></a>CDC：： GetMiterLimit

傳回裝置內容的斜接限制。

```
float GetMiterLimit() const;
```

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

當繪製具有斜切聯接的幾何線條時，會使用斜接限制。

## <a name="cdcgetnearestcolor"></a><a name="getnearestcolor"></a>CDC：： GetNearestColor

傳回最符合指定之邏輯色彩的純色。

```
COLORREF GetNearestColor(COLORREF crColor) const;
```

### <a name="parameters"></a>參數

*crColor*<br/>
指定要比對的色彩。

### <a name="return-value"></a>傳回值

RGB （紅色、綠色、藍色）色彩值，定義最接近裝置可代表之*crColor*值的純色。

### <a name="remarks"></a>備註

指定的裝置必須能夠代表此色彩。

## <a name="cdcgetoutlinetextmetrics"></a><a name="getoutlinetextmetrics"></a>CDC：： GetOutlineTextMetrics

抓取 TrueType 字型的度量資訊。

```
UINT GetOutlineTextMetrics(
    UINT cbData,
    LPOUTLINETEXTMETRIC lpotm) const;
```

### <a name="parameters"></a>參數

*lpotm*<br/>
指向[OUTLINETEXTMETRIC](/windows/win32/api/wingdi/ns-wingdi-outlinetextmetricw)結構的陣列。 如果此參數為 Null，此函式會傳回所抓取計量資料所需的緩衝區大小。

*cbData*<br/>
指定傳回信息的緩衝區大小（以位元組為單位）。

*lpotm*<br/>
指向 `OUTLINETEXTMETRIC` 結構。 如果此參數為 Null，此函式會傳回所抓取計量資訊所需的緩衝區大小。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

[OUTLINETEXTMETRIC](/windows/win32/api/wingdi/ns-wingdi-outlinetextmetricw)結構包含以 TrueType 格式提供的大部分字型度量資訊，包括[TEXTMETRIC](/windows/win32/api/wingdi/ns-wingdi-textmetricw)結構。 結構的最後四個成員 `OUTLINETEXTMETRIC` 是指向字串的指標。 除了其他成員所需的空間之外，應用程式應該為這些字串配置空間。 由於字串大小沒有系統強加限制，因此配置記憶體的最簡單方法是在第一次呼叫函式時，為*lpotm*指定 Null 來抓取所需的大小 `GetOutlineTextMetrics` 。

## <a name="cdcgetoutputcharwidth"></a><a name="getoutputcharwidth"></a>CDC：： GetOutputCharWidth

會使用輸出裝置內容， `m_hDC` 並從目前字型抓取連續字元群組中的個別字元寬度。

```
BOOL GetOutputCharWidth(
    UINT nFirstChar,
    UINT nLastChar,
    LPINT lpBuffer) const;
```

### <a name="parameters"></a>參數

*nFirstChar*<br/>
指定目前字型中，連續字元群組中的第一個字元。

*nLastChar*<br/>
指定目前字型中連續字元群組的最後一個字元。

*lpBuffer*<br/>
指向會接收目前字型中連續字元群組之寬度值的緩衝區。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

例如，如果*nFirstChar*識別字母 ' a '，而*nLastChar*識別字母 ' z '，則函數會抓取所有小寫字元的寬度。

函式會將值儲存在*lpBuffer*所指向的緩衝區中。 這個緩衝區必須夠大，才能容納所有寬度;也就是說，在此範例中，至少必須有26個專案。

如果在特定字型中不存在連續字元群組中的字元，則會將預設字元的寬度值指派給它。

## <a name="cdcgetoutputtabbedtextextent"></a><a name="getoutputtabbedtextextent"></a>CDC：： GetOutputTabbedTextExtent

呼叫這個成員函式，以使用[m_hDC](#m_hdc)（輸出裝置內容）來計算字元字串的寬度和高度。

```
CSize GetOutputTabbedTextExtent(
    LPCTSTR lpszString,
    int nCount,
    int nTabPositions,
    LPINT lpnTabStopPositions) const;

CSize GetOutputTabbedTextExtent(
    const CString& str,
    int nTabPositions,
    LPINT lpnTabStopPositions) const;
```

### <a name="parameters"></a>參數

*lpszString*<br/>
指向要測量的字元字串。 您也可以傳遞此參數的[CString](../../atl-mfc-shared/reference/cstringt-class.md)物件。

*nCount*<br/>
指定*lpszString*所指向[的字串長度](/windows/win32/gdi/specifying-length-of-text-output-string)。

*nTabPositions*<br/>
指定*lpnTabStopPositions*所指向之陣列中的索引標籤停用位置數目。

*lpnTabStopPositions*<br/>
指向包含邏輯單元中索引標籤停止位置的整數陣列。 定位停駐點必須以遞增順序排序;最小的 x 值應該是陣列中的第一個專案。 不允許使用 [上一頁] 索引標籤。

*字串*<br/>
`CString`物件，包含要測量的指定字元。

### <a name="return-value"></a>傳回值

[CSize](../../atl-mfc-shared/reference/csize-class.md)物件中字串的維度（以邏輯單位表示）。

### <a name="remarks"></a>備註

如果字串包含一個或多個定位字元，則字串的寬度是根據*lpnTabStopPositions*所指定的定位停駐點。 函式會使用目前選取的字型來計算字串的維度。

目前的裁剪區域不會位移函式所傳回的寬度和高度 `GetOutputTabbedTextExtent` 。

由於某些裝置不會將字元放在一般的資料格陣列中（也就是說，它們會將字元間距），因此，字串中字元的範圍總和可能不會等於字串的範圍。

如果*nTabPositions*為0，而*lpnTabStopPositions*為 Null，則索引標籤會展開為八個平均字元寬度。 如果*nTabPositions*是1，就會以*lpnTabStopPositions*點的陣列中第一個值所指定的距離來分隔定位停駐點。 如果*lpnTabStopPositions*指向一個以上的值，就會針對陣列中的每個值（最多為*nTabPositions*所指定的數位）設定制表位。

## <a name="cdcgetoutputtextextent"></a><a name="getoutputtextextent"></a>CDC：： GetOutputTextExtent

呼叫這個成員函式以使用輸出裝置內容、 [m_hDC](#m_hdc)，然後使用目前的字型來計算文字行的寬度和高度。

```
CSize GetOutputTextExtent(
    LPCTSTR lpszString,
    int nCount) const;

CSize GetOutputTextExtent(const CString& str) const;
```

### <a name="parameters"></a>參數

*lpszString*<br/>
指向字元的字串。 您也可以傳遞此參數的[CString](../../atl-mfc-shared/reference/cstringt-class.md)物件。

*nCount*<br/>
指定*lpszString*所指向[的字串長度](/windows/win32/gdi/specifying-length-of-text-output-string)。

*字串*<br/>
`CString`物件，包含要測量的指定字元。

### <a name="return-value"></a>傳回值

在[CSize](../../atl-mfc-shared/reference/csize-class.md)物件中傳回的字串維度（以邏輯單位表示）。

### <a name="remarks"></a>備註

目前的裁剪區域不會影響所傳回的寬度和高度 `GetOutputTextExtent` 。

由於某些裝置不會將字元放在一般的資料格陣列中（也就是說，它們會執行字偶間距調整），因此，字串中字元的範圍總和可能不會等於字串的範圍。

## <a name="cdcgetoutputtextmetrics"></a><a name="getoutputtextmetrics"></a>CDC：： GetOutputTextMetrics

使用輸出裝置內容，抓取目前字型的計量 `m_hDC` 。

```
BOOL GetOutputTextMetrics(LPTEXTMETRIC lpMetrics) const;
```

### <a name="parameters"></a>參數

*lpMetrics*<br/>
指向接收度量的[TEXTMETRIC](/windows/win32/api/wingdi/ns-wingdi-textmetricw)結構。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

## <a name="cdcgetpath"></a><a name="getpath"></a>CDC：： GetPath

抓取定義線條端點的座標，以及在選取至裝置內容的路徑中找到的曲線控制點。

```
int GetPath(
    LPPOINT lpPoints,
    LPBYTE lpTypes,
    int nCount) const;
```

### <a name="parameters"></a>參數

*lpPoints*<br/>
指向[點](/windows/win32/api/windef/ns-windef-point)資料結構的陣列，或 `CPoint` 放置線條端點和曲線控制點的物件。

*lpTypes*<br/>
指向放置頂點類型的位元組陣列。 值為下列其中一項：

- PT_MOVETO 指定*lpPoints*中的對應點會啟動一個不相交的圖形。

- PT_LINETO 指定在*lpPoints*中的上一個點和對應的點是線條的端點。

- PT_BEZIERTO 指定*lpPoints*中的對應點是 Bzier 曲線的控制點或結束點。

PT_BEZIERTO 類型一律會出現在三個集合中。 路徑中緊接在其前面的點會定義 Bzier 曲線的起點。 前兩個 PT_BEZIERTO 點是控制點，而第三個 PT_BEZIERTO 點是結束點（如果是硬式編碼）。

   PT_LINETO 或 PT_BEZIERTO 類型可能會與下列旗標結合（藉由使用位運算子**或**）來表示對應的點是圖形中的最後一個點，而且應該關閉該圖形：

- PT_CLOSEFIGURE 指定在繪製對應的線條或曲線之後，會自動關閉圖表。 此圖會藉由繪製線條或曲線端點的線條到對應至最後一個 PT_MOVETO 的點來關閉。

*nCount*<br/>
指定可能放在*lpPoints*陣列中的[點](/windows/win32/api/windef/ns-windef-point)資料結構總數。 這個值必須與可能放在*lpTypes*陣列中的位元組數目相同。

### <a name="return-value"></a>傳回值

如果*nCount*參數為非零值，則列舉的點數。 如果*nCount*為0，則為路徑中的總點數（並不會將 `GetPath` 任何內容寫入緩衝區）。 如果*nCount*不是零，而且小於路徑中的點數目，則傳回值為-1。

### <a name="remarks"></a>備註

裝置內容必須包含關閉的路徑。 路徑的點會以邏輯座標傳回。 點會儲存在裝置座標的路徑中，因此會 `GetPath` 使用目前轉換的反向，將裝置座標的點變更為邏輯座標。 您 `FlattenPath` 可以先呼叫成員函式 `GetPath` ，將路徑中的所有曲線轉換成線段。

### <a name="example"></a>範例

  請參閱[CDC：： BeginPath](#beginpath)的範例。

## <a name="cdcgetpixel"></a><a name="getpixel"></a>CDC：： GetPixel

在*x*和*y*所指定的點上，抓取圖元的 RGB 色彩值。

```
COLORREF GetPixel(
    int x,
    int y) const;

COLORREF GetPixel(POINT point) const;
```

### <a name="parameters"></a>參數

*x*<br/>
指定要檢查之點的邏輯 x 座標。

*y*<br/>
指定要檢查之點的邏輯 y 座標。

*此處*<br/>
指定要檢查之點的邏輯 x 和 y 座標。

### <a name="return-value"></a>傳回值

對於任一版本的函式，即為指定點之色彩的 RGB 色彩值。 如果座標未在裁剪區域中指定點，則為-1。

### <a name="remarks"></a>備註

點必須在裁剪區域中。 如果點不在裁剪區域中，則函式不會有任何作用，而且會傳回-1。

並非所有的裝置皆支援 `GetPixel` 函式。 如需詳細資訊，請參閱[GetDeviceCaps](#getdevicecaps)成員函式下的 RC_BITBLT 點陣功能。

成員函式 `GetPixel` 有兩種形式。 第一個會採用兩個座標值。第二個會接受[POINT](/windows/win32/api/windef/ns-windef-point)結構或[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)物件。

## <a name="cdcgetpolyfillmode"></a><a name="getpolyfillmode"></a>CDC：： GetPolyFillMode

抓取目前的多邊形填滿模式。

```
int GetPolyFillMode() const;
```

### <a name="return-value"></a>傳回值

如果函式成功，則為目前的多邊形填滿模式（替代或纏繞）。

### <a name="remarks"></a>備註

如需 `SetPolyFillMode` 多邊形填滿模式的說明，請參閱成員函式。

## <a name="cdcgetrop2"></a><a name="getrop2"></a>CDC：： GetROP2

抓取目前的繪圖模式。

```
int GetROP2() const;
```

### <a name="return-value"></a>傳回值

繪製模式。 如需繪圖模式值的清單，請參閱成員函式 `SetROP2` 。

### <a name="remarks"></a>備註

[繪圖模式] 指定畫筆色彩和填滿物件內部的色彩，如何與已經在顯示介面上的色彩結合。

## <a name="cdcgetsafehdc"></a><a name="getsafehdc"></a>CDC：： GetSafeHdc

呼叫此成員函式以取得[m_hDC](#m_hdc)，即輸出裝置內容。

```
HDC GetSafeHdc() const;
```

### <a name="return-value"></a>傳回值

裝置內容控制碼。

### <a name="remarks"></a>備註

這個成員函式也可以搭配 null 指標使用。

## <a name="cdcgetstretchbltmode"></a><a name="getstretchbltmode"></a>CDC：： GetStretchBltMode

抓取目前的點陣圖延展模式。

```
int GetStretchBltMode() const;
```

### <a name="return-value"></a>傳回值

如果函式成功，則傳回值會指定目前的點陣圖延伸模式（STRETCH_ANDSCANS、STRETCH_DELETESCANS 或 STRETCH_ORSCANS）。

### <a name="remarks"></a>備註

點陣圖延伸模式會定義如何從成員函式所延展或壓縮的點陣圖中移除資訊 `StretchBlt` 。

STRETCH_ANDSCANS 和 STRETCH_ORSCANS 模式通常用來保留單色點陣圖中的前景圖元。 STRETCH_DELETESCANS 模式通常用來保留色彩點陣圖中的色彩。

## <a name="cdcgettabbedtextextent"></a><a name="gettabbedtextextent"></a>CDC：： GetTabbedTextExtent

呼叫這個成員函式，以使用屬性裝置內容[m_hAttribDC](#m_hattribdc)來計算字元字串的寬度和高度。

```
CSize GetTabbedTextExtent(
    LPCTSTR lpszString,
    int nCount,
    int nTabPositions,
    LPINT lpnTabStopPositions) const;

CSize GetTabbedTextExtent(
    const CString& str,
    int nTabPositions,
    LPINT lpnTabStopPositions) const;
```

### <a name="parameters"></a>參數

*lpszString*<br/>
指向字元字串。 您也可以傳遞此參數的[CString](../../atl-mfc-shared/reference/cstringt-class.md)物件。

*nCount*<br/>
指定*lpszString*所指向[的字串長度](/windows/win32/gdi/specifying-length-of-text-output-string)。

*nTabPositions*<br/>
指定*lpnTabStopPositions*所指向之陣列中的索引標籤停用位置數目。

*lpnTabStopPositions*<br/>
指向包含邏輯單元中索引標籤停止位置的整數陣列。 定位停駐點必須以遞增順序排序;最小的 x 值應該是陣列中的第一個專案。 不允許使用 [上一頁] 索引標籤。

*字串*<br/>
`CString`物件，包含要繪製的指定字元。

### <a name="return-value"></a>傳回值

[CSize](../../atl-mfc-shared/reference/csize-class.md)物件中字串的維度（以邏輯單位表示）。

### <a name="remarks"></a>備註

如果字串包含一個或多個定位字元，則字串的寬度是根據*lpnTabStopPositions*所指定的定位停駐點。 函式會使用目前選取的字型來計算字串的維度。

目前的裁剪區域不會位移函式所傳回的寬度和高度 `GetTabbedTextExtent` 。

由於某些裝置不會將字元放在一般的資料格陣列中（也就是說，它們會將字元間距），因此，字串中字元的範圍總和可能不會等於字串的範圍。

如果*nTabPositions*為0，而*lpnTabStopPositions*為 Null，則索引標籤會展開為平均字元寬度的八倍。 如果*nTabPositions*是1，就會以*lpnTabStopPositions*點的陣列中第一個值所指定的距離來分隔定位停駐點。 如果*lpnTabStopPositions*指向一個以上的值，就會針對陣列中的每個值（最多為*nTabPositions*所指定的數位）設定制表位。

## <a name="cdcgettextalign"></a><a name="gettextalign"></a>CDC：： GetTextAlign

抓取裝置內容的文字對齊旗標狀態。

```
UINT GetTextAlign() const;
```

### <a name="return-value"></a>傳回值

文字對齊旗標的狀態。 傳回值是下列一個或多個值：

- TA_BASELINE 指定 X 軸與周框矩形內所選字型的基準對齊方式。

- TA_BOTTOM 指定 X 軸和周框底部的對齊方式。

- TA_CENTER 指定 y 軸和周框中心中央的對齊方式。

- TA_LEFT 指定 y 軸和周框左邊的對齊方式。

- TA_NOUPDATECP 指定目前的位置不會更新。

- TA_RIGHT 指定 y 軸和周框右邊的對齊方式。

- TA_TOP 指定 X 軸和周框頂端的對齊方式。

- TA_UPDATECP 指定目前的位置已更新。

### <a name="remarks"></a>備註

文字對齊旗標會決定和成員函式如何 `TextOut` `ExtTextOut` 對齊與字串起點相關的文字字串。 文字對齊旗標不一定是單一位旗標，而且可能等於0。 若要測試是否已設定旗標，應用程式應遵循下列步驟：

1. 將位 OR 運算子套用至旗標及其相關的旗標，如下所示：

   - TA_LEFT、TA_CENTER 和 TA_RIGHT

   - TA_BASELINE、TA_BOTTOM 和 TA_TOP

   - TA_NOUPDATECP 和 TA_UPDATECP

1. 將位 AND 運算子套用至結果和的傳回值 `GetTextAlign` 。

1. 測試此結果是否相等和旗標。

## <a name="cdcgettextcharacterextra"></a><a name="gettextcharacterextra"></a>CDC：： GetTextCharacterExtra

抓取 intercharacter 間距量的目前設定。

```
int GetTextCharacterExtra() const;
```

### <a name="return-value"></a>傳回值

Intercharacter 間距的數量。

### <a name="remarks"></a>備註

當它將一行文字寫入裝置內容時，GDI 會將此間距新增至每個字元，包括分隔字元。

Intercharacter 間距量的預設值為0。

## <a name="cdcgettextcolor"></a><a name="gettextcolor"></a>CDC：： GetTextColor

抓取目前的文字色彩。

```
COLORREF GetTextColor() const;
```

### <a name="return-value"></a>傳回值

以 RGB 色彩值為目前的文字色彩。

### <a name="remarks"></a>備註

文字色彩是使用 GDI 文字輸出成員函式[TextOut](#textout)、 [ExtTextOut](#exttextout)和[TabbedTextOut](#tabbedtextout)所繪製之字元的前景色彩。

## <a name="cdcgettextextent"></a><a name="gettextextent"></a>CDC：： GetTextExtent

呼叫這個成員函式，以使用目前的字型來判斷文字行的寬度和高度，以決定維度。

```
CSize GetTextExtent(
    LPCTSTR lpszString,
    int nCount) const;

CSize GetTextExtent(const CString& str) const;
```

### <a name="parameters"></a>參數

*lpszString*<br/>
指向字元的字串。 您也可以傳遞此參數的[CString](../../atl-mfc-shared/reference/cstringt-class.md)物件。

*nCount*<br/>
指定字串中的字元數。

*字串*<br/>
`CString`包含指定之字元的物件。

### <a name="return-value"></a>傳回值

[CSize](../../atl-mfc-shared/reference/csize-class.md)物件中字串的維度（以邏輯單位表示）。

### <a name="remarks"></a>備註

此資訊會從[m_hAttribDC](#m_hattribdc)的屬性裝置內容中抓取。

根據預設，會 `GetTextExtent` 假設其抓取維度的文字會沿著水平線設定（也就是，行距是0）。 如果您建立指定非零行距的字型，則必須明確地轉換文字的角度，以取得字串的維度。

目前的裁剪區域不會影響所傳回的寬度和高度 `GetTextExtent` 。

由於某些裝置不會將字元放在一般的資料格陣列中（也就是說，它們會執行字偶間距調整），因此，字串中字元的範圍總和可能不會等於字串的範圍。

## <a name="cdcgettextextentexpointi"></a><a name="gettextextentexpointi"></a>CDC：： GetTextExtentExPointI

抓取指定的字串中，符合指定之空間的字元數，並在陣列中填入每個字元的文字範圍。

```
BOOL GetTextExtentExPointI(
    LPWORD pgiIn,
    int cgi,
    int nMaxExtent,
    LPINT lpnFit,
    LPINT alpDx,
    LPSIZE lpSize) const;
```

### <a name="parameters"></a>參數

*pgiIn*<br/>
要抓取範圍之字元索引陣列的指標。

*cgi*<br/>
指定*pgiIn*所指向之陣列中的字元數。

*nMaxExtent*<br/>
指定格式化字串允許的最大寬度（以邏輯單位表示）。

*lpnFit*<br/>
整數的指標，接收會在*nMaxExtent*所指定的空間中容納的最大字元數計數。 當*lpnFit*為 Null 時，會忽略*nMaxExtent* 。

*alpDx*<br/>
接收部分圖像範圍之整數陣列的指標。 陣列中的每個元素都會以邏輯單位，提供字元索引陣列開頭與*nMaxExtent*所指定之空間中符合的其中一個字型之間的距離。 雖然此陣列的元素至少應該與*cgi*所指定的圖像索引一樣多，但此函式只會以*lpnFit*所指定的多個圖像索引的範圍填入陣列。 如果*lpnDx*為 Null，則函數不會計算部分字串寬度。

*lpSize*<br/>
[大小](/windows/win32/api/windef/ns-windef-size)結構的指標，可接收字元索引陣列的維度（以邏輯單位表示）。 這個值不能是 Null。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

此成員函式會模擬函數[GetTextExtentExPointI](/windows/win32/api/wingdi/nf-wingdi-gettextextentexpointi)的功能，如 Windows SDK 中所述。

## <a name="cdcgettextextentpointi"></a><a name="gettextextentpointi"></a>CDC：： GetTextExtentPointI

抓取指定之圖像索引陣列的寬度和高度。

```
BOOL GetTextExtentPointI(
    LPWORD pgiIn,
    int cgi,
    LPSIZE lpSize) const;
```

### <a name="parameters"></a>參數

*pgiIn*<br/>
要抓取範圍之字元索引陣列的指標。

*cgi*<br/>
指定*pgiIn*所指向之陣列中的字元數。

*lpSize*<br/>
[大小](/windows/win32/api/windef/ns-windef-size)結構的指標，可接收字元索引陣列的維度（以邏輯單位表示）。 這個值不能是 Null。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

此成員函式會模擬函數[GetTextExtentPointI](/windows/win32/api/wingdi/nf-wingdi-gettextextentpointi)的功能，如 Windows SDK 中所述。

## <a name="cdcgettextface"></a><a name="gettextface"></a>CDC：： GetTextFace

呼叫這個成員函式，將目前字型的字樣名稱複製到緩衝區。

```
int GetTextFace(
    int nCount,
    LPTSTR lpszFacename) const;

int GetTextFace(CString& rString) const;
```

### <a name="parameters"></a>參數

*nCount*<br/>
指定緩衝區的大小（以位元組為單位）。 如果字樣名稱超過此參數所指定的位元組數目，則會截斷名稱。

*lpszFacename*<br/>
指向字樣名稱的緩衝區。

*rString*<br/>
[CString](../../atl-mfc-shared/reference/cstringt-class.md)物件的參考。

### <a name="return-value"></a>傳回值

複製到緩衝區的位元組數目，不包括終止的 null 字元。 如果發生錯誤，則為0。

### <a name="remarks"></a>備註

字樣名稱會複製為以 null 結束的字串。

## <a name="cdcgettextmetrics"></a><a name="gettextmetrics"></a>CDC：： GetTextMetrics

使用屬性裝置內容，抓取目前字型的計量。

```
BOOL GetTextMetrics(LPTEXTMETRIC lpMetrics) const;
```

### <a name="parameters"></a>參數

*lpMetrics*<br/>
指向接收度量的[TEXTMETRIC](/windows/win32/api/wingdi/ns-wingdi-textmetricw)結構。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

## <a name="cdcgetviewportext"></a><a name="getviewportext"></a>CDC：： GetViewportExt

抓取裝置內容之區的 x 和 y 範圍。

```
CSize GetViewportExt() const;
```

### <a name="return-value"></a>傳回值

做為物件的 x 和 y 範圍（以裝置單位表示） `CSize` 。

## <a name="cdcgetviewportorg"></a><a name="getviewportorg"></a>CDC：： GetViewportOrg

抓取與裝置內容相關聯之視口來源的 x 和 y 座標。

```
CPoint GetViewportOrg() const;
```

### <a name="return-value"></a>傳回值

以物件形式提供的視口來源（以裝置座標表示） `CPoint` 。

## <a name="cdcgetwindow"></a><a name="getwindow"></a>CDC：： GetWindow

傳回與顯示裝置內容相關聯的視窗。

```
CWnd* GetWindow() const;
```

### <a name="return-value"></a>傳回值

`CWnd`如果成功，則為物件的指標; 否則為 Null。

### <a name="remarks"></a>備註

這是一個先進的函數。 例如，在列印或預覽列印時，這個成員函式可能不會傳回 view 視窗。 它一律會傳回與輸出相關聯的視窗。 使用給定 DC 繪製至此視窗的輸出函式。

## <a name="cdcgetwindowext"></a><a name="getwindowext"></a>CDC：： GetWindowExt

抓取與裝置內容相關聯之視窗的 x 和 y 範圍。

```
CSize GetWindowExt() const;
```

### <a name="return-value"></a>傳回值

做為物件的 x 和 y 範圍（以邏輯單位表示） `CSize` 。

## <a name="cdcgetwindoworg"></a><a name="getwindoworg"></a>CDC：： GetWindowOrg

抓取與裝置內容相關聯之視窗原點的 x 和 y 座標。

```
CPoint GetWindowOrg() const;
```

### <a name="return-value"></a>傳回值

做為物件的視窗原點（以邏輯座標表示） `CPoint` 。

## <a name="cdcgetworldtransform"></a><a name="getworldtransform"></a>CDC：： GetWorldTransform

抓取目前的世界空間以進行頁面空間轉換。

```
BOOL GetWorldTransform(XFORM& rXform) const;
```

### <a name="parameters"></a>參數

*rXform*<br/>
[XFORM](/windows/win32/api/wingdi/ns-wingdi-xform)結構的參考，它會接收目前的世界空間以進行頁面空間轉換。

### <a name="return-value"></a>傳回值

會在成功時傳回非零值。

失敗時傳回0。

若要取得延伸錯誤資訊，請呼叫[GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror)。

### <a name="remarks"></a>備註

這個方法會包裝 Windows GDI 函數[GetWorldTransform](/windows/win32/api/wingdi/nf-wingdi-getworldtransform)。

## <a name="cdcgradientfill"></a><a name="gradientfill"></a>CDC：： GradientFill

呼叫這個成員函式可使用平滑淡出到另一端的色彩，來填滿矩形和三角形結構。

```
BOOL GradientFill(
    TRIVERTEX* pVertices,
    ULONG nVertices,
    void* pMesh,
    ULONG nMeshElements,
    DWORD dwMode);
```

### <a name="parameters"></a>參數

*pVertices*<br/>
[TRIVERTEX](/windows/win32/api/wingdi/ns-wingdi-trivertex)結構陣列的指標，分別定義三角形頂點。

*nVertices*<br/>
頂點的數目。

*pMesh*<br/>
三角形模式中[GRADIENT_TRIANGLE](/windows/win32/api/wingdi/ns-wingdi-gradient_triangle)結構的陣列，或矩形模式中[GRADIENT_RECT](/windows/win32/api/wingdi/ns-wingdi-gradient_rect)結構的陣列。

*nMeshElements*<br/>
*PMesh*中的元素數目（三角形或矩形）。

*dwMode*<br/>
指定漸層填滿模式。 如需可能值的清單，請參閱 Windows SDK 中的[GradientFill](/windows/win32/api/wingdi/nf-wingdi-gradientfill) 。

### <a name="return-value"></a>傳回值

如果成功，則為 TRUE，否則為 FALSE。

### <a name="remarks"></a>備註

如需詳細資訊，請參閱 `GradientFill` Windows SDK 中的。

## <a name="cdcgraystring"></a><a name="graystring"></a>CDC：： GrayString

藉由撰寫記憶體點陣圖中的文字、讓點陣圖變暗，然後將點陣圖複製到顯示器，在指定的位置繪製暗灰色（灰色）文字。

```
virtual BOOL GrayString(
    CBrush* pBrush,
    BOOL (CALLBACK* lpfnOutput)(
    HDC,
    LPARAM,
    int),
    LPARAM lpData,
    int nCount,
    int x,
    int y,
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>參數

*pBrush*<br/>
識別要用於變暗（讓）的筆刷。

*lpfnOutput*<br/>
指定將繪製字串之應用程式提供的回呼函式的程式實例位址。 如需詳細資訊，請參閱 Windows `OutputFunc` [回呼函數](callback-functions-used-by-mfc.md#graystring)的說明。 如果此參數為 Null，系統會使用 Windows 函式 `TextOut` 來繪製字串，而*lpData*會假設為要輸出之字元字串的長指標。

*lpData*<br/>
指定要傳遞至輸出函數之資料的最遠指標。 如果*lpfnOutput*為 Null，則*lpData*必須是要輸出之字串的長指標。

*nCount*<br/>
指定要輸出的字元數。 如果此參數為0，則會 `GrayString` 計算字串的長度（假設*lpData*是字串的指標）。 如果*nCount*是1，且*lpfnOutput*所指向的函式傳回0，則會顯示影像但不會呈現灰色。

*x*<br/>
指定括住字串之矩形開始位置的邏輯 x 座標。

*y*<br/>
指定括住字串之矩形開始位置的邏輯 y 座標。

*nWidth*<br/>
指定括住字串之矩形的寬度（以邏輯單位表示）。 如果*nWidth*為0，則 `GrayString` 會計算區域的寬度，假設*lpData*是字串的指標。

*nHeight*<br/>
指定括住字串之矩形的高度（以邏輯單位表示）。 如果*nHeight*為0，則 `GrayString` 會計算區域的高度，假設*lpData*是字串的指標。

### <a name="return-value"></a>傳回值

如果已繪製字串，則為非零，如果函 `TextOut` 式或應用程式提供的輸出函數傳回0，或如果記憶體不足，無法建立記憶體點陣圖來變暗，則為0。

### <a name="remarks"></a>備註

不論選取的筆刷和背景為何，函式都會將文字變暗。 此成員函式會 `GrayString` 使用目前選取的字型。 使用此函式之前，必須先選取 MM_TEXT 對應模式。

應用程式可以在支援純灰色色彩的裝置上繪製暗灰色（灰色）字串，而不需要呼叫成員函式 `GrayString` 。 系統色彩 COLOR_GRAYTEXT 是用來繪製停用文字的灰色系統色彩。 應用程式可以呼叫 Windows 函式 `GetSysColor` 來取出 COLOR_GRAYTEXT 的色彩值。 如果色彩不是0（黑色），應用程式可以呼叫成員函式， `SetTextColor` 將文字色彩設定為色彩值，然後直接繪製字串。 如果抓取的色彩是黑色，則應用程式必須呼叫 `GrayString` 以暗（灰色）文字。

如果*lpfnOutput*為 Null，GDI 會使用 Windows [TextOut](/windows/win32/api/wingdi/nf-wingdi-textoutw)函式，而*lpData*會假設為要輸出之字元的最遠指標。 如果成員函式無法處理要輸出的字元 `TextOut` （例如，字串儲存為點陣圖），應用程式就必須提供自己的輸出函數。

另請注意，在回到 Windows 之前，所有回呼函式都必須先將 Microsoft Foundation 例外狀況設陷，因為例外狀況無法跨回呼界限擲回。 如需例外狀況的詳細資訊，請參閱[例外](../../mfc/exception-handling-in-mfc.md)狀況一文。

傳遞至的回呼函式 `GrayString` 必須使用 **`__stdcall`** 呼叫慣例，而且必須以匯出 **`__declspec`** 。

當架構處於預覽模式時，成員函式的呼叫 `GrayString` 會轉譯為 `TextOut` 呼叫，而且不會呼叫回呼函數。

## <a name="cdchimetrictodp"></a><a name="himetrictodp"></a>CDC：： HIMETRICtoDP

當您將 HIMETRIC 大小從 OLE 轉換成圖元時，請使用此函數。

```cpp
void HIMETRICtoDP(LPSIZE lpSize) const;
```

### <a name="parameters"></a>參數

*lpSize*<br/>
指向[大小](/windows/win32/api/windef/ns-windef-size)結構或[CSize](../../atl-mfc-shared/reference/csize-class.md)物件。

### <a name="remarks"></a>備註

如果裝置內容物件的對應模式是 MM_LOENGLISH、MM_HIENGLISH、MM_LOMETRIC 或 MM_HIMETRIC，則轉換是以實體英寸的圖元數為基礎。 如果對應模式是其他不受限制的模式之一（例如 MM_TEXT），則轉換會以邏輯英寸的圖元數為基礎。

## <a name="cdchimetrictolp"></a><a name="himetrictolp"></a>CDC：： HIMETRICtoLP

呼叫此函式可將 HIMETRIC 單位轉換成邏輯單元。

```cpp
void HIMETRICtoLP(LPSIZE lpSize) const;
```

### <a name="parameters"></a>參數

*lpSize*<br/>
指向[大小](/windows/win32/api/windef/ns-windef-size)結構或[CSize](../../atl-mfc-shared/reference/csize-class.md)物件。

### <a name="remarks"></a>備註

當您從 OLE 取得 HIMETRIC 大小，並想要將其轉換成應用程式的自然對應模式時，請使用此函式。

轉換的完成方式是先將 HIMETRIC 單位轉換成圖元，然後使用裝置內容的目前對應單位，將這些單位轉換成邏輯單元。 請注意，裝置的視窗和視口的範圍會影響結果。

## <a name="cdcintersectcliprect"></a><a name="intersectcliprect"></a>CDC：： IntersectClipRect

藉由形成目前區域和*x1*、 *y1*、 *x2*和*y2*所指定之矩形的交集，建立新的裁剪區域。

```
int IntersectClipRect(
    int x1,
    int y1,
    int x2,
    int y2);

int IntersectClipRect(LPCRECT lpRect);
```

### <a name="parameters"></a>參數

*x1*<br/>
指定矩形左上角的邏輯 x 座標。

*y1*<br/>
指定矩形左上角的邏輯 y 座標。

*x2*<br/>
指定矩形右下角的邏輯 x 座標。

*y2*<br/>
指定矩形右下角的邏輯 y 座標。

*lpRect*<br/>
指定矩形。 您可以將 `CRect` 物件或指標傳遞給 `RECT` 這個參數的結構。

### <a name="return-value"></a>傳回值

新裁剪區域的類型。 它可以是下列任何一個值：

- COMPLEXREGION 新的裁剪區域具有重迭的框線。

- 錯誤裝置內容無效。

- NullREGION 新的裁剪區域是空的。

- SIMPLEREGION 新的裁剪區域沒有重迭的框線。

### <a name="remarks"></a>備註

GDI 會裁剪所有後續的輸出，以符合新界限。 寬度和高度不得超過32767。

## <a name="cdcinvertrect"></a><a name="invertrect"></a>CDC：： InvertRect

反轉指定矩形的內容。

```cpp
void InvertRect(LPCRECT lpRect);
```

### <a name="parameters"></a>參數

*lpRect*<br/>
指向 `RECT` ，其中包含要反轉之矩形的邏輯座標。 您也可以傳遞 `CRect` 此參數的物件。

### <a name="remarks"></a>備註

反轉是邏輯 NOT 運算，而且會翻轉每個圖元的位。 在單色顯示上，函式會將白色圖元變成黑色和黑色圖元。 色彩顯示時，反轉的方式取決於如何產生顯示色彩。 `InvertRect`以相同的矩形呼叫兩次，會將顯示還原成先前的色彩。

如果矩形是空的，則不會繪製任何內容。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCDocView#36](../../mfc/codesnippet/cpp/cdc-class_8.cpp)]

## <a name="cdcinvertrgn"></a><a name="invertrgn"></a>CDC：： InvertRgn

反轉*pRgn*所指定區域中的色彩。

```
BOOL InvertRgn(CRgn* pRgn);
```

### <a name="parameters"></a>參數

*pRgn*<br/>
識別要反轉的區域。 區域的座標是以邏輯單元來指定。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

在單色顯示上，函式會將白色圖元變成黑色和黑色圖元。 色彩顯示時，反轉的方式取決於如何產生顯示色彩。

## <a name="cdcisprinting"></a><a name="isprinting"></a>CDC：： IsPrinting

判斷是否使用裝置內容進行列印。

```
BOOL IsPrinting() const;
```

### <a name="return-value"></a>傳回值

如果 `CDC` 物件是印表機 DC，則為非零，否則為0。

## <a name="cdclineto"></a><a name="lineto"></a>CDC：： LineTo

從目前的位置繪製一條線到*x*和*y* （或*point*）所指定的點，但不包括在內。

```
BOOL LineTo(
    int x,
    int y);

BOOL LineTo(POINT point);
```

### <a name="parameters"></a>參數

*x*<br/>
指定線條的端點邏輯 x 座標。

*y*<br/>
指定線條的端點邏輯 y 座標。

*此處*<br/>
指定行的端點。 您可以傳遞 `POINT` 此參數的結構或 `CPoint` 物件。

### <a name="return-value"></a>傳回值

如果已繪製行，則為非零值;否則為0。

### <a name="remarks"></a>備註

線條會以選取的畫筆繪製。 目前的位置設定為*x*、 *y*或*點*。

### <a name="example"></a>範例

  請參閱[CRect：： CenterPoint](../../atl-mfc-shared/reference/crect-class.md#centerpoint)的範例。

## <a name="cdclptodp"></a><a name="lptodp"></a>CDC：： LPtoDP

將邏輯單元轉換成裝置單位。

```cpp
void LPtoDP(
    LPPOINT lpPoints,
    int nCount = 1) const;

void LPtoDP(LPRECT lpRect) const;
void LPtoDP(LPSIZE lpSize) const;
```

### <a name="parameters"></a>參數

*lpPoints*<br/>
指向點陣列。 陣列中的每個點都是[點](/windows/win32/api/windef/ns-windef-point)結構或[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)物件。

*nCount*<br/>
陣列中的點數目。

*lpRect*<br/>
指向[矩形](/windows/win32/api/windef/ns-windef-rect)結構或[CRect](../../atl-mfc-shared/reference/crect-class.md)物件。 這個參數是用來將矩形從邏輯對應至裝置單位的常見案例。

*lpSize*<br/>
指向[大小](/windows/win32/api/windef/ns-windef-size)結構或[CSize](../../atl-mfc-shared/reference/csize-class.md)物件。

### <a name="remarks"></a>備註

函式會將每個點的座標，或大小的維度，從 GDI 的邏輯座標系統對應到裝置座標系統。 轉換取決於目前的對應模式，以及裝置的視窗和視口的來源和範圍的設定。

點的 x 和 y 座標是範圍-32768 到32767的2位元組帶正負號的整數。 當對應模式產生的值大於這些限制時，系統會分別將值設定為-32768 和32767。

## <a name="cdclptohimetric"></a><a name="lptohimetric"></a>CDC：： LPtoHIMETRIC

呼叫此函式可將邏輯單元轉換成 HIMETRIC 單位。

```cpp
void LPtoHIMETRIC(LPSIZE lpSize) const;
```

### <a name="parameters"></a>參數

*lpSize*<br/>
指向 `SIZE` 結構或 `CSize` 物件。

### <a name="remarks"></a>備註

當您將 HIMETRIC 大小授與 OLE 時，請使用此函式，從應用程式的自然對應模式轉換。 請注意，裝置的視窗和視口的範圍會影響結果。

轉換的完成方式是先使用裝置內容的目前對應單位，將邏輯單元轉換成圖元，然後將這些單位轉換成 HIMETRIC 單位。

## <a name="cdcm_hattribdc"></a><a name="m_hattribdc"></a>CDC：： m_hAttribDC

這個物件的屬性裝置內容 `CDC` 。

```
HDC m_hAttribDC;
```

### <a name="remarks"></a>備註

根據預設，此裝置內容等於 `m_hDC` 。 一般而言， `CDC` 從裝置內容要求資訊的 GDI 呼叫會導向至 `m_hAttribDC` 。 如需使用這兩個裝置內容的詳細資訊，請參閱[CDC](../../mfc/reference/cdc-class.md)類別描述。

## <a name="cdcm_hdc"></a><a name="m_hdc"></a>CDC：： m_hDC

這個物件的輸出裝置內容 `CDC` 。

```
HDC m_hDC;
```

### <a name="remarks"></a>備註

根據預設， `m_hDC` 等於 `m_hAttribDC` 所包裝的其他裝置內容 `CDC` 。 一般而言， `CDC` 建立輸出的 GDI 呼叫會移至 `m_hDC` 裝置內容。 您可以初始化 `m_hDC` 並 `m_hAttribDC` 指向不同的裝置。 如需使用這兩個裝置內容的詳細資訊，請參閱[CDC](../../mfc/reference/cdc-class.md)類別描述。

## <a name="cdcmaskblt"></a><a name="maskblt"></a>CDC：： MaskBlt

使用指定的遮罩和點陣運算，結合來源與目的地點陣圖的色彩資料。

```
BOOL MaskBlt(
    int x,
    int y,
    int nWidth,
    int nHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    CBitmap& maskBitmap,
    int xMask,
    int yMask,
    DWORD dwRop);
```

### <a name="parameters"></a>參數

*x*<br/>
指定目的地矩形左上角的邏輯 x 座標。

*y*<br/>
指定目的地矩形左上角的邏輯 y 座標。

*nWidth*<br/>
指定目的地矩形和來源點陣圖的寬度（以邏輯單位表示）。

*nHeight*<br/>
指定目的地矩形和來源點陣圖的高度（以邏輯單位表示）。

*pSrcDC*<br/>
識別要從中複製點陣圖的裝置內容。 如果*dwRop*參數指定不包含來源的點陣作業，則此值必須為零。

*xSrc*<br/>
指定來源點陣圖左上角的邏輯 x 座標。

*ySrc*<br/>
指定來源點陣圖左上角的邏輯 y 座標。

*maskBitmap*<br/>
識別與來源裝置內容中的色彩點陣圖結合的單色遮罩點陣圖。

*xMask*<br/>
指定*maskBitmap*參數所指定之遮罩點陣圖的水準圖元位移。

*yMask*<br/>
指定*maskBitmap*參數所指定之遮罩點陣圖的垂直圖元位移。

*dwRop*<br/>
指定前景和背景三元點陣作業代碼，函式會使用此作業碼來控制來源與目的地資料的組合。 背景點陣作業程式碼會儲存在此值的高位位元組內;前景點陣作業程式碼會儲存在此值的高位位元組內;會忽略這個值的低字，而且應該是零。 [宏 MAKEROP4] 會建立這類前景和背景點陣操作代碼的組合。 如需此函式內容中前景和背景的討論，請參閱備註一節。 如需常見的點陣作業碼清單，請參閱成員函式 `BitBlt` 。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

*MaskBitmap*所指定遮罩中的值為1，表示應該在該位置套用*dwRop*所指定的前景點陣作業程式碼。 遮罩中的值為0表示*dwRop*指定的背景點陣作業程式碼應套用至該位置。 如果點陣作業需要來源，遮罩矩形必須涵蓋來源矩形。 如果不存在，函式將會失敗。 如果點陣作業不需要來源，mask 矩形就必須涵蓋目的矩形。 如果不存在，函式將會失敗。

如果在呼叫此函式時，對來源裝置內容的旋轉或切變轉換有效，就會發生錯誤。 不過，允許其他類型的轉換。

如果來源、模式及目的地點陣圖的色彩格式不同，則此函式會轉換模式或來源格式（或兩者），以符合目的地格式。 如果遮罩點陣圖不是單色點陣圖，就會發生錯誤。 當記錄了增強型中繼檔時，如果來源裝置內容識別增強型中繼檔的裝置內容，就會發生錯誤（而且函式會傳回0）。 並非所有裝置都支援 `MaskBlt` 。 應用程式應該呼叫 `GetDeviceCaps` 來判斷裝置是否支援此功能。 如果未提供遮罩點陣圖，則此函式的行為與 `BitBlt` 使用前景點陣作業程式碼完全相同。 遮罩點陣圖中的圖元位移對應至來源裝置內容點陣圖中的點（0，0）。 這適用于遮罩點陣圖包含一組遮罩的情況;應用程式可以藉由調整傳送至的圖元位移和矩形大小，輕鬆地將其中任何一個套用至遮罩 blitting 工作 `MaskBlt` 。

## <a name="cdcmodifyworldtransform"></a><a name="modifyworldtransform"></a>CDC：： ModifyWorldTransform

使用指定的模式變更裝置內容的世界轉換。

```
BOOL ModifyWorldTransform(
    const XFORM& rXform,
    DWORD iMode);
```

### <a name="parameters"></a>參數

*rXform*<br/>
[XFORM](/windows/win32/api/wingdi/ns-wingdi-xform)結構的參考，用來修改指定裝置內容的世界轉換。

*iMode*<br/>
指定轉換資料如何修改目前的世界轉換。 如需此參數可接受的值清單，請參閱[ModifyWorldTransform](/windows/win32/api/wingdi/nf-wingdi-modifyworldtransform)。

### <a name="return-value"></a>傳回值

會在成功時傳回非零值。

失敗時傳回0。

若要取得延伸錯誤資訊，請呼叫[GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror)。

### <a name="remarks"></a>備註

這個方法會包裝 Windows GDI 函數[ModifyWorldTransform](/windows/win32/api/wingdi/nf-wingdi-modifyworldtransform)。

## <a name="cdcmoveto"></a><a name="moveto"></a>CDC：： MoveTo

將目前的位置移至*x*和*y* （或依*點*）所指定的點。

```
CPoint MoveTo(
    int x,
    int y);

CPoint MoveTo(POINT point);
```

### <a name="parameters"></a>參數

*x*<br/>
指定新位置的邏輯 x 座標。

*y*<br/>
指定新位置的邏輯 y 座標。

*此處*<br/>
指定新的位置。 您可以傳遞 `POINT` 此參數的結構或 `CPoint` 物件。

### <a name="return-value"></a>傳回值

先前位置的 x 和 y 座標， `CPoint` 表示為物件。

### <a name="example"></a>範例

  請參閱[CRect：： CenterPoint](../../atl-mfc-shared/reference/crect-class.md#centerpoint)的範例。

## <a name="cdcoffsetcliprgn"></a><a name="offsetcliprgn"></a>CDC：： OffsetClipRgn

依據指定的位移移動裝置內容的裁剪區域。

```
int OffsetClipRgn(
    int x,
    int y);

int OffsetClipRgn(SIZE size);
```

### <a name="parameters"></a>參數

*x*<br/>
指定要向左或向右移動的邏輯單元數目。

*y*<br/>
指定要向上或向下移動的邏輯單元數目。

*size*<br/>
指定要位移的數量。

### <a name="return-value"></a>傳回值

新區域的類型。 它可以是下列任何一個值：

- COMPLEXREGION 裁剪區域具有重迭的框線。

- 錯誤裝置內容無效。

- NullREGION 裁剪區域是空的。

- SIMPLEREGION 裁剪區域沒有重迭的框線。

### <a name="remarks"></a>備註

函式沿著 X 軸和*y*軸移動區域*x*單位。

## <a name="cdcoffsetviewportorg"></a><a name="offsetviewportorg"></a>CDC：： OffsetViewportOrg

修改與目前的視口原點座標相對的視口原點座標。

```
virtual CPoint OffsetViewportOrg(
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>參數

*nWidth*<br/>
指定要加入至目前原點 x 座標的裝置單位數。

*nHeight*<br/>
指定要加入至目前原點 y 座標的裝置單位數。

### <a name="return-value"></a>傳回值

先前的視口原點（在裝置座標中）， `CPoint` 表示為物件。

## <a name="cdcoffsetwindoworg"></a><a name="offsetwindoworg"></a>CDC：： OffsetWindowOrg

修改視窗原點相對於目前視窗原點座標的座標。

```
CPoint OffsetWindowOrg(
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>參數

*nWidth*<br/>
指定要加入至目前原點 x 座標的邏輯單元數目。

*nHeight*<br/>
指定要加入至目前原點 y 座標的邏輯單元數目。

### <a name="return-value"></a>傳回值

先前的視窗原點（邏輯座標），表示為 `CPoint` 物件。

## <a name="cdcoperator-hdc"></a><a name="operator_hdc"></a>CDC：： operator HDC

使用此運算子來抓取物件的裝置內容控制碼 `CDC` 。

```
operator HDC() const;
```

### <a name="return-value"></a>傳回值

如果成功，則為裝置內容物件的控制碼;否則為 Null。

### <a name="remarks"></a>備註

您可以使用控制碼直接呼叫 Windows Api。

## <a name="cdcpaintrgn"></a><a name="paintrgn"></a>CDC：:P aintRgn

使用目前筆刷填滿*pRgn*所指定的區域。

```
BOOL PaintRgn(CRgn* pRgn);
```

### <a name="parameters"></a>參數

*pRgn*<br/>
識別要填入的區域。 給定區域的座標是以邏輯單元指定。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

## <a name="cdcpatblt"></a><a name="patblt"></a>CDC：:P atBlt

在裝置上建立位模式。

```
BOOL PatBlt(
    int x,
    int y,
    int nWidth,
    int nHeight,
    DWORD dwRop);
```

### <a name="parameters"></a>參數

*x*<br/>
指定要接收模式之矩形左上角的邏輯 x 座標。

*y*<br/>
指定要接收模式之矩形左上角的邏輯 y 座標。

*nWidth*<br/>
指定要接收模式之矩形的寬度（以邏輯單位表示）。

*nHeight*<br/>
指定要接收模式之矩形的高度（以邏輯單位表示）。

*dwRop*<br/>
指定點陣操作程式碼。 點陣作業程式碼（ROPs）定義 GDI 如何結合包含目前筆刷、可能來源點陣圖和目的地點陣圖的輸出運算色彩。 這個參數可以是下列其中一個值：

- PATCOPY 會將模式複製到目的地點陣圖。

- PATINVERT 會使用布林 XOR 運算子，結合目的地點陣圖與模式。

- DSTINVERT 反轉目的地點陣圖。

- 即黑會將所有輸出變成黑色。

- WHITENESS 會將所有輸出變成白色。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

模式是選取的筆刷和裝置上已有的模式組合。 *DwRop*所指定的點陣作業程式碼會定義如何合併模式。 針對此函式所列出的點陣作業是完整256三元點陣操作代碼的有限子集;特別是，無法使用參考來源的點陣作業程式碼。

並非所有的裝置內容都支援 `PatBlt` 函數。 若要判斷裝置內容是否支援 `PatBlt` ，請呼叫 `GetDeviceCaps` 具有 RASTERCAPS 索引的成員函式，並檢查 RC_BITBLT 旗標的傳回值。

## <a name="cdcpie"></a><a name="pie"></a>CDC：:P ie

繪製橢圓形的楔形，其中心和兩個端點是以線條聯結。

```
BOOL Pie(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4);

BOOL Pie(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```

### <a name="parameters"></a>參數

*x1*<br/>
指定周框左上角的 x 座標（以邏輯單位表示）。

*y1*<br/>
指定周框左上角的 y 座標（以邏輯單位表示）。

*x2*<br/>
指定周框右下角的 x 座標（以邏輯單位表示）。

*y2*<br/>
指定周框右下角的 y 座標（以邏輯單位表示）。

*x3*<br/>
指定弧形起點的 x 座標（以邏輯單位表示）。 這點不一定要完全落在弧線上。

*y3*<br/>
指定弧形起點的 y 座標（以邏輯單位表示）。 這點不一定要完全落在弧線上。

*四*<br/>
指定弧形端點的 x 座標（以邏輯單位表示）。 這點不一定要完全落在弧線上。

*y4*<br/>
指定弧形端點的 y 座標（以邏輯單位表示）。 這點不一定要完全落在弧線上。

*lpRect*<br/>
指定周框。 您可以將 `CRect` 物件或指標傳遞給 `RECT` 這個參數的結構。

*ptStart*<br/>
指定弧線的起始點。這點不一定要完全落在弧線上。您可以針對這個參數傳遞[POINT](/windows/win32/api/windef/ns-windef-point)結構或[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)物件。

*ptEnd*<br/>
指定弧線的端點。這點不一定要完全落在弧線上。您可以傳遞 `POINT` 此參數的結構或 `CPoint` 物件。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

弧線的中心是由*x1*、 *y1*、 *X2*和*y2* （或*lpRect*）所指定的周框中央。 弧線的開始和結束點是由*x3*、 *y3*、 *X4*和*y4* （或*ptStart*和*ptEnd*）所指定。

弧線會以選取的畫筆繪製，以逆時針方向移動。 兩個額外的線條會從每個端點繪製到弧形的中心。 圓形圖區域會填滿目前的筆刷。 如果*x3*等於*x4*和*y3*等於*y4*，結果會是一個橢圓形，其中包含從橢圓形中間到點（ *x3*、 *y3*）或（ *x4*， *y4*）的單行。

此函式所繪製的圖表會延伸至，但不包含右和下座標。 這表示圖形的高度是*y2*  -  *y1* ，而圖的寬度是*x2*  -  *x1*。 周框矩形的寬度和高度必須大於2個單位且小於32767個單位。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCDocView#37](../../mfc/codesnippet/cpp/cdc-class_9.cpp)]

## <a name="cdcplaymetafile"></a><a name="playmetafile"></a>CDC：:P layMetaFile

在裝置內容上播放指定中繼檔的內容。

```
BOOL PlayMetaFile(HMETAFILE hMF);

BOOL PlayMetaFile(
    HENHMETAFILE hEnhMetaFile,
    LPCRECT lpBounds);
```

### <a name="parameters"></a>參數

*hMF*<br/>
識別要播放的中繼檔。

*hEnhMetaFile*<br/>
識別增強型中繼檔。

*lpBounds*<br/>
指向 `RECT` 結構或 `CRect` 物件，其中包含用來顯示圖片之周框的座標。 座標會以邏輯單元來指定。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

中繼檔可以任意次數播放。

的第二個版本會 `PlayMetaFile` 顯示儲存在指定之增強格式中繼檔中的圖片。 當應用程式呼叫的第二個版本時 `PlayMetaFile` ，Windows 會使用增強型中繼檔標頭中的圖片框，將圖片對應到*lpBounds*參數所指向的矩形。 （在呼叫之前，您可以在輸出裝置中設定世界轉換，以剪切或旋轉這張圖片 `PlayMetaFile` ）。沿著矩形邊緣的點會包含在圖片中。 在播放增強型中繼檔之前，您可以在輸出裝置中定義裁剪區域，以裁剪增強型中繼檔圖片。

如果增強型中繼檔包含選擇性的調色板，應用程式可以在呼叫的第二個版本之前，先在輸出裝置上設定調色板，以達成一致的色彩 `PlayMetaFile` 。 若要取得選用的調色板，請使用 Windows 函式 `GetEnhMetaFilePaletteEntries` 。 增強型中繼檔可以內嵌在新建立的增強型中繼檔中，方法是呼叫的第二個版本 `PlayMetaFile` ，並將來源增強型中繼檔播放至新增強型中繼檔的裝置內容。

此函式會保留輸出裝置內容的狀態。 此函式會刪除增強型中繼檔中所建立但未刪除的任何物件。 若要停止此函式，應用程式可以 `CancelDC` 從另一個執行緒呼叫 Windows 函數來終止作業。 在此情況下，函數會傳回零。

## <a name="cdcplgblt"></a><a name="plgblt"></a>CDC：:P lgBlt

執行從來源裝置內容中指定矩形到指定裝置內容中的平行四邊形的位區塊傳輸。

```
BOOL PlgBlt(
    LPPOINT lpPoint,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    int nWidth,
    int nHeight,
    CBitmap& maskBitmap,
    int xMask,
    int yMask);
```

### <a name="parameters"></a>參數

*lpPoint*<br/>
指向邏輯空間中三個點的陣列，識別目的地平行四邊形的三個角落。 來源矩形的左上角會對應至此陣列中的第一個點，即此陣列中第二個點的右上角，以及第三個點的左下角。 來源矩形的右下角會對應到平行四邊形中的隱含第四個點。

*pSrcDC*<br/>
識別來源裝置內容。

*xSrc*<br/>
指定來源矩形左上角的 x 座標（以邏輯單位表示）。

*ySrc*<br/>
指定來源矩形左上角的 y 座標（以邏輯單位表示）。

*nWidth*<br/>
指定來源矩形的寬度（以邏輯單位表示）。

*nHeight*<br/>
指定來源矩形的高度（以邏輯單位表示）。

*maskBitmap*<br/>
識別用來遮罩來源矩形色彩的選擇性單色點陣圖。

*xMask*<br/>
指定單色點陣圖左上角的 x 座標。

*yMask*<br/>
指定單色點陣圖左上角的 y 座標。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

如果指定的位元遮罩控制碼識別有效的單色點陣圖，則函式會使用這個點陣圖來遮罩來源矩形的色彩資料位。

平行四邊形（D）的第四個頂點是藉由將前三個點（A、B 和 C）視為向量，並計算 D = B + C-A 來定義。

如果位元遮罩存在，遮罩中的值為1表示來源圖元色彩應該複製到目的地。 遮罩中的值為0表示不會變更目的地圖元色彩。

如果遮罩矩形小於來源和目的矩形，函式會複寫遮罩模式。

來源裝置內容中允許縮放、轉譯和反映轉換;不過，旋轉和切變轉換並不是。 如果遮罩點陣圖不是單色點陣圖，就會發生錯誤。 目的地裝置內容的延展模式是用來決定如何延展或壓縮圖元（如果有必要的話）。 當記錄了增強型中繼檔時，如果來源裝置內容識別增強型中繼檔的裝置內容，就會發生錯誤。

目的地座標會根據目的地裝置內容而轉換；來源座標會根據來源裝置內容而轉換。 如果來源轉換具有旋轉或切變，則會傳回錯誤。 如果目的地和來源矩形的色彩格式不相同，會 `PlgBlt` 將來源矩形轉換成符合目的矩形。 並非所有裝置都支援 `PlgBlt` 。 如需詳細資訊，請參閱成員函式中 RC_BITBLT 點陣功能的描述 `CDC::GetDeviceCaps` 。

如果來源和目的地裝置內容代表不相容的裝置，則會傳回 `PlgBlt` 錯誤。

## <a name="cdcpolybezier"></a><a name="polybezier"></a>CDC：:P olyBezier

繪製一或多個 Bzier 曲線。

```
BOOL PolyBezier(
    const POINT* lpPoints,
    int nCount);
```

### <a name="parameters"></a>參數

*lpPoints*<br/>
指向[點](/windows/win32/api/windef/ns-windef-point)資料結構的陣列，其中包含曲線的端點和控制點。

*nCount*<br/>
指定*lpPoints*陣列中的點數目。 這個值必須是要繪製之曲線數目的三倍以上，因為每個 Bzier 曲線都需要兩個控制點和一個端點，而初始曲線則需要一個額外的起點。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

此函式會使用*lpPoints*參數所指定的端點和控制點，繪製三個 Bzier 曲線。 第一個曲線會從第一個點繪製到第四個點，方法是使用第二個和第三個點作為控制點。 序列中的每個後續曲線都只需要三個點：前一個樣條的終點會當做起點，序列中的下兩個點是控制點，而第三個是結束點。

函數不會使用目前的位置，也不會更新 `PolyBezier` 。 此圖不會填滿。 此函式會使用目前的畫筆繪製線條。

## <a name="cdcpolybezierto"></a><a name="polybezierto"></a>CDC：:P olyBezierTo

繪製一或多個 Bzier 曲線。

```
BOOL PolyBezierTo(
    const POINT* lpPoints,
    int nCount);
```

### <a name="parameters"></a>參數

*lpPoints*<br/>
指向包含端點和控制點的[點](/windows/win32/api/windef/ns-windef-point)資料結構陣列。

*nCount*<br/>
指定*lpPoints*陣列中的點數目。 這個值必須是要繪製之曲線數目的三倍，因為每個 Bzier 曲線都需要兩個控制點和一個結束點。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

此函式會使用*lpPoints*參數所指定的控制點來繪製三 Bzier 曲線。 第一個曲線會從目前位置繪製到第三個點，方法是使用前兩個點作為控制點。 針對每個後續的曲線，函式需要剛好三個點，並使用上一個曲線的結束點做為下一個樣條的起點。 `PolyBezierTo`將目前的位置移至最後一個 Bzier 曲線的結束點。 此圖不會填滿。 此函式會使用目前的畫筆繪製線條。

### <a name="example"></a>範例

  請參閱[CDC：： BeginPath](#beginpath)的範例。

## <a name="cdcpolydraw"></a><a name="polydraw"></a>CDC：:P olyDraw

繪製一組線段和 Bzier 曲線。

```
BOOL PolyDraw(
    const POINT* lpPoints,
    const BYTE* lpTypes,
    int nCount);
```

### <a name="parameters"></a>參數

*lpPoints*<br/>
指向[點](/windows/win32/api/windef/ns-windef-point)資料結構的陣列，其中包含每個線段的端點，以及每個 Bzier 曲線的端點和控制點。

*lpTypes*<br/>
指向陣列，指定如何使用*lpPoints*陣列中的每個點。 它可以是下列其中一個值：

- PT_MOVETO 指定這個點會啟動一個不相交的圖形。 這個點會成為新的目前位置。

- PT_LINETO 指定要從目前位置繪製線條到這個點，然後再成為新的目前位置。

- PT_BEZIERTO 指定此點是 Bzier 曲線的控制點或結束點。

PT_BEZIERTO 類型一律會出現在三個集合中。 目前的位置會定義 Bzier 曲線的起點。 前兩個 PT_BEZIERTO 點是控制點，而第三個 PT_BEZIERTO 點是結束點。 結束點會成為新的目前位置。 如果沒有連續的 PT_BEZIERTO 點，則會產生錯誤。

   PT_LINETO 或 PT_BEZIERTO 型別可以使用位運算子來與下列常數結合，或表示對應的點是圖形中的最後一個點，而該圖表已關閉：

- PT_CLOSEFIGURE 指定在此點的 PT_LINETO 或 PT_BEZIERTO 類型完成後，會自動關閉圖形。 線條會從這個點繪製到最近的 PT_MOVETO 或 `MoveTo` 點。

   這個旗標會與線條的 PT_LINETO 類型或 Bzier 曲線之結束點的 PT_BEZIERTO 類型結合，方法是使用位**or**運算子。 目前的位置會設定為結尾行的結束點。

*nCount*<br/>
指定*lpPoints*陣列中的總點數數，與*lpTypes*陣列中的位元組數目相同。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

此函式可以用來繪製不連續的圖形，以取代 `CDC::MoveTo` 、和成員函式的連續呼叫 `CDC::LineTo` `CDC::PolyBezierTo` 。 使用目前的畫筆繪製線條和曲線，而不會填滿圖形。 如果已藉由呼叫成員函式來啟動作用中的路徑，則會 `CDC::BeginPath` `PolyDraw` 將新增至路徑。 包含在*lpPoints*陣列和*lpTypes*中的點，會指出每個點是否為、或作業的一部分 `CDC::MoveTo` `CDC::LineTo` `CDC::BezierTo` 。 也可以關閉圖形。 此函式會更新目前的位置。

### <a name="example"></a>範例

  請參閱[CDC：： BeginPath](#beginpath)的範例。

## <a name="cdcpolygon"></a><a name="polygon"></a>CDC：:P olygon

使用目前的畫筆繪製由兩個或多個以線條連接的點（頂點）所組成的多邊形。

```
BOOL Polygon(
    LPPOINT lpPoints,
    int nCount);
```

### <a name="parameters"></a>參數

*lpPoints*<br/>
指向指定多邊形頂點的點陣列。 陣列中的每個點都是 `POINT` 結構或 `CPoint` 物件。

*nCount*<br/>
指定陣列中的頂點數目。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

系統會在必要時自動關閉多邊形，方法是從最後一個頂點繪製一條線到第一個。

您可以使用和成員函式來抓取或設定目前的多邊形填滿模式 `GetPolyFillMode` `SetPolyFillMode` 。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCDocView#38](../../mfc/codesnippet/cpp/cdc-class_10.cpp)]

## <a name="cdcpolyline"></a><a name="polyline"></a>CDC：:P olyline

繪製一組連接*lpPoints*所指定之點的線段。

```
BOOL Polyline(
    LPPOINT lpPoints,
    int nCount);
```

### <a name="parameters"></a>參數

*lpPoints*<br/>
指向 `POINT` 要連接的結構或物件的陣列 `CPoint` 。

*nCount*<br/>
指定陣列中的點數目。 此值必須至少為2。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

這些行會使用目前的畫筆，從第一個點繪製到後續點。 和成員函式不同的 `LineTo` 是，函式 `Polyline` 不會使用也不會更新目前的位置。

如需詳細資訊，請參閱 Windows SDK 中的[折線](/windows/win32/api/wingdi/nf-wingdi-polyline)。

## <a name="cdcpolylineto"></a><a name="polylineto"></a>CDC：:P olylineTo

繪製一或多條直線。

```
BOOL PolylineTo(
    const POINT* lpPoints,
    int nCount);
```

### <a name="parameters"></a>參數

*lpPoints*<br/>
指向包含線條頂點之[POINT](/windows/win32/api/windef/ns-windef-point)資料結構的陣列。

*nCount*<br/>
指定陣列中的點數目。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

線條是使用目前的畫筆，從目前位置繪製到*lpPoints*參數所指定的第一個點。 針對每一行額外的程式碼，函式會從上一行的結束點繪製到*lpPoints*所指定的下一個點。 `PolylineTo`將目前的位置移至最後一行的結束點。 如果此函式所繪製的線段形成封閉的圖形，則不會填滿圖表。

## <a name="cdcpolypolygon"></a><a name="polypolygon"></a>CDC：:P olyPolygon

建立兩個或多個使用目前多邊形填滿模式填滿的多邊形。

```
BOOL PolyPolygon(
    LPPOINT lpPoints,
    LPINT lpPolyCounts,
    int nCount);
```

### <a name="parameters"></a>參數

*lpPoints*<br/>
指向 `POINT` 定義多邊形頂點的結構或 `CPoint` 物件陣列。

*lpPolyCounts*<br/>
指向整數陣列，其中每個都指定*lpPoints*陣列中其中一個多邊形的點數目。

*nCount*<br/>
*LpPolyCounts*陣列中的專案數。 這個數位會指定要繪製的多邊形數目。 此值必須至少為2。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

多邊形可能不相交或重迭。

對函式的呼叫中指定的每個多邊形都 `PolyPolygon` 必須關閉。 不同于成員函式所建立 `Polygon` 的多邊形，所建立的多邊形 `PolyPolygon` 不會自動關閉。

函式會建立兩個或多個多邊形。 若要建立單一多邊形，應用程式應該使用成員函式 `Polygon` 。

您可以使用和成員函式來抓取或設定目前的多邊形填滿模式 `GetPolyFillMode` `SetPolyFillMode` 。

## <a name="cdcpolypolyline"></a><a name="polypolyline"></a>CDC：:P olyPolyline

繪製多個連接線段的序列。

```
BOOL PolyPolyline(
    const POINT* lpPoints,
    const DWORD* lpPolyPoints,
    int nCount);
```

### <a name="parameters"></a>參數

*lpPoints*<br/>
指向包含折線頂點的結構陣列。 折線會連續指定。

*lpPolyPoints*<br/>
指向變數陣列，指定*lpPoints*陣列中對應多邊形的點數目。 每個專案都必須大於或等於2。

*nCount*<br/>
指定*lpPolyPoints*陣列中的總次數。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

使用目前的畫筆繪製線段。 區段所形成的圖表並不會填滿。 這個函式不會使用或更新目前的位置。

## <a name="cdcptvisible"></a><a name="ptvisible"></a>CDC：:P tVisible

判斷指定的點是否在裝置內容的裁剪區域中。

```
virtual BOOL PtVisible(
    int x,
    int y) const;

BOOL PtVisible(POINT point) const;
```

### <a name="parameters"></a>參數

*x*<br/>
指定點的邏輯 x 座標。

*y*<br/>
指定點的邏輯 y 座標。

*此處*<br/>
指定要在邏輯座標中檢查的點。 您可以傳遞 `POINT` 此參數的結構或 `CPoint` 物件。

### <a name="return-value"></a>傳回值

如果指定的點在裁剪區域內，則為非零值;否則為0。

## <a name="cdcqueryabort"></a><a name="queryabort"></a>CDC：： QueryAbort

呼叫列印應用程式的[SetAbortProc](#setabortproc)成員函式所安裝的 abort 函式，並查詢是否應終止列印。

```
BOOL QueryAbort() const;
```

### <a name="return-value"></a>傳回值

如果列印應該繼續，或如果沒有中止程式，則傳回值為非零。 如果列印工作應終止，則為0。 傳回值是由 abort 函數提供。

## <a name="cdcrealizepalette"></a><a name="realizepalette"></a>CDC：： RealizePalette

將專案從目前的邏輯調色板對應至系統元件區。

```
UINT RealizePalette();
```

### <a name="return-value"></a>傳回值

指出邏輯調色板中有多少專案對應到系統元件中的不同專案。 這代表自上次實現邏輯調色板之後，此函式重新對應的專案數，以容納系統元件中的變更。

### <a name="remarks"></a>備註

邏輯色調色板可做為彩色應用程式與系統之間的緩衝區，讓應用程式可以視需要使用多個色彩，而不會干擾自己所顯示的色彩或其他視窗所顯示的色彩。

當視窗具有輸入焦點並呼叫時 `RealizePalette` ，Windows 會確保視窗會顯示所有要求的色彩，最高可在螢幕上同時使用的最大數目。 Windows 也會藉由比對在視窗的調色板中，藉由將它們對應至可用的色彩來顯示。

此外，Windows 也會比對非作用中視窗所要求的色彩，以盡可能接近可用的色彩。 這會大幅減少非作用中視窗中顯示的色彩變更。

## <a name="cdcrectangle"></a><a name="rectangle"></a>CDC：： Rectangle

使用目前的畫筆繪製矩形。

```
BOOL Rectangle(
    int x1,
    int y1,
    int x2,
    int y2);

BOOL Rectangle(LPCRECT lpRect);
```

### <a name="parameters"></a>參數

*x1*<br/>
指定矩形左上角的 x 座標（以邏輯單位表示）。

*y1*<br/>
指定矩形左上角的 y 座標（以邏輯單位表示）。

*x2*<br/>
指定矩形右下角的 x 座標（以邏輯單位表示）。

*y2*<br/>
指定矩形右下角的 y 座標（以邏輯單位表示）。

*lpRect*<br/>
指定邏輯單元中的矩形。 您可以將 `CRect` 物件或指標傳遞給 `RECT` 這個參數的結構。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

矩形的內部會使用目前的筆刷來填滿。

矩形會擴充至，但不包括右和下座標。 這表示矩形的高度是*y2*  -  *y1* ，而矩形的寬度是*x2*  -  *x1*。 矩形的寬度和高度必須大於2個單位且小於32767個單位。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCDocView#39](../../mfc/codesnippet/cpp/cdc-class_11.cpp)]

## <a name="cdcrectvisible"></a><a name="rectvisible"></a>CDC：： RectVisible

判斷指定矩形的任何部分是否位於顯示內容的裁剪區域中。

```
virtual BOOL RectVisible(LPCRECT lpRect) const;
```

### <a name="parameters"></a>參數

*lpRect*<br/>
指向 `RECT` 結構或 `CRect` 物件，其中包含指定矩形的邏輯座標。

### <a name="return-value"></a>傳回值

如果指定矩形的任何部分位於裁剪區域內，則為非零值;否則為0。

## <a name="cdcreleaseattribdc"></a><a name="releaseattribdc"></a>CDC：： ReleaseAttribDC

呼叫這個成員函式可將設定 `m_hAttribDC` 為 Null。

```
virtual void ReleaseAttribDC();
```

### <a name="remarks"></a>備註

這不會導致 `Detach` 發生。 只有輸出裝置內容會附加至 `CDC` 物件，而且只有它可以卸離。

## <a name="cdcreleaseoutputdc"></a><a name="releaseoutputdc"></a>CDC：： ReleaseOutputDC

呼叫這個成員函式，將 `m_hDC` 成員設定為 Null。

```
virtual void ReleaseOutputDC();
```

### <a name="remarks"></a>備註

當輸出裝置內容附加至物件時，無法呼叫這個成員函式 `CDC` 。 使用成員函式 `Detach` 來卸離輸出裝置內容。

## <a name="cdcresetdc"></a><a name="resetdc"></a>CDC：： ResetDC

呼叫這個成員函式，以更新物件所包裝的裝置內容 `CDC` 。

```
BOOL ResetDC(const DEVMODE* lpDevMode);
```

### <a name="parameters"></a>參數

*lpDevMode*<br/>
Windows 結構的指標 `DEVMODE` 。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

裝置內容會從 Windows 結構中指定的資訊進行更新 `DEVMODE` 。 此成員函式只會重設屬性裝置內容。

`ResetDC`當視窗處理訊息時，應用程式通常會使用成員函式 `WM_DEVMODECHANGE` 。 您也可以在列印檔案時，使用這個成員函式來變更紙張方向或紙張。

您不能使用這個成員函式來變更驅動程式名稱、裝置名稱或輸出埠。 當使用者變更埠連線或裝置名稱時，您必須刪除原始裝置內容，並使用新的資訊建立新的裝置內容。

在您呼叫這個成員函式之前，您必須確定已選取所有物件（非股票物件）到裝置內容中。

## <a name="cdcrestoredc"></a><a name="restoredc"></a>CDC：： RestoreDC

將裝置內容還原到*nSavedDC*所識別的先前狀態。

```
virtual BOOL RestoreDC(int nSavedDC);
```

### <a name="parameters"></a>參數

*nSavedDC*<br/>
指定要還原的裝置內容。 它可以是先前函式呼叫所傳回的值 `SaveDC` 。 如果*nSavedDC*為-1，則會還原最近儲存的裝置內容。

### <a name="return-value"></a>傳回值

如果已還原指定的內容，則為非零。否則為0。

### <a name="remarks"></a>備註

`RestoreDC`藉由將先前呼叫成員函式所建立的堆疊中的狀態資訊彈出，來還原裝置內容 `SaveDC` 。

堆疊可以包含數個裝置內容的狀態資訊。 如果*nSavedDC*所指定的內容不在堆疊的頂端，會 `RestoreDC` 刪除*nSavedDC*指定的裝置內容與堆疊頂端之間的所有狀態資訊。 已刪除的資訊將會遺失。

## <a name="cdcroundrect"></a><a name="roundrect"></a>CDC：： RoundRect

使用目前的畫筆繪製具有圓角的矩形。

```
BOOL RoundRect(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3);

BOOL RoundRect(
    LPCRECT lpRect,
    POINT point);
```

### <a name="parameters"></a>參數

*x1*<br/>
指定矩形左上角的 x 座標（以邏輯單位表示）。

*y1*<br/>
指定矩形左上角的 y 座標（以邏輯單位表示）。

*x2*<br/>
指定矩形右下角的 x 座標（以邏輯單位表示）。

*y2*<br/>
指定矩形右下角的 y 座標（以邏輯單位表示）。

*x3*<br/>
指定用來繪製圓角之橢圓形的寬度（以邏輯單位表示）。

*y3*<br/>
指定用來繪製圓角的橢圓形高度（以邏輯單位表示）。

*lpRect*<br/>
指定邏輯單元中的周框。 您可以將 `CRect` 物件或指標傳遞給 `RECT` 這個參數的結構。

*此處*<br/>
*Point*的 x 座標會指定用來繪製圓角之橢圓形的寬度（以邏輯單位表示）。 *Point*的 y 座標會指定用來繪製圓角的橢圓形高度（以邏輯單位表示）。 您可以傳遞 `POINT` 此參數的結構或 `CPoint` 物件。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

矩形的內部會使用目前的筆刷來填滿。

此函式所繪製的圖表會延伸至，但不包含右和下座標。 這表示圖形的高度是*y2*  -  *y1* ，而圖的寬度是*x2*  -  *x1*。 周框的高度和寬度都必須大於2個單位且小於32767個單位。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCDocView#40](../../mfc/codesnippet/cpp/cdc-class_12.cpp)]

## <a name="cdcsavedc"></a><a name="savedc"></a>CDC：： SaveDC

藉由將狀態資訊（例如裁剪區域、選取的物件和對應模式）複製到 Windows 維護的內容堆疊，來儲存裝置內容的目前狀態。

```
virtual int SaveDC();
```

### <a name="return-value"></a>傳回值

識別已儲存裝置內容的整數。 如果發生錯誤，則為0。 這個傳回值可以藉由呼叫來用來還原裝置內容 `RestoreDC` 。

### <a name="remarks"></a>備註

您稍後可以使用來還原已儲存的裝置內容 `RestoreDC` 。

`SaveDC`可以使用任意數目的次數來儲存任意數目的裝置內容狀態。

## <a name="cdcscaleviewportext"></a><a name="scaleviewportext"></a>CDC：： ScaleViewportExt

修改相對於目前值的資料區範圍。

```
virtual CSize ScaleViewportExt(
    int xNum,
    int xDenom,
    int yNum,
    int yDenom);
```

### <a name="parameters"></a>參數

*xNum*<br/>
指定要乘以目前 x 範圍的數量。

*xDenom*<br/>
指定用來將目前 x 範圍乘以*xNum*參數值的結果除以的量。

*yNum*<br/>
指定目前 y 範圍乘以的數量。

*yDenom*<br/>
指定將目前 y 範圍乘以*yNum*參數值時，要除以的結果量。

### <a name="return-value"></a>傳回值

先前的視口範圍（以裝置單位）做為 `CSize` 物件。

### <a name="remarks"></a>備註

公式的撰寫方式如下：

`xNewVE = ( xOldVE * xNum ) / xDenom`

`yNewVE = ( yOldVE * yNum ) / yDenom`

新的視口範圍的計算方式是將目前的範圍乘以指定的分子，然後再除以指定的分母。

## <a name="cdcscalewindowext"></a><a name="scalewindowext"></a>CDC：： ScaleWindowExt

修改相對於目前值的視窗範圍。

```
virtual CSize ScaleWindowExt(
    int xNum,
    int xDenom,
    int yNum,
    int yDenom);
```

### <a name="parameters"></a>參數

*xNum*<br/>
指定要乘以目前 x 範圍的數量。

*xDenom*<br/>
指定用來將目前 x 範圍乘以*xNum*參數值的結果除以的量。

*yNum*<br/>
指定目前 y 範圍乘以的數量。

*yDenom*<br/>
指定將目前 y 範圍乘以*yNum*參數值時，要除以的結果量。

### <a name="return-value"></a>傳回值

先前的視窗範圍（以邏輯單位表示）， `CSize` 表示為物件。

### <a name="remarks"></a>備註

公式的撰寫方式如下：

`xNewWE = ( xOldWE * xNum ) / xDenom`

`yNewWE = ( yOldWE * yNum ) / yDenom`

新視窗範圍的計算方式是將目前的範圍乘以指定的分子，然後再除以指定的分母。

## <a name="cdcscrolldc"></a><a name="scrolldc"></a>CDC：： ScrollDC

水準和垂直捲動位的矩形。

```
BOOL ScrollDC(
    int dx,
    int dy,
    LPCRECT lpRectScroll,
    LPCRECT lpRectClip,
    CRgn* pRgnUpdate,
    LPRECT lpRectUpdate);
```

### <a name="parameters"></a>參數

*dx*<br/>
指定水準滾動單位的數目。

*dy*<br/>
指定垂直捲動單位的數目。

*lpRectScroll*<br/>
指向 `RECT` `CRect` 包含捲軸矩形座標的結構或物件。

*lpRectClip*<br/>
指向 `RECT` `CRect` 包含裁剪矩形座標的結構或物件。 當這個矩形小於*lpRectScroll*所指向的原始矩形時，只會在較小的矩形中進行滾動。

*pRgnUpdate*<br/>
識別滾動進程所發現的區域。 函式 `ScrollDC` 會定義此區域，而不一定是矩形。

*lpRectUpdate*<br/>
指向 `RECT` 結構或 `CRect` 物件，其會接收範圍為滾動更新區域之矩形的座標。 這是需要重新繪製的最大矩形區域。 當函式傳回時，結構或物件中的值會在用戶端座標中，而不論指定裝置內容的對應模式為何。

### <a name="return-value"></a>傳回值

如果執行滾動，則為非零值;否則為0。

### <a name="remarks"></a>備註

如果*lpRectUpdate*為 Null，Windows 就不會計算更新矩形。 如果*pRgnUpdate*和*LPRECTUPDATE*都是 Null，Windows 就不會計算更新區域。 如果*pRgnUpdate*不是 Null，Windows 會假設它包含滾動進程（由成員函式定義）所發現之區域的有效指標 `ScrollDC` 。 如有需要，您可以將*lpRectUpdate*中傳回的更新區域傳遞至 `CWnd::InvalidateRgn` 。

`ScrollWindow` `CWnd` 當需要滾動視窗的整個工作區時，應用程式應該使用類別的成員函式。 否則，應該使用 `ScrollDC` 。

## <a name="cdcselectclippath"></a><a name="selectclippath"></a>CDC：： SelectClipPath

選取目前的路徑做為裝置內容的裁剪區域，並使用指定的模式結合新區域與任何現有的裁剪區域。

```
BOOL SelectClipPath(int nMode);
```

### <a name="parameters"></a>參數

*nMode*<br/>
指定路徑的使用方式。 允許下列值：

- RGN_AND 新的裁剪區域包含目前裁剪區域和目前路徑的交集（重迭的區域）。

- RGN_COPY 新的裁剪區域是目前的路徑。

- RGN_DIFF 新的裁剪區域包含目前裁剪區域的區域，而且會排除目前路徑的區域。

- RGN_OR 新的裁剪區域包含目前裁剪區域的聯集（結合的區域）和目前的路徑。

- RGN_XOR 新的裁剪區域包含目前裁剪區域和目前路徑的聯集，但沒有重迭的區域。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

識別的裝置內容必須包含關閉的路徑。

## <a name="cdcselectcliprgn"></a><a name="selectcliprgn"></a>CDC：： SelectClipRgn

選取指定的區域作為裝置內容的目前裁剪區域。

```
int SelectClipRgn(CRgn* pRgn);

int SelectClipRgn(
    CRgn* pRgn,
    int nMode);
```

### <a name="parameters"></a>參數

*pRgn*<br/>
識別要選取的區域。

- 針對此函式的第一個版本，如果此值為 Null，則會選取整個工作區，而且輸出仍然會裁剪到視窗。

- 針對此函式的第二個版本，只有在指定 RGN_COPY 模式時，此控制碼才可以是 Null。

*nMode*<br/>
指定要執行的作業。 它必須是下列其中一個值：

- RGN_AND 新的裁剪區域會結合目前裁剪區域的重迭區域，以及*pRgn*所識別的區域。

- RGN_COPY 新的裁剪區域是*pRgn*所識別的區域複本。 這項功能與的第一個版本相同 `SelectClipRgn` 。 如果*pRgn*所識別的區域是 Null，新的裁剪區域就會變成預設的裁剪區域（null 區域）。

- RGN_DIFF 新的裁剪區域會將目前裁剪區域的區域與從*pRgn*所識別之區域中排除的區域結合。

- RGN_OR 新的裁剪區域會結合目前的裁剪區域和*pRgn*所識別的區域。

- RGN_XOR 新的裁剪區域會結合目前的裁剪區域和*pRgn*所識別的區域，但不包括任何重迭的區域。

### <a name="return-value"></a>傳回值

區域的類型。 可以是下列其中任何一個值：

- COMPLEXREGION 新的裁剪區域具有重迭的框線。

- 錯誤裝置內容或區域無效。

- NullREGION 新的裁剪區域是空的。

- SIMPLEREGION 新的裁剪區域沒有重迭的框線。

### <a name="remarks"></a>備註

只會使用所選區域的複本。 您可以為任何數目的其他裝置內容選取區域本身，也可以加以刪除。

函式會假設給定區域的座標是以裝置單位來指定。 某些印表機裝置支援比圖形輸出更高解析度的文字輸出，以保留表達文字度量所需的精確度。 這些裝置會以較高的解析度（也就是文字單位）來報告裝置單位。 這些裝置接著會調整圖形的座標，讓數個回報的裝置單位只對應至1個圖形單位。 您應該一律 `SelectClipRgn` 使用文字單位來呼叫函數。

必須在 GDI 中進行繪圖物件縮放的應用程式可以使用 GETSCALINGFACTOR 印表機 escape 來判斷縮放比例。 這個調整因數會影響裁剪。 如果使用區域來裁剪圖形，GDI 會將座標除以縮放比例。 如果區域是用來裁剪文字，GDI 就不會調整規模。 縮放比例1會使座標除以 2;縮放比例2會使座標除以 4;以此類推。

## <a name="cdcselectobject"></a><a name="selectobject"></a>CDC：： SelectObject

在裝置內容中選取物件。

```
CPen* SelectObject(CPen* pPen);
CBrush* SelectObject(CBrush* pBrush);
virtual CFont* SelectObject(CFont* pFont);
CBitmap* SelectObject(CBitmap* pBitmap);
int SelectObject(CRgn* pRgn);
CGdiObject* SelectObject(CGdiObject* pObject);
```

### <a name="parameters"></a>參數

*pPen*<br/>
要選取之[CPen](../../mfc/reference/cpen-class.md)物件的指標。

*pBrush*<br/>
要選取之[CBrush](../../mfc/reference/cbrush-class.md)物件的指標。

*pFont*<br/>
要選取之[CFont](../../mfc/reference/cfont-class.md)物件的指標。

*pBitmap*<br/>
要選取之[CBitmap](../../mfc/reference/cbitmap-class.md)物件的指標。

*pRgn*<br/>
要選取之[CRgn](../../mfc/reference/crgn-class.md)物件的指標。

*pObject*<br/>
要選取之[CGdiObject](../../mfc/reference/cgdiobject-class.md)物件的指標。

### <a name="return-value"></a>傳回值

要被取代之物件的指標。 這是衍生自的其中一個類別之物件的指標 `CGdiObject` ，例如，視使用的函式版本而定 `CPen` 。 如果發生錯誤，則傳回值為 Null。 此函式可能會傳回暫存物件的指標。 這個暫存物件只在處理一個 Windows 訊息期間有效。 如需詳細資訊，請參閱 `CGdiObject::FromHandle`。

採用區域參數的成員函式版本，會與成員函式執行相同的工作 `SelectClipRgn` 。 其傳回值可以是下列任何一項：

- COMPLEXREGION 新的裁剪區域具有重迭的框線。

- 錯誤裝置內容或區域無效。

- NullREGION 新的裁剪區域是空的。

- SIMPLEREGION 新的裁剪區域沒有重迭的框線。

### <a name="remarks"></a>備註

類別 `CDC` 針對特定類型的 GDI 物件（包括畫筆、筆刷、字型、點陣圖和區域）提供五個特殊化的版本。 新選取的物件會取代相同類型的前一個物件。 例如，如果將的一般版本*pObject*指向 `SelectObject` [CPen](../../mfc/reference/cpen-class.md)物件，則函式會以*pObject*所指定的畫筆取代目前的畫筆。

應用程式只能在記憶體裝置內容中選取一個點陣圖，並一次只在一個記憶體裝置內容中。 點陣圖的格式必須是單色，或與裝置內容相容;如果不是，則會傳回 `SelectObject` 錯誤。

對於 Windows 3.1 和更新版本，函式 `SelectObject` 會傳回相同的值，不論它是否用於中繼檔中。 在舊版的 Windows 下， `SelectObject` 會傳回非零值表示成功，而0表示在中繼檔中使用時失敗。

## <a name="cdcselectpalette"></a><a name="selectpalette"></a>CDC：： SelectPalette

選取*pPalette*所指定的邏輯調色板，做為裝置內容的選定 [調色板] 物件。

```
CPalette* SelectPalette(
    CPalette* pPalette,
    BOOL bForceBackground);
```

### <a name="parameters"></a>參數

*pPalette*<br/>
識別要選取的邏輯調色板。 這個調色板必須已經使用成員函式 `CPalette` [CreatePalette](../../mfc/reference/cpalette-class.md#createpalette)來建立。

*bForceBackground*<br/>
指定是否強制將邏輯調色板做為背景調色板。 如果*bForceBackground*為非零值，則不論視窗是否有輸入焦點，選取的調色板一律是背景調色板。 如果*bForceBackground*為0，且裝置內容附加至視窗，則當視窗具有輸入焦點時，邏輯調色板會是前景調色板。

### <a name="return-value"></a>傳回值

物件的指標， `CPalette` 識別邏輯調色板已由*pPalette*所指定的調色板所取代。 如果發生錯誤，則為 Null。

### <a name="remarks"></a>備註

新的調色板會變成 GDI 使用的調色板物件，以控制顯示在裝置內容中的色彩，並取代上一個調色板。

應用程式可以在一個以上的裝置內容中選取一個邏輯調色板。 不過，對邏輯元件區所做的變更會影響所選取的所有裝置內容。 如果應用程式選取一個色板到一個以上的裝置內容，則裝置內容必須全部屬於相同的實體裝置。

## <a name="cdcselectstockobject"></a><a name="selectstockobject"></a>CDC：： SelectStockObject

選取對應至其中一個預先定義之股價、筆刷或字型的[CGdiObject](../../mfc/reference/cgdiobject-class.md)物件。

```
virtual CGdiObject* SelectStockObject(int nIndex);
```

### <a name="parameters"></a>參數

*nIndex*<br/>
指定所需的股票物件種類。 它可能是下列其中一個值：

- BLACK_BRUSH 黑色筆刷。

- DKGRAY_BRUSH 深色灰色筆刷。

- GRAY_BRUSH 灰色筆刷。

- HOLLOW_BRUSH 空心筆刷。

- LTGRAY_BRUSH 淺灰色筆刷。

- Null_BRUSH Null 筆刷。

- WHITE_BRUSH 白色筆刷。

- BLACK_PEN 黑色畫筆。

- Null_PEN Null 畫筆。

- WHITE_PEN 的白色畫筆。

- ANSI_FIXED_FONT ANSI 固定系統字型。

- ANSI_VAR_FONT ANSI 變數系統字型。

- DEVICE_DEFAULT_FONT 與裝置相關的字型。

- OEM_FIXED_FONT OEM 相依的固定字型。

- SYSTEM_FONT 系統字型。 根據預設，Windows 會使用系統字型來繪製功能表、對話方塊控制項和其他文字。 不過，最好不要依賴 SYSTEM_FONT 來取得對話方塊和視窗所使用的字型。 相反地，請使用函式搭配 `SystemParametersInfo` SPI_GETNONCLIENTMETRICS 參數，以取得目前的字型。 `SystemParametersInfo`將目前的主題納入考慮，並提供標題、功能表和訊息對話的字型資訊。

- 在3.0 版之前，SYSTEM_FIXED_FONT Windows 中使用的固定寬度系統字型。 此物件可用於與舊版 Windows 的相容性。

- DEFAULT_PALETTE 預設色調色板。 此色板是由系統元件中的20個靜態色彩所組成。

### <a name="return-value"></a>傳回值

如果函式成功，則為 `CGdiObject` 已取代之物件的指標。 所指向的實際物件是[CPen](../../mfc/reference/cpen-class.md)、 [CBrush](../../mfc/reference/cbrush-class.md)或[CFont](../../mfc/reference/cfont-class.md)物件。 如果呼叫不成功，則傳回值為 Null。

## <a name="cdcsetabortproc"></a><a name="setabortproc"></a>CDC：： SetAbortProc

安裝列印工作的中止程式。

```
int SetAbortProc(BOOL (CALLBACK* lpfn)(HDC, int));
```

### <a name="parameters"></a>參數

*lpfn*<br/>
要安裝為中止程式之 abort 函式的指標。 如需回呼函數的詳細資訊，請參閱[CDC：： SetAbortProc 的回呼函數](callback-functions-used-by-mfc.md#setabortproc)。

### <a name="return-value"></a>傳回值

指定函數的結果 `SetAbortProc` 。 下列幾個值比其他值更可能，但全部都是可行的。

- SP_ERROR 一般錯誤。

- 目前沒有足夠的磁碟空間可用來進行多工緩衝處理，而且沒有其他空間可以使用。 SP_OUTOFDISK

- SP_OUTOFMEMORY 沒有足夠的記憶體可用於進行多工緩衝處理。

- SP_USERABORT 使用者已透過「列印管理員」結束作業。

### <a name="remarks"></a>備註

如果應用程式允許在進行幕後處理時取消列印工作，它必須先設定 abort 函式，才能使用[StartDoc](#startdoc)成員函式來啟動列印工作。 列印管理員會在幕後處理期間呼叫 abort 函式，以允許應用程式取消列印工作或處理磁碟空間不足的狀況。 如果未設定 abort 函式，列印工作將會失敗，因為沒有足夠的磁碟空間可進行多工緩衝處理。

請注意，Microsoft Visual C++ 的功能會簡化傳遞至之回呼函式的建立 `SetAbortProc` 。 傳遞至成員函式的位址 `EnumObjects` 是使用 `__declspec(dllexport)` 和呼叫慣例所匯出之函式的指標 **`__stdcall`** 。

您也不需要在應用程式的模組定義檔中**匯出 export 語句中**的函數名稱。 您可以改用**EXPORT**函數修飾詞，如下所示：

`BOOL CALLBACK EXPORT AFunction( HDC, int );`

讓編譯器以名稱發出適當的匯出記錄，而不需要加上別名。 這適用于大部分的需求。 在某些特殊情況下（例如，依序數匯出函式或將匯出設為別名），您仍然需要在模組定義檔中使用**export 語句。**

回呼登錄介面現在是型別安全的（您必須傳入函式指標，指向特定回呼的正確函式類型）。

另請注意，在回到 Windows 之前，所有回呼函式都必須先將 Microsoft Foundation 例外狀況設陷，因為例外狀況無法跨回呼界限擲回。 如需例外狀況的詳細資訊，請參閱[例外](../../mfc/exception-handling-in-mfc.md)狀況一文。

## <a name="cdcsetarcdirection"></a><a name="setarcdirection"></a>CDC：： SetArcDirection

設定要用於弧線和矩形函數的繪製方向。

```
int SetArcDirection(int nArcDirection);
```

### <a name="parameters"></a>參數

*nArcDirection*<br/>
指定新的弧線方向。 這個參數可以是下列其中一個值：

- 以逆時針繪製 AD_COUNTERCLOCKWISE 的圖表。

- 以順時針方向繪製 AD_CLOCKWISE 圖形。

### <a name="return-value"></a>傳回值

如果成功，則指定舊的 arc 方向;否則為0。

### <a name="remarks"></a>備註

預設方向為 [逆時針]。 函式會 `SetArcDirection` 指定下列函數繪製的方向：

|Arc|Pie|
|---------|---------|
|`ArcTo`|`Rectangle`|
|`Chord`|`RoundRect`|
|`Ellipse`||

## <a name="cdcsetattribdc"></a><a name="setattribdc"></a>CDC：： SetAttribDC

呼叫此函式可設定屬性裝置內容 `m_hAttribDC` 。

```
virtual void SetAttribDC(HDC hDC);
```

### <a name="parameters"></a>參數

*hDC*<br/>
Windows 裝置內容。

### <a name="remarks"></a>備註

此成員函式不會將裝置內容附加至 `CDC` 物件。 只有輸出裝置內容會附加至 `CDC` 物件。

## <a name="cdcsetbkcolor"></a><a name="setbkcolor"></a>CDC：： SetBkColor

將目前的背景色彩設定為指定的色彩。

```
virtual COLORREF SetBkColor(COLORREF crColor);
```

### <a name="parameters"></a>參數

*crColor*<br/>
指定新的背景色彩。

### <a name="return-value"></a>傳回值

先前的背景色彩，這是 RGB 色彩值。 如果發生錯誤，則傳回值為0x80000000。

### <a name="remarks"></a>備註

如果背景模式不透明，系統會使用背景色彩來填滿樣式線條中的間距、筆刷中的影線線之間的間距，以及字元儲存格中的背景。 當您在色彩和單色裝置內容之間轉換點陣圖時，系統也會使用背景色彩。

如果裝置無法顯示指定的色彩，系統會將背景色彩設定為最接近的實體色彩。

## <a name="cdcsetbkmode"></a><a name="setbkmode"></a>CDC：： SetBkMode

設定背景模式。

```
int SetBkMode(int nBkMode);
```

### <a name="parameters"></a>參數

*nBkMode*<br/>
指定要設定的模式。 這個參數可以是下列其中一個值：

- 不透明背景會在繪製文字、影線筆刷或畫筆之前，以目前的背景色彩填滿。 這是預設的背景模式。

- 在繪製之前，透明背景不會變更。

### <a name="return-value"></a>傳回值

先前的背景模式。

### <a name="remarks"></a>備註

背景模式定義系統是否在繪製文字、陰影筆刷或任何非實線的畫筆樣式之前，先移除繪圖介面上的現有背景色彩。

### <a name="example"></a>範例

  請參閱[CWnd：： OnCtlColor](../../mfc/reference/cwnd-class.md#onctlcolor)的範例。

## <a name="cdcsetboundsrect"></a><a name="setboundsrect"></a>CDC：： SetBoundsRect

控制指定裝置內容的周框矩形資訊累計。

```
UINT SetBoundsRect(
    LPCRECT lpRectBounds,
    UINT flags);
```

### <a name="parameters"></a>參數

*lpRectBounds*<br/>
指向 `RECT` `CRect` 用來設定周框的結構或物件。 矩形維度會以邏輯座標提供。 這個參數可以是 Null。

*flags*<br/>
指定如何將新的矩形與累積的矩形結合。 這個參數可以是下列值的組合：

- DCB_ACCUMULATE 將*lpRectBounds*所指定的矩形加入至周框（使用矩形聯集運算）。

- DCB_DISABLE 關閉界限累積。

- DCB_ENABLE 開啟界限累積。 （已停用界限累積的預設設定）。

### <a name="return-value"></a>傳回值

周框的目前狀態（如果函數成功）。 如同*旗標*，傳回值可以是**DCB_** 值的組合：

- DCB_ACCUMULATE 周框不是空的。 一律會設定這個值。

- DCB_DISABLE 界限累積已關閉。

- DCB_ENABLE 界限累積已開啟。

### <a name="remarks"></a>備註

Windows 可以維護所有繪圖作業的周框。 應用程式可以查詢和重設這個矩形。 繪製界限適用于讓點陣圖快取失效。

## <a name="cdcsetbrushorg"></a><a name="setbrushorg"></a>CDC：： SetBrushOrg

指定 GDI 將指派給應用程式選取到裝置內容中下一個筆刷的來源。

```
CPoint SetBrushOrg(
    int x,
    int y);

CPoint SetBrushOrg(POINT point);
```

### <a name="parameters"></a>參數

*x*<br/>
指定新來源的 x 座標（以裝置為單位）。 這個值必須在0-7 的範圍內。

*y*<br/>
指定新原點的 y 座標（以裝置為單位）。 這個值必須在0-7 的範圍內。

*此處*<br/>
指定新來源的 x 和 y 座標。 每個值都必須在0-7 的範圍內。 您可以傳遞 `POINT` 此參數的結構或 `CPoint` 物件。

### <a name="return-value"></a>傳回值

筆刷在裝置單位中的上一個原點。

### <a name="remarks"></a>備註

筆刷來源的預設座標為（0，0）。 若要改變筆刷的原點，請呼叫物件的函式 `UnrealizeObject` `CBrush` ，呼叫 `SetBrushOrg` ，然後呼叫成員函式， `SelectObject` 以選取筆刷到裝置內容中。

請勿使用 `SetBrushOrg` with stock `CBrush` 物件。

## <a name="cdcsetcoloradjustment"></a><a name="setcoloradjustment"></a>CDC：： SetColorAdjustment

使用指定的值，設定裝置內容的色彩調整值。

```
BOOL SetColorAdjustment(const COLORADJUSTMENT* lpColorAdjust);
```

### <a name="parameters"></a>參數

*lpColorAdjust*<br/>
指向包含色彩調整值的[COLORADJUSTMENT](/windows/win32/api/wingdi/ns-wingdi-coloradjustment)資料結構。

### <a name="return-value"></a>傳回值

如果成功則為非零；否則為 0。

### <a name="remarks"></a>備註

`CDC::StretchBlt`當設定半色調模式時，會使用色彩調整值來調整來源點陣圖的輸入色彩，以進行成員函式的呼叫。

## <a name="cdcsetdcbrushcolor"></a><a name="setdcbrushcolor"></a>CDC：： SetDCBrushColor

將目前的裝置內容（DC）筆刷色彩設定為指定的色彩值。

```
COLORREF SetDCBrushColor(COLORREF crColor);
```

### <a name="parameters"></a>參數

*crColor*<br/>
指定新的筆刷色彩。

### <a name="return-value"></a>傳回值

如果函式成功，則傳回值會將先前的 DC 筆刷色彩指定為 COLORRE光圈值。

如果函式失敗，則傳回值是 CLR_INVALID。

### <a name="remarks"></a>備註

這個方法會模擬函數[SetDCBrushColor](/windows/win32/api/wingdi/nf-wingdi-setdcbrushcolor)的功能，如 Windows SDK 中所述。

## <a name="cdcsetdcpencolor"></a><a name="setdcpencolor"></a>CDC：： SetDCPenColor

將目前的裝置內容（DC）畫筆色彩設為指定的色彩值。

```
COLORREF SetDCPenColor(COLORREF crColor);
```

### <a name="parameters"></a>參數

*crColor*<br/>
指定新的畫筆色彩。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

此成員函式會利用 Win32 函數[SetDCPenColor](/windows/win32/api/wingdi/nf-wingdi-setdcpencolor)，如 Windows SDK 中所述。

## <a name="cdcsetgraphicsmode"></a><a name="setgraphicsmode"></a>CDC：： SetGraphicsMode

設定指定裝置內容的圖形模式。

```
int SetGraphicsMode(int iMode);
```

### <a name="parameters"></a>參數

*iMode*<br/>
指定圖形模式。 如需此參數可接受的值清單，請參閱[SetGraphicsMode](/windows/win32/api/wingdi/nf-wingdi-setgraphicsmode)。

### <a name="return-value"></a>傳回值

傳回成功時的舊圖形模式。

失敗時傳回0。 若要取得延伸錯誤資訊，請呼叫[GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror)。

### <a name="remarks"></a>備註

這個方法會包裝 Windows GDI 函數[SetGraphicsMode](/windows/win32/api/wingdi/nf-wingdi-setgraphicsmode)。

## <a name="cdcsetlayout"></a><a name="setlayout"></a>CDC：： SetLayout

呼叫此成員函式，將裝置內容的文字和圖形版面配置變更為從右至左，文化特性（例如阿拉伯文和希伯來文）的標準版面配置。

```
DWORD SetLayout(DWORD dwLayout);
```

### <a name="parameters"></a>參數

*dwLayout*<br/>
裝置內容版面配置和點陣圖控制旗標。 它可以是下列值的組合。

|值|意義|
|-----------|-------------|
|LAYOUT_BITMAPORIENTATIONPRESERVED|針對[cdc：： BitBlt](#bitblt)和[Cdc：： StretchBlt](#stretchblt)的呼叫停用任何反映。|
|LAYOUT_RTL|將預設水準配置設定為從右至左。|
|LAYOUT_LTR|將預設版面配置設定為由左至右。|

### <a name="return-value"></a>傳回值

如果成功，則為裝置內容的先前配置。

如果失敗，請 GDI_ERROR。 若要取得延伸錯誤資訊，請呼叫[GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror)。

### <a name="remarks"></a>備註

一般來說，您不會對 `SetLayout` 視窗呼叫。 相反地，您可以藉由設定[擴充視窗樣式](../../mfc/reference/styles-used-by-mfc.md#extended-window-styles)（例如 WS_EX_RTLREADING），在視窗中控制由右至左的版面配置。 裝置內容（例如印表機或中繼檔）不會繼承此版面配置。 若要設定由右至左配置的裝置內容，唯一的方法是呼叫 `SetLayout` 。

如果您呼叫**SetLayout （LAYOUT_RTL** ）， `SetLayout` 會自動將對應模式變更為 MM_ISOTROPIC。 因此，後續對[GetMapMode](#getmapmode)的呼叫將會傳回 MM_ISOTROPIC，而不是 MM_TEXT。

在某些情況下（例如有許多點陣圖），您可能會想要保留由左至右的版面配置。 在這些情況下，藉由呼叫或來轉譯影像 `BitBlt` `StretchBlt` ，然後將*dwLayout*的點陣圖控制旗標設定為 LAYOUT_BITMAPORIENTATIONPRESERVED。

當您使用 LAYOUT_RTL 旗標變更版面配置之後，通常會反轉指定 right 或 left 的旗標。 為了避免混淆，您可能會想要定義標準旗標的替代名稱。 如需建議的替代旗標名稱清單，請參閱 Windows SDK 中的[SetLayout](/windows/win32/api/wingdi/nf-wingdi-setlayout) 。

## <a name="cdcsetmapmode"></a><a name="setmapmode"></a>CDC：： SetMapMode

設定對應模式。

```
virtual int SetMapMode(int nMapMode);
```

### <a name="parameters"></a>參數

*nMapMode*<br/>
指定新的對應模式。 它可以是下列任何一個值：

- MM_ANISOTROPIC 的邏輯單元會以任意縮放的軸轉換成任意單位。 將對應模式設定為 MM_ANISOTROPIC 並不會變更目前的視窗或視口設定。 若要變更單位、方向和縮放比例，請呼叫[SetWindowExt](#setwindowext)和[SetViewportExt](#setviewportext)成員函式。

- MM_HIENGLISH 每個邏輯單元都會轉換成0.001 英寸。 正向右 x，正 y 已啟動。

- MM_HIMETRIC 每個邏輯單元都會轉換成0.01 毫米。 正向右 x，正 y 已啟動。

- MM_ISOTROPIC 的邏輯單元會轉換成具有同樣縮放軸的任意單位;也就是說，沿著 X 軸的1個單位會沿著 y 軸與1個單位相等。 使用 `SetWindowExt` 和成員函式 `SetViewportExt` 來指定所需的單位和軸的方向。 GDI 會視需要進行調整，以確保 x 和 y 單位的大小維持不變。

- MM_LOENGLISH 每個邏輯單元都會轉換成0.01 英寸。 正向右 x，正 y 已啟動。

- MM_LOMETRIC 每個邏輯單元都會轉換成0.1 毫米。 正向右 x，正 y 已啟動。

- MM_TEXT 每個邏輯單元都會轉換成1個裝置圖元。 正向右 x，正 y 已關閉。

- MM_TWIPS 每個邏輯單元都會轉換成點1/20。 （因為點是1/72 英寸，所以 twip 是1/1440 英寸）。正向右 x，正 y 已啟動。

### <a name="return-value"></a>傳回值

先前的對應模式。

### <a name="remarks"></a>備註

對應模式會定義用來將邏輯單元轉換成裝置單位的測量單位;它也會定義裝置的 x 和 y 軸方向。 GDI 使用對應模式，將邏輯座標轉換為適當的裝置座標。 MM_TEXT 模式可讓應用程式以裝置圖元來工作，其中1個單位等於1個圖元。 圖元的實體大小會因裝置而異。

[MM_HIENGLISH]、[MM_HIMETRIC]、[MM_LOENGLISH]、[MM_LOMETRIC] 和 [MM_TWIPS] 模式對於必須以實際意義的單位（例如，英寸或毫米）繪製的應用程式很有用。 [MM_ISOTROPIC] 模式可確保1:1 外觀比例，這在保留影像的確切形狀時非常有用。 MM_ANISOTROPIC 模式可讓 x 和 y 座標獨立調整。

> [!NOTE]
> 如果您呼叫[SetLayout](#setlayout)來將 DC （裝置內容）變更為由右至左配置，則 `SetLayout` 會自動將對應模式變更為 MM_ISOTROPIC。

### <a name="example"></a>範例

  請參閱[CView：： OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc)的範例。

## <a name="cdcsetmapperflags"></a><a name="setmapperflags"></a>CDC：： SetMapperFlags

變更字型對應工具將邏輯字型轉換成實體字型時所使用的方法。

```
DWORD SetMapperFlags(DWORD dwFlag);
```

### <a name="parameters"></a>參數

*dwFlag*<br/>
指定字型對應程式是否嘗試比對字型的外觀高度和寬度與裝置。 當此值 ASPECT_FILTERING 時，對應工具只會選取其 x 外觀和 y 外觀的字型，完全符合指定裝置的字型。

### <a name="return-value"></a>傳回值

字型對應工具旗標的先前值。

### <a name="remarks"></a>備註

應用程式可以使用 `SetMapperFlags` 使字型對應工具嘗試只選擇完全符合所指定裝置外觀比例的實體字型。

只使用點陣字型的應用程式可以使用函式， `SetMapperFlags` 確保字體對應工具選取的字型在指定的裝置上具有吸引力和可讀性。 使用可調整（TrueType）字型的應用程式通常不會使用 `SetMapperFlags` 。

如果沒有實體字型的外觀比例符合邏輯字型中的規格，GDI 會選擇新的外觀比例，並選取符合這個新外觀比例的字型。

## <a name="cdcsetmiterlimit"></a><a name="setmiterlimit"></a>CDC：： SetMiterLimit

設定裝置內容的斜切聯結長度限制。

```
BOOL SetMiterLimit(float fMiterLimit);
```

### <a name="parameters"></a>參數

*fMiterLimit*<br/>
指定裝置內容的新斜接限制。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

「斜接」長度定義為從聯結內部之線條牆的交集到聯結外之線條牆交集的距離。 斜接限制是將斜接長度的最大允許比率設為線條寬度。 預設的斜接限制為10.0。

## <a name="cdcsetoutputdc"></a><a name="setoutputdc"></a>CDC：： SetOutputDC

呼叫此成員函式以設定輸出裝置內容 `m_hDC` 。

```
virtual void SetOutputDC(HDC hDC);
```

### <a name="parameters"></a>參數

*hDC*<br/>
Windows 裝置內容。

### <a name="remarks"></a>備註

只有在尚未將裝置內容附加至物件時，才能呼叫此成員函式 `CDC` 。 此成員函式 `m_hDC` 會設定，但不會將裝置內容附加至 `CDC` 物件。

## <a name="cdcsetpixel"></a><a name="setpixel"></a>CDC：： Bitmap.setpixel

將指定的點上的圖元設定為*crColor*所指定的最接近色彩近似值。

```
COLORREF SetPixel(
    int x,
    int y,
    COLORREF crColor);

COLORREF SetPixel(
    POINT point,
    COLORREF crColor);
```

### <a name="parameters"></a>參數

*x*<br/>
指定要設定之點的邏輯 x 座標。

*y*<br/>
指定要設定之點的邏輯 y 座標。

*crColor*<br/>
COLORREF RGB 值，指定用來繪製點的色彩。 如需此值的說明，請參閱 Windows SDK 中的[COLORREF](/windows/win32/gdi/colorref) 。

*此處*<br/>
指定要設定之點的邏輯 x 和 y 座標。 您可以傳遞 `POINT` 此參數的結構或 `CPoint` 物件。

### <a name="return-value"></a>傳回值

實際繪製點之色彩的 RGB 值。 如果使用了該色彩的近似值，這個值可能會與*crColor*所指定的不同。 如果函式失敗（如果點位於裁剪區域外），則傳回值為-1。

### <a name="remarks"></a>備註

點必須在裁剪區域中。 如果點不在裁剪區域中，則函式不會執行任何工作。

並非所有的裝置皆支援 `SetPixel` 函式。 若要判斷裝置是否支援 `SetPixel` ，請呼叫 `GetDeviceCaps` 具有 RASTERCAPS 索引的成員函式，並檢查 RC_BITBLT 旗標的傳回值。

## <a name="cdcsetpixelv"></a><a name="setpixelv"></a>CDC：： SetPixelV

將指定座標處的圖元設定為最接近指定之色彩的近似值。

```
BOOL SetPixelV(
    int x,
    int y,
    COLORREF crColor);

BOOL SetPixelV(
    POINT point,
    COLORREF crColor);
```

### <a name="parameters"></a>參數

*x*<br/>
指定要設定之點的 x 座標（以邏輯單位表示）。

*y*<br/>
指定要設定之點的 y 座標（以邏輯單位表示）。

*crColor*<br/>
指定要用來繪製點的色彩。

*此處*<br/>
指定要設定之點的邏輯 x 和 y 座標。 您可以針對這個參數傳遞[POINT](/windows/win32/api/windef/ns-windef-point)資料結構或[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)物件。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

點必須同時位於裁剪區域和裝置介面的可見部分。 並非所有裝置都支援成員函式。 如需詳細資訊，請參閱成員函式中的 RC_BITBLT 功能 `CDC::GetDeviceCaps` 。 `SetPixelV`的速度較快， `SetPixel` 因為它不需要傳回實際繪製之點的色彩值。

## <a name="cdcsetpolyfillmode"></a><a name="setpolyfillmode"></a>CDC：： SetPolyFillMode

設定多邊形填滿模式。

```
int SetPolyFillMode(int nPolyFillMode);
```

### <a name="parameters"></a>參數

*nPolyFillMode*<br/>
指定新的填滿模式。 此值可以是 [替代] 或 [纏繞]。 Windows 中設定的預設模式是 [替代]。

### <a name="return-value"></a>傳回值

先前的填滿模式（如果成功）;否則為0。

### <a name="remarks"></a>備註

當多邊形填滿模式為 [替代] 時，系統會在每個掃描線上的奇數和偶數多邊形邊填滿區域。 也就是說，系統會填滿第一個和第二端之間、第三和第四端之間的區域，依此類推。 此為預設模式。

當多邊形填滿模式是纏繞時，系統會使用繪製圖形的方向來判斷是否要填滿區域。 多邊形中的每個直線線段都會以順時針或逆時針方向繪製。 每當從封閉區域繪製到圖形外的虛數直線通過順時針線段時，就會遞增計數。 當線條通過逆時針線段時，計數就會遞減。 當線條到達圖表的外部時，如果計數為非零值，則會填滿區域。

## <a name="cdcsetrop2"></a><a name="setrop2"></a>CDC：： SetROP2

設定目前的繪圖模式。

```
int SetROP2(int nDrawMode);
```

### <a name="parameters"></a>參數

*nDrawMode*<br/>
指定新的繪圖模式。 可以是下列其中任何一個值：

- R2_BLACK 圖元一律為黑色。

- R2_WHITE 圖元一律為白色。

- R2_NOP 圖元會保持不變。

- R2_NOT 圖元是螢幕色彩的反向。

- R2_COPYPEN 圖元是畫筆色彩。

- R2_NOTCOPYPEN 圖元是畫筆色彩的反向。

- R2_MERGEPENNOT 圖元是畫筆色彩和螢幕色彩（最後圖元 = （不是螢幕圖元）或畫筆）之反向的組合。

- R2_MASKPENNOT 圖元是畫筆和螢幕的反向色彩的組合（最後圖元 = （不是螢幕圖元）和畫筆）。

- R2_MERGENOTPEN 圖元是螢幕色彩和畫筆色彩（最後圖元 = （而不是畫筆）或螢幕圖元）之反向的組合。

- R2_MASKNOTPEN 圖元是螢幕和畫筆反向的色彩組合（最後圖元 = （不是畫筆）和螢幕圖元）。

- R2_MERGEPEN 圖元是畫筆色彩和螢幕色彩（最後圖元 = 畫筆或螢幕圖元）的組合。

- R2_NOTMERGEPEN 圖元是 R2_MERGEPEN 色彩的反向（最後圖元 = 不是（畫筆或螢幕圖元））。

- R2_MASKPEN 圖元是畫筆和螢幕（最後圖元 = 畫筆和螢幕圖元）通用的色彩組合。

- R2_NOTMASKPEN 圖元是 R2_MASKPEN 色彩的反向（最後圖元 = 不是（畫筆和螢幕圖元））。

- R2_XORPEN 圖元是畫筆或螢幕中的色彩組合，但不能同時（最後一個圖元 = 畫筆 XOR 螢幕圖元）。

- R2_NOTXORPEN 圖元是 R2_XORPEN 色彩的反向（最後圖元 = 不是（畫筆 XOR 螢幕圖元））。

### <a name="return-value"></a>傳回值

先前的繪製模式。

它可以是 Windows SDK 中提供的任何值。

### <a name="remarks"></a>備註

[繪圖模式] 指定畫筆色彩和填滿物件內部的色彩，如何與已經在顯示介面上的色彩結合。

繪製模式僅適用于點陣裝置;並不適用于向量裝置。 繪製模式是二進位的點陣作業代碼，代表兩個變數的所有可能布林組合，使用二元運算子 AND、OR 和 XOR （exclusive OR），而一元運算則不是。

## <a name="cdcsetstretchbltmode"></a><a name="setstretchbltmode"></a>CDC：： SetStretchBltMode

設定成員函式的點陣圖延展模式 `StretchBlt` 。

```
int SetStretchBltMode(int nStretchMode);
```

### <a name="parameters"></a>參數

*nStretchMode*<br/>
指定延展模式。 可以是下列其中任何一個值：

|值|說明|
|-----------|-----------------|
|BLACKONWHITE|使用已消除和現有圖元的色彩值，執行布林和運算。 如果點陣圖是單色點陣圖，此模式會保留黑色圖元，並以白色圖元為代價。|
|COLORONCOLOR|刪除圖元。 此模式會刪除所有已消除的圖元行，而不會嘗試保留其資訊。|
|色|將來源矩形的圖元對應到目的地矩形中的圖元區塊。 以圖元為單位的目的區塊平均色彩接近來源圖元的色彩。|
||設定半色調延展模式之後，應用程式必須呼叫 Win32 函數[SetBrushOrgEx](/windows/win32/api/wingdi/nf-wingdi-setbrushorgex)來設定筆刷來源。 如果無法這麼做，筆刷對齊就會發生。|
|STRETCH_ANDSCANS|**Windows 95/98**：與 BLACKONWHITE 相同|
|STRETCH_DELETESCANS|**Windows 95/98**：與 COLORONCOLOR 相同|
|STRETCH_HALFTONE|**Windows 95/98**：與半色調相同。|
|STRETCH_ORSCANS|**Windows 95/98**：與 WHITEONBLACK 相同|
|WHITEONBLACK|使用已消除和現有圖元的色彩值，執行布林或運算。 如果點陣圖是單色點陣圖，此模式會以黑色圖元為單位保留白色圖元。|

### <a name="return-value"></a>傳回值

先前的延展模式。 可以是 STRETCH_ANDSCANS、STRETCH_DELETESCANS 或 STRETCH_ORSCANS。

### <a name="remarks"></a>備註

點陣圖延展模式會定義如何從使用函式壓縮的點陣圖中移除資訊。

BLACKONWHITE （STRETCH_ANDSCANS）和 WHITEONBLACK （STRETCH_ORSCANS）模式通常用來保留單色點陣圖中的前景圖元。 COLORONCOLOR （STRETCH_DELETESCANS）模式通常用來保留色彩點陣圖中的色彩。

半色調模式需要比其他三種模式更多的來源影像處理;其速度比其他專案慢，但會產生較高品質的影像。 另請注意， `SetBrushOrgEx` 必須在設定半色調模式後呼叫，以避免筆刷對齊。

視設備磁碟機的功能而定，可能也會提供其他延展模式。

## <a name="cdcsettextalign"></a><a name="settextalign"></a>CDC：： SetTextAlign

設定文字對齊旗標。

```
UINT SetTextAlign(UINT nFlags);
```

### <a name="parameters"></a>參數

*nFlags*<br/>
指定文字對齊旗標。 旗標會指定點和矩形之間的關聯性，以限定文字。 這個點可以是目前的位置或文字輸出函數所指定的座標。 文字字串中的相鄰字元資料格會定義界限的矩形。 *NFlags*參數可以是下列三個類別中的一個或多個旗標。 請從每個類別中只選擇一個旗標。 第一個類別會影響 x 方向的文字對齊方式：

- TA_CENTER 將點對齊周框的水準中央。

- TA_LEFT 將點對齊周框的左邊。 這是預設值。

- TA_RIGHT 將點對齊周框的右邊。

第二個分類會影響 y 方向的文字對齊方式：

- TA_BASELINE 將點對齊所選字型的基底線條。

- TA_BOTTOM 將點對齊周框的底部。

- TA_TOP 將點對齊周框的頂端。 這是預設值。

第三個類別決定在寫入文字時是否更新目前的位置：

- TA_NOUPDATECP 不會在每次呼叫文字輸出函數之後，更新目前的位置。 這是預設值。

- TA_UPDATECP 在每次呼叫文字輸出函數之後，更新目前的 x 位置。 新位置位於文字周框的右邊。 設定此旗標時，會忽略呼叫成員函式時所指定的座標 `TextOut` 。

### <a name="return-value"></a>傳回值

先前的文字對齊設定（如果成功）。 低序位位元組包含水準設定，而高序位位元組包含垂直設定;否則為0。

### <a name="remarks"></a>備註

和成員函式會在將 `TextOut` `ExtTextOut` 文字字串放在顯示或裝置上時，使用這些旗標。 旗標會指定特定點和矩形之間的關聯性，以限定文字。 這個點的座標會當做參數傳遞給成員函式 `TextOut` 。 文字字串中的相鄰字元資料格會形成界限的矩形。

## <a name="cdcsettextcharacterextra"></a><a name="settextcharacterextra"></a>CDC：： SetTextCharacterExtra

設定 intercharacter 間距的數量。

```
int SetTextCharacterExtra(int nCharExtra);
```

### <a name="parameters"></a>參數

*nCharExtra*<br/>
指定要新增至每個字元的額外空間量（以邏輯單位表示）。 如果目前的對應模式不是 `MM_TEXT` ，則會將*nCharExtra*轉換並舍入至最接近的圖元。

### <a name="return-value"></a>傳回值

上一個 intercharacter 間距的數量。

### <a name="remarks"></a>備註

當它將一行文字寫入裝置內容時，GDI 會將此間距新增至每個字元，包括分隔字元。 Intercharacter 間距量的預設值為0。

## <a name="cdcsettextcolor"></a><a name="settextcolor"></a>CDC：： SetTextColor

將文字色彩設定為指定的色彩。

```
virtual COLORREF SetTextColor(COLORREF crColor);
```

### <a name="parameters"></a>參數

*crColor*<br/>
指定文字的色彩做為 RGB 色彩值。

### <a name="return-value"></a>傳回值

先前文字色彩的 RGB 值。

### <a name="remarks"></a>備註

將文字寫入此裝置內容時，以及在色彩和單色裝置內容之間轉換點陣圖時，系統將會使用此文字色彩。

如果裝置無法代表指定的色彩，系統會將文字色彩設定為最接近的實體色彩。 字元的背景色彩是由和成員函式所指定 `SetBkColor` `SetBkMode` 。

### <a name="example"></a>範例

  請參閱[CWnd：： OnCtlColor](../../mfc/reference/cwnd-class.md#onctlcolor)的範例。

## <a name="cdcsettextjustification"></a><a name="settextjustification"></a>CDC：： SetTextJustification

將空格新增至字串中的分行符號字元。

```
int SetTextJustification(
    int nBreakExtra,
    int nBreakCount);
```

### <a name="parameters"></a>參數

*nBreakExtra*<br/>
指定要加入至文字行的總額外空間（以邏輯單位表示）。 如果目前的對應模式不是 `MM_TEXT` ，則這個參數所指定的值會轉換成目前的對應模式，並舍入到最接近的裝置單位。

*nBreakCount*<br/>
指定行中的分行字元數。

### <a name="return-value"></a>傳回值

如果函式成功，則為一個;否則為0。

### <a name="remarks"></a>備註

應用程式可以使用成員函式 `GetTextMetrics` 來抓取字型的 break 字元。

`SetTextJustification`呼叫成員函式之後，對文字輸出函數的呼叫（例如），會將 `TextOut` 指定的額外空間平均分佈在指定的分隔字元數之間。 Break 字元通常是空白字元（ASCII 32），但可由字型定義為其他字元。

成員函式 `GetTextExtent` 通常與搭配使用 `SetTextJustification` 。 `GetTextExtent`在對齊之前計算指定行的寬度。 應用程式可以藉由在對齊之後，從字串的寬度減去傳回的值，以判斷要在*nBreakExtra*參數中指定多少空間 `GetTextExtent` 。

函式 `SetTextJustification` 可以用來對齊包含多個不同字型之執行的一行。 在此情況下，必須分別對齊和寫入每個執行，以分次建立這一行。

因為在對齊期間可能會發生舍入錯誤，所以系統會保留一個執行中的錯誤詞彙，以定義目前的錯誤。 對齊包含多個回合的一行時， `GetTextExtent` 會在計算下一次執行的範圍時，自動使用此錯誤字詞。 這可讓文字輸出函數將錯誤混合到新的回合中。

在對齊每一行之後，必須清除此誤差詞，以避免將它併入下一行。 藉由呼叫 `SetTextJustification` ，並將*nBreakExtra*設為0，即可清除此字詞。

## <a name="cdcsetviewportext"></a><a name="setviewportext"></a>CDC：： SetViewportExt

設定裝置內容之區的 x 和 y 範圍。

```
virtual CSize SetViewportExt(
    int cx,
    int cy);

CSize SetViewportExt(SIZE size);
```

### <a name="parameters"></a>參數

*cx*<br/>
指定區的 x 範圍（以裝置為單位）。

*cy*<br/>
指定視口的 y 範圍（以裝置單位表示）。

*size*<br/>
指定視口的 x 和 y 範圍（以裝置單位表示）。

### <a name="return-value"></a>傳回值

以[CSize](../../atl-mfc-shared/reference/csize-class.md)物件的形式，先前的視口範圍。 發生錯誤時，傳回之物件的 x 和 y 座標 `CSize` 會同時設定為0。

### <a name="remarks"></a>備註

[視口] 和 [裝置內容] 視窗會定義 GDI 對應在邏輯座標系統中的位置，以指向實際裝置的座標系統。 換句話說，它們會定義 GDI 將邏輯座標轉換成裝置座標的方式。

設定下列對應模式時， `SetWindowExt` 會忽略和的呼叫 `SetViewportExt` ：

|MM_HIENGLISH|MM_LOMETRIC|
|-------------------|------------------|
|MM_HIMETRIC|MM_TEXT|
|MM_LOENGLISH|MM_TWIPS|

設定 MM_ISOTROPIC 模式時，應用程式必須先呼叫成員函式， `SetWindowExt` 然後再呼叫 `SetViewportExt` 。

### <a name="example"></a>範例

  請參閱[CView：： OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc)的範例。

## <a name="cdcsetviewportorg"></a><a name="setviewportorg"></a>CDC：： SetViewportOrg

設定裝置內容的視口原點。

```
virtual CPoint SetViewportOrg(
    int x,
    int y);

CPoint SetViewportOrg(POINT point);
```

### <a name="parameters"></a>參數

*x*<br/>
指定視口原點的 x 座標（以裝置為單位）。 此值必須在裝置座標系統的範圍內。

*y*<br/>
指定視口原點的 y 座標（以裝置為單位）。 此值必須在裝置座標系統的範圍內。

*此處*<br/>
指定區的原點。 這些值必須在裝置座標系統的範圍內。 您可以傳遞 `POINT` 此參數的結構或 `CPoint` 物件。

### <a name="return-value"></a>傳回值

物件的先前來源（以裝置座標 `CPoint` 表示）。

### <a name="remarks"></a>備註

[視口] 和 [裝置內容] 視窗會定義 GDI 對應在邏輯座標系統中的位置，以指向實際裝置的座標系統。 換句話說，它們會定義 GDI 將邏輯座標轉換成裝置座標的方式。

[視口] 原點會將裝置座標系統中的點標示為 GDI 對應視窗原點的位置，這是由成員函式所指定之邏輯座標系統中的點 `SetWindowOrg` 。 GDI 會遵循將視窗原點對應至視口原點所需的相同程式，來對應所有其他點。 例如，圍繞視窗原點點的圓圈中的所有點，都會在視口原點的點周圍。 同樣地，行中通過視窗原點的所有點都將位於通過視口原點的一行。

### <a name="example"></a>範例

  請參閱[CView：： OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc)的範例。

## <a name="cdcsetwindowext"></a><a name="setwindowext"></a>CDC：： SetWindowExt

設定與裝置內容相關聯之視窗的 x 和 y 範圍。

```
virtual CSize SetWindowExt(
    int cx,
    int cy);

CSize SetWindowExt(SIZE size);
```

### <a name="parameters"></a>參數

*cx*<br/>
指定視窗的 x 範圍（以邏輯單位表示）。

*cy*<br/>
指定視窗的 y 範圍（以邏輯單位表示）。

*size*<br/>
指定視窗的 x 和 y 範圍（以邏輯單位表示）。

### <a name="return-value"></a>傳回值

視窗先前的範圍（以邏輯單位表示），表示為 `CSize` 物件。 如果發生錯誤，傳回物件的 x 和 y 座標 `CSize` 會同時設定為0。

### <a name="remarks"></a>備註

此視窗連同裝置內容的視口，會定義如何將邏輯座標系統中的點對應到裝置座標系統中的點。

設定下列對應模式時， `SetWindowExt` 會忽略和函式的呼叫 `SetViewportExt` ：

- MM_HIENGLISH

- MM_HIMETRIC

- MM_LOENGLISH

- MM_LOMETRIC

- MM_TEXT

- MM_TWIPS

設定 MM_ISOTROPIC 模式時，應用程式必須先呼叫成員函式， `SetWindowExt` 然後再呼叫 `SetViewportExt` 。

### <a name="example"></a>範例

  請參閱[CView：： OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc)的範例。

## <a name="cdcsetwindoworg"></a><a name="setwindoworg"></a>CDC：： SetWindowOrg

設定裝置內容的視窗原點。

```
CPoint SetWindowOrg(
    int x,
    int y);

CPoint SetWindowOrg(POINT point);
```

### <a name="parameters"></a>參數

*x*<br/>
指定視窗新原點的邏輯 x 座標。

*y*<br/>
指定視窗新原點的邏輯 y 座標。

*此處*<br/>
指定視窗新原點的邏輯座標。 您可以傳遞 `POINT` 此參數的結構或 `CPoint` 物件。

### <a name="return-value"></a>傳回值

視窗的先前來源，做為 `CPoint` 物件。

### <a name="remarks"></a>備註

此視窗連同裝置內容的視口，會定義如何將邏輯座標系統中的點對應到裝置座標系統中的點。

視窗原點會將邏輯座標系統中的點標示為 GDI，以將其做為函式所指定之裝置座標系統中的點 `SetWindowOrg` 。 GDI 會遵循將視窗原點對應至視口原點所需的相同程式，來對應所有其他點。 例如，圍繞視窗原點點的圓圈中的所有點，都會在視口原點的點周圍。 同樣地，行中通過視窗原點的所有點都將位於通過視口原點的一行。

## <a name="cdcsetworldtransform"></a><a name="setworldtransform"></a>CDC：： SetWorldTransform

針對指定的裝置內容，設定世界空間與頁面空間之間的二維線性轉換。 這種轉換可以用來縮放、旋轉、傾斜或轉譯圖形輸出。

```
BOOL SetWorldTransform(const XFORM& rXform);
```

### <a name="parameters"></a>參數

*rXform*<br/>
參考包含轉換資料的[XFORM](/windows/win32/api/wingdi/ns-wingdi-xform)結構。

### <a name="return-value"></a>傳回值

會在成功時傳回非零值。

失敗時傳回0。

若要取得延伸錯誤資訊，請呼叫[GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror)。

### <a name="remarks"></a>備註

這個方法會包裝 Windows GDI 函數[SetWorldTransform](/windows/win32/api/wingdi/nf-wingdi-setworldtransform)。

## <a name="cdcstartdoc"></a><a name="startdoc"></a>CDC：： StartDoc

通知設備磁碟機新的列印工作正在啟動，而且所有後續 `StartPage` 和呼叫都 `EndPage` 應該在相同的作業下以多工緩衝處理，直到 `EndDoc` 呼叫發生為止。

```
int StartDoc(LPDOCINFO lpDocInfo);
int StartDoc(LPCTSTR lpszDocName);
```

### <a name="parameters"></a>參數

*lpDocInfo*<br/>
指向[DOCINFO](/windows/win32/api/wingdi/ns-wingdi-docinfow)結構，其中包含檔檔的名稱和輸出檔的名稱。

*lpszDocName*<br/>
字串的指標，其中包含檔檔的名稱。

### <a name="return-value"></a>傳回值

如果函數成功，則傳回值會大於零。 這個值是檔的列印工作識別碼。

如果函數失敗，則傳回值會小於或等於零。

### <a name="remarks"></a>備註

這可確保超過一頁的檔不會與其他作業交錯。

針對 Windows 版本3.1 和更新版本，此函式會取代 STARTDOC 印表機 escape。 使用此函式可確保包含一個以上頁面的檔不會與其他列印工作交錯。

`StartDoc`不應在中繼檔內使用。

### <a name="example"></a>範例

此程式碼片段會取得預設的印表機、開啟列印工作，並以 "Hello，World！" 的一個頁面進行多工緩衝處理 在其上。 因為此程式碼列印的文字不會縮放為印表機的邏輯單元，所以輸出文字可能會以這類小寫字母表示無法讀取結果。 CDC 調整函式（例如 `SetMapMode` 、 `SetViewportOrg` 和 `SetWindowExt` ）可以用來修正調整。

[!code-cpp[NVC_MFCDocView#41](../../mfc/codesnippet/cpp/cdc-class_13.cpp)]

## <a name="cdcstartpage"></a><a name="startpage"></a>CDC：： StartPage

呼叫此成員函式以準備印表機驅動程式以接收資料。

```
int StartPage();
```

### <a name="return-value"></a>傳回值

如果函式成功，則大於或等於0，如果發生錯誤，則為負數值。

### <a name="remarks"></a>備註

`StartPage`取代 NEWFRAME 和 BANDINFO 的轉義。

如需列印呼叫順序的總覽，請參閱[StartDoc](#startdoc)成員函式。

系統會在對 `ResetDC` 和的呼叫之間停用成員函式 `StartPage` `EndPage` 。

### <a name="example"></a>範例

  請參閱[CDC：： StartDoc](#startdoc)的範例。

## <a name="cdcstretchblt"></a><a name="stretchblt"></a>CDC：： StretchBlt

將來源矩形的點陣圖複製到目的地矩形，必要時可延伸或壓縮點陣圖，使其符合目的地矩形的維度。

```
BOOL StretchBlt(
    int x,
    int y,
    int nWidth,
    int nHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    int nSrcWidth,
    int nSrcHeight,
    DWORD dwRop);
```

### <a name="parameters"></a>參數

*x*<br/>
指定目的地矩形左上角的 X 座標 (以邏輯單位表示)。

*y*<br/>
指定目的地矩形左上角的 Y 座標 (以邏輯單位表示)。

*nWidth*<br/>
指定目的地矩形的寬度 (以邏輯單位表示)。

*nHeight*<br/>
指定目的地矩形的高度 (以邏輯單位表示)。

*pSrcDC*<br/>
指定來源裝置內容。

*xSrc*<br/>
指定來源矩形左上角的 X 座標 (以邏輯單位表示)。

*ySrc*<br/>
指定來源矩形左上角的 Y 座標 (以邏輯單位表示)。

*nSrcWidth*<br/>
指定來源矩形的寬度 (以邏輯單位表示)。

*nSrcHeight*<br/>
指定來源矩形的高度 (以邏輯單位表示)。

*dwRop*<br/>
指定待執行的點陣作業。 點陣作業程式碼定義 GDI 在輸出作業中結合色彩的方式；該輸出作業與目前的筆刷、可能的來源點陣圖和目的地點陣圖相關。 這個參數可以是下列其中一個值：

- 即黑會將所有輸出變成黑色。

- DSTINVERT 反轉目的地點陣圖。

- MERGECOPY 會使用布林值 AND 運算子來結合模式和來源點陣圖。

- MERGEPAINT 會使用布林值 OR 運算子，結合反向來源點陣圖與目的地點陣圖。

- NOTSRCCOPY 會將反轉的來源點陣圖複製到目的地。

- NOTSRCERASE 使用布林值 OR 運算子來反轉結合目的地和來源點陣圖的結果。

- PATCOPY 會將模式複製到目的地點陣圖。

- PATINVERT 會使用布林 XOR 運算子來結合目的地點陣圖與模式。

- PATPAINT 會使用布林值 OR 運算子，結合反向來源點陣圖與模式。 使用布林值 OR 運算子合併此作業的結果與目的地點陣圖。

- SRCAND 會使用布林值 AND 運算子結合目的地和來源點陣圖的圖元。

- SRCCOPY 會將來源點陣圖複製到目的地點陣圖。

- SRCERASE 會反轉目的地點陣圖，並使用布林值 AND 運算子來結合結果與來源點陣圖。

- SRCINVERT 會使用布林 XOR 運算子結合目的地和來源點陣圖的圖元。

- SRCPAINT 使用布林值 OR 運算子結合目的地和來源點陣圖的圖元。

- WHITENESS 會將所有輸出變成白色。

### <a name="return-value"></a>傳回值

如果繪製了點陣圖即為非零，否則為 0。

### <a name="remarks"></a>備註

此函式使用目的地裝置內容 (以 `SetStretchBltMode` 設定) 的縮放模式判斷如何縮放或壓縮點陣圖。

函 `StretchBlt` 式會將點陣圖從*pSrcDC*所指定的來源裝置移到裝置內容物件所代表的目的地裝置（其成員函式會被呼叫）。 *XSrc*、 *ySrc*、 *nSrcWidth*和*nSrcHeight*參數會定義來源矩形的左上角和維度。 *X*、 *y*、 *nWidth*和*nHeight*參數提供目的矩形的左上角和維度。 *DwRop*所指定的點陣作業會定義來源點陣圖和目的地裝置上已有的位如何結合。

`StretchBlt`如果*NSrcWidth*和*NWidth*或*nSrcHeight*和*nHeight*參數的正負號不同，函式會建立點陣圖的鏡像映射。 如果*nSrcWidth*和*nWidth*具有不同的正負號，函式會沿著 X 軸建立點陣圖的鏡像影像。 如果*nSrcHeight*和*nHeight*具有不同的正負號，函式會沿著 y 軸建立點陣圖的鏡像影像。

`StretchBlt` 函式會延伸或壓縮記憶體中的來源點陣圖，然後將結果複製到目的地。 如果要合併模式和結果，除非將延伸的來源點陣圖複製到目的地，否則不會進行合併。 如果使用筆刷，會使用在目的地裝置內容中選取的筆刷。 目的地座標會根據目的地裝置內容而轉換；來源座標會根據來源裝置內容而轉換。

如果目的地、來源和模式點陣圖的色彩格式不同，`StretchBlt` 會轉換來源和模式點陣圖以符合目的地點陣圖。 轉換中會使用目的地裝置内容的前景和背景色彩。

如果 `StretchBlt` 必須將單色點陣圖轉換為彩色，會將白色位元 (1) 設為背景色彩，並將黑色位元 (0) 設為前景色彩。 若要將彩色轉換為單色，則會將符合背景色彩的像素轉換成白色 (1)，並將其他所有像素設為黑色 (0)。 會使用彩色裝置內容的前景和背景色彩。

並非所有的裝置皆支援 `StretchBlt` 函式。 若要判斷裝置是否支援 `StretchBlt` ，請呼叫 `GetDeviceCaps` 具有 RASTERCAPS 索引的成員函式，並檢查 RC_STRETCHBLT 旗標的傳回值。

## <a name="cdcstrokeandfillpath"></a><a name="strokeandfillpath"></a>CDC：： StrokeAndFillPath

關閉路徑中任何已開啟的資料，使用目前的畫筆來將路徑的外框筆觸，並使用目前的筆刷填滿其內部。

```
BOOL StrokeAndFillPath();
```

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

裝置內容必須包含關閉的路徑。 成員函式 `StrokeAndFillPath` 的作用與關閉路徑中的所有已開啟的資料，以及個別的筆劃和填滿路徑相同，不同之處在于即使畫筆寬，已填滿的區域也不會重迭繪製的區域。

## <a name="cdcstrokepath"></a><a name="strokepath"></a>CDC：： StrokePath

使用目前的畫筆來呈現指定的路徑。

```
BOOL StrokePath();
```

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

裝置內容必須包含關閉的路徑。

## <a name="cdctabbedtextout"></a><a name="tabbedtextout"></a>CDC：： TabbedTextOut

呼叫這個成員函式以在指定的位置寫入字元字串，將索引標籤擴充至索引標籤-停止位置陣列中指定的值。

```
virtual CSize TabbedTextOut(
    int x,
    int y,
    LPCTSTR lpszString,
    int nCount,
    int nTabPositions,
    LPINT lpnTabStopPositions,
    int nTabOrigin);

CSize TabbedTextOut(
    int x,
    int y,
    const CString& str,
    int nTabPositions,
    LPINT lpnTabStopPositions,
    int nTabOrigin);
```

### <a name="parameters"></a>參數

*x*<br/>
指定字串起始點的邏輯 x 座標。

*y*<br/>
指定字串起始點的邏輯 y 座標。

*lpszString*<br/>
指向要繪製的字元字串。 您可以針對這個參數傳遞字元陣列的指標或[CString](../../atl-mfc-shared/reference/cstringt-class.md)物件。

*nCount*<br/>
指定*lpszString*所指向[的字串長度](/windows/win32/gdi/specifying-length-of-text-output-string)。

*nTabPositions*<br/>
指定索引標籤-停止位置之陣列中的值數目。

*lpnTabStopPositions*<br/>
指向包含索引標籤-停止位置的陣列（以邏輯單位表示）。 定位停駐點必須以遞增順序排序;最小的 x 值應該是陣列中的第一個專案。

*nTabOrigin*<br/>
指定展開索引標籤的起始位置 x 座標（以邏輯單位表示）。

*字串*<br/>
`CString`包含指定之字元的物件。

### <a name="return-value"></a>傳回值

當做物件的字串維度（以邏輯單位表示） `CSize` 。

### <a name="remarks"></a>備註

文字是以目前選取的字型來撰寫。 如果*nTabPositions*為0，而*lpnTabStopPositions*為 Null，則索引標籤會展開為平均字元寬度的八倍。

如果*nTabPositions*是1，就會以*lpnTabStopPositions*陣列中第一個值所指定的距離來分隔定位停駐點。 如果*lpnTabStopPositions*陣列包含一個以上的值，就會針對陣列中的每個值設定制表位，最多可達*nTabPositions*所指定的數目。 *NTabOrigin*參數可讓應用程式針對單一行多次呼叫函式 `TabbedTextOut` 。 如果應用程式多次呼叫函式，並將*nTabOrigin*設定為相同的值，則函式會展開所有索引標籤（相對於*nTabOrigin*所指定的位置）。

根據預設，函式不會使用或更新目前的位置。 如果應用程式在呼叫函數時需要更新目前的位置，應用程式可以呼叫[SetTextAlign](#settextalign)成員函式，並將*nFlags*設為 TA_UPDATECP。 設定此旗標時，Windows 會改*x*為*y* `TabbedTextOut` 使用目前的位置，忽略後續呼叫的 x 和 y 參數。

## <a name="cdctextout"></a><a name="textout"></a>CDC：： TextOut

使用目前選取的字型，在指定的位置寫入字元字串。

```
virtual BOOL TextOut(
    int x,
    int y,
    LPCTSTR lpszString,
    int nCount);

BOOL TextOut(
    int x,
    int y,
    const CString& str);
```

### <a name="parameters"></a>參數

*x*<br/>
指定文字起點的邏輯 X 座標。

*y*<br/>
指定文字起點的邏輯 Y 座標。

*lpszString*<br/>
指向要繪製的字元字串。

*nCount*<br/>
指定字串中的字元數。

*字串*<br/>
`CString` 物件，其中包含要繪製的字元。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

字元原點在字元儲存格的左上角。 根據預設，函式不會使用或更新目前的位置。

如果應用程式在呼叫時需要更新目前的位置 `TextOut` ，應用程式可以呼叫成員函式， `SetTextAlign` 並將*nFlags*設為 TA_UPDATECP。 設定此旗標時，Windows 會改*x*為*y* `TextOut` 使用目前的位置，忽略後續呼叫的 x 和 y 參數。

### <a name="example"></a>範例

  請參閱[CDC：： BeginPath](#beginpath)的範例。

## <a name="cdctransparentblt"></a><a name="transparentblt"></a>CDC：： TransparentBlt

呼叫這個成員函式，將色彩資料的位區塊（對應至指定來源裝置內容中的圖元矩形）傳送到目的地裝置內容。

```
BOOL TransparentBlt(
    int xDest,
    int yDest,
    int nDestWidth,
    int nDestHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    int nSrcWidth,
    int nSrcHeight,
    UINT clrTransparent);
```

### <a name="parameters"></a>參數

*xDest*<br/>
指定目的地矩形左上角的 x 座標（以邏輯單位表示）。

*yDest*<br/>
指定目的地矩形左上角的 y 座標（以邏輯單位表示）。

*nDestWidth*<br/>
指定目的地矩形的寬度（以邏輯單位表示）。

*nDestHeight*<br/>
指定目的地矩形的高度（以邏輯單位表示）。

*pSrcDC*<br/>
來源裝置內容的指標。

*xSrc*<br/>
指定來源矩形的 x 座標（以邏輯單位表示）。

*ySrc*<br/>
指定來源矩形的 y 座標（以邏輯單位表示）。

*nSrcWidth*<br/>
指定來源矩形的寬度（以邏輯單位表示）。

*nSrcHeight*<br/>
指定來源矩形的高度（以邏輯單位表示）。

*clrTransparent*<br/>
來源點陣圖中要視為透明的 RGB 色彩。

### <a name="return-value"></a>傳回值

如果成功，則為 TRUE，否則為 FALSE。

### <a name="remarks"></a>備註

`TransparentBlt`允許透明度;也就是說， *clrTransparent*所指出的 RGB 色彩會針對傳輸呈現透明。

如需詳細資訊，請參閱 Windows SDK 中的[TransparentBlt](/windows/win32/api/wingdi/nf-wingdi-transparentblt) 。

## <a name="cdcupdatecolors"></a><a name="updatecolors"></a>CDC：： UpdateColors

以圖元為單位，將工作區中的目前色彩比對系統元件，以更新裝置內容的工作區。

```cpp
void UpdateColors();
```

### <a name="remarks"></a>備註

具有已實現之邏輯調色板的非作用中視窗，可以在 `UpdateColors` 系統元件變更時，呼叫來重新繪製其工作區的替代方法。

如需有關使用調色板的詳細資訊，請參閱 Windows SDK 中的[UpdateColors](/windows/win32/api/wingdi/nf-wingdi-updatecolors) 。

成員函式 `UpdateColors` 通常會比重繪區域更快速地更新工作區。 不過，由於函式會根據每個圖元的色彩來執行色彩轉譯，然後再變更系統元件，因此每次呼叫此函式都會導致部分色彩精確度遺失。

## <a name="cdcwidenpath"></a><a name="widenpath"></a>CDC：： WidenPath

將目前的路徑重新定義為將路徑繪製到裝置內容中時，所要繪製的區域。

```
BOOL WidenPath();
```

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

只有當目前的畫筆是第二個成員函式所建立的幾何畫筆 `CreatePen` ，或如果畫筆是使用的第一個版本所建立， `CreatePen` 且其寬度為大於1的裝置，此函式才會成功。 裝置內容必須包含關閉的路徑。 路徑中的任何 Bzier 曲線都會轉換成直線序列，將逼近加寬的曲線。 因此，在呼叫之後，路徑中不會保留任何 Bzier 曲線 `WidenPath` 。

## <a name="see-also"></a>另請參閱

[CObject 類別](../../mfc/reference/cobject-class.md)<br/>
[階層架構圖表](../../mfc/hierarchy-chart.md)<br/>
[CPaintDC 類別](../../mfc/reference/cpaintdc-class.md)<br/>
[CWindowDC 類別](../../mfc/reference/cwindowdc-class.md)<br/>
[CClientDC 類別](../../mfc/reference/cclientdc-class.md)<br/>
[CMetaFileDC 類別](../../mfc/reference/cmetafiledc-class.md)
