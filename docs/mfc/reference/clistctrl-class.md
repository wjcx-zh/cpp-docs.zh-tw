---
title: CListCtrl 類別
ms.date: 06/13/2019
f1_keywords:
- CListCtrl
- AFXCMN/CListCtrl
- AFXCMN/CListCtrl::CListCtrl
- AFXCMN/CListCtrl::ApproximateViewRect
- AFXCMN/CListCtrl::Arrange
- AFXCMN/CListCtrl::CancelEditLabel
- AFXCMN/CListCtrl::Create
- AFXCMN/CListCtrl::CreateDragImage
- AFXCMN/CListCtrl::CreateEx
- AFXCMN/CListCtrl::DeleteAllItems
- AFXCMN/CListCtrl::DeleteColumn
- AFXCMN/CListCtrl::DeleteItem
- AFXCMN/CListCtrl::DrawItem
- AFXCMN/CListCtrl::EditLabel
- AFXCMN/CListCtrl::EnableGroupView
- AFXCMN/CListCtrl::EnsureVisible
- AFXCMN/CListCtrl::FindItem
- AFXCMN/CListCtrl::GetBkColor
- AFXCMN/CListCtrl::GetBkImage
- AFXCMN/CListCtrl::GetCallbackMask
- AFXCMN/CListCtrl::GetCheck
- AFXCMN/CListCtrl::GetColumn
- AFXCMN/CListCtrl::GetColumnOrderArray
- AFXCMN/CListCtrl::GetColumnWidth
- AFXCMN/CListCtrl::GetCountPerPage
- AFXCMN/CListCtrl::GetEditControl
- AFXCMN/CListCtrl::GetEmptyText
- AFXCMN/CListCtrl::GetExtendedStyle
- AFXCMN/CListCtrl::GetFirstSelectedItemPosition
- AFXCMN/CListCtrl::GetFocusedGroup
- AFXCMN/CListCtrl::GetGroupCount
- AFXCMN/CListCtrl::GetGroupInfo
- AFXCMN/CListCtrl::GetGroupInfoByIndex
- AFXCMN/CListCtrl::GetGroupMetrics
- AFXCMN/CListCtrl::GetGroupRect
- AFXCMN/CListCtrl::GetGroupState
- AFXCMN/CListCtrl::GetHeaderCtrl
- AFXCMN/CListCtrl::GetHotCursor
- AFXCMN/CListCtrl::GetHotItem
- AFXCMN/CListCtrl::GetHoverTime
- AFXCMN/CListCtrl::GetImageList
- AFXCMN/CListCtrl::GetInsertMark
- AFXCMN/CListCtrl::GetInsertMarkColor
- AFXCMN/CListCtrl::GetInsertMarkRect
- AFXCMN/CListCtrl::GetItem
- AFXCMN/CListCtrl::GetItemCount
- AFXCMN/CListCtrl::GetItemData
- AFXCMN/CListCtrl::GetItemIndexRect
- AFXCMN/CListCtrl::GetItemPosition
- AFXCMN/CListCtrl::GetItemRect
- AFXCMN/CListCtrl::GetItemSpacing
- AFXCMN/CListCtrl::GetItemState
- AFXCMN/CListCtrl::GetItemText
- AFXCMN/CListCtrl::GetNextItem
- AFXCMN/CListCtrl::GetNextItemIndex
- AFXCMN/CListCtrl::GetNextSelectedItem
- AFXCMN/CListCtrl::GetNumberOfWorkAreas
- AFXCMN/CListCtrl::GetOrigin
- AFXCMN/CListCtrl::GetOutlineColor
- AFXCMN/CListCtrl::GetSelectedColumn
- AFXCMN/CListCtrl::GetSelectedCount
- AFXCMN/CListCtrl::GetSelectionMark
- AFXCMN/CListCtrl::GetStringWidth
- AFXCMN/CListCtrl::GetSubItemRect
- AFXCMN/CListCtrl::GetTextBkColor
- AFXCMN/CListCtrl::GetTextColor
- AFXCMN/CListCtrl::GetTileInfo
- AFXCMN/CListCtrl::GetTileViewInfo
- AFXCMN/CListCtrl::GetToolTips
- AFXCMN/CListCtrl::GetTopIndex
- AFXCMN/CListCtrl::GetView
- AFXCMN/CListCtrl::GetViewRect
- AFXCMN/CListCtrl::GetWorkAreas
- AFXCMN/CListCtrl::HasGroup
- AFXCMN/CListCtrl::HitTest
- AFXCMN/CListCtrl::InsertColumn
- AFXCMN/CListCtrl::InsertGroup
- AFXCMN/CListCtrl::InsertGroupSorted
- AFXCMN/CListCtrl::InsertItem
- AFXCMN/CListCtrl::InsertMarkHitTest
- AFXCMN/CListCtrl::IsGroupViewEnabled
- AFXCMN/CListCtrl::IsItemVisible
- AFXCMN/CListCtrl::MapIDToIndex
- AFXCMN/CListCtrl::MapIndexToID
- AFXCMN/CListCtrl::MoveGroup
- AFXCMN/CListCtrl::MoveItemToGroup
- AFXCMN/CListCtrl::RedrawItems
- AFXCMN/CListCtrl::RemoveAllGroups
- AFXCMN/CListCtrl::RemoveGroup
- AFXCMN/CListCtrl::Scroll
- AFXCMN/CListCtrl::SetBkColor
- AFXCMN/CListCtrl::SetBkImage
- AFXCMN/CListCtrl::SetCallbackMask
- AFXCMN/CListCtrl::SetCheck
- AFXCMN/CListCtrl::SetColumn
- AFXCMN/CListCtrl::SetColumnOrderArray
- AFXCMN/CListCtrl::SetColumnWidth
- AFXCMN/CListCtrl::SetExtendedStyle
- AFXCMN/CListCtrl::SetGroupInfo
- AFXCMN/CListCtrl::SetGroupMetrics
- AFXCMN/CListCtrl::SetHotCursor
- AFXCMN/CListCtrl::SetHotItem
- AFXCMN/CListCtrl::SetHoverTime
- AFXCMN/CListCtrl::SetIconSpacing
- AFXCMN/CListCtrl::SetImageList
- AFXCMN/CListCtrl::SetInfoTip
- AFXCMN/CListCtrl::SetInsertMark
- AFXCMN/CListCtrl::SetInsertMarkColor
- AFXCMN/CListCtrl::SetItem
- AFXCMN/CListCtrl::SetItemCount
- AFXCMN/CListCtrl::SetItemCountEx
- AFXCMN/CListCtrl::SetItemData
- AFXCMN/CListCtrl::SetItemIndexState
- AFXCMN/CListCtrl::SetItemPosition
- AFXCMN/CListCtrl::SetItemState
- AFXCMN/CListCtrl::SetItemText
- AFXCMN/CListCtrl::SetOutlineColor
- AFXCMN/CListCtrl::SetSelectedColumn
- AFXCMN/CListCtrl::SetSelectionMark
- AFXCMN/CListCtrl::SetTextBkColor
- AFXCMN/CListCtrl::SetTextColor
- AFXCMN/CListCtrl::SetTileInfo
- AFXCMN/CListCtrl::SetTileViewInfo
- AFXCMN/CListCtrl::SetToolTips
- AFXCMN/CListCtrl::SetView
- AFXCMN/CListCtrl::SetWorkAreas
- AFXCMN/CListCtrl::SortGroups
- AFXCMN/CListCtrl::SortItems
- AFXCMN/CListCtrl::SortItemsEx
- AFXCMN/CListCtrl::SubItemHitTest
- AFXCMN/CListCtrl::Update
helpviewer_keywords:
- CListCtrl [MFC], CListCtrl
- CListCtrl [MFC], ApproximateViewRect
- CListCtrl [MFC], Arrange
- CListCtrl [MFC], CancelEditLabel
- CListCtrl [MFC], Create
- CListCtrl [MFC], CreateDragImage
- CListCtrl [MFC], CreateEx
- CListCtrl [MFC], DeleteAllItems
- CListCtrl [MFC], DeleteColumn
- CListCtrl [MFC], DeleteItem
- CListCtrl [MFC], DrawItem
- CListCtrl [MFC], EditLabel
- CListCtrl [MFC], EnableGroupView
- CListCtrl [MFC], EnsureVisible
- CListCtrl [MFC], FindItem
- CListCtrl [MFC], GetBkColor
- CListCtrl [MFC], GetBkImage
- CListCtrl [MFC], GetCallbackMask
- CListCtrl [MFC], GetCheck
- CListCtrl [MFC], GetColumn
- CListCtrl [MFC], GetColumnOrderArray
- CListCtrl [MFC], GetColumnWidth
- CListCtrl [MFC], GetCountPerPage
- CListCtrl [MFC], GetEditControl
- CListCtrl [MFC], GetEmptyText
- CListCtrl [MFC], GetExtendedStyle
- CListCtrl [MFC], GetFirstSelectedItemPosition
- CListCtrl [MFC], GetFocusedGroup
- CListCtrl [MFC], GetGroupCount
- CListCtrl [MFC], GetGroupInfo
- CListCtrl [MFC], GetGroupInfoByIndex
- CListCtrl [MFC], GetGroupMetrics
- CListCtrl [MFC], GetGroupRect
- CListCtrl [MFC], GetGroupState
- CListCtrl [MFC], GetHeaderCtrl
- CListCtrl [MFC], GetHotCursor
- CListCtrl [MFC], GetHotItem
- CListCtrl [MFC], GetHoverTime
- CListCtrl [MFC], GetImageList
- CListCtrl [MFC], GetInsertMark
- CListCtrl [MFC], GetInsertMarkColor
- CListCtrl [MFC], GetInsertMarkRect
- CListCtrl [MFC], GetItem
- CListCtrl [MFC], GetItemCount
- CListCtrl [MFC], GetItemData
- CListCtrl [MFC], GetItemIndexRect
- CListCtrl [MFC], GetItemPosition
- CListCtrl [MFC], GetItemRect
- CListCtrl [MFC], GetItemSpacing
- CListCtrl [MFC], GetItemState
- CListCtrl [MFC], GetItemText
- CListCtrl [MFC], GetNextItem
- CListCtrl [MFC], GetNextItemIndex
- CListCtrl [MFC], GetNextSelectedItem
- CListCtrl [MFC], GetNumberOfWorkAreas
- CListCtrl [MFC], GetOrigin
- CListCtrl [MFC], GetOutlineColor
- CListCtrl [MFC], GetSelectedColumn
- CListCtrl [MFC], GetSelectedCount
- CListCtrl [MFC], GetSelectionMark
- CListCtrl [MFC], GetStringWidth
- CListCtrl [MFC], GetSubItemRect
- CListCtrl [MFC], GetTextBkColor
- CListCtrl [MFC], GetTextColor
- CListCtrl [MFC], GetTileInfo
- CListCtrl [MFC], GetTileViewInfo
- CListCtrl [MFC], GetToolTips
- CListCtrl [MFC], GetTopIndex
- CListCtrl [MFC], GetView
- CListCtrl [MFC], GetViewRect
- CListCtrl [MFC], GetWorkAreas
- CListCtrl [MFC], HasGroup
- CListCtrl [MFC], HitTest
- CListCtrl [MFC], InsertColumn
- CListCtrl [MFC], InsertGroup
- CListCtrl [MFC], InsertGroupSorted
- CListCtrl [MFC], InsertItem
- CListCtrl [MFC], InsertMarkHitTest
- CListCtrl [MFC], IsGroupViewEnabled
- CListCtrl [MFC], IsItemVisible
- CListCtrl [MFC], MapIDToIndex
- CListCtrl [MFC], MapIndexToID
- CListCtrl [MFC], MoveGroup
- CListCtrl [MFC], MoveItemToGroup
- CListCtrl [MFC], RedrawItems
- CListCtrl [MFC], RemoveAllGroups
- CListCtrl [MFC], RemoveGroup
- CListCtrl [MFC], Scroll
- CListCtrl [MFC], SetBkColor
- CListCtrl [MFC], SetBkImage
- CListCtrl [MFC], SetCallbackMask
- CListCtrl [MFC], SetCheck
- CListCtrl [MFC], SetColumn
- CListCtrl [MFC], SetColumnOrderArray
- CListCtrl [MFC], SetColumnWidth
- CListCtrl [MFC], SetExtendedStyle
- CListCtrl [MFC], SetGroupInfo
- CListCtrl [MFC], SetGroupMetrics
- CListCtrl [MFC], SetHotCursor
- CListCtrl [MFC], SetHotItem
- CListCtrl [MFC], SetHoverTime
- CListCtrl [MFC], SetIconSpacing
- CListCtrl [MFC], SetImageList
- CListCtrl [MFC], SetInfoTip
- CListCtrl [MFC], SetInsertMark
- CListCtrl [MFC], SetInsertMarkColor
- CListCtrl [MFC], SetItem
- CListCtrl [MFC], SetItemCount
- CListCtrl [MFC], SetItemCountEx
- CListCtrl [MFC], SetItemData
- CListCtrl [MFC], SetItemIndexState
- CListCtrl [MFC], SetItemPosition
- CListCtrl [MFC], SetItemState
- CListCtrl [MFC], SetItemText
- CListCtrl [MFC], SetOutlineColor
- CListCtrl [MFC], SetSelectedColumn
- CListCtrl [MFC], SetSelectionMark
- CListCtrl [MFC], SetTextBkColor
- CListCtrl [MFC], SetTextColor
- CListCtrl [MFC], SetTileInfo
- CListCtrl [MFC], SetTileViewInfo
- CListCtrl [MFC], SetToolTips
- CListCtrl [MFC], SetView
- CListCtrl [MFC], SetWorkAreas
- CListCtrl [MFC], SortGroups
- CListCtrl [MFC], SortItems
- CListCtrl [MFC], SortItemsEx
- CListCtrl [MFC], SubItemHitTest
- CListCtrl [MFC], Update
ms.assetid: fe08a1ca-4b05-4ff7-a12a-ee4c765a2197
ms.openlocfilehash: c8f1b8a9ed0ca8437ba40e77b47448d1bb209d20
ms.sourcegitcommit: 7ecd91d8ce18088a956917cdaf3a3565bd128510
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 03/16/2020
ms.locfileid: "79418675"
---
# <a name="clistctrl-class"></a>CListCtrl 類別

封裝「清單檢視控制項」的功能，顯示項目集合，其中每個項目是由圖示 (來自影像清單) 和標籤所組成的。

## <a name="syntax"></a>語法

```
class CListCtrl : public CWnd
```

## <a name="members"></a>成員

### <a name="public-constructors"></a>公用建構函式

|名稱|描述|
|----------|-----------------|
|[CListCtrl：： CListCtrl](#clistctrl)|建構 `CListCtrl` 物件。|

### <a name="public-methods"></a>公用方法

|名稱|描述|
|----------|-----------------|
|[CListCtrl：： ApproximateViewRect](#approximateviewrect)|決定顯示清單視圖控制項之專案所需的寬度和高度。|
|[CListCtrl：：排列](#arrange)|對齊方格上的專案。|
|[CListCtrl：： CancelEditLabel](#canceleditlabel)|取消專案文字編輯作業。|
|[CListCtrl：： Create](#create)|建立清單控制項，並將它附加至 `CListCtrl` 物件。|
|[CListCtrl：： CreateDragImage](#createdragimage)|為指定的專案建立拖曳影像清單。|
|[CListCtrl：： CreateEx](#createex)|使用指定的 Windows 擴充樣式建立清單控制項，並將它附加至 `CListCtrl` 物件。|
|[CListCtrl：:D eleteAllItems](#deleteallitems)|從控制項中刪除所有專案。|
|[CListCtrl：:D eleteColumn](#deletecolumn)|刪除清單視圖控制項中的資料行。|
|[CListCtrl：:D eleteItem](#deleteitem)|從控制項中刪除專案。|
|[CListCtrl：:D rawItem](#drawitem)|當主控描繪控制項的視覺外觀變更時呼叫。|
|[CListCtrl：： EditLabel](#editlabel)|開始就地編輯專案的文字。|
|[CListCtrl：： EnableGroupView](#enablegroupview)|啟用或停用清單視圖控制項中的專案是否顯示為群組。|
|[CListCtrl：： EnsureVisible](#ensurevisible)|確保專案可見。|
|[CListCtrl：： FindItem](#finditem)|搜尋具有指定特性的清單視圖專案。|
|[CListCtrl：： GetBkColor](#getbkcolor)|抓取清單視圖控制項的背景色彩。|
|[CListCtrl：： GetBkImage](#getbkimage)|抓取清單視圖控制項的目前背景影像。|
|[CListCtrl：： GetCallbackMask](#getcallbackmask)|抓取清單視圖控制項的回呼遮罩。|
|[CListCtrl：： GetCheck](#getcheck)|抓取與專案相關聯之狀態影像的目前顯示狀態。|
|[CListCtrl：： GetColumn](#getcolumn)|抓取控制項資料行的屬性。|
|[CListCtrl：： GetColumnOrderArray](#getcolumnorderarray)|抓取清單視圖控制項的資料行順序（由左到右）。|
|[CListCtrl：： GetColumnWidth](#getcolumnwidth)|抓取報表檢視或清單視圖中資料行的寬度。|
|[CListCtrl：： GetCountPerPage](#getcountperpage)|計算清單視圖控制項中可以垂直調整的專案數。|
|[CListCtrl：： GetEditControl](#geteditcontrol)|抓取編輯控制項的控制碼，用來編輯專案的文字。|
|[CListCtrl：： GetEmptyText](#getemptytext)|如果目前的清單視圖控制項是空的，則抓取要顯示的字串。|
|[CListCtrl：： GetExtendedStyle](#getextendedstyle)|抓取清單視圖控制項的目前擴充樣式。|
|[CListCtrl：： GetFirstSelectedItemPosition](#getfirstselecteditemposition)|抓取清單視圖控制項中第一個選取清單視圖專案的位置。|
|[CListCtrl：： GetFocusedGroup](#getfocusedgroup)|抓取目前清單視圖控制項中具有鍵盤焦點的群組。|
|[CListCtrl：： GetGroupCount](#getgroupcount)|抓取目前清單視圖控制項中的群組數目。|
|[CListCtrl：： GetGroupInfo](#getgroupinfo)|取得清單視圖控制項之指定群組的資訊。|
|[CListCtrl：： GetGroupInfoByIndex](#getgroupinfobyindex)|抓取目前清單視圖控制項中指定之群組的相關資訊。|
|[CListCtrl：： GetGroupMetrics](#getgroupmetrics)|抓取群組的計量。|
|[CListCtrl：： GetGroupRect](#getgrouprect)|抓取目前清單視圖控制項中指定群組的周框。|
|[CListCtrl：： GetGroupState](#getgroupstate)|抓取目前清單視圖控制項中指定群組的狀態。|
|[CListCtrl：： GetHeaderCtrl](#getheaderctrl)|抓取清單視圖控制項的標頭控制項。|
|[CListCtrl：： GetHotCursor](#gethotcursor)|當啟用清單視圖控制項的熱追蹤時，抓取使用的資料指標。|
|[CListCtrl：： GetHotItem](#gethotitem)|抓取目前游標下的清單視圖專案。|
|[CListCtrl：： GetHoverTime](#gethovertime)|抓取清單視圖控制項的目前停留時間。|
|[CListCtrl：： GetImageList](#getimagelist)|抓取用於繪製清單視圖專案之影像清單的控制碼。|
|[CListCtrl：： GetInsertMark](#getinsertmark)|抓取插入標記的目前位置。|
|[CListCtrl：： GetInsertMarkColor](#getinsertmarkcolor)|抓取插入標記的目前色彩。|
|[CListCtrl：： GetInsertMarkRect](#getinsertmarkrect)|抓取插入點的邊界矩形。|
|[CListCtrl：： GetItem](#getitem)|抓取清單視圖專案的屬性。|
|[CListCtrl：： GetItemCount](#getitemcount)|抓取清單視圖控制項中的專案數。|
|[CListCtrl：： GetItemData](#getitemdata)|抓取與專案相關聯的應用程式特定值。|
|[CListCtrl：： GetItemIndexRect](#getitemindexrect)|抓取目前清單視圖控制項中所有或部分子工作的周框。|
|[CListCtrl：： GetItemPosition](#getitemposition)|抓取清單視圖專案的位置。|
|[CListCtrl：： GetItemRect](#getitemrect)|抓取專案的周框。|
|[CListCtrl：： GetItemSpacing](#getitemspacing)|計算目前清單視圖控制項中專案之間的間距。|
|[CListCtrl：： GetItemState](#getitemstate)|抓取清單視圖專案的狀態。|
|[CListCtrl：： GetItemText](#getitemtext)|抓取清單視圖專案或子項的文字。|
|[CListCtrl：： GetNextItem](#getnextitem)|搜尋具有指定之屬性的清單視圖專案，以及與指定專案的指定關聯性。|
|[CListCtrl：： GetNextItemIndex](#getnextitemindex)|抓取目前清單視圖控制項中，具有一組指定屬性的專案索引。|
|[CListCtrl：： GetNextSelectedItem](#getnextselecteditem)|抓取清單視圖專案位置的索引，以及下一個選取之清單視圖專案的反覆運算位置。|
|[CListCtrl：： GetNumberOfWorkAreas](#getnumberofworkareas)|抓取清單視圖控制項目前的工作區數目。|
|[CListCtrl：： GetOrigin](#getorigin)|抓取清單視圖控制項的目前視圖原點。|
|[CListCtrl：： GetOutlineColor](#getoutlinecolor)|抓取清單視圖控制項的框線色彩。|
|[CListCtrl：： GetSelectedColumn](#getselectedcolumn)|抓取清單控制項中目前選取之資料行的索引。|
|[CListCtrl：： GetSelectedCount](#getselectedcount)|抓取清單視圖控制項中選取的專案數。|
|[CListCtrl：： GetSelectionMark](#getselectionmark)|抓取清單視圖控制項的選取專案標記。|
|[CListCtrl：： GetStringWidth](#getstringwidth)|決定顯示所有指定字串所需的最小資料行寬度。|
|[CListCtrl：： GetSubItemRect](#getsubitemrect)|抓取清單視圖控制項中專案的周框。|
|[CListCtrl：： GetTextBkColor](#gettextbkcolor)|抓取清單視圖控制項的文字背景色彩。|
|[CListCtrl：： GetTextColor](#gettextcolor)|抓取清單視圖控制項的文字色彩。|
|[CListCtrl：： GetTileInfo](#gettileinfo)|在清單視圖控制項中抓取磚的相關資訊。|
|[CListCtrl：： GetTileViewInfo](#gettileviewinfo)|在磚視圖中抓取清單視圖控制項的相關資訊。|
|[CListCtrl：： GetToolTips](#gettooltips)|抓取清單視圖控制項用來顯示工具提示的工具提示控制項。|
|[CListCtrl：： GetTopIndex](#gettopindex)|抓取最上方可見專案的索引。|
|[CListCtrl：： GetView](#getview)|取得清單視圖控制項的視圖。|
|[CListCtrl：： GetViewRect](#getviewrect)|抓取清單視圖控制項中所有專案的周框。|
|[CListCtrl：： GetWorkAreas](#getworkareas)|抓取清單視圖控制項的目前工作區域。|
|[CListCtrl：： HasGroup](#hasgroup)|判斷清單視圖控制項是否有指定的群組。|
|[CListCtrl：： HitTest](#hittest)|判斷哪個清單視圖專案位於指定的位置。|
|[CListCtrl：： InsertColumn](#insertcolumn)|在清單視圖控制項中插入新的資料行。|
|[CListCtrl：： InsertGroup](#insertgroup)|將群組插入清單視圖控制項中。|
|[CListCtrl：： InsertGroupSorted](#insertgroupsorted)|將指定的群組插入群組的已排序清單中。|
|[CListCtrl：： InsertItem](#insertitem)|在清單視圖控制項中插入新專案。|
|[CListCtrl：： InsertMarkHitTest](#insertmarkhittest)|抓取最接近指定點的插入點。|
|[CListCtrl：： IsGroupViewEnabled](#isgroupviewenabled)|決定是否為清單視圖控制項啟用群組視圖。|
|[CListCtrl：： IsItemVisible](#isitemvisible)|指出目前清單視圖控制項中的指定專案是否可見。|
|[CListCtrl：： MapIDToIndex](#mapidtoindex)|將目前清單視圖控制項中專案的唯一識別碼對應至索引。|
|[CListCtrl：： MapIndexToID](#mapindextoid)|將目前清單視圖控制項中專案的索引對應到唯一的識別碼。|
|[CListCtrl：： MoveGroup](#movegroup)|移動指定的群組。|
|[CListCtrl：： MoveItemToGroup](#moveitemtogroup)|將指定的群組移至清單視圖控制項的指定之以零為基底的索引。|
|[CListCtrl：： RedrawItems](#redrawitems)|強制清單視圖控制項重新繪製某個範圍的專案。|
|[CListCtrl：： RemoveAllGroups](#removeallgroups)|從清單視圖控制項移除所有群組。|
|[CListCtrl：： RemoveGroup](#removegroup)|從清單視圖控制項中移除指定的群組。|
|[CListCtrl：： Scroll](#scroll)|滾動清單視圖控制項的內容。|
|[CListCtrl：： SetBkColor](#setbkcolor)|設定清單視圖控制項的背景色彩。|
|[CListCtrl：： SetBkImage](#setbkimage)|設定清單視圖控制項的目前背景影像。|
|[CListCtrl：： SetCallbackMask](#setcallbackmask)|設定清單視圖控制項的回呼遮罩。|
|[CListCtrl：： SetCheck](#setcheck)|設定與專案相關聯之狀態影像的目前顯示狀態。|
|[CListCtrl：： SetColumn](#setcolumn)|設定清單視圖資料行的屬性。|
|[CListCtrl：： SetColumnOrderArray](#setcolumnorderarray)|設定清單視圖控制項的資料行順序（由左到右）。|
|[CListCtrl：： SetColumnWidth](#setcolumnwidth)|在報表檢視或清單視圖中變更資料行的寬度。|
|[CListCtrl：： SetExtendedStyle](#setextendedstyle)|設定清單視圖控制項的目前擴充樣式。|
|[CListCtrl：： SetGroupInfo](#setgroupinfo)|設定清單視圖控制項之指定群組的資訊。|
|[CListCtrl：： SetGroupMetrics](#setgroupmetrics)|設定清單視圖控制項的群組計量。|
|[CListCtrl：： SetHotCursor](#sethotcursor)|設定針對清單視圖控制項啟用熱追蹤時所使用的資料指標。|
|[CListCtrl：： SetHotItem](#sethotitem)|設定清單視圖控制項的目前作用中專案。|
|[CListCtrl：： SetHoverTime](#sethovertime)|設定清單視圖控制項的目前停留時間。|
|[CListCtrl：： SetIconSpacing](#seticonspacing)|設定清單視圖控制項中圖示之間的間距。|
|[CListCtrl：： SetImageList](#setimagelist)|將影像清單指派給清單視圖控制項。|
|[CListCtrl：： SetInfoTip](#setinfotip)|設定工具提示文字。|
|[CListCtrl：： SetInsertMark](#setinsertmark)|將插入點設定為已定義的位置。|
|[CListCtrl：： SetInsertMarkColor](#setinsertmarkcolor)|設定插入點的色彩。|
|[CListCtrl：： SetItem](#setitem)|設定部分或所有清單視圖專案的屬性。|
|[CListCtrl：： SetItemCount](#setitemcount)|準備清單視圖控制項以加入大量專案。|
|[CListCtrl：： SetItemCountEx](#setitemcountex)|設定虛擬清單視圖控制項的專案計數。|
|[CListCtrl：： SetItemData](#setitemdata)|設定專案的應用程式特定值。|
|[CListCtrl：： SetItemIndexState](#setitemindexstate)|設定目前清單視圖控制項中專案的狀態。|
|[CListCtrl：： SetItemPosition](#setitemposition)|將專案移至清單視圖控制項中的指定位置。|
|[CListCtrl：： SetItemState](#setitemstate)|變更清單視圖控制項中專案的狀態。|
|[CListCtrl：： SetItemText](#setitemtext)|變更清單視圖專案或子項的文字。|
|[CListCtrl：： SetOutlineColor](#setoutlinecolor)|設定清單視圖控制項的框線色彩。|
|[CListCtrl：： SetSelectedColumn](#setselectedcolumn)|設定清單視圖控制項的選取資料行。|
|[CListCtrl：： SetSelectionMark](#setselectionmark)|設定清單視圖控制項的選取標記。|
|[CListCtrl：： SetTextBkColor](#settextbkcolor)|設定清單視圖控制項中文字的背景色彩。|
|[CListCtrl：： SetTextColor](#settextcolor)|設定清單視圖控制項的文字色彩。|
|[CListCtrl：： SetTileInfo](#settileinfo)|設定清單視圖控制項磚的資訊。|
|[CListCtrl：： SetTileViewInfo](#settileviewinfo)|設定清單視圖控制項在磚視圖中使用的資訊。|
|[CListCtrl：： SetToolTips](#settooltips)|設定清單視圖控制項將用來顯示工具提示的工具提示控制項。|
|[CListCtrl：： SetView](#setview)|設定清單視圖控制項的視圖。|
|[CListCtrl：： SetWorkAreas](#setworkareas)|設定可以在清單視圖控制項中顯示圖示的區域。|
|[CListCtrl：： SortGroups](#sortgroups)|使用使用者定義函數排序清單視圖控制項的群組。|
|[CListCtrl：： SortItems](#sortitems)|使用應用程式定義的比較函數排序清單視圖專案。|
|[CListCtrl：： SortItemsEx](#sortitemsex)|使用應用程式定義的比較函數排序清單視圖專案。|
|[CListCtrl：： SubItemHitTest](#subitemhittest)|判斷哪個清單視圖專案（如果有的話）位於指定的位置。|
|[CListCtrl：： Update](#update)|強制控制項重新繪製指定的專案。|

## <a name="remarks"></a>備註

除了 [圖示] 和 [標籤] 之外，每個專案都可以在圖示和標籤右邊的資料行中顯示資訊。 這個控制項（因此 `CListCtrl` 類別）僅適用于在 Windows 95/98 和 Windows NT 3.51 版和更新版本下執行的程式。

以下是 `CListCtrl` 類別的簡要總覽。 如需詳細的概念性討論，請參閱[使用 CListCtrl](../../mfc/using-clistctrl.md)和[控制項](../../mfc/controls-mfc.md)。

## <a name="views"></a>檢視

清單視圖控制項可以用四種不同的方式來顯示其內容，稱為「views」。

- 圖示視圖

   每個專案都會顯示為完整大小的圖示（32 x 32 圖元），其下方會加上標籤。 使用者可以將專案拖曳至 [清單] 視圖視窗中的任何位置。

- 小型圖示視圖

   每個專案都會顯示為小圖示（16 x 16 圖元），且標籤位於其右邊。 使用者可以將專案拖曳至 [清單] 視圖視窗中的任何位置。

- [清單] 檢視

   每個專案都會顯示為一個小圖示，並在其右邊加上標籤。 專案會以資料行排列，而且無法拖曳至 [清單] 視圖視窗中的任何位置。

- 報表檢視

   每個專案都會出現在自己的行中，而其他資訊則會排列在右邊的欄位中。 最左邊的資料行包含小型圖示和標籤，而後續的資料行則包含應用程式所指定的子標題。 內嵌的標題控制項（類別[CHeaderCtrl](../../mfc/reference/cheaderctrl-class.md)）會執行這些資料行。 如需報表檢視中標題控制項和資料行的詳細資訊，請參閱[使用 CListCtrl：將資料行加入至控制項（報表檢視）](../../mfc/adding-columns-to-the-control-report-view.md)。

控制項目前清單視圖的樣式會決定目前的視圖。 如需這些樣式和其使用方式的詳細資訊，請參閱[使用 CListCtrl：變更清單控制項樣式](../../mfc/changing-list-control-styles.md)。

## <a name="extended-styles"></a>延伸樣式

除了標準清單樣式以外，類別 `CListCtrl` 支援一組大型的擴充樣式，提供豐富的功能。 這項功能的一些範例包括：

- 暫留選取範圍

   啟用時，可在游標停留在一段特定時間的專案上時，允許自動選取專案。

- 虛擬清單視圖

   啟用時，可讓控制項支援最多 DWORD 專案。 藉由將管理專案資料的額外負荷放在應用程式上，即可達成此目的。 除了專案選取和焦點資訊以外，所有專案資訊都必須由應用程式管理。 如需詳細資訊，請參閱[使用 CListCtrl：虛擬清單控制項](../../mfc/virtual-list-controls.md)。

- 單鍵啟用和按兩次啟動

   啟用時，可讓您進行熱追蹤（專案文字的自動反白顯示），以及一或兩次按一下醒目提示專案的啟用。

- 拖放資料行順序

   啟用時，可讓您在清單視圖控制項中，資料行的拖放重新排列順序。 僅適用于報表檢視。

如需使用這些新擴充樣式的詳細資訊，請參閱[使用 CListCtrl：變更清單控制項樣式](../../mfc/changing-list-control-styles.md)。

## <a name="items-and-subitems"></a>專案和子項

清單視圖控制項中的每個專案都包含一個圖示（來自影像清單）、一個標籤、一個目前的狀態，以及一個應用程式定義的值（稱為「專案資料」）。 一個或多個子專案也可以與每個專案相關聯。 「子專案」是一種字串，在報表檢視中，可以顯示在專案圖示和標籤右邊的資料行中。 清單視圖控制項中的所有專案都必須有相同數目的子項。

類別 `CListCtrl` 提供數個函式來插入、刪除、尋找和修改這些專案。 如需詳細資訊，請參閱[CListCtrl：： GetItem](#getitem)、 [CListCtrl：： InsertItem](#insertitem)和[CListCtrl：： FindItem](#finditem)、[將專案新增至控制項](../adding-items-to-the-control.md)，以及[在清單控制項中進行滾動、排列、排序和尋找](../scrolling-arranging-sorting-and-finding-in-list-controls.md)。

根據預設，清單視圖控制項會負責儲存專案的圖示和文字屬性。 不過，除了這些專案類型以外，類別 `CListCtrl` 支援「回呼專案」。 「回呼專案」是一種清單視圖專案，應用程式（而不是控制項）會儲存文字、圖示或兩者。 回呼遮罩是用來指定應用程式所提供的專案屬性（文字和/或圖示）。 如果應用程式使用回呼專案，它必須能夠視需要提供文字和/或圖示屬性。 當您的應用程式已經維護部分資訊時，回呼專案會很有説明。 如需詳細資訊，請參閱[使用 CListCtrl：回呼專案和回呼遮罩](../callback-items-and-the-callback-mask.md)。

## <a name="image-lists"></a>影像清單

清單視圖專案的圖示、標題專案影像和應用程式定義的狀態會包含在數個影像清單中（由類別[CImageList](cimagelist-class.md)實作為），您可以建立並指派給清單視圖控制項。 每個清單視圖控制項最多可以有四種不同類型的影像清單：

- 大圖示

   用於完整大小圖示的圖示視圖中。

- 小圖示

   用於圖示視圖中所用圖示較小版本的小型圖示、清單和報表檢視。

- 應用程式定義的狀態

   包含狀態影像，會顯示在專案圖示旁，以指示應用程式定義的狀態。

- 標頭項目

   用於報表檢視中，顯示在每個標題控制項專案中的小型影像。

根據預設，清單視圖控制項會終結在終結時指派給它的影像清單;不過，開發人員可以自訂此行為，方法是在不再使用每個影像清單時予以終結，如同應用程式所決定。 如需詳細資訊，請參閱[使用 CListCtrl：清單專案和影像清單](../list-items-and-image-lists.md)。

## <a name="inheritance-hierarchy"></a>繼承階層

[CObject](cobject-class.md)

[CCmdTarget](ccmdtarget-class.md)

[CWnd](cwnd-class.md)

`CListCtrl`

## <a name="requirements"></a>需求

**標頭：** afxcmn.h

## <a name="approximateviewrect"></a>CListCtrl：： ApproximateViewRect

決定顯示清單視圖控制項之專案所需的寬度和高度。

```
CSize ApproximateViewRect(
    CSize sz = CSize(-1, -1),
    int iCount = -1) const;
```

### <a name="parameters"></a>參數

*sz*<br/>
控制項的建議維度（以圖元為單位）。 如果未指定維度，架構會使用控制項目前的寬度或高度值。

*iCount*<br/>
要顯示在控制項中的專案數。 如果此參數為-1，則架構會使用目前在控制項中的總專案數。

### <a name="return-value"></a>傳回值

`CSize` 物件，其中包含顯示專案所需的大約寬度和高度（以圖元為單位）。

### <a name="remarks"></a>備註

此成員函式會依照 Windows SDK 中的說明，實作用[ListView_ApproximateViewRect](/windows/win32/api/commctrl/nf-commctrl-listview_approximateviewrect)Win32 宏的行為。

## <a name="arrange"></a>CListCtrl：：排列

重新置放圖示視圖中的專案，使其對齊方格。

```
BOOL Arrange(UINT nCode);
```

### <a name="parameters"></a>參數

*nCode*<br/>
指定專案的對齊樣式。 它可能是下列其中一個值：

- LVA_ALIGNLEFT 會沿著視窗的左邊緣對齊專案。

- LVA_ALIGNTOP 會沿著視窗的上邊緣對齊專案。

- LVA_DEFAULT 根據清單視圖的目前對齊樣式（預設值）對齊專案。

- LVA_SNAPTOGRID 將所有圖示貼齊最接近的格線位置。

### <a name="return-value"></a>傳回值

如果成功則不為零，否則為 0。

### <a name="remarks"></a>備註

*NCode*參數會指定對齊樣式。

### <a name="example"></a>範例

```cpp
    // Align all of the list view control items along the top
    // of the window (the list view control must be in icon or
    // small icon mode).
    m_myListCtrl.Arrange(LVA_ALIGNTOP);
```

## <a name="canceleditlabel"></a>CListCtrl：： CancelEditLabel

取消專案文字編輯作業。

```
void CancelEditLabel();
```

### <a name="remarks"></a>備註

此成員函式會模擬[LVM_CANCELEDITLABEL](/windows/win32/Controls/lvm-canceleditlabel)訊息的功能，如 Windows SDK 中所述。

## <a name="clistctrl"></a>CListCtrl：： CListCtrl

建構 `CListCtrl` 物件。

```
CListCtrl();
```

## <a name="create"></a>CListCtrl：： Create

建立清單控制項，並將它附加至 `CListCtrl` 物件。

```
virtual BOOL Create(
    DWORD dwStyle,
    const RECT& rect,
    CWnd* pParentWnd,
    UINT nID);
```

### <a name="parameters"></a>參數

*dwStyle*<br/>
指定清單控制項的樣式。 將清單控制項樣式的任何組合套用至控制項。 如需這些樣式的完整清單，請參閱 Windows SDK 中的[清單視圖視窗樣式](/windows/win32/Controls/list-view-window-styles)。 使用[SetExtendedStyle](#setextendedstyle)設定控制項特定的擴充樣式。

*各種*<br/>
指定清單控制項的大小和位置。 它可以是 `CRect` 物件或[矩形](/previous-versions/dd162897\(v=vs.85\))結構。

*pParentWnd*<br/>
指定清單控制項的父視窗，通常是 `CDialog`。 它不得為 NULL。

*nID*<br/>
指定清單控制項的識別碼。

### <a name="return-value"></a>傳回值

如果成功則不為零，否則為 0。

### <a name="remarks"></a>備註

您可以使用兩個步驟來建立 `CListCtrl`。 首先，呼叫此函式，然後呼叫 `Create`，這會建立清單視圖控制項並將其附加至 `CListCtrl` 物件。

若要將擴充的 Windows 樣式套用至清單控制項物件，請呼叫[CreateEx](#createex) ，而不是 `Create`。

### <a name="example"></a>範例

```cpp
    m_myListCtrl.Create(
        WS_CHILD|WS_VISIBLE|WS_BORDER|LVS_REPORT|LVS_EDITLABELS,
        CRect(10,10,400,200), pParentWnd, IDD_MYLISTCTRL);
```

## <a name="createex"></a>CListCtrl：： CreateEx

建立控制項（子視窗），並將它與 `CListCtrl` 物件產生關聯。

```
virtual BOOL CreateEx(
    DWORD dwExStyle,
    DWORD dwStyle,
    const RECT& rect,
    CWnd* pParentWnd,
    UINT nID);
```

### <a name="parameters"></a>參數

*dwExStyle*<br/>
指定所要建立之控制項的延伸樣式。 如需擴充 Windows 樣式的清單，請參閱 Windows SDK 中[CreateWindowEx](/windows/win32/api/winuser/nf-winuser-createwindowexw)的*dwExStyle*參數。

*dwStyle*<br/>
指定清單控制項的樣式。 將清單控制項樣式的任何組合套用至控制項。 如需這些樣式的完整清單，請參閱 Windows SDK 中的[清單視圖視窗樣式](/windows/win32/Controls/list-view-window-styles)。

*各種*<br/>
[矩形](/previous-versions/dd162897\(v=vs.85\))結構的參考，描述要建立之視窗的大小和位置，以*pParentWnd*的用戶端座標表示。

*pParentWnd*<br/>
做為控制項父系之視窗的指標。

*nID*<br/>
控制項的子視窗識別碼。

### <a name="return-value"></a>傳回值

如果成功則為非零；否則為 0。

### <a name="remarks"></a>備註

使用 `CreateEx` 而非[Create](#create)來套用擴充的 windows 樣式（由 Windows 擴充樣式指定于**WS_EX_** 的前面）。

`CreateEx` 會使用*dwExStyle*所指定的擴充 Windows 樣式來建立控制項。 若要設定控制項特定的擴充樣式，請呼叫[SetExtendedStyle](#setextendedstyle)。 例如，使用 `CreateEx` 將這類樣式設定為 WS_EX_CONTEXTHELP，但使用 `SetExtendedStyle` 將這類樣式設定為 LVS_EX_FULLROWSELECT。 如需詳細資訊，請參閱 Windows SDK 中的[擴充清單視圖樣式](/windows/win32/Controls/extended-list-view-styles)一文中所述的樣式。

## <a name="createdragimage"></a>CListCtrl：： CreateDragImage

為*nItem*所指定的專案建立拖曳影像清單。

```
CImageList* CreateDragImage(
    int nItem,
    LPPOINT lpPoint);
```

### <a name="parameters"></a>參數

*nItem*<br/>
要建立其拖曳影像清單之專案的索引。

*lpPoint*<br/>
[點](/previous-versions/dd162805\(v=vs.85\))結構的位址，會接收影像左上角的起始位置（以視圖座標表示）。

### <a name="return-value"></a>傳回值

如果成功，則為拖曳影像清單的指標;否則為 Null。

### <a name="remarks"></a>備註

`CImageList` 物件是永久的，您必須在完成時將它刪除。 例如，

```cpp
        CImageList* pImageList = m_myListCtrl.CreateDragImage(nItem, &point);

        // do something

        delete pImageList;
```

## <a name="deleteallitems"></a>CListCtrl：:D eleteAllItems

刪除清單視圖控制項中的所有專案。

```
BOOL DeleteAllItems();
```

### <a name="return-value"></a>傳回值

如果成功則不為零，否則為 0。

### <a name="example"></a>範例

```cpp
    // Delete all of the items from the list view control.
    m_myListCtrl.DeleteAllItems();
    ASSERT(m_myListCtrl.GetItemCount() == 0);
```

## <a name="deletecolumn"></a>CListCtrl：:D eleteColumn

刪除清單視圖控制項中的資料行。

```
BOOL DeleteColumn(int nCol);
```

### <a name="parameters"></a>參數

*nCol*<br/>
要刪除之資料行的索引。

### <a name="return-value"></a>傳回值

如果成功則不為零，否則為 0。

### <a name="example"></a>範例

```cpp
        int nColumnCount = m_myListCtrl.GetHeaderCtrl()->GetItemCount();

        // Delete all of the columns.
        for (int i=0; i < nColumnCount; i++)
        {
            m_myListCtrl.DeleteColumn(0);
        }
```

## <a name="deleteitem"></a>CListCtrl：:D eleteItem

從清單視圖控制項中刪除專案。

```
BOOL DeleteItem(int nItem);
```

### <a name="parameters"></a>參數

*nItem*<br/>
指定要刪除之專案的索引。

### <a name="return-value"></a>傳回值

如果成功則不為零，否則為 0。

### <a name="example"></a>範例

```cpp
        int nCount = m_myListCtrl.GetItemCount();

        // Delete all of the items from the list view control.
        for (int i=0; i < nCount; i++)
        {
            m_myListCtrl.DeleteItem(0);
        }
```

## <a name="drawitem"></a>CListCtrl：:D rawItem

當主控描繪清單視圖控制項的視覺外觀變更時，由架構呼叫。

```
virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
```

### <a name="parameters"></a>參數

*lpDrawItemStruct*<br/>
`DRAWITEMSTRUCT` 結構的長指標，其中包含所需繪圖類型的相關資訊。

### <a name="remarks"></a>備註

[DRAWITEMSTRUCT](/windows/win32/api/winuser/ns-winuser-drawitemstruct)結構的 `itemAction` 成員會定義要執行的繪圖動作。

根據預設，此成員函式不會執行任何工作。 覆寫這個成員函式，以針對主控描繪 `CListCtrl` 物件來執行繪製。

在此成員函式終止之前，應用程式應該還原為*lpDrawItemStruct*中提供的顯示內容所選取的所有圖形裝置介面（GDI）物件。

## <a name="editlabel"></a>CListCtrl：： EditLabel

開始就地編輯專案的文字。

```
CEdit* EditLabel(int nItem);
```

### <a name="parameters"></a>參數

*nItem*<br/>
要編輯之清單視圖專案的索引。

### <a name="return-value"></a>傳回值

如果成功，則為用來編輯專案文字之 `CEdit` 物件的指標;否則為 Null。

### <a name="remarks"></a>備註

具有 [LVS_EDITLABELS] 視窗樣式的清單視圖控制項可讓使用者就地編輯專案標籤。 使用者按一下具有焦點之專案的標籤，開始編輯。

使用此函式可開始就地編輯指定的清單視圖專案文字。

### <a name="example"></a>範例

```cpp
        // Make sure the focus is set to the list view control.
        m_myListCtrl.SetFocus();

        // Show the edit control on the label of the first
        // item in the list view control.
        CEdit* pmyEdit = m_myListCtrl.EditLabel(1);
        ASSERT(pmyEdit != NULL);
```

## <a name="enablegroupview"></a>CListCtrl：： EnableGroupView

啟用或停用清單視圖控制項中的專案是否顯示為群組。

```
LRESULT EnableGroupView(BOOL fEnable);
```

### <a name="parameters"></a>參數

*fEnable*<br/>
指出是否要啟用 listview 控制項來分組顯示的專案。 TRUE 表示啟用群組;FALSE 表示停用它。

### <a name="return-value"></a>傳回值

傳回下列其中一值：

- **0**將清單視圖專案顯示為群組的功能已啟用或停用。

- **1**控制項的狀態已成功變更。

- **-1**作業失敗。

### <a name="remarks"></a>備註

此成員函式會模擬[LVM_ENABLEGROUPVIEW](/windows/win32/Controls/lvm-enablegroupview)訊息的功能，如 Windows SDK 中所述。

## <a name="ensurevisible"></a>CListCtrl：： EnsureVisible

確保清單視圖專案至少是部分可見的。

```
BOOL EnsureVisible(
    int nItem,
    BOOL bPartialOK);
```

### <a name="parameters"></a>參數

*nItem*<br/>
要顯示之清單視圖專案的索引。

*bPartialOK*<br/>
指定是否可接受部分可見度。

### <a name="return-value"></a>傳回值

如果成功則不為零，否則為 0。

### <a name="remarks"></a>備註

必要時，會滾動清單視圖控制項。 如果*bPartialOK*參數不是零，則如果專案是部分可見的，就不會發生任何滾動。

### <a name="example"></a>範例

```cpp
        // Ensure that the last item is visible.
        int nCount = m_myListCtrl.GetItemCount();
        if (nCount > 0)
            m_myListCtrl.EnsureVisible(nCount-1, FALSE);
```

## <a name="finditem"></a>CListCtrl：： FindItem

搜尋具有指定特性的清單視圖專案。

```
int FindItem(
    LVFINDINFO* pFindInfo,
    int nStart = -1) const;
```

### <a name="parameters"></a>參數

*pFindInfo*<br/>
[LVFINDINFO](/windows/win32/api/commctrl/ns-commctrl-lvfindinfow)結構的指標，其中包含要搜尋之專案的相關資訊。

*N 開始*<br/>
要開始搜尋的專案索引，或-1 表示從開頭開始。 如果*n 開始*不等於-1， *n 開始*中的專案會從搜尋中排除。

### <a name="return-value"></a>傳回值

如果成功，則為專案的索引，否則為-1。

### <a name="remarks"></a>備註

*PFindInfo*參數會指向 `LVFINDINFO` 結構，其中包含用來搜尋清單視圖專案的資訊。

### <a name="example"></a>範例

```cpp
        LVFINDINFO info;
        int nIndex;

        info.flags = LVFI_PARTIAL|LVFI_STRING;
        info.psz = _T("item");

        // Delete all of the items that begin with the string.
        while ((nIndex = m_myListCtrl.FindItem(&info)) != -1)
        {
            m_myListCtrl.DeleteItem(nIndex);
        }
```

## <a name="getbkcolor"></a>CListCtrl：： GetBkColor

抓取清單視圖控制項的背景色彩。

```
COLORREF GetBkColor() const;
```

### <a name="return-value"></a>傳回值

32位值，用來指定 RGB 色彩。

### <a name="example"></a>範例

請參閱[CListCtrl：： SetBkColor](#setbkcolor)的範例。

## <a name="getbkimage"></a>CListCtrl：： GetBkImage

抓取清單視圖控制項的目前背景影像。

```
BOOL GetBkImage(LVBKIMAGE* plvbkImage) const;
```

### <a name="parameters"></a>參數

*plvbkImage*<br/>
`LVBKIMAGE` 結構的指標，其中包含清單視圖的目前背景影像。

### <a name="return-value"></a>傳回值

如果成功，則傳回非零，否則會傳回零。

### <a name="remarks"></a>備註

這個方法會依照 Windows SDK 中的說明，執行 Win32 宏的行為[ListView_GetBkImage](/windows/win32/api/commctrl/nf-commctrl-listview_getbkimage)。

### <a name="example"></a>範例

```cpp
        LVBKIMAGE bki;

        // If no background image is set for the list view control use
        // the Microsoft homepage image as the background image.
        if (m_myListCtrl.GetBkImage(&bki) && (bki.ulFlags == LVBKIF_SOURCE_NONE))
        {
            m_myListCtrl.SetBkImage(
                _T("https://www.microsoft.com/library/images/gifs/homepage/microsoft.gif"),
                TRUE);
        }
```

## <a name="getcallbackmask"></a>CListCtrl：： GetCallbackMask

抓取清單視圖控制項的回呼遮罩。

```
UINT GetCallbackMask() const;
```

### <a name="return-value"></a>傳回值

清單視圖控制項的回呼遮罩。

### <a name="remarks"></a>備註

「回呼專案」是一種清單視圖專案，應用程式（而不是控制項）會儲存文字、圖示或兩者。 雖然清單視圖控制項可以為您儲存這些屬性，但如果您的應用程式已經維護這部分資訊，您可能會想要使用回呼專案。 回呼遮罩會指定應用程式所維護的專案狀態位，而且它會套用至整個控制項，而不是特定專案。 回呼遮罩預設為零，表示控制項正在追蹤所有項目的狀態。 如果應用程式使用回呼專案，或指定非零的回呼遮罩，它必須能夠視需要提供清單視圖專案屬性。

### <a name="example"></a>範例

請參閱[CListCtrl：： SetCallbackMask](#setcallbackmask)的範例。

## <a name="getcheck"></a>CListCtrl：： GetCheck

抓取與專案相關聯之狀態影像的目前顯示狀態。

```
BOOL GetCheck(int nItem) const;
```

### <a name="parameters"></a>參數

*nItem*<br/>
清單控制項專案之以零為基底的索引。

### <a name="return-value"></a>傳回值

如果已選取專案，則為非零，否則為0。

### <a name="remarks"></a>備註

此成員函式會依照 Windows SDK 中的說明，實作用[ListView_GetCheckState](/windows/win32/api/commctrl/nf-commctrl-listview_getcheckstate)Win32 宏的行為。

### <a name="example"></a>範例

請參閱[CListCtrl：： SetCheck](#setcheck)的範例。

## <a name="getcolumn"></a>CListCtrl：： GetColumn

抓取清單視圖控制項的資料行屬性。

```
BOOL GetColumn(
    int nCol,
    LVCOLUMN* pColumn) const;
```

### <a name="parameters"></a>參數

*nCol*<br/>
要抓取其屬性之資料行的索引。

*pColumn*<br/>
[LVCOLUMN](/windows/win32/api/commctrl/ns-commctrl-lvcolumnw)結構的位址，指定用來抓取和接收資料行相關資訊的資訊。 `mask` 成員會指定要取得的資料行屬性。 如果 `mask` 成員指定 LVCF_TEXT 值，則 `pszText` 成員必須包含接收專案文字的緩衝區位址，而且 `cchTextMax` 成員必須指定緩衝區的大小。

### <a name="return-value"></a>傳回值

如果成功則不為零，否則為 0。

### <a name="remarks"></a>備註

`LVCOLUMN` 結構包含報表檢視中資料行的相關資訊。

### <a name="example"></a>範例

```cpp
        LVCOLUMN col;

        col.mask = LVCF_WIDTH;

        // Double the column width of the first column.
        if (m_myListCtrl.GetColumn(0, &col))
        {
            col.cx *= 2;
            m_myListCtrl.SetColumn(0, &col);
        }
```

## <a name="getcolumnorderarray"></a>CListCtrl：： GetColumnOrderArray

抓取清單視圖控制項的資料行順序（由左到右）。

```
BOOL GetColumnOrderArray(
    LPINT piArray,
    int iCount = -1);
```

### <a name="parameters"></a>參數

*piArray*<br/>
緩衝區的指標，將包含清單視圖控制項中資料行的索引值。 緩衝區必須夠大，才能包含清單視圖控制項中的總數據行數。

*iCount*<br/>
清單視圖控制項中的資料行數目。 如果此參數為-1，則架構會自動抓取資料行數目。

### <a name="return-value"></a>傳回值

如果成功則不為零，否則為 0。

### <a name="remarks"></a>備註

此成員函式會依照 Windows SDK 中的說明，實作用[ListView_GetColumnOrderArray](/windows/win32/api/commctrl/nf-commctrl-listview_getcolumnorderarray)Win32 宏的行為。

### <a name="example"></a>範例

```cpp
        // Reverse the order of the columns in the list view control
        // (i.e. make the first column the last, the last column
        // the first, and so on...).
        CHeaderCtrl* pHeaderCtrl = m_myListCtrl.GetHeaderCtrl();

        if (pHeaderCtrl != NULL)
        {
            int  nColumnCount = pHeaderCtrl->GetItemCount();
            LPINT pnOrder = (LPINT) malloc(nColumnCount*sizeof(int));
            ASSERT(pnOrder != NULL);
            m_myListCtrl.GetColumnOrderArray(pnOrder, nColumnCount);

            int i, j, nTemp;
            for (i = 0, j = nColumnCount-1; i < j; i++, j--)
            {
                nTemp = pnOrder[i];
                pnOrder[i] = pnOrder[j];
                pnOrder[j] = nTemp;
            }

            m_myListCtrl.SetColumnOrderArray(nColumnCount, pnOrder);
            free(pnOrder);
        }
```

## <a name="getcolumnwidth"></a>CListCtrl：： GetColumnWidth

抓取報表檢視或清單視圖中資料行的寬度。

```
int GetColumnWidth(int nCol) const;
```

### <a name="parameters"></a>參數

*nCol*<br/>
指定要抓取其寬度之資料行的索引。

### <a name="return-value"></a>傳回值

*NCol*所指定之資料行的寬度（以圖元為單位）。

### <a name="example"></a>範例

```cpp
        // Increase the column width of the second column by 20.
        int nWidth = m_myListCtrl.GetColumnWidth(1);
        m_myListCtrl.SetColumnWidth(1, 20 + nWidth);
```

## <a name="getcountperpage"></a>CListCtrl：： GetCountPerPage

計算在清單視圖或報表檢視中，清單視圖控制項的可見區域中可以垂直調整的專案數。

```
int GetCountPerPage() const;
```

### <a name="return-value"></a>傳回值

在清單視圖或報表檢視中，清單視圖控制項的可見區域中可垂直調整的專案數。

### <a name="example"></a>範例

請參閱[CListCtrl：： GetTopIndex](#gettopindex)的範例。

## <a name="geteditcontrol"></a>CListCtrl：： GetEditControl

抓取編輯控制項的控制碼，用來編輯清單視圖專案的文字。

```
CEdit* GetEditControl() const;
```

### <a name="return-value"></a>傳回值

如果成功，則為用來編輯專案文字之[CEdit](cedit-class.md)物件的指標;否則為 Null。

### <a name="example"></a>範例

```cpp
        // The string replacing the text in the edit control.
        LPCTSTR lpszmyString = _T("custom label!");

        // If possible, replace the text in the label edit control.
        CEdit* pEdit = m_myListCtrl.GetEditControl();

        if (pEdit != NULL)
        {
            pEdit->SetWindowText(lpszmyString);
        }
```

## <a name="getemptytext"></a>CListCtrl：： GetEmptyText

如果目前的清單視圖控制項是空的，則抓取要顯示的字串。

```
CString GetEmptyText() const;
```

### <a name="return-value"></a>傳回值

[CString](../../atl-mfc-shared/reference/cstringt-class.md) ，其中包含控制項是空的時要顯示的文字。

### <a name="remarks"></a>備註

這個方法會傳送[LVM_GETEMPTYTEXT](/windows/win32/Controls/lvm-getemptytext)訊息，如 Windows SDK 所述。

## <a name="getextendedstyle"></a>CListCtrl：： GetExtendedStyle

抓取清單視圖控制項的目前擴充樣式。

```
DWORD GetExtendedStyle();
```

### <a name="return-value"></a>傳回值

清單視圖控制項目前使用的擴充樣式組合。 如需這些擴充樣式的描述性清單，請參閱 Windows SDK 中的[擴充清單視圖樣式](/windows/win32/Controls/extended-list-view-styles)一文。

### <a name="remarks"></a>備註

此成員函式會依照 Windows SDK 中的說明，實作用[ListView_GetExtendedListViewStyle](/windows/win32/api/commctrl/nf-commctrl-listview_getextendedlistviewstyle)Win32 宏的行為。

### <a name="example"></a>範例

請參閱[CListCtrl：： SetExtendedStyle](#setextendedstyle)的範例。

## <a name="getfirstselecteditemposition"></a>CListCtrl：： GetFirstSelectedItemPosition

取得清單視圖控制項中第一個選取專案的位置。

```
POSITION GetFirstSelectedItemPosition() const;
```

### <a name="return-value"></a>傳回值

可用於反復專案或物件指標抓取的位置值;如果未選取任何專案，則為 Null。

### <a name="example"></a>範例

下列程式碼範例將示範此函式的使用方式。

```cpp
        POSITION pos = m_myListCtrl.GetFirstSelectedItemPosition();
        if (pos == NULL)
        {
            TRACE(_T("No items were selected!\n"));
        }
        else
        {
            while (pos)
            {
                int nItem = m_myListCtrl.GetNextSelectedItem(pos);
                TRACE(_T("Item %d was selected!\n"), nItem);
                // you could do your own processing on nItem here
            }
        }
```

## <a name="getfocusedgroup"></a>CListCtrl：： GetFocusedGroup

抓取目前清單視圖控制項中具有鍵盤焦點的群組。

```
int GetFocusedGroup() const;
```

### <a name="return-value"></a>傳回值

如果有這類群組，則為其狀態為 LVGS_FOCUSED 之群組的索引;否則為-1。

### <a name="remarks"></a>備註

這個方法會傳送[LVM_GETFOCUSEDGROUP](/windows/win32/Controls/lvm-getfocusedgroup)訊息，如 Windows SDK 所述。 如需詳細資訊，請參閱[LVGROUP](/windows/win32/api/commctrl/ns-commctrl-lvgroup)結構之 `state` 成員的 LVGS_FOCUSED 值。

## <a name="getgroupcount"></a>CListCtrl：： GetGroupCount

抓取目前清單視圖控制項中的群組數目。

```
int GetGroupCount()const;
```

### <a name="return-value"></a>傳回值

清單視圖控制項中的群組數目。

### <a name="remarks"></a>備註

這個方法會傳送[LVM_GETGROUPCOUNT](/windows/win32/Controls/lvm-getgroupcount)訊息，如 Windows SDK--> 中所述。

## <a name="getgroupinfo"></a>CListCtrl：： GetGroupInfo

取得清單視圖控制項之指定群組的資訊。

```
int GetGroupInfo(
    int iGroupId,
    PLVGROUP pgrp) const;
```

### <a name="parameters"></a>參數

*iGroupId*<br/>
要抓取其資訊之群組的識別碼。

*pgrp*<br/>
[LVGROUP](/windows/win32/api/commctrl/ns-commctrl-lvgroup)的指標，其中包含指定之群組的資訊。

### <a name="return-value"></a>傳回值

如果成功，則傳回群組的識別碼，否則傳回-1。

### <a name="remarks"></a>備註

此成員函式會模擬[LVM_GETGROUPINFO](/windows/win32/Controls/lvm-getgroupinfo)訊息的功能，如 Windows SDK 中所述。

## <a name="getgroupinfobyindex"></a>CListCtrl：： GetGroupInfoByIndex

抓取目前清單視圖控制項中指定之群組的相關資訊。

```
BOOL GetGroupInfoByIndex(
    int iIndex,
    PLVGROUP pGroup) const;
```

### <a name="parameters"></a>參數

|參數|描述|
|---------------|-----------------|
|*iIndex*|在以零為基底的群組索引。|
|*pGroup*|脫銷[LVGROUP](/windows/win32/api/commctrl/ns-commctrl-lvgroup)結構的指標，接收*iIndex*參數所指定之群組的相關資訊。<br /><br /> 呼叫端負責初始化[LVGROUP](/windows/win32/api/commctrl/ns-commctrl-lvgroup)結構的成員。 將 `cbSize` 成員設定為結構的大小，以及 `mask` 成員的旗標，以指定要取得的資訊。|

### <a name="return-value"></a>傳回值

如果此方法成功，則為 TRUE;否則為 FALSE。

### <a name="remarks"></a>備註

這個方法會傳送[LVM_GETGROUPINFOBYINDEX](/windows/win32/controls/lvm-getgroupinfobyindex)訊息，如 Windows SDK--> 中所述。

### <a name="example"></a>範例

下列程式碼範例會定義用來存取目前清單視圖控制項的變數 `m_listCtrl`。 下一個範例中會使用此變數。

```cpp
public:
    // Variable used to access the list control.
    CListCtrl m_listCtrl;
```

### <a name="example"></a>範例

下列程式碼範例示範 `GetGroupInfoByIndex` 方法。 在這個程式碼範例的先前章節中，我們建立了清單視圖控制項，它會在報表檢視中顯示兩個標題為 "ClientID" 和 "年級" 的資料行。 下列程式碼範例會抓取索引為0的群組相關資訊（如果有這類群組存在的話）。
```cpp
    // GetGroupInfoByIndex
    const int GROUP_HEADER_BUFFER_SIZE = 40;

// Initialize the structure
    LVGROUP gInfo = {0};
    gInfo.cbSize = sizeof(LVGROUP);
    wchar_t wstrHeadGet[GROUP_HEADER_BUFFER_SIZE] = {0};
    gInfo.cchHeader = GROUP_HEADER_BUFFER_SIZE;
    gInfo.pszHeader = wstrHeadGet;
    gInfo.mask = (LVGF_ALIGN | LVGF_STATE | LVGF_HEADER | LVGF_GROUPID);
    gInfo.state = LVGS_NORMAL;
    gInfo.uAlign  = LVGA_HEADER_LEFT;

    BOOL bRet = m_listCtrl.GetGroupInfoByIndex( 0, &gInfo );
    if (bRet == TRUE) {
        CString strHeader = CString( gInfo.pszHeader );
        CString str;
        str.Format(_T("Header: '%s'"), strHeader);
        AfxMessageBox(str, MB_ICONINFORMATION);
    }
    else
    {
        AfxMessageBox(_T("No group information was retrieved."));
    }
```

## <a name="getgroupmetrics"></a>CListCtrl：： GetGroupMetrics

抓取群組的計量。

```
void GetGroupMetrics(PLVGROUPMETRICS pGroupMetrics) const;
```

### <a name="parameters"></a>參數

*pGroupMetrics*<br/>
包含群組計量資訊之[LVGROUPMETRICS](/windows/win32/api/commctrl/ns-commctrl-lvgroupmetrics)的指標。

### <a name="remarks"></a>備註

此成員函式會模擬[LVM_GETGROUPMETRICS](/windows/win32/Controls/lvm-getgroupmetrics)訊息的功能，如 Windows SDK 中所述。

## <a name="getgrouprect"></a>CListCtrl：： GetGroupRect

抓取目前清單視圖控制項中指定群組的周框。

```
BOOL GetGroupRect(
    int iGroupId,
    LPRECT lpRect,
    int iCoords = LVGGR_GROUP) const;
```

### <a name="parameters"></a>參數

|參數|描述|
|---------------|-----------------|
|*iGroupId*|在指定群組。|
|*lpRect*|[in、out][RECT](/previous-versions/dd162897\(v=vs.85\))結構的指標。 如果此方法成功，結構會接收*iGroupId*所指定之群組的矩形座標。|
|*iCoords*|在指定要抓取的矩形座標。 使用下列其中一個值：<br /><br /> -LVGGR_GROUP-（預設值）整個展開群組的座標。<br />-LVGGR_HEADER-僅限標頭（折迭的群組）的座標。<br />-LVGGR_SUBSETLINK-僅限子集連結的座標（標記子集）。|

### <a name="return-value"></a>傳回值

如果此方法成功，則為 TRUE;否則為 FALSE。

### <a name="remarks"></a>備註

呼叫端負責配置*pRect*參數所指向的[矩形](/previous-versions/dd162897\(v=vs.85\))結構。

這個方法會傳送[LVM_GETGROUPRECT](/windows/win32/Controls/lvm-getgrouprect)訊息，如 Windows SDK 所述。

### <a name="example"></a>範例

下列程式碼範例會定義用來存取目前清單視圖控制項的變數 `m_listCtrl`。 下一個範例中會使用此變數。
```cpp
public:
    // Variable used to access the list control.
    CListCtrl m_listCtrl;
```

### <a name="example"></a>範例

下列程式碼範例示範 `GetGroupRect` 方法。 在這個程式碼範例的先前章節中，我們建立了清單視圖控制項，它會在報表檢視中顯示兩個標題為 "ClientID" 和 "年級" 的資料行。 下列程式碼範例會在其索引為0的群組周圍繪製3D 矩形（如果有這類群組存在的話）。

```cpp
    // GetGroupRect

    // Get the graphics rectangle that surrounds group 0.
    CRect rect;
    BOOL bRet = m_listCtrl.GetGroupRect( 0, &rect, LVGGR_GROUP);
    // Draw a blue rectangle around group 0.
    if (bRet == TRUE) {
        m_listCtrl.GetDC()->Draw3dRect( &rect, RGB(0, 0, 255), RGB(0, 0, 255));
    }
    else {
        AfxMessageBox(_T("No group information was retrieved."), MB_ICONINFORMATION);
    }
```

## <a name="getgroupstate"></a>CListCtrl：： GetGroupState

抓取目前清單視圖控制項中指定群組的狀態。

```
UINT GetGroupState(
    int iGroupId,
    DWORD dwMask) const;
```

### <a name="parameters"></a>參數

|參數|描述|
|---------------|-----------------|
|*iGroupId*|在以零為基底的群組索引。|
|*dwMask*|在遮罩，指定要針對指定的群組抓取的狀態值。 如需詳細資訊，請參閱[LVGROUP](/windows/win32/api/commctrl/ns-commctrl-lvgroup)結構的 `mask` 成員。|

### <a name="return-value"></a>傳回值

指定群組的要求狀態，如果找不到群組，則為0。

### <a name="remarks"></a>備註

傳回值是*dwMask*參數上位 and 運算的結果，以及代表目前清單視圖控制項的[LVGROUP](/windows/win32/api/commctrl/ns-commctrl-lvgroup)結構之 `state` 成員的值。

這個方法會傳送[LVM_GETGROUPSTATE](/windows/win32/Controls/lvm-getgroupstate)訊息，如 Windows SDK 所述。 如需詳細資訊，請參閱[ListView_GetGroupState](/windows/win32/api/commctrl/nf-commctrl-listview_getgroupstate)宏。

## <a name="getheaderctrl"></a>CListCtrl：： GetHeaderCtrl

抓取清單視圖控制項的標頭控制項。

```
CHeaderCtrl* GetHeaderCtrl();
```

### <a name="return-value"></a>傳回值

清單視圖控制項所使用之標頭控制項的指標。

### <a name="remarks"></a>備註

此成員函式會依照 Windows SDK 中的說明，實作用[ListView_GetHeader](/windows/win32/api/commctrl/nf-commctrl-listview_getheader)Win32 宏的行為。

### <a name="example"></a>範例

請參閱[CListCtrl：： GetColumnOrderArray](#getcolumnorderarray)的範例。

## <a name="gethotcursor"></a>CListCtrl：： GetHotCursor

當啟用清單視圖控制項的熱追蹤時，抓取使用的資料指標。

```
HCURSOR GetHotCursor();
```

### <a name="return-value"></a>傳回值

清單視圖控制項正在使用之目前作用中資料指標資源的控制碼。

### <a name="remarks"></a>備註

此成員函式會依照 Windows SDK 中的說明，實作用[ListView_GetHotCursor](/windows/win32/api/commctrl/nf-commctrl-listview_gethotcursor)Win32 宏的行為。 當游標通過任何清單視圖專案時，就會出現作用中游標，只有在啟用 [暫留選取] 時才會顯示。 藉由設定 LVS_EX_TRACKSELECT 擴充樣式來啟用暫留選取。

### <a name="example"></a>範例

```cpp
        // Set the hot cursor to be the system app starting cursor.
        HCURSOR hCursor = ::LoadCursor(NULL, IDC_APPSTARTING);
        m_myListCtrl.SetHotCursor(hCursor);
        ASSERT(m_myListCtrl.GetHotCursor() == hCursor);
```

## <a name="gethotitem"></a>CListCtrl：： GetHotItem

抓取目前游標下的清單視圖專案。

```
int GetHotItem();
```

### <a name="return-value"></a>傳回值

清單視圖控制項的目前作用中專案的索引。

### <a name="remarks"></a>備註

此成員函式會依照 Windows SDK 中的說明，實作用[ListView_GetHotItem](/windows/win32/api/commctrl/nf-commctrl-listview_gethotitem)Win32 宏的行為。 當啟用熱追蹤（和暫留選取）時，熱專案會定義為目前選取的專案。

如果已啟用熱追蹤，當使用者在清單視圖專案上暫停時，專案標籤會自動反白顯示，而不使用滑鼠按鍵。

### <a name="example"></a>範例

```cpp
    // Set the hot item to the first item only if no other item is
    // highlighted.
    if (m_myListCtrl.GetHotItem() == -1)
        m_myListCtrl.SetHotItem(0);
```

## <a name="gethovertime"></a>CListCtrl：： GetHoverTime

抓取清單視圖控制項的目前停留時間。

```
DWORD GetHoverTime() const;
```

### <a name="return-value"></a>傳回值

傳回延遲（以毫秒為單位），滑鼠游標必須停留在專案上，才能選取它。 如果傳回值為-1，則暫留時間是預設的暫留時間。

### <a name="remarks"></a>備註

此成員函式會依照 Windows SDK 中的說明，實作用[ListView_GetHoverTime](/windows/win32/api/commctrl/nf-commctrl-listview_gethovertime)Win32 宏的行為。

### <a name="example"></a>範例

```cpp
        // If the hover time is the default set to 1 sec.
        DWORD dwTime = m_myListCtrl.GetHoverTime();
        if (dwTime == -1)
            m_myListCtrl.SetHoverTime(1000);
```

## <a name="getimagelist"></a>CListCtrl：： GetImageList

抓取用於繪製清單視圖專案之影像清單的控制碼。

```
CImageList* GetImageList(int nImageList) const;
```

### <a name="parameters"></a>參數

*nImageList*<br/>
值，指定要取出的影像清單。 其可以是下列其中一個值：

- 具有大型圖示的 LVSIL_NORMAL 影像清單。

- 具有小圖示的 LVSIL_SMALL 影像清單。

- 具有狀態影像的 LVSIL_STATE 影像清單。

### <a name="return-value"></a>傳回值

用於繪製清單視圖專案之影像清單的指標。

### <a name="example"></a>範例

```cpp
        ASSERT(m_myListCtrl.GetImageList(LVSIL_NORMAL) == NULL);
        m_myListCtrl.SetImageList(&m_lcImageList, LVSIL_NORMAL);
        ASSERT(m_myListCtrl.GetImageList(LVSIL_NORMAL) == &m_lcImageList);
```

## <a name="getinsertmark"></a>CListCtrl：： GetInsertMark

抓取插入標記的目前位置。

```
BOOL GetInsertMark(LPLVINSERTMARK plvim) const;
```

### <a name="parameters"></a>參數

*plvim*<br/>
[LVINSERTMARK](/windows/win32/api/commctrl/ns-commctrl-lvinsertmark)結構的指標，其中包含插入標記的資訊。

### <a name="return-value"></a>傳回值

如果成功，則傳回 TRUE，否則傳回 FALSE。 如果 `LVINSERTMARK` 結構之 `cbSize` 成員中的大小不等於結構的實際大小，則會傳回 FALSE。

### <a name="remarks"></a>備註

此成員函式會模擬[LVM_GETINSERTMARK](/windows/win32/Controls/lvm-getinsertmark)訊息的功能，如 Windows SDK 中所述。

## <a name="getinsertmarkcolor"></a>CListCtrl：： GetInsertMarkColor

抓取插入標記的目前色彩。

```
COLORREF GetInsertMarkColor() const;
```

### <a name="return-value"></a>傳回值

傳回包含插入點色彩的[COLORREF](/windows/win32/gdi/colorref)結構。

### <a name="remarks"></a>備註

此成員函式會模擬[LVM_GETINSERTMARKCOLOR](/windows/win32/Controls/lvm-getinsertmarkcolor)訊息的功能，如 Windows SDK 中所述。

## <a name="getinsertmarkrect"></a>CListCtrl：： GetInsertMarkRect

抓取插入點的邊界矩形。

```
int GetInsertMarkRect(LPRECT pRect) const;
```

### <a name="parameters"></a>參數

*pRect*<br/>
`RECT` 結構的指標，其中包含限定插入點之矩形的座標。

### <a name="return-value"></a>傳回值

傳回下列其中一值：

- **0**找不到插入點。

- 找到**1**個插入點。

### <a name="remarks"></a>備註

此成員函式會模擬[LVM_GETINSERTMARKRECT](/windows/win32/Controls/lvm-getinsertmarkrect)訊息的功能，如 Windows SDK 中所述。

## <a name="getitem"></a>CListCtrl：： GetItem

抓取部分或所有清單視圖專案的屬性。

```
BOOL GetItem(LVITEM* pItem) const;
```

### <a name="parameters"></a>參數

*pItem*<br/>
接收專案屬性之[LVITEM](/windows/win32/api/commctrl/ns-commctrl-lvitemw)結構的指標。

### <a name="return-value"></a>傳回值

如果成功則不為零，否則為 0。

### <a name="remarks"></a>備註

`LVITEM` 結構會指定或接收清單視圖專案的屬性。

## <a name="getitemcount"></a>CListCtrl：： GetItemCount

抓取清單視圖控制項中的專案數。

```
int GetItemCount() const;
```

### <a name="return-value"></a>傳回值

清單視圖控制項中的專案數。

### <a name="example"></a>範例

請參閱[CListCtrl：:D eleteitem](#deleteitem)的範例。

## <a name="getitemdata"></a>CListCtrl：： GetItemData

抓取與 `nItem`所指定之專案相關聯的32位應用程式特定值。

```
DWORD_PTR GetItemData(int nItem) const;
```

### <a name="parameters"></a>參數

*nItem*<br/>
要抓取其資料之清單專案的索引。

### <a name="return-value"></a>傳回值

與指定專案相關聯的32位應用程式特定值。

### <a name="remarks"></a>備註

這個值是[LVITEM](/windows/win32/api/commctrl/ns-commctrl-lvitemw)結構的 `lParam` 成員，如 Windows SDK 所述。

### <a name="example"></a>範例

```cpp
    // If any item's data is equal to zero then reset it to -1.
    for (int i=0; i < m_myListCtrl.GetItemCount(); i++)
    {
        if (m_myListCtrl.GetItemData(i) == 0)
        {
            m_myListCtrl.SetItemData(i, (DWORD) -1);
        }
    }
```

## <a name="getitemindexrect"></a>CListCtrl：： GetItemIndexRect

抓取目前清單視圖控制項中所有或部分子工作的周框。

```
BOOL GetItemIndexRect(
    PLVITEMINDEX pItemIndex,
    int iColumn,
    int rectType,
    LPRECT pRect) const;
```

### <a name="parameters"></a>參數

|參數|描述|
|---------------|-----------------|
|*pItemIndex*|在子專案父項之[LVITEMINDEX](/windows/win32/api/commctrl/ns-commctrl-lvitemindex)結構的指標。<br /><br /> 呼叫端負責配置和設定[LVITEMINDEX](/windows/win32/api/commctrl/ns-commctrl-lvitemindex)結構的成員。 此參數不可以是 NULL。|
|*iColumn*|在控制項中資料行以零為基底的索引。|
|*rectType*|在會抓取周框矩形的清單視圖子下拉式部分。 指定下列其中一個值：<br /><br /> LVIR_BOUNDS-傳回整個子工作的周框，包括圖示和標籤。<br /><br /> LVIR_ICON-傳回子工作圖示或小圖示的周框。<br /><br /> LVIR_LABEL-傳回子項文字的周框。|
|*pRect*|脫銷[RECT](/previous-versions/dd162897\(v=vs.85\))結構的指標，可接收子工作周框的相關資訊。<br /><br /> 呼叫端負責配置[RECT](/previous-versions/dd162897\(v=vs.85\))結構。 此參數不可以是 NULL。|

### <a name="return-value"></a>傳回值

如果此方法成功，則為 TRUE;否則為 FALSE。

### <a name="remarks"></a>備註

這個方法會傳送[LVM_GETITEMINDEXRECT](/windows/win32/Controls/lvm-getitemindexrect)訊息，如 Windows SDK 所述。 如需詳細資訊，請參閱[ListView_GetItemIndexRect 宏](/windows/win32/api/commctrl/nf-commctrl-listview_getitemindexrect)。

### <a name="example"></a>範例

下列程式碼範例會定義用來存取目前清單視圖控制項的變數 `m_listCtrl`。 下一個範例中會使用此變數。

```cpp
public:
    // Variable used to access the list control.
    CListCtrl m_listCtrl;
```

### <a name="example"></a>範例

下列程式碼範例示範 `GetGroupRect` 方法。 在輸入此程式碼範例之前，我們建立了一個清單視圖控制項，它會在報表檢視中顯示兩個標題為 "ClientID" 和 "年級" 的資料行。 下列程式碼範例會在兩個數據行中繪製第二個子項周圍的3D 矩形。

```cpp
    // GetItemIndexRect
    // Get the rectangle that bounds the second item in the first group.
    LVITEMINDEX lvItemIndex;
    lvItemIndex.iGroup = 0;
    lvItemIndex.iItem = 1;
    CRect rect;
    BOOL bRet = m_listCtrl.GetItemIndexRect(
        &lvItemIndex, 0, LVIR_BOUNDS, &rect);

    // Draw a red rectangle around the item.
    m_listCtrl.GetDC()->Draw3dRect( &rect, RGB(255, 0, 0), RGB(255, 0, 0) );
```

## <a name="getitemposition"></a>CListCtrl：： GetItemPosition

抓取清單視圖專案的位置。

```
BOOL GetItemPosition(
    int nItem,
    LPPOINT lpPoint) const;
```

### <a name="parameters"></a>參數

*nItem*<br/>
要取出其位置之專案的索引。

*lpPoint*<br/>
[點](/previous-versions/dd162805\(v=vs.85\))結構的位址，接收此專案左上角的位置，以視圖座標表示。

### <a name="return-value"></a>傳回值

如果成功則不為零，否則為 0。

### <a name="example"></a>範例

```cpp
        POINT pt;

        // Move all items in the list control 100 pixels to the right.
        UINT i, nCount = m_myListCtrl.GetItemCount();

        for (i=0; i < nCount; i++)
        {
            m_myListCtrl.GetItemPosition(i, &pt);
            pt.x += 100;
            m_myListCtrl.SetItemPosition(i, pt);
        }
```

## <a name="getitemrect"></a>CListCtrl：： GetItemRect

抓取目前視圖中所有或部分專案的周框。

```
BOOL GetItemRect(
    int nItem,
    LPRECT lpRect,
    UINT nCode) const;
```

### <a name="parameters"></a>參數

*nItem*<br/>
要取出其位置之專案的索引。

*lpRect*<br/>
接收周框之[RECT](/previous-versions/dd162897\(v=vs.85\))結構的位址。

*nCode*<br/>
要取出周框的清單視圖專案部分。 其可以是下列其中一個值：

- LVIR_BOUNDS 會傳回整個專案的周框，包括圖示和標籤。

- LVIR_ICON 會傳回圖示或小圖示的周框。

- LVIR_LABEL 會傳回專案文字的周框。

### <a name="return-value"></a>傳回值

如果成功則不為零，否則為 0。

### <a name="example"></a>範例

```cpp
// OnClick is the handler for the NM_CLICK notification
void CListCtrlDlg::OnClick(NMHDR* pNMHDR, LRESULT* pResult)
{
    UNREFERENCED_PARAMETER(pResult);
    LPNMITEMACTIVATE pia = (LPNMITEMACTIVATE)pNMHDR;

    // Get the current mouse location and convert it to client
    // coordinates.
    CPoint pos( ::GetMessagePos() );
    ScreenToClient(&pos);

    // Get indexes of the first and last visible items in
    // the listview control.
    int index = m_myListCtrl.GetTopIndex();
    int last_visible_index = index + m_myListCtrl.GetCountPerPage();
    if (last_visible_index > m_myListCtrl.GetItemCount())
        last_visible_index = m_myListCtrl.GetItemCount();

    // Loop until number visible items has been reached.
    while (index <= last_visible_index)
    {
        // Get the bounding rectangle of an item. If the mouse
        // location is within the bounding rectangle of the item,
        // you know you have found the item that was being clicked.
        CRect r;
        m_myListCtrl.GetItemRect(index, &r, LVIR_BOUNDS);
        if (r.PtInRect(pia->ptAction))
        {
            UINT flag = LVIS_SELECTED | LVIS_FOCUSED;
            m_myListCtrl.SetItemState(index, flag, flag);
            break;
        }

        // Get the next item in listview control.
        index++;
    }
}
```

## <a name="getitemspacing"></a>CListCtrl：： GetItemSpacing

計算目前清單視圖控制項中專案之間的間距。

```
BOOL GetItemSpacing(
    BOOL fSmall,
    int* pnHorzSpacing,
    int* pnVertSpacing) const;
```

### <a name="parameters"></a>參數

|參數|描述|
|---------------|-----------------|
|*fSmall*|在要取得其專案間距的視圖。 針對小型圖示視圖指定 TRUE，或針對圖示視圖指定 FALSE。|
|*pnHorzSpacing*|脫銷包含專案之間的水準間距。|
|*pnVertSpacing*|脫銷包含專案之間的垂直間距。|

### <a name="return-value"></a>傳回值

如果此方法成功，則為 TRUE;否則為 FALSE。

### <a name="remarks"></a>備註

這個方法會傳送[LVM_GETITEMSPACING](/windows/win32/Controls/lvm-getitemspacing)訊息，如 Windows SDK 所述。

## <a name="getitemstate"></a>CListCtrl：： GetItemState

抓取清單視圖專案的狀態。

```
UINT GetItemState(
    int nItem,
    UINT nMask) const;
```

### <a name="parameters"></a>參數

*nItem*<br/>
要抓取其狀態之專案的索引。

*nMask*<br/>
遮罩，指定要傳回之專案的狀態旗標。

### <a name="return-value"></a>傳回值

指定之清單視圖專案的狀態旗標。

### <a name="remarks"></a>備註

專案的狀態是由[LVITEM](/windows/win32/api/commctrl/ns-commctrl-lvitemw)結構的 `state` 成員指定，如 Windows SDK 所述。 當您指定或變更專案的狀態時，`stateMask` 成員會指定您想要變更的狀態位。

### <a name="example"></a>範例

請參閱[CListCtrl：： GetTopIndex](#gettopindex)的範例。

## <a name="getitemtext"></a>CListCtrl：： GetItemText

抓取清單視圖專案或子項的文字。

```
int GetItemText(
    int nItem,
    int nSubItem,
    LPTSTR lpszText,
    int nLen) const;

CString GetItemText(
    int nItem,
    int nSubItem) const;
```

### <a name="parameters"></a>參數

*nItem*<br/>
要抓取其文字之專案的索引。

*nSubItem*<br/>
指定要抓取其文字的子工作。

*lpszText*<br/>
要接收專案文字之字串的指標。

*nLen*<br/>
*LpszText*所指向的緩衝區長度。

### <a name="return-value"></a>傳回值

傳回的版本**int**會傳回抓取字串的長度。

傳回 `CString` 的版本會傳回專案文字。

### <a name="remarks"></a>備註

如果*nSubItem*為零，則此函式會抓取專案標籤;如果*nSubItem*為非零值，則會抓取子工作的文字。 如需子引數的詳細資訊，請參閱 Windows SDK 中的[LVITEM](/windows/win32/api/commctrl/ns-commctrl-lvitemw)結構討論。

## <a name="getnextitem"></a>CListCtrl：： GetNextItem

搜尋具有指定之屬性的清單視圖專案，並將指定的關聯性帶給給定的專案。

```
int GetNextItem(
    int nItem,
    int nFlags) const;
```

### <a name="parameters"></a>參數

*nItem*<br/>
要開始搜尋的專案索引，或-1 以尋找符合指定旗標的第一個專案。 指定的專案本身已從搜尋中排除。

*nFlags*<br/>
所要求專案與指定專案的幾何關聯性，以及所要求專案的狀態。 幾何關係可以是下列其中一個值：

- LVNI_ABOVE 搜尋位於指定專案上方的專案。

- LVNI_ALL 依索引搜尋後續專案（預設值）。

- LVNI_BELOW 搜尋位於指定專案底下的專案。

- LVNI_TOLEFT 搜尋指定專案左側的專案。

- LVNI_TORIGHT 搜尋指定專案右邊的專案。

此狀態可以是零，也可以是下列其中一個或多個值：

- LVNI_DROPHILITED 專案已設定 LVIS_DROPHILITED 狀態旗標。

- LVNI_FOCUSED 專案已設定 LVIS_FOCUSED 狀態旗標。

- LVNI_SELECTED 專案已設定 LVIS_SELECTED 狀態旗標。

如果專案未設定所有指定的狀態旗標，搜尋會繼續進行下一個專案。

### <a name="return-value"></a>傳回值

如果成功，則為下一個專案的索引，否則為-1。

## <a name="getnextitemindex"></a>CListCtrl：： GetNextItemIndex

抓取目前清單視圖控制項中，具有一組指定屬性的專案索引。

```
BOOL GetNextItemIndex(
    PLVITEMINDEX pItemIndex,
    int nFlags) const;
```

### <a name="parameters"></a>參數

|參數|描述|
|---------------|-----------------|
|*pItemIndex*|[in、out][LVITEMINDEX](/windows/win32/api/commctrl/ns-commctrl-lvitemindex)結構的指標，描述搜尋開始的專案，或-1，尋找符合*nFlags*參數中旗標的第一個專案。<br /><br /> 如果此方法成功，`LVITEMINDEX` 結構會描述搜尋找到的專案。|
|*nFlags*|在旗標的位元組合（OR），指定如何執行搜尋。<br /><br /> 搜尋可以視目標專案的索引、狀態或外觀，或目標專案相對於*pItemIndex*參數所指定之專案的實體位置而定。 如需詳細資訊，請參閱[LVM_GETNEXTITEMINDEX](/windows/win32/controls/lvm-getnextitemindex)訊息中的*flags*參數。|

### <a name="return-value"></a>傳回值

如果此方法成功，則為 TRUE;否則為 FALSE。

### <a name="remarks"></a>備註

呼叫端負責配置和設定*pItemIndex*參數所指向之 `LVITEMINDEX` 結構的成員。

這個方法會傳送[LVM_GETNEXTITEMINDEX](/windows/win32/controls/lvm-getnextitemindex)訊息，如 Windows SDK 所述。

## <a name="getnextselecteditem"></a>CListCtrl：： GetNextSelectedItem

取得*pos*所識別之清單專案的索引，然後將*POS*設定為位置值。

```
int GetNextSelectedItem(POSITION& pos) const;
```

### <a name="parameters"></a>參數

*pos*<br/>
先前呼叫 `GetNextSelectedItem` 或 `GetFirstSelectedItemPosition`所傳回之位置值的參考。 這個呼叫會將值更新為下一個位置。

### <a name="return-value"></a>傳回值

*Pos*所識別之清單專案的索引。

### <a name="remarks"></a>備註

如果您在呼叫 `GetFirstSelectedItemPosition`時建立初始位置，可以在正向反復專案迴圈中使用 `GetNextSelectedItem`。

您必須確定您的位置值有效。 如果無效，則 MFC 程式庫判斷提示的 Debug 版本。

### <a name="example"></a>範例

下列程式碼範例將示範此函式的使用方式。

```cpp
        POSITION pos = m_myListCtrl.GetFirstSelectedItemPosition();
        if (pos == NULL)
        {
            TRACE(_T("No items were selected!\n"));
        }
        else
        {
            while (pos)
            {
                int nItem = m_myListCtrl.GetNextSelectedItem(pos);
                TRACE(_T("Item %d was selected!\n"), nItem);
                // you could do your own processing on nItem here
            }
        }
```

## <a name="getnumberofworkareas"></a>CListCtrl：： GetNumberOfWorkAreas

抓取清單視圖控制項目前的工作區數目。

```
UINT GetNumberOfWorkAreas() const;
```

### <a name="return-value"></a>傳回值

目前未使用。

### <a name="remarks"></a>備註

此成員函式會依照 Windows SDK 中的說明，實作用[ListView_GetNumberOfWorkAreas](/windows/win32/api/commctrl/nf-commctrl-listview_getnumberofworkareas)Win32 宏的行為。

### <a name="example"></a>範例

```cpp
        UINT i, uCount = m_myListCtrl.GetNumberOfWorkAreas();
        LPRECT lpRects = (LPRECT) malloc(uCount*sizeof(RECT));

        if (lpRects != NULL)
        {
            // Dump all of the work area dimensions.
            m_myListCtrl.GetWorkAreas(uCount, lpRects);

            for (i=0; i < uCount; i++)
            {
                TRACE(_T("Work area %d; left = %d, top = %d, right = %d, ")
                    _T("bottom = %d\r\n"),
                    i, lpRects[i].left, lpRects[i].top, lpRects[i].right,
                    lpRects[i].bottom);
            }

            free(lpRects);
        }
        else
        {
            TRACE(_T("Couldn't allocate enough memory!"));
        }
```

## <a name="getoutlinecolor"></a>CListCtrl：： GetOutlineColor

抓取清單視圖控制項的框線色彩。

```
COLORREF GetOutlineColor() const;
```

### <a name="return-value"></a>傳回值

傳回包含外框色彩的[COLORREF](/windows/win32/gdi/colorref)結構。

### <a name="remarks"></a>備註

此成員函式會模擬[LVM_GETOUTLINECOLOR](/windows/win32/Controls/lvm-getoutlinecolor)訊息的功能，如 Windows SDK 中所述。

## <a name="getorigin"></a>CListCtrl：： GetOrigin

抓取清單視圖控制項的目前視圖原點。

```
BOOL GetOrigin(LPPOINT lpPoint) const;
```

### <a name="parameters"></a>參數

*lpPoint*<br/>
接收視圖來源之[點](/previous-versions/dd162805\(v=vs.85\))結構的位址。

### <a name="return-value"></a>傳回值

如果成功則不為零，否則為 0。 不過，如果控制項位於報表檢視中，則傳回值一律為零。

## <a name="getselectedcolumn"></a>CListCtrl：： GetSelectedColumn

抓取清單控制項中目前選取之資料行的索引。

```
UINT GetSelectedColumn() const;
```

### <a name="return-value"></a>傳回值

選取之資料行的索引。

### <a name="remarks"></a>備註

此成員函式會模擬[LVM_GETSELECTEDCOLUMN](/windows/win32/Controls/lvm-getselectedcolumn)訊息的功能，如 Windows SDK 中所述。

## <a name="getselectedcount"></a>CListCtrl：： GetSelectedCount

抓取清單視圖控制項中選取的專案數。

```
UINT GetSelectedCount() const;
```

### <a name="return-value"></a>傳回值

清單視圖控制項中選取的專案數。

### <a name="example"></a>範例

```cpp
        UINT i, uSelectedCount = m_myListCtrl.GetSelectedCount();
        int  nItem = -1;

        // Update all of the selected items.
        if (uSelectedCount > 0)
        {
            for (i=0; i < uSelectedCount; i++)
            {
                nItem = m_myListCtrl.GetNextItem(nItem, LVNI_SELECTED);
                ASSERT(nItem != -1);
                m_myListCtrl.Update(nItem);
            }
        }
```

## <a name="getselectionmark"></a>CListCtrl：： GetSelectionMark

抓取清單視圖控制項的選取專案標記。

```
int GetSelectionMark();
```

### <a name="return-value"></a>傳回值

以零為基底的選擇標記，如果沒有選取標記，則為-1。

### <a name="remarks"></a>備註

此成員函式會依照 Windows SDK 中的說明，實作用[ListView_GetSelectionMark](/windows/win32/api/commctrl/nf-commctrl-listview_getselectionmark)Win32 宏的行為。

### <a name="example"></a>範例

```cpp
    // Set the selection mark to the first item only if no other item is
    // selected.
    if (m_myListCtrl.GetSelectionMark() == -1)
        m_myListCtrl.SetSelectionMark(0);
```

## <a name="getstringwidth"></a>CListCtrl：： GetStringWidth

決定顯示所有指定字串所需的最小資料行寬度。

```
int GetStringWidth(LPCTSTR lpsz) const;
```

### <a name="parameters"></a>參數

*lpsz*<br/>
要判斷其寬度之以 null 終止之字串的位址。

### <a name="return-value"></a>傳回值

*Lpsz*所指向之字串的寬度（以圖元為單位）。

### <a name="remarks"></a>備註

傳回的寬度會考慮控制項目前的字型和欄邊界，而不是小圖示的寬度。

### <a name="example"></a>範例

```cpp
        CString strColumn;
        int nWidth;

        // Insert six columns in the list view control. Make the width of
        // the column be the width of the column header plus 50%.
        for (int i = 0; i < 6; i++)
        {
            strColumn.Format(_T("column %d"), i);
            nWidth = 3*m_myListCtrl.GetStringWidth(strColumn)/2;
            m_myListCtrl.InsertColumn(i, strColumn, LVCFMT_LEFT, nWidth);
        }
```

## <a name="getsubitemrect"></a>CListCtrl：： GetSubItemRect

抓取清單視圖控制項中專案的周框。

```
BOOL GetSubItemRect(
    int iItem,
    int iSubItem,
    int nArea,
    CRect& ref);
```

### <a name="parameters"></a>參數

*iItem*<br/>
子專案的父項目索引。

*iSubItem*<br/>
子工作的以一為基的索引。

*nArea*<br/>
決定要抓取的周框（清單視圖子工作子項）部分。 將位 OR 運算子套用至下列一個或多個值，即可指定周框的部分（圖示、標籤或兩者）：

- LVIR_BOUNDS 會傳回整個專案的周框，包括圖示和標籤。

- LVIR_ICON 會傳回圖示或小圖示的周框。

- LVIR_LABEL 會傳回整個專案的周框，包括圖示和標籤。 這等同于 LVIR_BOUNDS。

*ref*<br/>
[CRect](../../atl-mfc-shared/reference/crect-class.md)物件的參考，其中包含子工作周框的座標。

### <a name="return-value"></a>傳回值

如果成功則不為零，否則為 0。

### <a name="remarks"></a>備註

此成員函式會依照 Windows SDK 中的說明，實作用[ListView_GetSubItemRect](/windows/win32/api/commctrl/nf-commctrl-listview_getsubitemrect)Win32 宏的行為。

## <a name="gettextbkcolor"></a>CListCtrl：： GetTextBkColor

抓取清單視圖控制項的文字背景色彩。

```
COLORREF GetTextBkColor() const;
```

### <a name="return-value"></a>傳回值

32位值，用來指定 RGB 色彩。

### <a name="example"></a>範例

請參閱[CListCtrl：： SetTextBkColor](#settextbkcolor)的範例。

## <a name="gettextcolor"></a>CListCtrl：： GetTextColor

抓取清單視圖控制項的文字色彩。

```
COLORREF GetTextColor() const;
```

### <a name="return-value"></a>傳回值

32位值，用來指定 RGB 色彩。

### <a name="example"></a>範例

請參閱[CListCtrl：： SetTextColor](#settextcolor)的範例。

## <a name="gettileinfo"></a>CListCtrl：： GetTileInfo

在清單視圖控制項中抓取磚的相關資訊。

```
BOOL GetTileInfo(PLVTILEINFO plvti) const;
```

### <a name="parameters"></a>參數

*plvti*<br/>
接收磚資訊之[LVTILEINFO](/windows/win32/api/commctrl/ns-commctrl-lvtileinfo)結構的指標。

### <a name="return-value"></a>傳回值

不使用傳回值。

### <a name="remarks"></a>備註

此成員函式會模擬[LVM_GETTILEINFO](/windows/win32/Controls/lvm-gettileinfo)訊息的功能，如 Windows SDK 中所述。

## <a name="gettileviewinfo"></a>CListCtrl：： GetTileViewInfo

在磚視圖中抓取清單視圖控制項的相關資訊。

```
BOOL GetTileViewInfo(PLVTILEVIEWINFO ptvi) const;
```

### <a name="parameters"></a>參數

*ptvi*<br/>
接收所抓取資訊之[LVTILEVIEWINFO](/windows/win32/api/commctrl/ns-commctrl-lvtileviewinfo)結構的指標。

### <a name="return-value"></a>傳回值

不使用傳回值。

### <a name="remarks"></a>備註

此成員函式會模擬[LVM_GETTILEVIEWINFO](/windows/win32/Controls/lvm-gettileviewinfo)訊息的功能，如 Windows SDK 中所述。

## <a name="gettooltips"></a>CListCtrl：： GetToolTips

抓取清單視圖控制項用來顯示工具提示的工具提示控制項。

```
CToolTipCtrl* GetToolTips() const;
```

### <a name="return-value"></a>傳回值

清單控制項所要使用之[CToolTipCtrl](ctooltipctrl-class.md)物件的指標。 如果[Create](#create)成員函式使用樣式 LVS_NOTOOLTIPS，則不會使用任何工具提示，而且會傳回 Null。

### <a name="remarks"></a>備註

此成員函式會依照 Windows SDK 中的說明，實作用[LVM_GETTOOLTIPS](/windows/win32/Controls/lvm-gettooltips)Win32 訊息的行為。 的 MFC 執行 `GetToolTips` 會傳回清單控制項所使用的 `CToolTipCtrl` 物件，而不是工具提示控制項的控制碼。

### <a name="example"></a>範例

```cpp
        CToolTipCtrl* pTip = m_myListCtrl.GetToolTips();
        if (NULL != pTip)
        {
            pTip->UpdateTipText(_T("I'm a list view!"), &m_myListCtrl,
                IDD_MYLISTCTRL);
        }
```

## <a name="gettopindex"></a>CListCtrl：： GetTopIndex

在清單視圖或報表檢視中時，抓取最頂端可見專案的索引。

```
int GetTopIndex() const;
```

### <a name="return-value"></a>傳回值

最上層可見專案的索引。

### <a name="example"></a>範例

```cpp
        // Make sure the focus is set to the list view control.
        m_myListCtrl.SetFocus();

        // Select all of the items that are completely visible.
        int n = m_myListCtrl.GetTopIndex();
        int nLast = n + m_myListCtrl.GetCountPerPage();

        for (; n < nLast; n++)
        {
            m_myListCtrl.SetItemState(n, LVIS_SELECTED, LVIS_SELECTED);
            ASSERT(m_myListCtrl.GetItemState(n, LVIS_SELECTED) == LVIS_SELECTED);
        }
```

## <a name="getview"></a>CListCtrl：： GetView

取得清單視圖控制項的視圖。

```
DWORD GetView() const;
```

### <a name="return-value"></a>傳回值

清單視圖控制項的目前視圖。

### <a name="remarks"></a>備註

此成員函式會模擬[LVM_GETVIEW](/windows/win32/Controls/lvm-getview)訊息的功能，如 Windows SDK 中所述。

## <a name="getviewrect"></a>CListCtrl：： GetViewRect

抓取清單視圖控制項中所有專案的周框。

```
BOOL GetViewRect(LPRECT lpRect) const;
```

### <a name="parameters"></a>參數

*lpRect*<br/>
[RECT](/previous-versions/dd162897\(v=vs.85\))結構的位址。

### <a name="return-value"></a>傳回值

如果成功則不為零，否則為 0。

### <a name="remarks"></a>備註

清單視圖必須在圖示視圖或小型圖示視圖中。

## <a name="getworkareas"></a>CListCtrl：： GetWorkAreas

抓取清單視圖控制項的目前工作區域。

```
void GetWorkAreas(
    int nWorkAreas,
    LPRECT pRect) const;
```

### <a name="parameters"></a>參數

*nWorkAreas*<br/>
*PRect*陣列中包含的 `RECT` 結構數目。

*pRect*<br/>
`RECT` 結構（或[CRect](../../atl-mfc-shared/reference/crect-class.md)物件）陣列的指標，可接收清單視圖控制項的工作區域。 這些結構中的值是在用戶端座標中。

### <a name="remarks"></a>備註

此成員函式會依照 Windows SDK 中的說明，實作用[ListView_GetWorkAreas](/windows/win32/api/commctrl/nf-commctrl-listview_getworkareas)Win32 宏的行為。

### <a name="example"></a>範例

請參閱[CListCtrl：： GetNumberOfWorkAreas](#getnumberofworkareas)的範例。

## <a name="hasgroup"></a>CListCtrl：： HasGroup

判斷清單視圖控制項是否有指定的群組。

```
BOOL HasGroup(int iGroupId) const;
```

### <a name="parameters"></a>參數

*iGroupId*<br/>
所要求之群組的識別碼。

### <a name="return-value"></a>傳回值

成功時傳回 TRUE，失敗時傳回 FALSE。

### <a name="remarks"></a>備註

此成員函式會模擬[LVM_HASGROUP](/windows/win32/Controls/lvm-hasgroup)訊息的功能，如 Windows SDK 中所述。

## <a name="hittest"></a>CListCtrl：： HitTest

判斷哪個清單視圖專案（如果有的話）位於指定的位置。

```
int HitTest(LVHITTESTINFO* pHitTestInfo) const;

int HitTest(
    CPoint pt,
    UINT* pFlags = NULL) const;
```

### <a name="parameters"></a>參數

*pHitTestInfo*<br/>
`LVHITTESTINFO` 結構的位址，其中包含要進行點擊測試的位置，並接收點擊測試結果的相關資訊。

*pt*<br/>
要測試的點。

*pFlags*<br/>
整數的指標，可接收測試結果的相關資訊。 請參閱 Windows SDK 中[LVHITTESTINFO](/windows/win32/api/commctrl/ns-commctrl-lvhittestinfo)結構之 `flags` 成員的說明。

### <a name="return-value"></a>傳回值

*PHitTestInfo*指定之位置的專案索引（如果有的話），否則為-1。

### <a name="remarks"></a>備註

您可以使用結構 `flag` 成員的 [LVHT_ABOVE]、[LVHT_BELOW]、[LVHT_TOLEFT] 和 [LVHT_TORIGHT] 值，來決定是否要滾動清單視圖控制項的內容。 其中有兩個旗標可以合併，例如，如果位置在工作區的上方和左側。

您可以測試結構的 `flag` 成員的 LVHT_ONITEM 值，以判斷指定的位置是否在清單視圖專案上。 這個值是結構 `flag` 成員的 LVHT_ONITEMICON、LVHT_ONITEMLABEL 和 LVHT_ONITEMSTATEICON 值的位 OR 運算。

### <a name="example"></a>範例

```cpp
void CListCtrlDlg::OnRClick(NMHDR* pNMHDR, LRESULT* pResult)
{
    LPNMITEMACTIVATE pia = (LPNMITEMACTIVATE)pNMHDR;
    CPoint point(pia->ptAction);

    // Select the item the user clicked on.
    UINT uFlags;
    int nItem = m_myListCtrl.HitTest(point, &uFlags);

    if (uFlags & LVHT_ONITEMLABEL)
    {
        m_myListCtrl.SetItem(nItem, 0, LVIF_STATE, NULL, 0, LVIS_SELECTED,
            LVIS_SELECTED, 0);
    }

    *pResult = 0;
}
```

## <a name="insertcolumn"></a>CListCtrl：： InsertColumn

在清單視圖控制項中插入新的資料行。

```
int InsertColumn(
    int nCol,
    const LVCOLUMN* pColumn);

int InsertColumn(
    int nCol,
    LPCTSTR lpszColumnHeading,
    int nFormat = LVCFMT_LEFT,
    int nWidth = -1,
    int nSubItem = -1);
```

### <a name="parameters"></a>參數

*nCol*<br/>
新資料行的索引。

*pColumn*<br/>
包含新資料行之屬性的 `LVCOLUMN` 結構的位址。

*lpszColumnHeading*<br/>
包含資料行標題之字串的位址。

*nFormat*<br/>
指定資料行對齊方式的整數。 它可以是下列其中一個值： LVCFMT_LEFT、LVCFMT_RIGHT 或 LVCFMT_CENTER。

*nWidth*<br/>
資料行的寬度（以圖元為單位）。 如果此參數為-1，則不會設定資料行寬度。

*nSubItem*<br/>
與資料行相關聯之子項的索引。 如果此參數為-1，則不會有任何子項與資料行相關聯。

### <a name="return-value"></a>傳回值

如果成功，則為新資料行的索引，否則為-1。

### <a name="remarks"></a>備註

清單視圖控制項中最左邊的資料行必須靠左對齊。

[LVCOLUMN](/windows/win32/api/commctrl/ns-commctrl-lvcolumnw)結構包含報表檢視中資料行的屬性。 它也會用來接收資料行的相關資訊。 Windows SDK 中會描述此結構。

## <a name="insertgroup"></a>CListCtrl：： InsertGroup

將群組插入清單視圖控制項中。

```
LRESULT InsertGroup(
    int index,
    PLVGROUP pgrp);
```

### <a name="parameters"></a>參數

*index*<br/>
要插入群組之專案的索引。

*pgrp*<br/>
[LVGROUP](/windows/win32/api/commctrl/ns-commctrl-lvgroup)結構的指標，其中包含要加入的群組。

### <a name="return-value"></a>傳回值

傳回已加入群組之專案的索引，如果作業失敗，則傳回-1。

### <a name="remarks"></a>備註

此成員函式會模擬[LVM_INSERTGROUP](/windows/win32/Controls/lvm-insertgroup)訊息的功能，如 Windows SDK 中所述。

## <a name="insertgroupsorted"></a>CListCtrl：： InsertGroupSorted

將指定的群組插入群組的已排序清單中。

```
LRESULT InsertGroupSorted(PLVINSERTGROUPSORTED pStructInsert);
```

### <a name="parameters"></a>參數

*pStructInsert*<br/>
包含要插入之群組的[LVINSERTGROUPSORTED](/windows/win32/api/commctrl/ns-commctrl-lvinsertgroupsorted)結構的指標。

### <a name="return-value"></a>傳回值

不使用傳回值。

### <a name="remarks"></a>備註

此成員函式會模擬[LVM_INSERTGROUPSORTED](/windows/win32/Controls/lvm-insertgroupsorted)訊息的功能，如 Windows SDK 中所述。

## <a name="insertitem"></a>CListCtrl：： InsertItem

將專案插入清單視圖控制項中。

```
int InsertItem(const LVITEM* pItem);

int InsertItem(
    int nItem,
    LPCTSTR lpszItem);

int InsertItem(
    int nItem,
    LPCTSTR lpszItem,
    int nImage);

int InsertItem(
    UINT nMask,
    int nItem,
    LPCTSTR lpszItem,
    UINT nState,
    UINT nStateMask,
    int nImage,
    LPARAM lParam);
```

### <a name="parameters"></a>參數

*pItem*<br/>
[LVITEM](/windows/win32/api/commctrl/ns-commctrl-lvitemw)結構的指標，指定專案的屬性，如 Windows SDK 中所述。

*nItem*<br/>
要插入之專案的索引。

*lpszItem*<br/>
包含專案標籤之字串的位址，如果專案是回呼專案，則為 LPSTR_TEXTCALLBACK。 如需回呼專案的詳細資訊，請參閱[CListCtrl：： GetCallbackMask](#getcallbackmask)。

*nImage*<br/>
專案影像的索引，如果專案是回呼專案，則為 I_IMAGECALLBACK。 如需回呼專案的詳細資訊，請參閱[CListCtrl：： GetCallbackMask](#getcallbackmask)。

*nMask*<br/>
*NMask*參數會指定做為參數傳遞的專案屬性是有效的。 它可以是 Windows SDK 的[LVITEM 結構](/windows/win32/api/commctrl/ns-commctrl-lvitemw)中所描述的一或多個 mask 值。 有效的值可以與位 OR 運算子結合。

*nState*<br/>
指出專案的狀態、狀態影像和重迭影像。 如需詳細資訊，請參閱 Windows SDK 主題[LVITEM 結構](/windows/win32/api/commctrl/ns-commctrl-lvitemw)和[清單視圖專案狀態](/windows/win32/Controls/list-view-item-states)，以取得有效旗標的清單。

*nStateMask*<br/>
指出將抓取或修改的狀態成員的位。 如需詳細資訊，請參閱 Windows SDK 中的[LVITEM 結構](/windows/win32/api/commctrl/ns-commctrl-lvitemw)。

*lParam*<br/>
與專案相關聯的32位應用程式特定值。 如果指定了這個參數，您就必須將*nMask*屬性設定 LVIF_PARAM。

### <a name="return-value"></a>傳回值

如果成功，則為新專案的索引，否則為-1。

### <a name="remarks"></a>備註

呼叫這個方法可能會導致 LVM_INSERTITEM 訊息傳送至您的控制項視窗。 控制項的相關訊息處理常式可能無法在某些條件下設定專案文字（例如，使用視窗樣式，例如 LVS_OWNERDRAW）。 如需有關這些條件的詳細資訊，請參閱 Windows SDK 中的[LVM_INSERTITEM](/windows/win32/Controls/lvm-insertitem) 。

### <a name="example"></a>範例

```cpp
        CString strText;
        int nColumnCount = m_myListCtrl.GetHeaderCtrl()->GetItemCount();

        // Insert 10 items in the list view control.
        for (int i = 0; i < 10; i++)
        {
            strText.Format(TEXT("item %d"), i);

            // Insert the item, select every other item.
            m_myListCtrl.InsertItem(LVIF_TEXT | LVIF_STATE, i, strText,
                (i % 2) == 0 ? LVIS_SELECTED : 0, LVIS_SELECTED, 0, 0);

            // Initialize the text of the subitems.
            for (int j = 1; j < nColumnCount; j++)
            {
                strText.Format(TEXT("sub-item %d %d"), i, j);
                m_myListCtrl.SetItemText(i, j, strText);
            }
        }
```

## <a name="insertmarkhittest"></a>CListCtrl：： InsertMarkHitTest

抓取最接近指定點的插入點。

```
int InsertMarkHitTest(
    LPPOINT pPoint,
    LPLVINSERTMARK plvim) const;
```

### <a name="parameters"></a>參數

*pPoint*<br/>
[點](/previous-versions/dd162805\(v=vs.85\))結構的指標，其中包含相對於清單控制項工作區的點擊測試座標。

*plvim*<br/>
[LVINSERTMARK](/windows/win32/api/commctrl/ns-commctrl-lvinsertmark)結構的指標，指定最接近 point 參數所定義之座標的插入點。

### <a name="return-value"></a>傳回值

最接近指定點的插入點。

### <a name="remarks"></a>備註

此成員函式會模擬[LVM_INSERTMARKHITTEST](/windows/win32/Controls/lvm-insertmarkhittest)訊息的功能，如 Windows SDK 中所述。

## <a name="isgroupviewenabled"></a>CListCtrl：： IsGroupViewEnabled

決定是否為清單視圖控制項啟用群組視圖。

```
BOOL IsGroupViewEnabled() const;
```

### <a name="return-value"></a>傳回值

如果已啟用群組視圖，則傳回 TRUE，否則傳回 FALSE。

### <a name="remarks"></a>備註

此成員函式會模擬[LVM_ISGROUPVIEWENABLED](/windows/win32/Controls/lvm-isgroupviewenabled)訊息的功能，如 Windows SDK 中所述。

## <a name="isitemvisible"></a>CListCtrl：： IsItemVisible

指出目前清單視圖控制項中的指定專案是否可見。

```
BOOL IsItemVisible(int index) const;
```

### <a name="parameters"></a>參數

|參數|描述|
|---------------|-----------------|
|*index*|在目前清單視圖控制項中專案以零為基底的索引。|

### <a name="return-value"></a>傳回值

如果指定的專案為可見，則為 TRUE;否則為 FALSE。

### <a name="remarks"></a>備註

這個方法會傳送[LVM_ISITEMVISIBLE](/windows/win32/Controls/lvm-isitemvisible)訊息，如 Windows SDK 所述。

## <a name="mapidtoindex"></a>CListCtrl：： MapIDToIndex

將目前清單視圖控制項中專案的唯一識別碼對應至索引。

```
UINT MapIDToIndex(UINT id) const;
```

### <a name="parameters"></a>參數

|參數|描述|
|---------------|-----------------|
|*id*|在專案的唯一識別碼。|

### <a name="return-value"></a>傳回值

指定之識別碼的目前索引。

### <a name="remarks"></a>備註

清單視圖控制項會在內部依索引追蹤專案。 這可能會出現問題，因為索引可能會在控制項的存留期間變更。 當建立專案時，清單視圖控制項可以標記具有識別碼的專案，而您可以使用此識別碼來保證清單視圖控制項存留期間的唯一性。

請注意，在多執行緒環境中，索引只會在裝載清單視圖控制項的執行緒上保證，而不是在背景執行緒上。

這個方法會傳送[LVM_MAPIDTOINDEX](/windows/win32/controls/lvm-mapidtoindex)訊息，如 Windows SDK 所述。

## <a name="mapindextoid"></a>CListCtrl：： MapIndexToID

將目前清單視圖控制項中專案的索引對應到唯一的識別碼。

```
UINT MapIndexToID(UINT index) const;
```

### <a name="parameters"></a>參數

|參數|描述|
|---------------|-----------------|
|*index*|在專案之以零為基底的索引。|

### <a name="return-value"></a>傳回值

指定之專案的唯一識別碼。

### <a name="remarks"></a>備註

清單視圖控制項會在內部依索引追蹤專案。 這可能會出現問題，因為索引可能會在控制項的存留期間變更。 建立專案時，清單視圖控制項可以標記具有識別碼的專案。 您可以使用此識別碼來存取清單視圖控制項存留期的特定專案。

請注意，在多執行緒環境中，索引只會在裝載清單視圖控制項的執行緒上保證，而不是在背景執行緒上。

這個方法會傳送[LVM_MAPINDEXTOID](/windows/win32/Controls/lvm-mapindextoid)訊息，如 Windows SDK 所述。

### <a name="example"></a>範例

下列程式碼範例會定義用來存取目前清單視圖控制項的變數 `m_listCtrl`。 下一個範例中會使用此變數。

```cpp
public:
    // Variable used to access the list control.
    CListCtrl m_listCtrl;
```

### <a name="example"></a>範例

下列程式碼範例示範 `MapIndexToID` 方法。 在這個程式碼範例的先前章節中，我們建立了清單視圖控制項，它會在報表檢視中顯示兩個標題為 "ClientID" 和 "年級" 的資料行。 下列範例會將每個清單視圖專案的索引對應到識別碼，然後抓取每個識別碼的索引。 最後，此範例會報告是否已抓取原始索引。

```cpp
    // MapIndexToID
    int iCount = m_listCtrl.GetItemCount();
    UINT nId = 0;
    UINT nIndex = 0;
    for (int iIndexOriginal = 0; iIndexOriginal < iCount; iIndexOriginal++)
    {
        // Map index to ID.
        nId = m_listCtrl.MapIndexToID((UINT)iIndexOriginal);

        // Map ID to index.
        nIndex = m_listCtrl.MapIDToIndex(nId);

        if (nIndex != (UINT)(iIndexOriginal))
        {
            CString str;
            str.Format(_T("Mapped index (%d) is not equal to original index (%d)"),
                nIndex, (UINT)(iIndexOriginal));
            AfxMessageBox(str);
            return;
        }
    }
    AfxMessageBox(_T("The mapped indexes and original indexes are equal."),
        MB_ICONINFORMATION);
```

## <a name="movegroup"></a>CListCtrl：： MoveGroup

將指定的群組移至清單視圖控制項的指定之以零為基底的索引。

```
LRESULT MoveGroup(
    int iGroupId,
    int toIndex);
```

### <a name="parameters"></a>參數

*iGroupId*<br/>
要移動之群組的識別碼。

*toIndex*<br/>
以零為基底的索引，這是要移動群組的位置。

### <a name="return-value"></a>傳回值

不使用傳回值。

### <a name="remarks"></a>備註

此成員函式會模擬[LVM_MOVEGROUP](/windows/win32/Controls/lvm-movegroup)訊息的功能，如 Windows SDK 中所述。

## <a name="moveitemtogroup"></a>CListCtrl：： MoveItemToGroup

將指定的專案移到指定的群組中。

```
void MoveItemToGroup(
    int idItemFrom,
    int idGroupTo);
```

### <a name="parameters"></a>參數

*idItemFrom*<br/>
在要移動之專案的索引。

*idGroupTo*<br/>
在要將專案移至其中之群組的識別碼。

### <a name="remarks"></a>備註

> [!NOTE]
>  這個方法目前未執行。

這個方法會模擬[LVM_MOVEITEMTOGROUP](/windows/win32/Controls/lvm-moveitemtogroup)訊息的功能，如 Windows SDK 所述。

## <a name="redrawitems"></a>CListCtrl：： RedrawItems

強制清單視圖控制項重新繪製某個範圍的專案。

```
BOOL RedrawItems(
    int nFirst,
    int nLast);
```

### <a name="parameters"></a>參數

*nFirst*<br/>
要重新繪製之第一個專案的索引。

*nLast*<br/>
要重新繪製之最後一個專案的索引。

### <a name="return-value"></a>傳回值

如果成功則不為零，否則為 0。

### <a name="remarks"></a>備註

在清單視圖視窗收到 WM_PAINT 訊息之前，不會實際重新繪製指定的專案。 若要立即重新繪製，請在使用此函數之後呼叫 Windows [UpdateWindow](/windows/win32/api/winuser/nf-winuser-updatewindow)函式。

## <a name="removeallgroups"></a>CListCtrl：： RemoveAllGroups

從清單視圖控制項移除所有群組。

```
void RemoveAllGroups();
```

### <a name="remarks"></a>備註

此成員函式會模擬[LVM_REMOVEALLGROUPS](/windows/win32/Controls/lvm-removeallgroups)訊息的功能，如 Windows SDK 中所述。

## <a name="removegroup"></a>CListCtrl：： RemoveGroup

從清單視圖控制項中移除指定的群組。

```
LRESULT RemoveGroup(int iGroupId);
```

### <a name="parameters"></a>參數

*iGroupId*<br/>
要移除之群組的識別碼。

### <a name="return-value"></a>傳回值

如果成功，則傳回群組的索引，否則為-1。

### <a name="remarks"></a>備註

此成員函式會模擬[LVM_REMOVEGROUP](/windows/win32/Controls/lvm-removegroup)訊息的功能，如 Windows SDK 中所述。

## <a name="scroll"></a>CListCtrl：： Scroll

滾動清單視圖控制項的內容。

```
BOOL Scroll(CSize size);
```

### <a name="parameters"></a>參數

*size*<br/>
`CSize` 物件，指定水準和垂直捲動的數量（以圖元為單位）。 [`y`]*大小*的成員會除以清單視圖控制項的線條的高度（以圖元為單位），而控制項則是依產生的行數而滾動。

### <a name="return-value"></a>傳回值

如果成功則不為零，否則為 0。

## <a name="setbkcolor"></a>CListCtrl：： SetBkColor

設定清單視圖控制項的背景色彩。

```
BOOL SetBkColor(COLORREF cr);
```

### <a name="parameters"></a>參數

*符*<br/>
要設定的背景色彩，或沒有背景色彩的 CLR_NONE 值。 具有背景色彩的清單視圖控制項，會明顯地比沒有背景色彩的控制項更快重繪。 如需相關資訊，請參閱 Windows SDK 中的[COLORREF](/windows/win32/gdi/colorref) 。

### <a name="return-value"></a>傳回值

如果成功則不為零，否則為 0。

### <a name="example"></a>範例

```cpp
        // Use the 3D button face color for the background.
        COLORREF crBkColor = ::GetSysColor(COLOR_3DFACE);
        m_myListCtrl.SetBkColor(crBkColor);
        ASSERT(m_myListCtrl.GetBkColor() == crBkColor);
```

## <a name="setbkimage"></a>CListCtrl：： SetBkImage

設定清單視圖控制項的背景影像。

```
BOOL SetBkImage(LVBKIMAGE* plvbkImage);

BOOL SetBkImage(
    HBITMAP hBitmap,
    BOOL fTile = TRUE,
    int xOffsetPercent = 0,
    int yOffsetPercent = 0);

BOOL SetBkImage(
    LPTSTR pszUrl,
    BOOL fTile = TRUE,
    int xOffsetPercent = 0,
    int yOffsetPercent = 0);
```

### <a name="parameters"></a>參數

*plvbkImage*<br/>
`LVBKIMAGE` 結構的位址，其中包含新的背景影像資訊。

*hBitmap*<br/>
點陣圖的控制碼。

*pszUrl*<br/>
以 Null 終止的字串，其中包含背景影像的 URL。

*fTile*<br/>
如果影像要在清單視圖控制項的背景中並排顯示，則為非零。否則為0。

*xOffsetPercent*<br/>
影像左邊緣的位移（以圖元為單位），來自清單視圖控制項的原點。

*yOffsetPercent*<br/>
影像上邊緣的位移（以圖元為單位），來自清單視圖控制項的原點。

### <a name="return-value"></a>傳回值

如果成功，則傳回非零，否則會傳回零。

### <a name="remarks"></a>備註

> [!NOTE]
>  由於 `CListCtrl::SetBkImage` 會使用 OLE COM 功能，因此必須先初始化 OLE 程式庫，才能使用 `SetBkImage`。 當應用程式初始化時，最好將 COM 程式庫初始化，並在應用程式終止時將程式庫解除初始化。 這會自動在利用 ActiveX 技術、OLE Automation、OLE 連結/內嵌或 ODBC/DAO 作業的 MFC 應用程式中執行。

### <a name="example"></a>範例

請參閱[CListCtrl：： GetBkImage](#getbkimage)的範例。

## <a name="setcallbackmask"></a>CListCtrl：： SetCallbackMask

設定清單視圖控制項的回呼遮罩。

```
BOOL SetCallbackMask(UINT nMask);
```

### <a name="parameters"></a>參數

*nMask*<br/>
回呼遮罩的新值。

### <a name="return-value"></a>傳回值

如果成功則不為零，否則為 0。

### <a name="example"></a>範例

```cpp
    // Set the callback mask so that only the selected and focused states
    // are stored for each item.
    m_myListCtrl.SetCallbackMask(LVIS_SELECTED|LVIS_FOCUSED);
    ASSERT(m_myListCtrl.GetCallbackMask() ==
        (LVIS_SELECTED|LVIS_FOCUSED));
```

## <a name="setcheck"></a>CListCtrl：： SetCheck

決定清單控制項專案的狀態影像是否為可見。

```
BOOL SetCheck(
    int nItem,
    BOOL fCheck = TRUE);
```

### <a name="parameters"></a>參數

*nItem*<br/>
清單控制項專案之以零為基底的索引。

*來*<br/>
指定是否應該顯示專案的狀態影像。 根據預設，*來*為 TRUE，且狀態影像為可見。 如果*來*為 FALSE，則不會顯示。

### <a name="return-value"></a>傳回值

如果已核取專案，則為非零，否則為0。

### <a name="example"></a>範例

```cpp
        int nCount = m_myListCtrl.GetItemCount();
        BOOL fCheck = FALSE;

        // Set the check state of every other item to TRUE and
        // all others to FALSE.
        for (int i = 0; i < nCount; i++)
        {
            m_myListCtrl.SetCheck(i, fCheck);
            ASSERT((m_myListCtrl.GetCheck(i) && fCheck) ||
                (!m_myListCtrl.GetCheck(i) && !fCheck));
            fCheck = !fCheck;
        }
```

## <a name="setcolumn"></a>CListCtrl：： SetColumn

設定清單視圖資料行的屬性。

```
BOOL SetColumn(
    int nCol,
    const LVCOLUMN* pColumn);
```

### <a name="parameters"></a>參數

*nCol*<br/>
要設定其屬性的資料行索引。

*pColumn*<br/>
[LVCOLUMN](/windows/win32/api/commctrl/ns-commctrl-lvcolumnw)結構的位址，其中包含新的資料行屬性，如 Windows SDK 中所述。 結構的 `mask` 成員會指定要設定的資料行屬性。 如果 `mask` 成員指定 LVCF_TEXT 值，結構的 `pszText` 成員就是以 null 終止之字串的位址，而且會忽略結構的 `cchTextMax` 成員。

### <a name="return-value"></a>傳回值

如果成功則不為零，否則為 0。

### <a name="example"></a>範例

請參閱[CListCtrl：： GetColumn](#getcolumn)的範例。

## <a name="setcolumnorderarray"></a>CListCtrl：： SetColumnOrderArray

設定清單視圖控制項的資料行順序（由左到右）。

```
BOOL SetColumnOrderArray(
    int iCount,
    LPINT piArray);
```

### <a name="parameters"></a>參數

*piArray*<br/>
緩衝區的指標，其中包含清單視圖控制項中資料行的索引值（由左至右）。 緩衝區必須夠大，才能包含清單視圖控制項中的總數據行數。

*iCount*<br/>
清單視圖控制項中的資料行數目。

### <a name="return-value"></a>傳回值

如果成功則不為零，否則為 0。

### <a name="remarks"></a>備註

此成員函式會依照 Windows SDK 中的說明，實作用[ListView_SetColumnOrderArray](/windows/win32/api/commctrl/nf-commctrl-listview_setcolumnorderarray)Win32 宏的行為。

### <a name="example"></a>範例

請參閱[CListCtrl：： GetColumnOrderArray](#getcolumnorderarray)的範例。

## <a name="setcolumnwidth"></a>CListCtrl：： SetColumnWidth

在報表檢視或清單視圖中變更資料行的寬度。

```
BOOL SetColumnWidth(
    int nCol,
    int cx);
```

### <a name="parameters"></a>參數

*nCol*<br/>
要設定其寬度之資料行的索引。 在清單視圖中，此參數必須是0。

*cx*<br/>
資料行的新寬度。 可以是 LVSCW_AUTOSIZE 或 LVSCW_AUTOSIZE_USEHEADER，如 Windows SDK 的[LVM_SETCOLUMNWIDTH](/windows/win32/Controls/lvm-setcolumnwidth)中所述。

### <a name="return-value"></a>傳回值

如果成功則不為零，否則為 0。

## <a name="setextendedstyle"></a>CListCtrl：： SetExtendedStyle

設定清單視圖控制項的目前擴充樣式。

```
DWORD SetExtendedStyle(DWORD dwNewStyle);
```

### <a name="parameters"></a>參數

*dwNewStyle*<br/>
清單視圖控制項所使用的擴充樣式組合。 如需這些樣式的描述性清單，請參閱 Windows SDK 中的[擴充清單視圖樣式](/windows/win32/Controls/extended-list-view-styles)主題。

### <a name="return-value"></a>傳回值

清單視圖控制項所使用之舊版延伸樣式的組合。

### <a name="remarks"></a>備註

此成員函式會依照 Windows SDK 中的說明，實作用[ListView_SetExtendedListViewStyle](/windows/win32/api/commctrl/nf-commctrl-listview_setextendedlistviewstyle)Win32 宏的行為。

### <a name="example"></a>範例

```cpp
    // Allow the header controls item to be movable by the user.
    m_myListCtrl.SetExtendedStyle
        (m_myListCtrl.GetExtendedStyle()|LVS_EX_HEADERDRAGDROP);
```

## <a name="setgroupinfo"></a>CListCtrl：： SetGroupInfo

設定描述目前清單視圖控制項之指定群組的資訊。

```
int SetGroupInfo(
    int iGroupId,
    PLVGROUP pgrp);
```

### <a name="parameters"></a>參數

*iGroupId*<br/>
已設定其資訊之群組的識別碼。

*pgrp*<br/>
[LVGROUP](/windows/win32/api/commctrl/ns-commctrl-lvgroup)結構的指標，其中包含要設定的資訊。 呼叫端負責配置此結構並設定其成員。

### <a name="return-value"></a>傳回值

如果方法成功，則為群組的識別碼;否則為-1。

### <a name="remarks"></a>備註

這個方法會傳送[LVM_SETGROUPINFO](/windows/win32/Controls/lvm-setgroupinfo)訊息，如 Windows SDK 所述。

## <a name="setgroupmetrics"></a>CListCtrl：： SetGroupMetrics

設定清單視圖控制項的群組計量。

```
void SetGroupMetrics(PLVGROUPMETRICS pGroupMetrics);
```

### <a name="parameters"></a>參數

*pGroupMetrics*<br/>
[LVGROUPMETRICS](/windows/win32/api/commctrl/ns-commctrl-lvgroupmetrics)結構的指標，其中包含要設定的群組計量資訊。

### <a name="remarks"></a>備註

此成員函式會模擬[LVM_SETGROUPMETRICS](/windows/win32/Controls/lvm-setgroupmetrics)訊息的功能，如 Windows SDK 中所述。

## <a name="sethotcursor"></a>CListCtrl：： SetHotCursor

設定針對清單視圖控制項啟用熱追蹤時所使用的資料指標。

```
HCURSOR SetHotCursor(HCURSOR hc);
```

### <a name="parameters"></a>參數

*hc*<br/>
資料指標資源的控制碼，用來表示熱資料指標。

### <a name="return-value"></a>傳回值

清單視圖控制項所使用的先前作用中游標資源的控制碼。

### <a name="remarks"></a>備註

此成員函式會依照 Windows SDK 中的說明，實作用[ListView_SetHotCursor](/windows/win32/api/commctrl/nf-commctrl-listview_sethotcursor)Win32 宏的行為。

只有在啟用 [暫留選取] 時，才會顯示作用中游標，因為游標通過任何清單視圖專案。 藉由設定 LVS_EX_TRACKSELECT 擴充樣式來啟用暫留選取。

### <a name="example"></a>範例

請參閱[CListCtrl：： GetHotCursor](#gethotcursor)的範例。

## <a name="sethotitem"></a>CListCtrl：： SetHotItem

設定清單視圖控制項的目前作用中專案。

```
int SetHotItem(int iIndex);
```

### <a name="parameters"></a>參數

*iIndex*<br/>
要設定為熱專案之專案的以零為基底的索引。

### <a name="return-value"></a>傳回值

先前作用中專案之以零為起始的索引。

### <a name="remarks"></a>備註

此成員函式會依照 Windows SDK 中的說明，實作用[ListView_SetHotItem](/windows/win32/api/commctrl/nf-commctrl-listview_sethotitem)Win32 宏的行為。

### <a name="example"></a>範例

請參閱[CListCtrl：： GetHotItem](#gethotitem)的範例。

## <a name="sethovertime"></a>CListCtrl：： SetHoverTime

設定清單視圖控制項的目前停留時間。

```
DWORD SetHoverTime(DWORD dwHoverTime = (DWORD)-1);
```

### <a name="parameters"></a>參數

*dwHoverTime*<br/>
新的延遲（以毫秒為單位），滑鼠游標必須停留在專案上，才能選取它。 如果傳遞預設值，時間會設定為預設的暫留時間。

### <a name="return-value"></a>傳回值

先前的暫留時間（以毫秒為單位）。

### <a name="remarks"></a>備註

此成員函式會依照 Windows SDK 中的說明，實作用[ListView_SetHoverTime](/windows/win32/api/commctrl/nf-commctrl-listview_sethovertime)Win32 宏的行為。

### <a name="example"></a>範例

請參閱[CListCtrl：： GetHoverTime](#gethovertime)的範例。

## <a name="seticonspacing"></a>CListCtrl：： SetIconSpacing

設定清單視圖控制項中圖示之間的間距。

```
CSize SetIconSpacing(
    int cx,
    int cy);

CSize SetIconSpacing(CSize size);
```

### <a name="parameters"></a>參數

*cx*<br/>
X 軸上圖示之間的距離（以圖元為單位）。

*cy*<br/>
Y 軸上圖示之間的距離（以圖元為單位）。

*size*<br/>
`CSize` 物件，指定 x 和 y 軸上圖示之間的距離（以圖元為單位）。

### <a name="return-value"></a>傳回值

[CSize](../../atl-mfc-shared/reference/csize-class.md)物件，包含圖示間距的先前值。

### <a name="remarks"></a>備註

此成員函式會依照 Windows SDK 中的說明，實作用[ListView_SetIconSpacing](/windows/win32/api/commctrl/nf-commctrl-listview_seticonspacing)Win32 宏的行為。

### <a name="example"></a>範例

```cpp
    // Leave lots of space between icons.
    m_myListCtrl.SetIconSpacing(CSize(100, 100));
```

## <a name="setimagelist"></a>CListCtrl：： SetImageList

將影像清單指派給清單視圖控制項。

```
CImageList* SetImageList(
    CImageList* pImageList,
    int nImageListType);
```

### <a name="parameters"></a>參數

*pImageList*<br/>
要指派之影像清單的指標。

*nImageListType*<br/>
影像清單的類型。 其可以是下列其中一個值：

- 具有大型圖示的 LVSIL_NORMAL 影像清單。

- 具有小圖示的 LVSIL_SMALL 影像清單。

- 具有狀態影像的 LVSIL_STATE 影像清單。

### <a name="return-value"></a>傳回值

上一個影像清單的指標。

### <a name="example"></a>範例

請參閱[CListCtrl：： GetImageList](#getimagelist)的範例。

## <a name="setinfotip"></a>CListCtrl：： SetInfoTip

設定工具提示文字。

```
BOOL SetInfoTip(PLVSETINFOTIP plvInfoTip);
```

### <a name="parameters"></a>參數

*plvInfoTip*<br/>
[LVFSETINFOTIP](/windows/win32/api/commctrl/ns-commctrl-lvsetinfotip)結構的指標，其中包含要設定的資訊。

### <a name="return-value"></a>傳回值

成功時傳回 TRUE，失敗時傳回 FALSE。

### <a name="remarks"></a>備註

此成員函式會模擬[LVM_SETINFOTIP](/windows/win32/Controls/lvm-setinfotip)訊息的功能，如 Windows SDK 中所述。

## <a name="setinsertmark"></a>CListCtrl：： SetInsertMark

將插入點設定為已定義的位置。

```
BOOL SetInsertMark(LPLVINSERTMARK plvim);
```

### <a name="parameters"></a>參數

*plvim*<br/>
[LVINSERTMARK](/windows/win32/api/commctrl/ns-commctrl-lvinsertmark)結構的指標，指定要設定插入點的位置。

### <a name="return-value"></a>傳回值

如果成功，則傳回 TRUE，否則傳回 FALSE。 如果 `LVINSERTMARK` 結構之 `cbSize` 成員中的大小不等於結構的實際大小，或插入點不適用於目前的視圖，則會傳回 FALSE。

### <a name="remarks"></a>備註

此成員函式會模擬[LVM_SETINSERTMARK](/windows/win32/Controls/lvm-setinsertmark)訊息的功能，如 Windows SDK 中所述。

## <a name="setinsertmarkcolor"></a>CListCtrl：： SetInsertMarkColor

設定插入點的色彩。

```
COLORREF SetInsertMarkColor(COLORREF color);
```

### <a name="parameters"></a>參數

*顏色*<br/>
[COLORREF](/windows/win32/gdi/colorref)結構，指定要設定插入點的色彩。

### <a name="return-value"></a>傳回值

傳回包含上一個色彩的 `COLORREF` 結構。

### <a name="remarks"></a>備註

此成員函式會模擬[LVM_SETINSERTMARKCOLOR](/windows/win32/Controls/lvm-setinsertmarkcolor)訊息的功能，如 Windows SDK 中所述。

## <a name="setitem"></a>CListCtrl：： SetItem

設定部分或所有清單視圖專案的屬性。

```
BOOL SetItem(const LVITEM* pItem);

BOOL SetItem(
    int nItem,
    int nSubItem,
    UINT nMask,
    LPCTSTR lpszItem,
    int nImage,
    UINT nState,
    UINT nStateMask,
    LPARAM lParam);

BOOL SetItem(
    int nItem,
    int nSubItem,
    UINT nMask,
    LPCTSTR lpszItem,
    int nImage,
    UINT nState,
    UINT nStateMask,
    LPARAM lParam,
    int nIndent);
```

### <a name="parameters"></a>參數

*pItem*<br/>
[LVITEM](/windows/win32/api/commctrl/ns-commctrl-lvitemw)結構的位址，其中包含新的專案屬性，如 Windows SDK 中所述。 結構的 `iItem` 和 `iSubItem` 成員會識別專案或子項，而結構的 `mask` 成員會指定要設定的屬性。 如需 `mask` 成員的詳細資訊，請參閱**備註**。

*nItem*<br/>
要設定其屬性之專案的索引。

*nSubItem*<br/>
要設定其屬性之子工作的索引。

*nMask*<br/>
指定要設定的屬性（請參閱備註）。

*lpszItem*<br/>
指定專案標籤之以 null 終止之字串的位址。

*nImage*<br/>
影像清單中專案影像的索引。

*nState*<br/>
指定要變更之狀態的值（請參閱備註）。

*nStateMask*<br/>
指定要變更的狀態（請參閱備註）。

*lParam*<br/>
要與專案相關聯的32位應用程式特定值。

*nIndent*<br/>
縮排的寬度（以圖元為單位）。 如果*nIndent*小於系統定義的最小寬度，新的寬度會設定為系統定義的最小值

### <a name="return-value"></a>傳回值

如果成功則不為零，否則為 0。

### <a name="remarks"></a>備註

`LVITEM` 結構和*nItem*和*nSubItem*參數的 `iItem` 和 `iSubItem` 成員，會識別要設定其屬性的專案和子項。

`LVITEM` 結構的 `mask` 成員和*nMask*參數會指定要設定的專案屬性：

- LVIF_TEXT `pszText` 成員，或*lpszItem*參數是以 null 終止之字串的位址;已忽略 `cchTextMax` 成員。

- LVIF_STATE `stateMask` member 或*nStateMask*參數指定要變更的專案狀態，而 `state` 成員或*nState*參數包含這些狀態的值。

### <a name="example"></a>範例

請參閱[CListCtrl：： HitTest](#hittest)的範例。

## <a name="setitemcount"></a>CListCtrl：： SetItemCount

準備清單視圖控制項以加入大量專案。

```
void SetItemCount(int nItems);
```

### <a name="parameters"></a>參數

*nItems*<br/>
控制項最後將包含的專案數。

### <a name="remarks"></a>備註

若要設定虛擬清單視圖控制項的專案計數，請參閱[CListCtrl：： SetItemCountEx](#setitemcountex)。

### <a name="remarks"></a>備註

此成員函式會依照 Windows SDK 中的說明，實作用[ListView_SetItemCount](/windows/win32/api/commctrl/nf-commctrl-listview_setitemcount)Win32 宏的行為。

### <a name="example"></a>範例

```cpp
        CString str;

        // Add 1024 items to the list view control.
        m_myListCtrl.SetItemCount(1024);

        for (int i = 0; i < 1024; i++)
        {
            str.Format(TEXT("item %d"), i);
            m_myListCtrl.InsertItem(i, str);
        }
```

## <a name="setitemcountex"></a>CListCtrl：： SetItemCountEx

設定虛擬清單視圖控制項的專案計數。

```
BOOL SetItemCountEx(
    int iCount,
    DWORD dwFlags = LVSICF_NOINVALIDATEALL);
```

### <a name="parameters"></a>參數

*iCount*<br/>
控制項最後將包含的專案數。

*dwFlags*<br/>
指定在重設專案計數之後，清單視圖控制項的行為。 此值可以是下列各項的組合：

- 除非受影響的專案目前為 view，否則清單視圖控制項 LVSICF_NOINVALIDATEALL 不會重新繪製。 這是預設值。

- LVSICF_NOSCROLL 當專案計數變更時，清單視圖控制項不會變更捲軸位置。

### <a name="return-value"></a>傳回值

如果成功則不為零，否則為 0。

### <a name="remarks"></a>備註

此成員函式會執行 Win32 宏的行為， [ListView_SetItemCountEx](/windows/win32/api/commctrl/nf-commctrl-listview_setitemcountex)，如 Windows SDKand 中所述，只應針對虛擬清單視圖呼叫。

### <a name="example"></a>範例

```cpp
        CString str;

        // Add 1024 items to the list view control.

        // Force my virtual list view control to allocate
        // enough memory for my 1024 items.
        m_myVirtualListCtrl.SetItemCountEx(1024, LVSICF_NOSCROLL|
            LVSICF_NOINVALIDATEALL);

        for (int i = 0; i < 1024; i++)
        {
            str.Format(TEXT("item %d"), i);
            m_myVirtualListCtrl.InsertItem(i, str);
        }
```

## <a name="setitemdata"></a>CListCtrl：： SetItemData

設定與*nItem*所指定的專案相關聯的32位應用程式特定值。

```
BOOL SetItemData(int nItem, DWORD_PTR dwData);
```

### <a name="parameters"></a>參數

*nItem*<br/>
要設定其資料之清單專案的索引。

*dwData*<br/>
要與專案相關聯的32位值。

### <a name="return-value"></a>傳回值

如果成功則為非零；否則為 0。

### <a name="remarks"></a>備註

這個值是[LVITEM](/windows/win32/api/commctrl/ns-commctrl-lvitemw)結構的 `lParam` 成員，如 Windows SDK 所述。

### <a name="example"></a>範例

```cpp
    // Set the data of each item to be equal to its index.
    for (int i = 0; i < m_myListCtrl.GetItemCount(); i++)
    {
        m_myListCtrl.SetItemData(i, i);
    }
```

## <a name="setitemindexstate"></a>CListCtrl：： SetItemIndexState

設定目前清單視圖控制項中專案的狀態。

```
BOOL SetItemIndexState(
    PLVITEMINDEX pItemIndex,
    DWORD dwState,
    DWORD dwMask) const;
```

### <a name="parameters"></a>參數

|參數|描述|
|---------------|-----------------|
|*pItemIndex*|在描述專案之[LVITEMINDEX](/windows/win32/api/commctrl/ns-commctrl-lvitemindex)結構的指標。 呼叫端負責配置此結構並設定其成員。|
|*dwState*|在要設定專案的狀態，這是[清單視圖專案狀態](/windows/win32/Controls/list-view-item-states)的位元組合。 指定零以重設或設定一個狀態。|
|*dwMask*|在*DwState*參數所指定之狀態有效位的遮罩。 指定[清單視圖專案狀態](/windows/win32/Controls/list-view-item-states)的位合（或）。|

### <a name="return-value"></a>傳回值

如果此方法成功，則為 TRUE;否則為 FALSE。

### <a name="remarks"></a>備註

如需*dwState*參數的詳細資訊，請參閱[清單視圖專案狀態](/windows/win32/Controls/list-view-item-states)。

如需*dwMask*參數的詳細資訊，請參閱[LVITEM](/windows/win32/api/commctrl/ns-commctrl-lvitemw)結構的*stateMask*成員。

這個方法會傳送[LVM_SETITEMINDEXSTATE](/windows/win32/Controls/lvm-setitemindexstate)訊息，如 Windows SDK 所述。

## <a name="setitemposition"></a>CListCtrl：： SetItemPosition

將專案移至清單視圖控制項中的指定位置。

```
BOOL SetItemPosition(
    int nItem,
    POINT pt);
```

### <a name="parameters"></a>參數

*nItem*<br/>
要設定其位置之專案的索引。

*pt*<br/>
[點](/previous-versions/dd162805\(v=vs.85\))結構，指定專案左上角的新位置（以視圖座標表示）。

### <a name="return-value"></a>傳回值

如果成功則不為零，否則為 0。

### <a name="remarks"></a>備註

控制項必須在圖示或小圖示視圖中。

如果清單視圖控制項具有 LVS_AUTOARRANGE 樣式，則清單視圖會在設定專案的位置之後排列。

### <a name="example"></a>範例

請參閱[CListCtrl：： GetItemPosition](#getitemposition)的範例。

## <a name="setitemstate"></a>CListCtrl：： SetItemState

變更清單視圖控制項中專案的狀態。

```
BOOL SetItemState(
    int nItem,
    LVITEM* pItem);

BOOL SetItemState(
    int nItem,
    UINT nState,
    UINT nMask);
```

### <a name="parameters"></a>參數

*nItem*<br/>
要設定其狀態之專案的索引。

*pItem*<br/>
[LVITEM](/windows/win32/api/commctrl/ns-commctrl-lvitemw)結構的位址，如 Windows SDK 中所述。 結構的 `stateMask` 成員會指定要變更的狀態位，而結構的 `state` 成員則包含這些位的新值。 其他成員則會被忽略。

*nState*<br/>
狀態位的新值。 如需可能值的清單，請參閱[CListCtrl：： GetNextItem](#getnextitem)和[LVITEM](/windows/win32/api/commctrl/ns-commctrl-lvitemw) state 成員。

*nMask*<br/>
指定要變更之狀態位的遮罩。 這個值會對應至[LVITEM](/windows/win32/api/commctrl/ns-commctrl-lvitemw)結構的 stateMask 成員。

### <a name="return-value"></a>傳回值

如果成功則不為零，否則為 0。

### <a name="remarks"></a>備註

專案的「狀態」是指定專案可用性、表示使用者動作，或以其他方式反映專案狀態的值。 清單視圖控制項會變更一些狀態位，例如當使用者選取專案時。 應用程式可能會變更其他狀態位來停用或隱藏專案，或指定重迭影像或狀態影像。

### <a name="example"></a>範例

請參閱[CListCtrl：： GetTopIndex](#gettopindex)的範例。

## <a name="setitemtext"></a>CListCtrl：： SetItemText

變更清單視圖專案或子項的文字。

```
BOOL SetItemText(
    int nItem,
    int nSubItem,
    LPCTSTR lpszText);
```

### <a name="parameters"></a>參數

*nItem*<br/>
要設定其文字之專案的索引。

*nSubItem*<br/>
子專案的索引，或為零以設定專案標籤。

*lpszText*<br/>
包含新專案文字之字串的指標。

### <a name="return-value"></a>傳回值

如果成功則不為零，否則為 0。

### <a name="remarks"></a>備註

這個方法不適合搭配包含 LVS_OWNERDATA 視窗樣式的控制項使用（事實上，這會造成在 Debug 組建中的判斷提示）。 如需這份清單控制項樣式的詳細資訊，請參閱[清單視圖控制項總覽](/windows/win32/Controls/list-view-controls-overview)。

### <a name="example"></a>範例

請參閱[CListCtrl：： InsertItem](#insertitem)的範例。

## <a name="setoutlinecolor"></a>CListCtrl：： SetOutlineColor

如果已設定 [ [LVS_EX_BORDERSELECT](/windows/win32/Controls/list-view-window-styles)擴充] 視窗樣式，則設定清單視圖控制項的框線色彩。

```
COLORREF SetOutlineColor(COLORREF color);
```

### <a name="parameters"></a>參數

*顏色*<br/>
包含外框色彩的新[COLORREF](/windows/win32/gdi/colorref)結構。

### <a name="return-value"></a>傳回值

包含外框色彩的上一個 `COLORREF` 結構

### <a name="remarks"></a>備註

此成員函式會模擬[LVM_SETOUTLINECOLOR](/windows/win32/Controls/lvm-setoutlinecolor)訊息的功能，如 Windows SDK 中所述。

## <a name="setselectedcolumn"></a>CListCtrl：： SetSelectedColumn

設定清單視圖控制項的選取資料行。

```
LRESULT SetSelectedColumn(int iCol);
```

### <a name="parameters"></a>參數

*iCol*<br/>
要選取之資料行的索引。

### <a name="return-value"></a>傳回值

不使用傳回值。

### <a name="remarks"></a>備註

此成員函式會模擬[LVM_SETSELECTEDCOLUMN](/windows/win32/Controls/lvm-setselectedcolumn)訊息的功能，如 Windows SDK 中所述。

## <a name="setselectionmark"></a>CListCtrl：： SetSelectionMark

設定清單視圖控制項的選取標記。

```
int SetSelectionMark(int iIndex);
```

### <a name="parameters"></a>參數

*iIndex*<br/>
多重選取範圍中第一個專案之以零為基底的索引。

### <a name="return-value"></a>傳回值

上一個選取標記，如果沒有選取標記，則為-1。

### <a name="remarks"></a>備註

此成員函式會依照 Windows SDK 中的說明，實作用[ListView_SetSelectionMark](/windows/win32/api/commctrl/nf-commctrl-listview_setselectionmark)Win32 宏的行為。

### <a name="example"></a>範例

請參閱[CListCtrl：： GetSelectionMark](#getselectionmark)的範例。

## <a name="settextbkcolor"></a>CListCtrl：： SetTextBkColor

設定清單視圖控制項中文字的背景色彩。

```
BOOL SetTextBkColor(COLORREF cr);
```

### <a name="parameters"></a>參數

*符*<br/>
COLORREF，指定新的文字背景色彩。 如需相關資訊，請參閱 Windows SDK 中的[COLORREF](/windows/win32/gdi/colorref) 。

### <a name="return-value"></a>傳回值

如果成功則不為零，否則為 0。

### <a name="example"></a>範例

```cpp
        // Use the 3D button face color for the background.
        COLORREF crBkColor = ::GetSysColor(COLOR_3DFACE);
        m_myListCtrl.SetTextBkColor(crBkColor);
        ASSERT(m_myListCtrl.GetTextBkColor() == crBkColor);
```

## <a name="settextcolor"></a>CListCtrl：： SetTextColor

設定清單視圖控制項的文字色彩。

```
BOOL SetTextColor(COLORREF cr);
```

### <a name="parameters"></a>參數

*符*<br/>
指定新文字色彩的 COLORREF。 如需相關資訊，請參閱 Windows SDK 中的[COLORREF](/windows/win32/gdi/colorref) 。

### <a name="return-value"></a>傳回值

如果成功則不為零，否則為 0。

### <a name="example"></a>範例

```cpp
    // Use the window text color for
    // the item text of the list view control.
    COLORREF crTextColor = ::GetSysColor(COLOR_WINDOWTEXT);
    m_myListCtrl.SetTextColor(crTextColor);
    ASSERT(m_myListCtrl.GetTextColor() == crTextColor);
```

## <a name="settileinfo"></a>CListCtrl：： SetTileInfo

設定清單視圖控制項磚的資訊。

```
BOOL SetTileInfo(PLVTILEINFO pTileInfo);
```

### <a name="parameters"></a>參數

*pTileInfo*<br/>
[LVTILEINFO](/windows/win32/api/commctrl/ns-commctrl-lvtileinfo)結構的指標，其中包含要設定的資訊。

### <a name="return-value"></a>傳回值

成功時傳回 TRUE，失敗時傳回 FALSE。

### <a name="remarks"></a>備註

此成員函式會模擬[LVM_SETTILEINFO](/windows/win32/Controls/lvm-settileinfo)訊息的功能，如 Windows SDK 中所述。

## <a name="settileviewinfo"></a>CListCtrl：： SetTileViewInfo

設定清單視圖控制項在磚視圖中使用的資訊。

```
BOOL SetTileViewInfo(PLVTILEVIEWINFO ptvi);
```

### <a name="parameters"></a>參數

*ptvi*<br/>
[LVTILEVIEWINFO](/windows/win32/api/commctrl/ns-commctrl-lvtileviewinfo)結構的指標，其中包含要設定的資訊。

### <a name="return-value"></a>傳回值

成功時傳回 TRUE，失敗時傳回 FALSE。

### <a name="remarks"></a>備註

此成員函式會模擬[LVM_SETTILEVIEWINFO](/windows/win32/Controls/lvm-settileviewinfo)訊息的功能，如 Windows SDK 中所述。

## <a name="settooltips"></a>CListCtrl：： SetToolTips

設定清單視圖控制項將用來顯示工具提示的工具提示控制項。

```
CToolTipCtrl* SetToolTips(CToolTipCtrl* pWndTip);
```

### <a name="parameters"></a>參數

*pWndTip*<br/>
清單控制項將使用之 `CToolTipCtrl` 物件的指標。

### <a name="return-value"></a>傳回值

[CToolTipCtrl](ctooltipctrl-class.md)物件的指標，其中包含控制項先前使用的工具提示，如果先前未使用任何工具提示，則為 Null。

### <a name="remarks"></a>備註

此成員函式會依照 Windows SDK 中的說明，實作用[LVM_SETTOOLTIPS](/windows/win32/Controls/lvm-settooltips)Win32 訊息的行為。

若不要使用工具提示，請在建立 `CListCtrl` 物件時指出 LVS_NOTOOLTIPS 樣式。

## <a name="setview"></a>CListCtrl：： SetView

設定清單視圖控制項的視圖。

```
DWORD SetView(int iView);
```

### <a name="parameters"></a>參數

*iView*<br/>
要選取的視圖。

### <a name="return-value"></a>傳回值

如果成功，則傳回1，否則傳回-1。 例如，如果此視圖無效，則會傳回-1。

### <a name="remarks"></a>備註

此成員函式會模擬[LVM_SETVIEW](/windows/win32/Controls/lvm-setview)訊息的功能，如 Windows SDK 中所述。

## <a name="setworkareas"></a>CListCtrl：： SetWorkAreas

設定可以在清單視圖控制項中顯示圖示的區域。

```
void SetWorkAreas(
    int nWorkAreas,
    LPRECT lpRect);
```

### <a name="parameters"></a>參數

*nWorkAreas*<br/>
*LpRect*所指向之陣列中的 `RECT` 結構（或[CRect](../../atl-mfc-shared/reference/crect-class.md)物件）數目。

*lpRect*<br/>
`RECT` 結構（或 `CRect` 物件）陣列的位址，指定清單視圖控制項的新工作區域。 這些區域必須在用戶端座標中指定。 如果此參數為 Null，則工作區域將會設定為控制項的工作區。

### <a name="remarks"></a>備註

此成員函式會依照 Windows SDK 中的說明，實作用[ListView_SetWorkAreas](/windows/win32/api/commctrl/nf-commctrl-listview_setworkareas)Win32 宏的行為。

### <a name="example"></a>範例

```cpp
    // Remove all working areas.
    m_myListCtrl.SetWorkAreas(0, NULL);
```

## <a name="sortgroups"></a>CListCtrl：： SortGroups

使用應用程式定義的比較函式，依清單視圖控制項中的識別碼來排序群組。

```
BOOL SortGroups(
    PFNLVGROUPCOMPARE _pfnGroupCompare,
    LPVOID _plv);
```

### <a name="parameters"></a>參數

*_pfnGroupCompare*<br/>
群組比較函式的指標。

*_plv*<br/>
Void 指標。

### <a name="return-value"></a>傳回值

成功時傳回 TRUE，失敗時傳回 FALSE。

### <a name="remarks"></a>備註

此成員函式會模擬[LVM_SORTGROUPS](/windows/win32/Controls/lvm-sortgroups)訊息的功能，如 Windows SDK 中所述。

## <a name="sortitems"></a>CListCtrl：： SortItems

使用應用程式定義的比較函數排序清單視圖專案。

```
BOOL SortItems(
    PFNLVCOMPARE pfnCompare,
    DWORD_PTR dwData);
```

### <a name="parameters"></a>參數

*pfnCompare*<br/>
在應用程式定義的比較函數的位址。

排序作業會在每次需要判斷兩個清單專案的相對順序時，呼叫比較函數。 比較函式必須是類別的靜態成員，或是不是任何類別成員的獨立函數。

*dwData*<br/>
在應用程式定義的值，會傳遞給比較函數。

### <a name="return-value"></a>傳回值

如果方法成功，則為 TRUE;否則為 FALSE。

### <a name="remarks"></a>備註

這個方法會變更每個專案的索引，以反映新的序列。

比較函數*pfnCompare*具有下列格式：

```
int CALLBACK CompareFunc(LPARAM lParam1,
    LPARAM lParam2,
    LPARAM lParamSort);
```
如果第一個專案應該在第二個專案前面，則比較函式必須傳回負值，如果第一個專案應該在第二個專案後面，則為正值; 如果兩個專案相等，則為零。

*LParam1*參數是與第一個比較的專案相關聯的32位值，而*lParam2*參數是與第二個專案相關聯的值。 這些值是在專案的[LVITEM](/windows/win32/api/commctrl/ns-commctrl-lvitemw)結構的*lParam*成員中，于插入清單時所指定的值。 *LParamSort*參數與*dwData*值相同。

這個方法會傳送[LVM_SORTITEMS](/windows/win32/Controls/lvm-sortitems)訊息，如 Windows SDK 所述。

### <a name="example"></a>範例

以下是簡單的比較函式，會導致專案依其*lParam*值排序。

```cpp
// Sort items by associated lParam
int CALLBACK CListCtrlDlg::MyCompareProc(LPARAM lParam1, LPARAM lParam2,
    LPARAM lParamSort)
{
    UNREFERENCED_PARAMETER(lParamSort);
    return (int)(lParam1 - lParam2);
}
```

```cpp
// Sort the items by passing in the comparison function.
void CListCtrlDlg::Sort()
{
    m_myListCtrl.SortItems(&CListCtrlDlg::MyCompareProc, 0);
}
```

## <a name="sortitemsex"></a>CListCtrl：： SortItemsEx

使用應用程式定義的比較函數，排序目前清單視圖控制項的專案。

```
BOOL SortItemsEx(
    PFNLVCOMPARE pfnCompare,
    DWORD_PTR dwData);
```

### <a name="parameters"></a>參數

|參數|描述|
|---------------|-----------------|
|*pfnCompare*|在應用程式定義的比較函數的位址。<br /><br /> 排序作業會在每次需要判斷兩個清單專案的相對順序時，呼叫比較函數。 比較函式必須是類別的靜態成員，或是不是任何類別成員的獨立函數。|
|*dwData*|在傳遞至比較函數的應用程式定義值。|

### <a name="return-value"></a>傳回值

如果此方法成功，則為 TRUE;否則為 FALSE。

### <a name="remarks"></a>備註

這個方法會變更每個專案的索引，以反映新的序列。

比較函數*pfnCompare*具有下列格式：

```
int CALLBACK CompareFunc(LPARAM lParam1,
    LPARAM lParam2,
    LPARAM lParamSort);
```
此訊息類似[LVM_SORTITEMS](/windows/win32/Controls/lvm-sortitems)，但傳遞至比較函數的資訊類型除外。 在[LVM_SORTITEMS](/windows/win32/Controls/lvm-sortitems)中， *lParam1*和*lParam2*是要比較之專案的值。 在[LVM_SORTITEMSEX](/windows/win32/Controls/lvm-sortitemsex)中， *lParam1*是要比較之第一個專案的目前索引，而*lParam2*是第二個專案的目前索引。 您可以傳送[LVM_GETITEMTEXT](/windows/win32/Controls/lvm-getitemtext)訊息來取得專案的詳細資訊。

如果第一個專案應該在第二個專案前面，則比較函式必須傳回負值，如果第一個專案應該在第二個專案後面，則為正值; 如果兩個專案相等，則為零。

> [!NOTE]
>  在排序過程中，清單視圖內容不穩定。 如果回呼函數將任何訊息傳送至[LVM_GETITEM](/windows/win32/Controls/lvm-getitem)以外的清單視圖控制項，則結果會是無法預測的。

這個方法會傳送[LVM_SORTITEMSEX](/windows/win32/Controls/lvm-sortitemsex)訊息，如 Windows SDK 所述。

### <a name="example"></a>範例

下列程式碼範例會定義用來存取目前清單視圖控制項的變數 `m_listCtrl`。 下一個範例中會使用此變數。

```cpp
public:
    // Variable used to access the list control.
    CListCtrl m_listCtrl;
```

### <a name="example"></a>範例

下列程式碼範例示範 `SortItemEx` 方法。 在這個程式碼範例的先前章節中，我們建立了清單視圖控制項，它會在報表檢視中顯示兩個標題為 "ClientID" 和 "年級" 的資料行。 下列程式碼範例會使用「等級」資料行中的值來排序資料表。

```cpp
// The ListCompareFunc() method is a global function used by SortItemEx().
int CALLBACK ListCompareFunc(
                             LPARAM lParam1,
                             LPARAM lParam2,
                             LPARAM lParamSort)
{
    CListCtrl* pListCtrl = (CListCtrl*) lParamSort;
    CString    strItem1 = pListCtrl->GetItemText(static_cast<int>(lParam1), 1);
    CString    strItem2 = pListCtrl->GetItemText(static_cast<int>(lParam2), 1)
    int x1 = _tstoi(strItem1.GetBuffer());
    int x2 = _tstoi(strItem2.GetBuffer());
    int result = 0;
    if ((x1 - x2) < 0)
        result = -1;
    else if ((x1 - x2) == 0)
        result = 0;
    else
        result = 1;

    return result;
}

void CCListCtrl_s2Dlg::OnBnClickedButton1()
{
    // SortItemsEx
    m_listCtrl.SortItemsEx( ListCompareFunc, (LPARAM)&m_listCtrl );
}
```

## <a name="subitemhittest"></a>CListCtrl：： SubItemHitTest

判斷哪個清單視圖專案（如果有的話）位於指定的位置。

```
int SubItemHitTest(LPLVHITTESTINFO pInfo);
```

### <a name="parameters"></a>參數

*pInfo*<br/>
[LVHITTESTINFO](/windows/win32/api/commctrl/ns-commctrl-lvhittestinfo)結構的指標。

### <a name="return-value"></a>傳回值

要測試之專案的以一為基的索引（如果有的話），否則為-1。

### <a name="remarks"></a>備註

此成員函式會依照 Windows SDK 中的說明，實作用[ListView_SubItemHitTest](/windows/win32/api/commctrl/nf-commctrl-listview_subitemhittest)Win32 宏的行為。

### <a name="example"></a>範例

```cpp
void CListCtrlDlg::OnDblClk(NMHDR* pNMHDR, LRESULT* pResult)
{
    UNREFERENCED_PARAMETER(pResult);
    LPNMITEMACTIVATE pia = (LPNMITEMACTIVATE)pNMHDR;
    LVHITTESTINFO lvhti;

    // Clear the subitem text the user clicked on.
    lvhti.pt = pia->ptAction;
    m_myListCtrl.SubItemHitTest(&lvhti);

    if (lvhti.flags & LVHT_ONITEMLABEL)
    {
        m_myListCtrl.SetItemText(lvhti.iItem, lvhti.iSubItem, NULL);
    }
}
```

## <a name="update"></a>CListCtrl：： Update

強制清單視圖控制項重新繪製*nItem*所指定的專案。

```
BOOL Update(int nItem);
```

### <a name="parameters"></a>參數

*nItem*<br/>
要更新之專案的索引。

### <a name="return-value"></a>傳回值

如果成功則不為零，否則為 0。

### <a name="remarks"></a>備註

如果清單視圖控制項具有 LVS_AUTOARRANGE 樣式，此函式也會進行排列。

### <a name="example"></a>範例

請參閱[CListCtrl：： GetSelectedCount](#getselectedcount)的範例。

## <a name="see-also"></a>另請參閱

[MFC 範例 ROWLIST](../../overview/visual-cpp-samples.md)<br/>
[CWnd 類別](cwnd-class.md)<br/>
[階層架構圖表](../hierarchy-chart.md)<br/>
[CImageList 類別](cimagelist-class.md)
