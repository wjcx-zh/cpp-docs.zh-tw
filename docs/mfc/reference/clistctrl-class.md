---
title: CListCtrl 類別
ms.date: 06/13/2019
f1_keywords:
- CListCtrl
- AFXCMN/CListCtrl
- AFXCMN/CListCtrl::CListCtrl
- AFXCMN/CListCtrl::ApproximateViewRect
- AFXCMN/CListCtrl::Arrange
- AFXCMN/CListCtrl::CancelEditLabel
- AFXCMN/CListCtrl::Create
- AFXCMN/CListCtrl::CreateDragImage
- AFXCMN/CListCtrl::CreateEx
- AFXCMN/CListCtrl::DeleteAllItems
- AFXCMN/CListCtrl::DeleteColumn
- AFXCMN/CListCtrl::DeleteItem
- AFXCMN/CListCtrl::DrawItem
- AFXCMN/CListCtrl::EditLabel
- AFXCMN/CListCtrl::EnableGroupView
- AFXCMN/CListCtrl::EnsureVisible
- AFXCMN/CListCtrl::FindItem
- AFXCMN/CListCtrl::GetBkColor
- AFXCMN/CListCtrl::GetBkImage
- AFXCMN/CListCtrl::GetCallbackMask
- AFXCMN/CListCtrl::GetCheck
- AFXCMN/CListCtrl::GetColumn
- AFXCMN/CListCtrl::GetColumnOrderArray
- AFXCMN/CListCtrl::GetColumnWidth
- AFXCMN/CListCtrl::GetCountPerPage
- AFXCMN/CListCtrl::GetEditControl
- AFXCMN/CListCtrl::GetEmptyText
- AFXCMN/CListCtrl::GetExtendedStyle
- AFXCMN/CListCtrl::GetFirstSelectedItemPosition
- AFXCMN/CListCtrl::GetFocusedGroup
- AFXCMN/CListCtrl::GetGroupCount
- AFXCMN/CListCtrl::GetGroupInfo
- AFXCMN/CListCtrl::GetGroupInfoByIndex
- AFXCMN/CListCtrl::GetGroupMetrics
- AFXCMN/CListCtrl::GetGroupRect
- AFXCMN/CListCtrl::GetGroupState
- AFXCMN/CListCtrl::GetHeaderCtrl
- AFXCMN/CListCtrl::GetHotCursor
- AFXCMN/CListCtrl::GetHotItem
- AFXCMN/CListCtrl::GetHoverTime
- AFXCMN/CListCtrl::GetImageList
- AFXCMN/CListCtrl::GetInsertMark
- AFXCMN/CListCtrl::GetInsertMarkColor
- AFXCMN/CListCtrl::GetInsertMarkRect
- AFXCMN/CListCtrl::GetItem
- AFXCMN/CListCtrl::GetItemCount
- AFXCMN/CListCtrl::GetItemData
- AFXCMN/CListCtrl::GetItemIndexRect
- AFXCMN/CListCtrl::GetItemPosition
- AFXCMN/CListCtrl::GetItemRect
- AFXCMN/CListCtrl::GetItemSpacing
- AFXCMN/CListCtrl::GetItemState
- AFXCMN/CListCtrl::GetItemText
- AFXCMN/CListCtrl::GetNextItem
- AFXCMN/CListCtrl::GetNextItemIndex
- AFXCMN/CListCtrl::GetNextSelectedItem
- AFXCMN/CListCtrl::GetNumberOfWorkAreas
- AFXCMN/CListCtrl::GetOrigin
- AFXCMN/CListCtrl::GetOutlineColor
- AFXCMN/CListCtrl::GetSelectedColumn
- AFXCMN/CListCtrl::GetSelectedCount
- AFXCMN/CListCtrl::GetSelectionMark
- AFXCMN/CListCtrl::GetStringWidth
- AFXCMN/CListCtrl::GetSubItemRect
- AFXCMN/CListCtrl::GetTextBkColor
- AFXCMN/CListCtrl::GetTextColor
- AFXCMN/CListCtrl::GetTileInfo
- AFXCMN/CListCtrl::GetTileViewInfo
- AFXCMN/CListCtrl::GetToolTips
- AFXCMN/CListCtrl::GetTopIndex
- AFXCMN/CListCtrl::GetView
- AFXCMN/CListCtrl::GetViewRect
- AFXCMN/CListCtrl::GetWorkAreas
- AFXCMN/CListCtrl::HasGroup
- AFXCMN/CListCtrl::HitTest
- AFXCMN/CListCtrl::InsertColumn
- AFXCMN/CListCtrl::InsertGroup
- AFXCMN/CListCtrl::InsertGroupSorted
- AFXCMN/CListCtrl::InsertItem
- AFXCMN/CListCtrl::InsertMarkHitTest
- AFXCMN/CListCtrl::IsGroupViewEnabled
- AFXCMN/CListCtrl::IsItemVisible
- AFXCMN/CListCtrl::MapIDToIndex
- AFXCMN/CListCtrl::MapIndexToID
- AFXCMN/CListCtrl::MoveGroup
- AFXCMN/CListCtrl::MoveItemToGroup
- AFXCMN/CListCtrl::RedrawItems
- AFXCMN/CListCtrl::RemoveAllGroups
- AFXCMN/CListCtrl::RemoveGroup
- AFXCMN/CListCtrl::Scroll
- AFXCMN/CListCtrl::SetBkColor
- AFXCMN/CListCtrl::SetBkImage
- AFXCMN/CListCtrl::SetCallbackMask
- AFXCMN/CListCtrl::SetCheck
- AFXCMN/CListCtrl::SetColumn
- AFXCMN/CListCtrl::SetColumnOrderArray
- AFXCMN/CListCtrl::SetColumnWidth
- AFXCMN/CListCtrl::SetExtendedStyle
- AFXCMN/CListCtrl::SetGroupInfo
- AFXCMN/CListCtrl::SetGroupMetrics
- AFXCMN/CListCtrl::SetHotCursor
- AFXCMN/CListCtrl::SetHotItem
- AFXCMN/CListCtrl::SetHoverTime
- AFXCMN/CListCtrl::SetIconSpacing
- AFXCMN/CListCtrl::SetImageList
- AFXCMN/CListCtrl::SetInfoTip
- AFXCMN/CListCtrl::SetInsertMark
- AFXCMN/CListCtrl::SetInsertMarkColor
- AFXCMN/CListCtrl::SetItem
- AFXCMN/CListCtrl::SetItemCount
- AFXCMN/CListCtrl::SetItemCountEx
- AFXCMN/CListCtrl::SetItemData
- AFXCMN/CListCtrl::SetItemIndexState
- AFXCMN/CListCtrl::SetItemPosition
- AFXCMN/CListCtrl::SetItemState
- AFXCMN/CListCtrl::SetItemText
- AFXCMN/CListCtrl::SetOutlineColor
- AFXCMN/CListCtrl::SetSelectedColumn
- AFXCMN/CListCtrl::SetSelectionMark
- AFXCMN/CListCtrl::SetTextBkColor
- AFXCMN/CListCtrl::SetTextColor
- AFXCMN/CListCtrl::SetTileInfo
- AFXCMN/CListCtrl::SetTileViewInfo
- AFXCMN/CListCtrl::SetToolTips
- AFXCMN/CListCtrl::SetView
- AFXCMN/CListCtrl::SetWorkAreas
- AFXCMN/CListCtrl::SortGroups
- AFXCMN/CListCtrl::SortItems
- AFXCMN/CListCtrl::SortItemsEx
- AFXCMN/CListCtrl::SubItemHitTest
- AFXCMN/CListCtrl::Update
helpviewer_keywords:
- CListCtrl [MFC], CListCtrl
- CListCtrl [MFC], ApproximateViewRect
- CListCtrl [MFC], Arrange
- CListCtrl [MFC], CancelEditLabel
- CListCtrl [MFC], Create
- CListCtrl [MFC], CreateDragImage
- CListCtrl [MFC], CreateEx
- CListCtrl [MFC], DeleteAllItems
- CListCtrl [MFC], DeleteColumn
- CListCtrl [MFC], DeleteItem
- CListCtrl [MFC], DrawItem
- CListCtrl [MFC], EditLabel
- CListCtrl [MFC], EnableGroupView
- CListCtrl [MFC], EnsureVisible
- CListCtrl [MFC], FindItem
- CListCtrl [MFC], GetBkColor
- CListCtrl [MFC], GetBkImage
- CListCtrl [MFC], GetCallbackMask
- CListCtrl [MFC], GetCheck
- CListCtrl [MFC], GetColumn
- CListCtrl [MFC], GetColumnOrderArray
- CListCtrl [MFC], GetColumnWidth
- CListCtrl [MFC], GetCountPerPage
- CListCtrl [MFC], GetEditControl
- CListCtrl [MFC], GetEmptyText
- CListCtrl [MFC], GetExtendedStyle
- CListCtrl [MFC], GetFirstSelectedItemPosition
- CListCtrl [MFC], GetFocusedGroup
- CListCtrl [MFC], GetGroupCount
- CListCtrl [MFC], GetGroupInfo
- CListCtrl [MFC], GetGroupInfoByIndex
- CListCtrl [MFC], GetGroupMetrics
- CListCtrl [MFC], GetGroupRect
- CListCtrl [MFC], GetGroupState
- CListCtrl [MFC], GetHeaderCtrl
- CListCtrl [MFC], GetHotCursor
- CListCtrl [MFC], GetHotItem
- CListCtrl [MFC], GetHoverTime
- CListCtrl [MFC], GetImageList
- CListCtrl [MFC], GetInsertMark
- CListCtrl [MFC], GetInsertMarkColor
- CListCtrl [MFC], GetInsertMarkRect
- CListCtrl [MFC], GetItem
- CListCtrl [MFC], GetItemCount
- CListCtrl [MFC], GetItemData
- CListCtrl [MFC], GetItemIndexRect
- CListCtrl [MFC], GetItemPosition
- CListCtrl [MFC], GetItemRect
- CListCtrl [MFC], GetItemSpacing
- CListCtrl [MFC], GetItemState
- CListCtrl [MFC], GetItemText
- CListCtrl [MFC], GetNextItem
- CListCtrl [MFC], GetNextItemIndex
- CListCtrl [MFC], GetNextSelectedItem
- CListCtrl [MFC], GetNumberOfWorkAreas
- CListCtrl [MFC], GetOrigin
- CListCtrl [MFC], GetOutlineColor
- CListCtrl [MFC], GetSelectedColumn
- CListCtrl [MFC], GetSelectedCount
- CListCtrl [MFC], GetSelectionMark
- CListCtrl [MFC], GetStringWidth
- CListCtrl [MFC], GetSubItemRect
- CListCtrl [MFC], GetTextBkColor
- CListCtrl [MFC], GetTextColor
- CListCtrl [MFC], GetTileInfo
- CListCtrl [MFC], GetTileViewInfo
- CListCtrl [MFC], GetToolTips
- CListCtrl [MFC], GetTopIndex
- CListCtrl [MFC], GetView
- CListCtrl [MFC], GetViewRect
- CListCtrl [MFC], GetWorkAreas
- CListCtrl [MFC], HasGroup
- CListCtrl [MFC], HitTest
- CListCtrl [MFC], InsertColumn
- CListCtrl [MFC], InsertGroup
- CListCtrl [MFC], InsertGroupSorted
- CListCtrl [MFC], InsertItem
- CListCtrl [MFC], InsertMarkHitTest
- CListCtrl [MFC], IsGroupViewEnabled
- CListCtrl [MFC], IsItemVisible
- CListCtrl [MFC], MapIDToIndex
- CListCtrl [MFC], MapIndexToID
- CListCtrl [MFC], MoveGroup
- CListCtrl [MFC], MoveItemToGroup
- CListCtrl [MFC], RedrawItems
- CListCtrl [MFC], RemoveAllGroups
- CListCtrl [MFC], RemoveGroup
- CListCtrl [MFC], Scroll
- CListCtrl [MFC], SetBkColor
- CListCtrl [MFC], SetBkImage
- CListCtrl [MFC], SetCallbackMask
- CListCtrl [MFC], SetCheck
- CListCtrl [MFC], SetColumn
- CListCtrl [MFC], SetColumnOrderArray
- CListCtrl [MFC], SetColumnWidth
- CListCtrl [MFC], SetExtendedStyle
- CListCtrl [MFC], SetGroupInfo
- CListCtrl [MFC], SetGroupMetrics
- CListCtrl [MFC], SetHotCursor
- CListCtrl [MFC], SetHotItem
- CListCtrl [MFC], SetHoverTime
- CListCtrl [MFC], SetIconSpacing
- CListCtrl [MFC], SetImageList
- CListCtrl [MFC], SetInfoTip
- CListCtrl [MFC], SetInsertMark
- CListCtrl [MFC], SetInsertMarkColor
- CListCtrl [MFC], SetItem
- CListCtrl [MFC], SetItemCount
- CListCtrl [MFC], SetItemCountEx
- CListCtrl [MFC], SetItemData
- CListCtrl [MFC], SetItemIndexState
- CListCtrl [MFC], SetItemPosition
- CListCtrl [MFC], SetItemState
- CListCtrl [MFC], SetItemText
- CListCtrl [MFC], SetOutlineColor
- CListCtrl [MFC], SetSelectedColumn
- CListCtrl [MFC], SetSelectionMark
- CListCtrl [MFC], SetTextBkColor
- CListCtrl [MFC], SetTextColor
- CListCtrl [MFC], SetTileInfo
- CListCtrl [MFC], SetTileViewInfo
- CListCtrl [MFC], SetToolTips
- CListCtrl [MFC], SetView
- CListCtrl [MFC], SetWorkAreas
- CListCtrl [MFC], SortGroups
- CListCtrl [MFC], SortItems
- CListCtrl [MFC], SortItemsEx
- CListCtrl [MFC], SubItemHitTest
- CListCtrl [MFC], Update
ms.assetid: fe08a1ca-4b05-4ff7-a12a-ee4c765a2197
ms.openlocfilehash: a1fa9f4bb7ba844dd2f0300cf007a786e8fde902
ms.sourcegitcommit: 1839405b97036891b6e4d37c99def044d6f37eff
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/18/2020
ms.locfileid: "88562476"
---
# <a name="clistctrl-class"></a>CListCtrl 類別

封裝「清單檢視控制項」的功能，顯示項目集合，其中每個項目是由圖示 (來自影像清單) 和標籤所組成的。

## <a name="syntax"></a>語法

```
class CListCtrl : public CWnd
```

## <a name="members"></a>成員

### <a name="public-constructors"></a>公用建構函式

|名稱|描述|
|----------|-----------------|
|[CListCtrl：： CListCtrl](#clistctrl)|建構 `CListCtrl` 物件。|

### <a name="public-methods"></a>公用方法

|名稱|描述|
|----------|-----------------|
|[CListCtrl：： ApproximateViewRect](#approximateviewrect)|決定顯示清單視圖控制項的專案所需的寬度和高度。|
|[CListCtrl：：排列](#arrange)|對齊格線上的專案。|
|[CListCtrl：： CancelEditLabel](#canceleditlabel)|取消專案文字編輯作業。|
|[CListCtrl：： Create](#create)|建立清單控制項，並將其附加至 `CListCtrl` 物件。|
|[CListCtrl：： CreateDragImage](#createdragimage)|為指定的專案建立拖曳影像清單。|
|[CListCtrl：： CreateEx](#createex)|使用指定的 Windows 擴充樣式建立清單控制項，並將其附加至 `CListCtrl` 物件。|
|[CListCtrl：:D eleteAllItems](#deleteallitems)|從控制項中刪除所有專案。|
|[CListCtrl：:D eleteColumn](#deletecolumn)|從清單視圖控制項中刪除資料行。|
|[CListCtrl：:D eleteItem](#deleteitem)|從控制項中刪除專案。|
|[CListCtrl：:D rawItem](#drawitem)|當主控描繪控制項的視覺外觀變更時呼叫。|
|[CListCtrl：： EditLabel](#editlabel)|開始就地編輯專案的文字。|
|[CListCtrl：： EnableGroupView](#enablegroupview)|啟用或停用清單視圖控制項中的專案是否顯示為群組。|
|[CListCtrl：： EnsureVisible](#ensurevisible)|確定專案可以看見。|
|[CListCtrl：： FindItem](#finditem)|搜尋具有指定特性的清單視圖專案。|
|[CListCtrl：： GetBkColor](#getbkcolor)|抓取清單視圖控制項的背景色彩。|
|[CListCtrl：： GetBkImage](#getbkimage)|抓取清單視圖控制項的目前背景影像。|
|[CListCtrl：： GetCallbackMask](#getcallbackmask)|抓取清單視圖控制項的回呼遮罩。|
|[CListCtrl：： GetCheck](#getcheck)|抓取與專案相關聯之狀態影像的目前顯示狀態。|
|[CListCtrl：： GetColumn](#getcolumn)|抓取控制項資料行的屬性。|
|[CListCtrl：： GetColumnOrderArray](#getcolumnorderarray)|從清單視圖控制項的左到右) 抓取資料行順序 (。|
|[CListCtrl：： GetColumnWidth](#getcolumnwidth)|抓取報表檢視或清單視圖中資料行的寬度。|
|[CListCtrl：： GetCountPerPage](#getcountperpage)|計算清單視圖控制項中可以垂直容納的專案數。|
|[CListCtrl：： GetEditControl](#geteditcontrol)|抓取用來編輯專案文字的編輯控制項控點。|
|[CListCtrl：： GetEmptyText](#getemptytext)|抓取目前的清單視圖控制項是否為空白時，所要顯示的字串。|
|[CListCtrl：： GetExtendedStyle](#getextendedstyle)|抓取清單視圖控制項目前的擴充樣式。|
|[CListCtrl：： GetFirstSelectedItemPosition](#getfirstselecteditemposition)|抓取清單視圖控制項中第一個選取清單視圖專案的位置。|
|[CListCtrl：： GetFocusedGroup](#getfocusedgroup)|抓取將鍵盤焦點放在目前清單視圖控制項中的群組。|
|[CListCtrl：： GetGroupCount](#getgroupcount)|抓取目前清單視圖控制項中的群組數目。|
|[CListCtrl：： GetGroupInfo](#getgroupinfo)|取得清單視圖控制項之指定群組的資訊。|
|[CListCtrl：： GetGroupInfoByIndex](#getgroupinfobyindex)|抓取目前清單視圖控制項中指定之群組的相關資訊。|
|[CListCtrl：： GetGroupMetrics](#getgroupmetrics)|抓取群組的度量。|
|[CListCtrl：： GetGroupRect](#getgrouprect)|抓取目前清單視圖控制項中指定群組的周框。|
|[CListCtrl：： GetGroupState](#getgroupstate)|抓取目前清單視圖控制項中指定之群組的狀態。|
|[CListCtrl：： GetHeaderCtrl](#getheaderctrl)|抓取清單視圖控制項的標題控制項。|
|[CListCtrl：： GetHotCursor](#gethotcursor)|抓取針對清單視圖控制項啟用熱追蹤時所使用的資料指標。|
|[CListCtrl：： GetHotItem](#gethotitem)|抓取目前在游標下的清單視圖專案。|
|[CListCtrl：： GetHoverTime](#gethovertime)|抓取清單視圖控制項目前的停留時間。|
|[CListCtrl：： GetImageList](#getimagelist)|抓取用來繪製清單視圖專案的影像清單控制碼。|
|[CListCtrl：： GetInsertMark](#getinsertmark)|抓取插入標記的目前位置。|
|[CListCtrl：： GetInsertMarkColor](#getinsertmarkcolor)|抓取插入標記目前的色彩。|
|[CListCtrl：： GetInsertMarkRect](#getinsertmarkrect)|抓取插入點界限的矩形。|
|[CListCtrl：： GetItem](#getitem)|抓取清單視圖專案的屬性。|
|[CListCtrl：： GetItemCount](#getitemcount)|抓取清單視圖控制項中的專案數。|
|[CListCtrl：： GetItemData](#getitemdata)|抓取與專案相關聯的應用程式特定值。|
|[CListCtrl：： GetItemIndexRect](#getitemindexrect)|抓取目前清單視圖控制項中，所有或部分子部分的周框。|
|[CListCtrl：： GetItemPosition](#getitemposition)|抓取清單視圖專案的位置。|
|[CListCtrl：： GetItemRect](#getitemrect)|抓取專案的周框。|
|[CListCtrl：： GetItemSpacing](#getitemspacing)|計算目前清單視圖控制項中專案之間的間距。|
|[CListCtrl：： GetItemState](#getitemstate)|抓取清單視圖專案的狀態。|
|[CListCtrl：： GetItemText](#getitemtext)|抓取清單視圖專案或子專案的文字。|
|[CListCtrl：： GetNextItem](#getnextitem)|使用指定的屬性以及指定之關聯性的指定專案，搜尋清單視圖專案。|
|[CListCtrl：： GetNextItemIndex](#getnextitemindex)|抓取目前清單視圖控制項中具有指定屬性集之專案的索引。|
|[CListCtrl：： GetNextSelectedItem](#getnextselecteditem)|抓取清單視圖專案位置的索引，以及下一次選取清單視圖專案的位置以進行反覆運算。|
|[CListCtrl：： GetNumberOfWorkAreas](#getnumberofworkareas)|抓取清單視圖控制項目前的工作區數目。|
|[CListCtrl：： GetOrigin](#getorigin)|抓取清單視圖控制項的目前視圖原點。|
|[CListCtrl：： GetOutlineColor](#getoutlinecolor)|抓取清單視圖控制項的框線色彩。|
|[CListCtrl：： GetSelectedColumn](#getselectedcolumn)|抓取清單控制項中目前所選資料行的索引。|
|[CListCtrl：： GetSelectedCount](#getselectedcount)|抓取清單視圖控制項中選取的專案數目。|
|[CListCtrl：： GetSelectionMark](#getselectionmark)|抓取清單視圖控制項的選取專案標記。|
|[CListCtrl：： GetStringWidth](#getstringwidth)|決定顯示所有指定字串所需的最小資料行寬度。|
|[CListCtrl：： GetSubItemRect](#getsubitemrect)|抓取清單視圖控制項中專案的周框。|
|[CListCtrl：： GetTextBkColor](#gettextbkcolor)|抓取清單視圖控制項的文字背景色彩。|
|[CListCtrl：： GetTextColor](#gettextcolor)|抓取清單視圖控制項的文字色彩。|
|[CListCtrl：： GetTileInfo](#gettileinfo)|抓取清單視圖控制項中的圖格相關資訊。|
|[CListCtrl：： GetTileViewInfo](#gettileviewinfo)|抓取並排顯示中清單視圖控制項的相關資訊。|
|[CListCtrl：： GetToolTips](#gettooltips)|抓取清單視圖控制項用來顯示工具提示的工具提示控制項。|
|[CListCtrl：： GetTopIndex](#gettopindex)|抓取最上層可見專案的索引。|
|[CListCtrl：： GetView](#getview)|取得清單視圖控制項的視圖。|
|[CListCtrl：： GetViewRect](#getviewrect)|抓取清單視圖控制項中所有專案的周框。|
|[CListCtrl：： GetWorkAreas](#getworkareas)|抓取清單視圖控制項目前的工作區域。|
|[CListCtrl：： HasGroup](#hasgroup)|判斷清單視圖控制項是否有指定的群組。|
|[CListCtrl：： System.windows.media.visualtreehelper.hittest](#hittest)|判斷哪一個清單視圖專案位於指定的位置。|
|[CListCtrl：： InsertColumn](#insertcolumn)|在清單視圖控制項中插入新的資料行。|
|[CListCtrl：： InsertGroup](#insertgroup)|將群組插入清單視圖控制項。|
|[CListCtrl：： InsertGroupSorted](#insertgroupsorted)|將指定的群組插入群組的已排序清單中。|
|[CListCtrl：： InsertItem](#insertitem)|在清單視圖控制項中插入新專案。|
|[CListCtrl：： InsertMarkHitTest](#insertmarkhittest)|抓取最接近指定點的插入點。|
|[CListCtrl：： IsGroupViewEnabled](#isgroupviewenabled)|決定是否啟用清單視圖控制項的群組視圖。|
|[CListCtrl：： IsItemVisible](#isitemvisible)|指出是否可以看到目前清單視圖控制項中的指定專案。|
|[CListCtrl：： MapIDToIndex](#mapidtoindex)|將目前清單視圖控制項中專案的唯一識別碼對應至索引。|
|[CListCtrl：： MapIndexToID](#mapindextoid)|將目前清單視圖控制項中專案的索引對應至唯一識別碼。|
|[CListCtrl：： MoveGroup](#movegroup)|移動指定的群組。|
|[CListCtrl：： MoveItemToGroup](#moveitemtogroup)|將指定的群組移至清單視圖控制項之以零為基底的指定索引。|
|[CListCtrl：： RedrawItems](#redrawitems)|強制清單視圖控制項重新繪製專案的範圍。|
|[CListCtrl：： RemoveAllGroups](#removeallgroups)|從清單視圖控制項移除所有群組。|
|[CListCtrl：： RemoveGroup](#removegroup)|從清單視圖控制項中移除指定的群組。|
|[CListCtrl：： Scroll](#scroll)|滾動清單視圖控制項的內容。|
|[CListCtrl：： SetBkColor](#setbkcolor)|設定清單視圖控制項的背景色彩。|
|[CListCtrl：： SetBkImage](#setbkimage)|設定清單視圖控制項的目前背景影像。|
|[CListCtrl：： SetCallbackMask](#setcallbackmask)|設定清單視圖控制項的回呼遮罩。|
|[CListCtrl：： SetCheck](#setcheck)|設定與專案相關聯之狀態影像的目前顯示狀態。|
|[CListCtrl：： SetColumn](#setcolumn)|設定清單視圖資料行的屬性。|
|[CListCtrl：： SetColumnOrderArray](#setcolumnorderarray)|將資料行順序設定 (從清單視圖控制項的左到右) 。|
|[CListCtrl：： SetColumnWidth](#setcolumnwidth)|在報表檢視或清單視圖中變更資料行的寬度。|
|[CListCtrl：： SetExtendedStyle](#setextendedstyle)|設定清單視圖控制項目前的擴充樣式。|
|[CListCtrl：： SetGroupInfo](#setgroupinfo)|設定清單視圖控制項之指定群組的資訊。|
|[CListCtrl：： SetGroupMetrics](#setgroupmetrics)|設定清單視圖控制項的群組度量。|
|[CListCtrl：： SetHotCursor](#sethotcursor)|設定當針對清單視圖控制項啟用熱追蹤時，所使用的資料指標。|
|[CListCtrl：： SetHotItem](#sethotitem)|設定清單視圖控制項的目前熱專案。|
|[CListCtrl：： SetHoverTime](#sethovertime)|設定清單視圖控制項目前的停留時間。|
|[CListCtrl：： SetIconSpacing](#seticonspacing)|在清單視圖控制項中設定圖示之間的間距。|
|[CListCtrl：： SetImageList](#setimagelist)|將影像清單指派給清單視圖控制項。|
|[CListCtrl：： SetInfoTip](#setinfotip)|設定工具提示文字。|
|[CListCtrl：： SetInsertMark](#setinsertmark)|將插入點設定為已定義的位置。|
|[CListCtrl：： SetInsertMarkColor](#setinsertmarkcolor)|設定插入點的色彩。|
|[CListCtrl：： SetItem](#setitem)|設定部分或全部清單視圖專案的屬性。|
|[CListCtrl：： SetItemCount](#setitemcount)|準備清單視圖控制項以加入大量專案。|
|[CListCtrl：： SetItemCountEx](#setitemcountex)|設定虛擬清單視圖控制項的專案計數。|
|[CListCtrl：： SetItemData](#setitemdata)|設定專案的應用程式特定值。|
|[CListCtrl：： SetItemIndexState](#setitemindexstate)|設定目前清單視圖控制項中專案的狀態。|
|[CListCtrl：： SetItemPosition](#setitemposition)|將專案移至清單視圖控制項中的指定位置。|
|[CListCtrl：： SetItemState](#setitemstate)|變更清單視圖控制項中專案的狀態。|
|[CListCtrl：： SetItemText](#setitemtext)|變更清單視圖專案或子專案的文字。|
|[CListCtrl：： SetOutlineColor](#setoutlinecolor)|設定清單視圖控制項框線的色彩。|
|[CListCtrl：： SetSelectedColumn](#setselectedcolumn)|設定清單視圖控制項的選定資料行。|
|[CListCtrl：： SetSelectionMark](#setselectionmark)|設定清單視圖控制項的選取專案標記。|
|[CListCtrl：： SetTextBkColor](#settextbkcolor)|設定清單視圖控制項中文字的背景色彩。|
|[CListCtrl：： SetTextColor](#settextcolor)|設定清單視圖控制項的文字色彩。|
|[CListCtrl：： SetTileInfo](#settileinfo)|設定清單視圖控制項圖格的資訊。|
|[CListCtrl：： SetTileViewInfo](#settileviewinfo)|設定清單視圖控制項在並排顯示中使用的資訊。|
|[CListCtrl：： SetToolTips](#settooltips)|設定 [清單視圖] 控制項將用來顯示工具提示的工具提示控制項。|
|[CListCtrl：： SetView](#setview)|設定清單視圖控制項的視圖。|
|[CListCtrl：： SetWorkAreas](#setworkareas)|設定可在清單視圖控制項中顯示圖示的區域。|
|[CListCtrl：： SortGroups](#sortgroups)|使用使用者定義函數來排序清單視圖控制項的群組。|
|[CListCtrl：： SortItems](#sortitems)|使用應用程式定義的比較函數排序清單視圖專案。|
|[CListCtrl：： SortItemsEx](#sortitemsex)|使用應用程式定義的比較函數排序清單視圖專案。|
|[CListCtrl：： SubItemHitTest](#subitemhittest)|判斷哪一個清單視圖專案（如果有的話）位於指定的位置。|
|[CListCtrl：： Update](#update)|強制控制項重新繪製指定的專案。|

## <a name="remarks"></a>備註

除了圖示和標籤之外，每個專案都可以將資訊顯示在圖示和標籤右邊的資料行中。 此控制項 (，因此 `CListCtrl` 類別) 僅適用于在 Windows 95/98 和 Windows NT 3.51 版和更新版本下執行的程式。

以下是類別的簡短總覽 `CListCtrl` 。 如需詳細的概念討論，請參閱 [使用 CListCtrl](../../mfc/using-clistctrl.md) 和 [控制項](../../mfc/controls-mfc.md)。

## <a name="views"></a>檢視

清單視圖控制項可以用四種不同的方式來顯示其內容，稱為「views」。

- 圖示視圖

   每個專案都會顯示為完整大小的圖示 (32 x 32 圖元) 並在其下方加上標籤。 使用者可以將專案拖曳至清單視圖視窗中的任何位置。

- 小圖示視圖

   每個專案都會顯示為小型圖示 (16 x 16 圖元) 具有其右邊的標籤。 使用者可以將專案拖曳至清單視圖視窗中的任何位置。

- 清單檢視

   每個專案都會顯示為一個小圖示，並在其右邊加上標籤。 專案會排列在資料行中，而且無法拖曳至清單視圖視窗中的任何位置。

- 報表檢視

   每個專案都會出現在自己的行上，而其他資訊會排列在右邊的資料行中。 最左邊的資料行包含小圖示和標籤，而後續的資料行則包含應用程式所指定的子。 內嵌的標題控制項 (類別 [CHeaderCtrl](../../mfc/reference/cheaderctrl-class.md)) 會執行這些資料行。 如需有關報表檢視中之標題控制項和資料行的詳細資訊，請參閱 [使用 CListCtrl：將資料行加入控制項 (報表檢視) ](../../mfc/adding-columns-to-the-control-report-view.md)。

控制項目前清單視圖的樣式會決定目前的視圖。 如需這些樣式及其用法的詳細資訊，請參閱 [使用 CListCtrl：變更清單控制項樣式](../../mfc/changing-list-control-styles.md)。

## <a name="extended-styles"></a>擴充樣式

除了標準清單樣式之外，類別還 `CListCtrl` 支援大量的擴充樣式，提供豐富的功能。 這項功能的一些範例包括：

- 停留選取範圍

   啟用時，允許在某段時間內的資料指標停留在專案上時，自動選取專案。

- 虛擬清單視圖

   啟用時，允許控制項支援最多 DWORD 專案。 您可以藉由將管理專案資料的額外負荷放在應用程式上，來達成這個目的。 除了專案選取專案和焦點資訊以外，所有專案資訊都必須由應用程式管理。 如需詳細資訊，請參閱 [使用 CListCtrl：虛擬清單控制項](../../mfc/virtual-list-controls.md)。

- 單鍵啟用（& 1）

   啟用時，可讓您 (自動反白顯示專案文字) 以及反白顯示專案的一或按兩下啟用。

- 拖放資料行排序

   啟用時，可讓您在清單視圖控制項中，將資料行的拖放功能重新排列。 僅適用于報表檢視。

如需使用這些新擴充樣式的詳細資訊，請參閱 [使用 CListCtrl：變更清單控制項樣式](../../mfc/changing-list-control-styles.md)。

## <a name="items-and-subitems"></a>專案和子專案

清單視圖控制項中的每個專案都是由影像清單中的圖示 (所組成) 、標籤、目前的狀態，以及應用程式定義的值 (稱為「專案資料」 ) 。 一或多個子專案也可以與每個專案相關聯。 「子專案」是一種字串，可在報表檢視中顯示于專案圖示和標籤右邊的資料行中。 清單視圖控制項中的所有專案都必須具有相同的子專案數目。

類別 `CListCtrl` 提供數個功能，可用於插入、刪除、尋找和修改這些專案。 如需詳細資訊，請參閱 [CListCtrl：： GetItem](#getitem)、 [CListCtrl：： InsertItem](#insertitem)和 [CListCtrl：： FindItem](#finditem)、 [將專案加入至控制項](../adding-items-to-the-control.md)，以及 [在清單控制項中滾動、排列、排序和尋找](../scrolling-arranging-sorting-and-finding-in-list-controls.md)。

依預設，清單視圖控制項負責儲存專案的圖示和文字屬性。 不過，除了這些專案類型，類別也 `CListCtrl` 支援「回呼專案」。 「回呼專案」是清單視圖專案，應用程式（而非控制項）會儲存文字、圖示或兩者。 回呼遮罩會用來指定應用程式提供 (文字和/或圖示) 的專案屬性。 如果應用程式使用回呼專案，它必須能夠視需要提供文字和/或圖示屬性。 當您的應用程式已經維護部分資訊時，回呼專案會很有説明。 如需詳細資訊，請參閱 [使用 CListCtrl：回呼專案和回呼遮罩](../callback-items-and-the-callback-mask.md)。

## <a name="image-lists"></a>影像清單

清單視圖專案的圖示、標頭專案影像和應用程式定義的狀態，都包含在數個影像清單中， (由類別 [CImageList](cimagelist-class.md) 所執行) ，您可以建立並指派給清單視圖控制項。 每個清單視圖控制項最多可以有四種不同類型的影像清單：

- 大型圖示

   用於完整大小圖示的圖示視圖中。

- 小圖示

   用於圖示視圖中所使用之較小版本圖示的小型圖示、清單和報表檢視。

- 應用程式定義的狀態

   包含狀態影像，這些影像會顯示在專案的圖示旁邊，以指出應用程式定義的狀態。

- 標頭項目

   用於顯示于每個標題控制項專案中之小型影像的報表檢視。

依預設，清單視圖控制項會在終結時終結指派給它的影像清單;不過，開發人員可以自訂此行為，方法是在不再使用時（由應用程式決定）終結每個影像清單。 如需詳細資訊，請參閱 [使用 CListCtrl：清單專案和影像清單](../list-items-and-image-lists.md)。

## <a name="inheritance-hierarchy"></a>繼承階層架構

[CObject](cobject-class.md)

[CCmdTarget](ccmdtarget-class.md)

[CWnd](cwnd-class.md)

`CListCtrl`

## <a name="requirements"></a>規格需求

**標頭：** afxcmn.h

## <a name="clistctrlapproximateviewrect"></a><a name="approximateviewrect"></a> CListCtrl：： ApproximateViewRect

決定顯示清單視圖控制項的專案所需的寬度和高度。

```
CSize ApproximateViewRect(
    CSize sz = CSize(-1, -1),
    int iCount = -1) const;
```

### <a name="parameters"></a>參數

*深圳*<br/>
建議的控制項維度（以圖元為單位）。 如果未指定維度，架構會使用控制項的目前寬度或高度值。

*iCount*<br/>
要在控制項中顯示的專案數目。 如果此參數為-1，則架構會使用目前在控制項中的總專案數。

### <a name="return-value"></a>傳回值

`CSize`物件，其中包含顯示專案所需的大約寬度和高度（以圖元為單位）。

### <a name="remarks"></a>備註

此成員函式會依照 Windows SDK 所述，執行 Win32 宏 [ListView_ApproximateViewRect](/windows/win32/api/commctrl/nf-commctrl-listview_approximateviewrect)的行為。

## <a name="clistctrlarrange"></a><a name="arrange"></a> CListCtrl：：排列

重新置放圖示視圖中的專案，使其在方格上對齊。

```
BOOL Arrange(UINT nCode);
```

### <a name="parameters"></a>參數

*nCode*<br/>
指定專案的對齊樣式。 它可能是下列其中一個值：

- LVA_ALIGNLEFT 將專案沿著視窗的左邊緣對齊。

- LVA_ALIGNTOP 將專案沿著視窗的上邊緣對齊。

- LVA_DEFAULT 會根據清單視圖的目前對齊樣式來對齊專案 (預設值) 。

- LVA_SNAPTOGRID 將所有圖示都貼齊最接近的方格位置。

### <a name="return-value"></a>傳回值

如果成功則不為零，否則為 0。

### <a name="remarks"></a>備註

*NCode*參數會指定對齊樣式。

### <a name="example"></a>範例

```cpp
    // Align all of the list view control items along the top
    // of the window (the list view control must be in icon or
    // small icon mode).
    m_myListCtrl.Arrange(LVA_ALIGNTOP);
```

## <a name="clistctrlcanceleditlabel"></a><a name="canceleditlabel"></a> CListCtrl：： CancelEditLabel

取消專案文字編輯作業。

```cpp
void CancelEditLabel();
```

### <a name="remarks"></a>備註

此成員函式會模擬 [LVM_CANCELEDITLABEL](/windows/win32/Controls/lvm-canceleditlabel) 訊息的功能，如 Windows SDK 中所述。

## <a name="clistctrlclistctrl"></a><a name="clistctrl"></a> CListCtrl：： CListCtrl

建構 `CListCtrl` 物件。

```
CListCtrl();
```

## <a name="clistctrlcreate"></a><a name="create"></a> CListCtrl：： Create

建立清單控制項，並將其附加至 `CListCtrl` 物件。

```
virtual BOOL Create(
    DWORD dwStyle,
    const RECT& rect,
    CWnd* pParentWnd,
    UINT nID);
```

### <a name="parameters"></a>參數

*dwStyle*<br/>
指定清單控制項的樣式。 將清單控制項樣式的任何組合套用至控制項。 如需這些樣式的完整清單，請參閱 Windows SDK 中的 [清單視圖視窗樣式](/windows/win32/Controls/list-view-window-styles) 。 使用 [SetExtendedStyle](#setextendedstyle)設定控制項特定的擴充樣式。

*矩形*<br/>
指定清單控制項的大小和位置。 它可以是 `CRect` 物件或 [RECT](/windows/win32/api/windef/ns-windef-rect) 結構。

*pParentWnd*<br/>
指定清單控制項的父視窗，通常是 `CDialog` 。 它不得為 NULL。

*nID*<br/>
指定清單控制項的識別碼。

### <a name="return-value"></a>傳回值

如果成功則不為零，否則為 0。

### <a name="remarks"></a>備註

您可以 `CListCtrl` 用兩個步驟來建立。 首先，呼叫此函式，然後呼叫 `Create` ，它會建立清單視圖控制項並將其附加至 `CListCtrl` 物件。

若要將擴充的 Windows 樣式套用至清單控制項物件，請呼叫 [CreateEx](#createex) ，而不是 `Create` 。

### <a name="example"></a>範例

```cpp
    m_myListCtrl.Create(
        WS_CHILD|WS_VISIBLE|WS_BORDER|LVS_REPORT|LVS_EDITLABELS,
        CRect(10,10,400,200), pParentWnd, IDD_MYLISTCTRL);
```

## <a name="clistctrlcreateex"></a><a name="createex"></a> CListCtrl：： CreateEx

 (子視窗) 建立控制項，並將它與物件產生關聯 `CListCtrl` 。

```
virtual BOOL CreateEx(
    DWORD dwExStyle,
    DWORD dwStyle,
    const RECT& rect,
    CWnd* pParentWnd,
    UINT nID);
```

### <a name="parameters"></a>參數

*dwExStyle*<br/>
指定要建立之控制項的延伸樣式。 如需擴充 Windows 樣式的清單，請參閱 Windows SDK 中[CreateWindowEx](/windows/win32/api/winuser/nf-winuser-createwindowexw)的*dwExStyle*參數。

*dwStyle*<br/>
指定清單控制項的樣式。 將清單控制項樣式的任何組合套用至控制項。 如需這些樣式的完整清單，請參閱 Windows SDK 中的 [清單視圖視窗樣式](/windows/win32/Controls/list-view-window-styles) 。

*矩形*<br/>
[矩形](/windows/win32/api/windef/ns-windef-rect)結構的參考，描述要建立之視窗的大小和位置（以*pParentWnd*的用戶端座標表示）。

*pParentWnd*<br/>
視窗的指標，該視窗為控制項的父代。

*nID*<br/>
控制項的子視窗識別碼。

### <a name="return-value"></a>傳回值

如果成功則為非零；否則為 0。

### <a name="remarks"></a>備註

使用 `CreateEx` instead Of [Create](#create) 來套用延伸的 windows 樣式（依 Windows 擴充樣式的 "前言 **WS_EX_** 指定）。

`CreateEx` 使用 *dwExStyle*所指定的擴充 Windows 樣式來建立控制項。 若要設定控制項特定的擴充樣式，請呼叫 [SetExtendedStyle](#setextendedstyle)。 例如，使用將 `CreateEx` 這類樣式設定為 WS_EX_CONTEXTHELP，但用 `SetExtendedStyle` 來將這類樣式設定為 LVS_EX_FULLROWSELECT。 如需詳細資訊，請參閱 Windows SDK 中的 [擴充清單視圖樣式](/windows/win32/Controls/extended-list-view-styles) 一文所述的樣式。

## <a name="clistctrlcreatedragimage"></a><a name="createdragimage"></a> CListCtrl：： CreateDragImage

為 *nItem*所指定的專案建立拖曳影像清單。

```
CImageList* CreateDragImage(
    int nItem,
    LPPOINT lpPoint);
```

### <a name="parameters"></a>參數

*nItem*<br/>
要建立其拖曳影像清單之專案的索引。

*lpPoint*<br/>
[點](/windows/win32/api/windef/ns-windef-point)結構的位址，這個結構會接收影像左上角的初始位置（以視圖座標表示）。

### <a name="return-value"></a>傳回值

如果成功，則為拖曳影像清單的指標;否則為 Null。

### <a name="remarks"></a>備註

`CImageList`物件是永久性的，而且您必須在完成時將它刪除。 例如：

```cpp
        CImageList* pImageList = m_myListCtrl.CreateDragImage(nItem, &point);

        // do something

        delete pImageList;
```

## <a name="clistctrldeleteallitems"></a><a name="deleteallitems"></a> CListCtrl：:D eleteAllItems

刪除清單視圖控制項中的所有專案。

```
BOOL DeleteAllItems();
```

### <a name="return-value"></a>傳回值

如果成功則不為零，否則為 0。

### <a name="example"></a>範例

```cpp
    // Delete all of the items from the list view control.
    m_myListCtrl.DeleteAllItems();
    ASSERT(m_myListCtrl.GetItemCount() == 0);
```

## <a name="clistctrldeletecolumn"></a><a name="deletecolumn"></a> CListCtrl：:D eleteColumn

從清單視圖控制項中刪除資料行。

```
BOOL DeleteColumn(int nCol);
```

### <a name="parameters"></a>參數

*nCol*<br/>
要刪除之資料行的索引。

### <a name="return-value"></a>傳回值

如果成功則不為零，否則為 0。

### <a name="example"></a>範例

```cpp
        int nColumnCount = m_myListCtrl.GetHeaderCtrl()->GetItemCount();

        // Delete all of the columns.
        for (int i=0; i < nColumnCount; i++)
        {
            m_myListCtrl.DeleteColumn(0);
        }
```

## <a name="clistctrldeleteitem"></a><a name="deleteitem"></a> CListCtrl：:D eleteItem

從清單視圖控制項中刪除專案。

```
BOOL DeleteItem(int nItem);
```

### <a name="parameters"></a>參數

*nItem*<br/>
指定要刪除之專案的索引。

### <a name="return-value"></a>傳回值

如果成功則不為零，否則為 0。

### <a name="example"></a>範例

```cpp
        int nCount = m_myListCtrl.GetItemCount();

        // Delete all of the items from the list view control.
        for (int i=0; i < nCount; i++)
        {
            m_myListCtrl.DeleteItem(0);
        }
```

## <a name="clistctrldrawitem"></a><a name="drawitem"></a> CListCtrl：:D rawItem

當主控描繪清單視圖控制項的視覺外觀變更時，由架構呼叫。

```
virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
```

### <a name="parameters"></a>參數

*lpDrawItemStruct*<br/>
`DRAWITEMSTRUCT`結構的長指標，其中包含所需繪圖類型的相關資訊。

### <a name="remarks"></a>備註

`itemAction` [DRAWITEMSTRUCT](/windows/win32/api/winuser/ns-winuser-drawitemstruct)結構的成員會定義要執行的繪圖動作。

依預設，此成員函式不會執行任何動作。 覆寫這個成員函式，以針對主控描繪物件來執行繪圖 `CListCtrl` 。

應用程式應該在此成員函式終止之前，還原為 *lpDrawItemStruct* 中提供的顯示內容選取的所有圖形裝置介面 (GDI) 物件。

## <a name="clistctrleditlabel"></a><a name="editlabel"></a> CListCtrl：： EditLabel

開始就地編輯專案的文字。

```
CEdit* EditLabel(int nItem);
```

### <a name="parameters"></a>參數

*nItem*<br/>
要編輯之清單視圖專案的索引。

### <a name="return-value"></a>傳回值

如果成功，則為 `CEdit` 用來編輯專案文字之物件的指標; 否則為 Null。

### <a name="remarks"></a>備註

具有 LVS_EDITLABELS 視窗樣式的清單視圖控制項，可讓使用者就地編輯專案標籤。 使用者可以按一下具有焦點之專案的標籤來開始編輯。

您可以使用此函式來開始編輯指定清單視圖專案的文字。

### <a name="example"></a>範例

```cpp
        // Make sure the focus is set to the list view control.
        m_myListCtrl.SetFocus();

        // Show the edit control on the label of the first
        // item in the list view control.
        CEdit* pmyEdit = m_myListCtrl.EditLabel(1);
        ASSERT(pmyEdit != NULL);
```

## <a name="clistctrlenablegroupview"></a><a name="enablegroupview"></a> CListCtrl：： EnableGroupView

啟用或停用清單視圖控制項中的專案是否顯示為群組。

```
LRESULT EnableGroupView(BOOL fEnable);
```

### <a name="parameters"></a>參數

*fEnable*<br/>
指出是否要啟用 listview 控制項來群組顯示的專案。 TRUE 表示啟用群組;FALSE 表示停用它。

### <a name="return-value"></a>傳回值

傳回下列其中一值：

- **0** 將清單視圖專案顯示為群組的功能已啟用或停用。

- **1** 控制項的狀態已成功變更。

- **-1** 作業失敗。

### <a name="remarks"></a>備註

此成員函式會模擬 [LVM_ENABLEGROUPVIEW](/windows/win32/Controls/lvm-enablegroupview) 訊息的功能，如 Windows SDK 中所述。

## <a name="clistctrlensurevisible"></a><a name="ensurevisible"></a> CListCtrl：： EnsureVisible

確保清單視圖專案至少為部分可見。

```
BOOL EnsureVisible(
    int nItem,
    BOOL bPartialOK);
```

### <a name="parameters"></a>參數

*nItem*<br/>
要顯示之清單視圖專案的索引。

*bPartialOK*<br/>
指定是否可接受部分可見度。

### <a name="return-value"></a>傳回值

如果成功則不為零，否則為 0。

### <a name="remarks"></a>備註

必要時，會滾動清單視圖控制項。 如果 *bPartialOK* 參數為非零值，則如果專案是部分可見的，就不會發生任何滾動。

### <a name="example"></a>範例

```cpp
        // Ensure that the last item is visible.
        int nCount = m_myListCtrl.GetItemCount();
        if (nCount > 0)
            m_myListCtrl.EnsureVisible(nCount-1, FALSE);
```

## <a name="clistctrlfinditem"></a><a name="finditem"></a> CListCtrl：： FindItem

搜尋具有指定特性的清單視圖專案。

```
int FindItem(
    LVFINDINFO* pFindInfo,
    int nStart = -1) const;
```

### <a name="parameters"></a>參數

*pFindInfo*<br/>
[LVFINDINFO](/windows/win32/api/commctrl/ns-commctrl-lvfindinfow)結構的指標，其中包含要搜尋之專案的相關資訊。

*N 開始*<br/>
要開始搜尋的專案索引，或-1 會從頭開始。 如果*n 開始*不等於-1，就會從搜尋中排除*n 開始*的專案。

### <a name="return-value"></a>傳回值

如果成功，則為專案的索引，否則為-1。

### <a name="remarks"></a>備註

*PFindInfo*參數指向 `LVFINDINFO` 結構，其中包含用來搜尋清單視圖專案的資訊。

### <a name="example"></a>範例

```cpp
        LVFINDINFO info;
        int nIndex;

        info.flags = LVFI_PARTIAL|LVFI_STRING;
        info.psz = _T("item");

        // Delete all of the items that begin with the string.
        while ((nIndex = m_myListCtrl.FindItem(&info)) != -1)
        {
            m_myListCtrl.DeleteItem(nIndex);
        }
```

## <a name="clistctrlgetbkcolor"></a><a name="getbkcolor"></a> CListCtrl：： GetBkColor

抓取清單視圖控制項的背景色彩。

```
COLORREF GetBkColor() const;
```

### <a name="return-value"></a>傳回值

用來指定 RGB 色彩的32位值。

### <a name="example"></a>範例

請參閱 [CListCtrl：： SetBkColor](#setbkcolor)的範例。

## <a name="clistctrlgetbkimage"></a><a name="getbkimage"></a> CListCtrl：： GetBkImage

抓取清單視圖控制項的目前背景影像。

```
BOOL GetBkImage(LVBKIMAGE* plvbkImage) const;
```

### <a name="parameters"></a>參數

*plvbkImage*<br/>
結構的指標， `LVBKIMAGE` 其中包含清單視圖的目前背景影像。

### <a name="return-value"></a>傳回值

如果成功，則傳回非零，否則傳回零。

### <a name="remarks"></a>備註

這個方法會依照 Windows SDK 所述，來實 [ListView_GetBkImage](/windows/win32/api/commctrl/nf-commctrl-listview_getbkimage)Win32 宏的行為。

### <a name="example"></a>範例

```cpp
        LVBKIMAGE bki;

        // If no background image is set for the list view control use
        // the Microsoft homepage image as the background image.
        if (m_myListCtrl.GetBkImage(&bki) && (bki.ulFlags == LVBKIF_SOURCE_NONE))
        {
            m_myListCtrl.SetBkImage(
                _T("https://www.microsoft.com/library/images/gifs/homepage/microsoft.gif"),
                TRUE);
        }
```

## <a name="clistctrlgetcallbackmask"></a><a name="getcallbackmask"></a> CListCtrl：： GetCallbackMask

抓取清單視圖控制項的回呼遮罩。

```
UINT GetCallbackMask() const;
```

### <a name="return-value"></a>傳回值

清單視圖控制項的回呼遮罩。

### <a name="remarks"></a>備註

「回呼專案」是清單視圖專案，應用程式（而非控制項）會儲存文字、圖示或兩者。 雖然清單視圖控制項可以為您儲存這些屬性，但如果您的應用程式已經維護部分資訊，您可能會想要使用回呼專案。 回呼遮罩會指定應用程式所維護的專案狀態位，而且會套用至整個控制項，而不是套用至特定的專案。 回呼遮罩預設為零，表示控制項正在追蹤所有項目的狀態。 如果應用程式使用回呼專案或指定非零的回呼遮罩，它必須能夠視需要提供清單視圖專案屬性。

### <a name="example"></a>範例

請參閱 [CListCtrl：： SetCallbackMask](#setcallbackmask)的範例。

## <a name="clistctrlgetcheck"></a><a name="getcheck"></a> CListCtrl：： GetCheck

抓取與專案相關聯之狀態影像的目前顯示狀態。

```
BOOL GetCheck(int nItem) const;
```

### <a name="parameters"></a>參數

*nItem*<br/>
清單控制項專案的以零為基底的索引。

### <a name="return-value"></a>傳回值

如果選取專案，則為非零，否則為0。

### <a name="remarks"></a>備註

此成員函式會依照 Windows SDK 所述，執行 Win32 宏 [ListView_GetCheckState](/windows/win32/api/commctrl/nf-commctrl-listview_getcheckstate)的行為。

### <a name="example"></a>範例

請參閱 [CListCtrl：： SetCheck](#setcheck)的範例。

## <a name="clistctrlgetcolumn"></a><a name="getcolumn"></a> CListCtrl：： GetColumn

抓取清單視圖控制項之資料行的屬性。

```
BOOL GetColumn(
    int nCol,
    LVCOLUMN* pColumn) const;
```

### <a name="parameters"></a>參數

*nCol*<br/>
要取出其屬性之資料行的索引。

*pColumn*<br/>
[LVCOLUMN](/windows/win32/api/commctrl/ns-commctrl-lvcolumnw)結構的位址，指定要取出的資訊，並接收資料行的相關資訊。 `mask`成員指定要取出的資料行屬性。 如果 `mask` 成員指定 LVCF_TEXT 值，則 `pszText` 成員必須包含接收專案文字的緩衝區位址，而且 `cchTextMax` 成員必須指定緩衝區的大小。

### <a name="return-value"></a>傳回值

如果成功則不為零，否則為 0。

### <a name="remarks"></a>備註

此 `LVCOLUMN` 結構包含有關報表檢視中之資料行的資訊。

### <a name="example"></a>範例

```cpp
        LVCOLUMN col;

        col.mask = LVCF_WIDTH;

        // Double the column width of the first column.
        if (m_myListCtrl.GetColumn(0, &col))
        {
            col.cx *= 2;
            m_myListCtrl.SetColumn(0, &col);
        }
```

## <a name="clistctrlgetcolumnorderarray"></a><a name="getcolumnorderarray"></a> CListCtrl：： GetColumnOrderArray

從清單視圖控制項的左到右) 抓取資料行順序 (。

```
BOOL GetColumnOrderArray(
    LPINT piArray,
    int iCount = -1);
```

### <a name="parameters"></a>參數

*piArray*<br/>
緩衝區的指標，此緩衝區將包含清單視圖控制項中資料行的索引值。 緩衝區必須夠大，才能包含清單視圖控制項中的總數據行數。

*iCount*<br/>
清單視圖控制項中的資料行數目。 如果此參數為-1，則架構會自動抓取資料行數目。

### <a name="return-value"></a>傳回值

如果成功則不為零，否則為 0。

### <a name="remarks"></a>備註

此成員函式會依照 Windows SDK 所述，執行 Win32 宏 [ListView_GetColumnOrderArray](/windows/win32/api/commctrl/nf-commctrl-listview_getcolumnorderarray)的行為。

### <a name="example"></a>範例

```cpp
        // Reverse the order of the columns in the list view control
        // (i.e. make the first column the last, the last column
        // the first, and so on...).
        CHeaderCtrl* pHeaderCtrl = m_myListCtrl.GetHeaderCtrl();

        if (pHeaderCtrl != NULL)
        {
            int  nColumnCount = pHeaderCtrl->GetItemCount();
            LPINT pnOrder = (LPINT) malloc(nColumnCount*sizeof(int));
            ASSERT(pnOrder != NULL);
            m_myListCtrl.GetColumnOrderArray(pnOrder, nColumnCount);

            int i, j, nTemp;
            for (i = 0, j = nColumnCount-1; i < j; i++, j--)
            {
                nTemp = pnOrder[i];
                pnOrder[i] = pnOrder[j];
                pnOrder[j] = nTemp;
            }

            m_myListCtrl.SetColumnOrderArray(nColumnCount, pnOrder);
            free(pnOrder);
        }
```

## <a name="clistctrlgetcolumnwidth"></a><a name="getcolumnwidth"></a> CListCtrl：： GetColumnWidth

抓取報表檢視或清單視圖中資料行的寬度。

```
int GetColumnWidth(int nCol) const;
```

### <a name="parameters"></a>參數

*nCol*<br/>
指定要取出其寬度之資料行的索引。

### <a name="return-value"></a>傳回值

*NCol*所指定資料行的寬度（以圖元為單位）。

### <a name="example"></a>範例

```cpp
        // Increase the column width of the second column by 20.
        int nWidth = m_myListCtrl.GetColumnWidth(1);
        m_myListCtrl.SetColumnWidth(1, 20 + nWidth);
```

## <a name="clistctrlgetcountperpage"></a><a name="getcountperpage"></a> CListCtrl：： GetCountPerPage

當在清單視圖或報表檢視中時，計算可在清單視圖控制項可見區域中垂直容納的專案數。

```
int GetCountPerPage() const;
```

### <a name="return-value"></a>傳回值

清單視圖或報表檢視時，可在清單視圖控制項可見區域中垂直容納的專案數。

### <a name="example"></a>範例

請參閱 [CListCtrl：： GetTopIndex](#gettopindex)的範例。

## <a name="clistctrlgeteditcontrol"></a><a name="geteditcontrol"></a> CListCtrl：： GetEditControl

抓取編輯控制項的控制碼，這個控制項是用來編輯清單視圖專案的文字。

```
CEdit* GetEditControl() const;
```

### <a name="return-value"></a>傳回值

如果成功，則為用來編輯專案文字之 [CEdit](cedit-class.md) 物件的指標;否則為 Null。

### <a name="example"></a>範例

```cpp
        // The string replacing the text in the edit control.
        LPCTSTR lpszmyString = _T("custom label!");

        // If possible, replace the text in the label edit control.
        CEdit* pEdit = m_myListCtrl.GetEditControl();

        if (pEdit != NULL)
        {
            pEdit->SetWindowText(lpszmyString);
        }
```

## <a name="clistctrlgetemptytext"></a><a name="getemptytext"></a> CListCtrl：： GetEmptyText

抓取目前的清單視圖控制項是否為空白時，所要顯示的字串。

```
CString GetEmptyText() const;
```

### <a name="return-value"></a>傳回值

[CString](../../atl-mfc-shared/reference/cstringt-class.md) ，包含控制項為空白時所顯示的文字。

### <a name="remarks"></a>備註

這個方法會傳送 [LVM_GETEMPTYTEXT](/windows/win32/Controls/lvm-getemptytext) 的訊息，如 Windows SDK 中所述。

## <a name="clistctrlgetextendedstyle"></a><a name="getextendedstyle"></a> CListCtrl：： GetExtendedStyle

抓取清單視圖控制項目前的擴充樣式。

```
DWORD GetExtendedStyle();
```

### <a name="return-value"></a>傳回值

清單視圖控制項目前正在使用的擴充樣式的組合。 如需這些擴充樣式的描述性清單，請參閱 Windows SDK 中的 [擴充清單視圖樣式](/windows/win32/Controls/extended-list-view-styles) 文章。

### <a name="remarks"></a>備註

此成員函式會依照 Windows SDK 所述，執行 Win32 宏 [ListView_GetExtendedListViewStyle](/windows/win32/api/commctrl/nf-commctrl-listview_getextendedlistviewstyle)的行為。

### <a name="example"></a>範例

請參閱 [CListCtrl：： SetExtendedStyle](#setextendedstyle)的範例。

## <a name="clistctrlgetfirstselecteditemposition"></a><a name="getfirstselecteditemposition"></a> CListCtrl：： GetFirstSelectedItemPosition

取得清單視圖控制項中第一個選取專案的位置。

```
POSITION GetFirstSelectedItemPosition() const;
```

### <a name="return-value"></a>傳回值

可用於反復專案或物件指標抓取的位置值;如果未選取任何專案，則為 Null。

### <a name="example"></a>範例

下列程式碼範例將示範此函式的使用方式。

```cpp
        POSITION pos = m_myListCtrl.GetFirstSelectedItemPosition();
        if (pos == NULL)
        {
            TRACE(_T("No items were selected!\n"));
        }
        else
        {
            while (pos)
            {
                int nItem = m_myListCtrl.GetNextSelectedItem(pos);
                TRACE(_T("Item %d was selected!\n"), nItem);
                // you could do your own processing on nItem here
            }
        }
```

## <a name="clistctrlgetfocusedgroup"></a><a name="getfocusedgroup"></a> CListCtrl：： GetFocusedGroup

抓取將鍵盤焦點放在目前清單視圖控制項中的群組。

```
int GetFocusedGroup() const;
```

### <a name="return-value"></a>傳回值

如果有這類群組，則為其狀態為 LVGS_FOCUSED 之群組的索引;否則為-1。

### <a name="remarks"></a>備註

這個方法會傳送 [LVM_GETFOCUSEDGROUP](/windows/win32/Controls/lvm-getfocusedgroup) 的訊息，如 Windows SDK 中所述。 如需詳細資訊，請參閱 `state` [LVGROUP](/windows/win32/api/commctrl/ns-commctrl-lvgroup) 結構成員的 LVGS_FOCUSED 值。

## <a name="clistctrlgetgroupcount"></a><a name="getgroupcount"></a> CListCtrl：： GetGroupCount

抓取目前清單視圖控制項中的群組數目。

```
int GetGroupCount()const;
```

### <a name="return-value"></a>傳回值

清單視圖控制項中的群組數目。

### <a name="remarks"></a>備註

這個方法會傳送 [LVM_GETGROUPCOUNT](/windows/win32/Controls/lvm-getgroupcount) 的訊息，如 Windows SDK--> 中所述。

## <a name="clistctrlgetgroupinfo"></a><a name="getgroupinfo"></a> CListCtrl：： GetGroupInfo

取得清單視圖控制項之指定群組的資訊。

```
int GetGroupInfo(
    int iGroupId,
    PLVGROUP pgrp) const;
```

### <a name="parameters"></a>參數

*iGroupId*<br/>
要取出其資訊的群組識別碼。

*pgrp*<br/>
[LVGROUP](/windows/win32/api/commctrl/ns-commctrl-lvgroup)的指標，其中包含指定之群組的資訊。

### <a name="return-value"></a>傳回值

如果成功，則傳回群組的識別碼，否則為-1。

### <a name="remarks"></a>備註

此成員函式會模擬 [LVM_GETGROUPINFO](/windows/win32/Controls/lvm-getgroupinfo) 訊息的功能，如 Windows SDK 中所述。

## <a name="clistctrlgetgroupinfobyindex"></a><a name="getgroupinfobyindex"></a> CListCtrl：： GetGroupInfoByIndex

抓取目前清單視圖控制項中指定之群組的相關資訊。

```
BOOL GetGroupInfoByIndex(
    int iIndex,
    PLVGROUP pGroup) const;
```

### <a name="parameters"></a>參數

*iIndex*\
在群組以零為基底的索引。

*pGroup*\
擴展 [LVGROUP](/windows/win32/api/commctrl/ns-commctrl-lvgroup) 結構的指標，此結構會接收 *iIndex* 參數所指定之群組的相關資訊。 呼叫端負責初始化 [LVGROUP](/windows/win32/api/commctrl/ns-commctrl-lvgroup) 結構的成員。 將 `cbSize` 成員設定為結構的大小，並將成員的旗標設定為 `mask` 指定要取出的資訊。

### <a name="return-value"></a>傳回值

如果此方法成功，則為 TRUE;否則為 FALSE。

### <a name="remarks"></a>備註

這個方法會傳送 [LVM_GETGROUPINFOBYINDEX](/windows/win32/controls/lvm-getgroupinfobyindex) 的訊息，如 Windows SDK--> 中所述。

### <a name="example"></a>範例

下列程式碼範例 `m_listCtrl` 會定義用來存取目前清單視圖控制項的變數。 下一個範例中會使用此變數。

```cpp
public:
    // Variable used to access the list control.
    CListCtrl m_listCtrl;
```

### <a name="example"></a>範例

下列程式碼範例會示範 `GetGroupInfoByIndex` 方法。 在此程式碼範例的先前章節中，我們建立了一個清單視圖控制項，它會在報表檢視中顯示標題為 "ClientID" 和 "年級" 的兩個數據行。 下列程式碼範例會抓取索引為0之群組的相關資訊（如果有這樣的群組）。

```cpp
    // GetGroupInfoByIndex
    const int GROUP_HEADER_BUFFER_SIZE = 40;

// Initialize the structure
    LVGROUP gInfo = {0};
    gInfo.cbSize = sizeof(LVGROUP);
    wchar_t wstrHeadGet[GROUP_HEADER_BUFFER_SIZE] = {0};
    gInfo.cchHeader = GROUP_HEADER_BUFFER_SIZE;
    gInfo.pszHeader = wstrHeadGet;
    gInfo.mask = (LVGF_ALIGN | LVGF_STATE | LVGF_HEADER | LVGF_GROUPID);
    gInfo.state = LVGS_NORMAL;
    gInfo.uAlign  = LVGA_HEADER_LEFT;

    BOOL bRet = m_listCtrl.GetGroupInfoByIndex( 0, &gInfo );
    if (bRet == TRUE) {
        CString strHeader = CString( gInfo.pszHeader );
        CString str;
        str.Format(_T("Header: '%s'"), strHeader);
        AfxMessageBox(str, MB_ICONINFORMATION);
    }
    else
    {
        AfxMessageBox(_T("No group information was retrieved."));
    }
```

## <a name="clistctrlgetgroupmetrics"></a><a name="getgroupmetrics"></a> CListCtrl：： GetGroupMetrics

抓取群組的度量。

```cpp
void GetGroupMetrics(PLVGROUPMETRICS pGroupMetrics) const;
```

### <a name="parameters"></a>參數

*pGroupMetrics*<br/>
包含群組計量資訊之 [LVGROUPMETRICS](/windows/win32/api/commctrl/ns-commctrl-lvgroupmetrics) 的指標。

### <a name="remarks"></a>備註

此成員函式會模擬 [LVM_GETGROUPMETRICS](/windows/win32/Controls/lvm-getgroupmetrics) 訊息的功能，如 Windows SDK 中所述。

## <a name="clistctrlgetgrouprect"></a><a name="getgrouprect"></a> CListCtrl：： GetGroupRect

抓取目前清單視圖控制項中指定群組的周框。

```
BOOL GetGroupRect(
    int iGroupId,
    LPRECT lpRect,
    int iCoords = LVGGR_GROUP) const;
```

### <a name="parameters"></a>參數

*iGroupId*\
在指定群組。

*lpRect*\
[in，out] [矩形](/windows/win32/api/windef/ns-windef-rect) 結構的指標。 如果這個方法成功，結構會接收 *iGroupId*所指定之群組的矩形座標。

*iCoords*\
在指定要取出的矩形座標。 使用下列其中一個值：

- LVGGR_GROUP- (整個展開群組的預設) 座標。

- LVGGR_HEADER-只有標頭 (折迭的群組) 的座標。

- LVGGR_SUBSETLINK-只有子集連結 (標記子集) 的座標。

### <a name="return-value"></a>傳回值

如果此方法成功，則為 TRUE;否則為 FALSE。

### <a name="remarks"></a>備註

呼叫端負責配置*pRect*參數所指向的[RECT](/windows/win32/api/windef/ns-windef-rect)結構。

這個方法會傳送 [LVM_GETGROUPRECT](/windows/win32/Controls/lvm-getgrouprect) 的訊息，如 Windows SDK 中所述。

### <a name="example"></a>範例

下列程式碼範例 `m_listCtrl` 會定義用來存取目前清單視圖控制項的變數。 下一個範例中會使用此變數。

```cpp
public:
    // Variable used to access the list control.
    CListCtrl m_listCtrl;
```

### <a name="example"></a>範例

下列程式碼範例會示範 `GetGroupRect` 方法。 在此程式碼範例的先前章節中，我們建立了一個清單視圖控制項，它會在報表檢視中顯示標題為 "ClientID" 和 "年級" 的兩個數據行。 下列程式碼範例會在其索引為0（如果有這類群組存在）的群組周圍繪製3D 矩形。

```cpp
    // GetGroupRect

    // Get the graphics rectangle that surrounds group 0.
    CRect rect;
    BOOL bRet = m_listCtrl.GetGroupRect( 0, &rect, LVGGR_GROUP);
    // Draw a blue rectangle around group 0.
    if (bRet == TRUE) {
        m_listCtrl.GetDC()->Draw3dRect( &rect, RGB(0, 0, 255), RGB(0, 0, 255));
    }
    else {
        AfxMessageBox(_T("No group information was retrieved."), MB_ICONINFORMATION);
    }
```

## <a name="clistctrlgetgroupstate"></a><a name="getgroupstate"></a> CListCtrl：： GetGroupState

抓取目前清單視圖控制項中指定之群組的狀態。

```
UINT GetGroupState(
    int iGroupId,
    DWORD dwMask) const;
```

### <a name="parameters"></a>參數

*iGroupId*\
在群組以零為基底的索引。

*dwMask*\
在指定要針對指定群組取得之狀態值的遮罩。 如需詳細資訊，請參閱 `mask` [LVGROUP](/windows/win32/api/commctrl/ns-commctrl-lvgroup) 結構的成員。

### <a name="return-value"></a>傳回值

指定之群組的要求狀態，如果找不到群組，則為0。

### <a name="remarks"></a>備註

傳回值是在 *dwMask* 參數上進行位 and 運算的結果，以及 `state` 代表目前清單視圖控制項之 [LVGROUP](/windows/win32/api/commctrl/ns-commctrl-lvgroup) 結構的成員值。

這個方法會傳送 [LVM_GETGROUPSTATE](/windows/win32/Controls/lvm-getgroupstate) 的訊息，如 Windows SDK 中所述。 如需詳細資訊，請參閱 [ListView_GetGroupState](/windows/win32/api/commctrl/nf-commctrl-listview_getgroupstate) 宏。

## <a name="clistctrlgetheaderctrl"></a><a name="getheaderctrl"></a> CListCtrl：： GetHeaderCtrl

抓取清單視圖控制項的標題控制項。

```
CHeaderCtrl* GetHeaderCtrl();
```

### <a name="return-value"></a>傳回值

清單視圖控制項所使用之標題控制項的指標。

### <a name="remarks"></a>備註

此成員函式會依照 Windows SDK 所述，執行 Win32 宏 [ListView_GetHeader](/windows/win32/api/commctrl/nf-commctrl-listview_getheader)的行為。

### <a name="example"></a>範例

請參閱 [CListCtrl：： GetColumnOrderArray](#getcolumnorderarray)的範例。

## <a name="clistctrlgethotcursor"></a><a name="gethotcursor"></a> CListCtrl：： GetHotCursor

抓取針對清單視圖控制項啟用熱追蹤時所使用的資料指標。

```
HCURSOR GetHotCursor();
```

### <a name="return-value"></a>傳回值

清單視圖控制項所使用之目前作用中資料指標資源的控制碼。

### <a name="remarks"></a>備註

此成員函式會依照 Windows SDK 所述，執行 Win32 宏 [ListView_GetHotCursor](/windows/win32/api/commctrl/nf-commctrl-listview_gethotcursor)的行為。 當游標通過任何清單視圖專案時，就會出現經常性存取游標，只有在啟用暫留選取專案時才會顯示。 藉由設定 LVS_EX_TRACKSELECT 擴充樣式來啟用暫止選取專案。

### <a name="example"></a>範例

```cpp
        // Set the hot cursor to be the system app starting cursor.
        HCURSOR hCursor = ::LoadCursor(NULL, IDC_APPSTARTING);
        m_myListCtrl.SetHotCursor(hCursor);
        ASSERT(m_myListCtrl.GetHotCursor() == hCursor);
```

## <a name="clistctrlgethotitem"></a><a name="gethotitem"></a> CListCtrl：： GetHotItem

抓取目前在游標下的清單視圖專案。

```
int GetHotItem();
```

### <a name="return-value"></a>傳回值

清單視圖控制項目前熱專案的索引。

### <a name="remarks"></a>備註

此成員函式會依照 Windows SDK 所述，執行 Win32 宏 [ListView_GetHotItem](/windows/win32/api/commctrl/nf-commctrl-listview_gethotitem)的行為。 啟用熱追蹤 (和暫止選取) 時，會將熱專案定義為目前選取的專案。

如果啟用熱追蹤，當使用者在清單視圖專案上暫停時，專案標籤會自動反白顯示，而不需要使用滑鼠按鍵。

### <a name="example"></a>範例

```cpp
    // Set the hot item to the first item only if no other item is
    // highlighted.
    if (m_myListCtrl.GetHotItem() == -1)
        m_myListCtrl.SetHotItem(0);
```

## <a name="clistctrlgethovertime"></a><a name="gethovertime"></a> CListCtrl：： GetHoverTime

抓取清單視圖控制項目前的停留時間。

```
DWORD GetHoverTime() const;
```

### <a name="return-value"></a>傳回值

傳回以毫秒為單位的延遲（以毫秒為單位），在選取專案之前，滑鼠游標必須停留在專案上。 如果傳回值為-1，則停留時間是預設的暫止時間。

### <a name="remarks"></a>備註

此成員函式會依照 Windows SDK 所述，執行 Win32 宏 [ListView_GetHoverTime](/windows/win32/api/commctrl/nf-commctrl-listview_gethovertime)的行為。

### <a name="example"></a>範例

```cpp
        // If the hover time is the default set to 1 sec.
        DWORD dwTime = m_myListCtrl.GetHoverTime();
        if (dwTime == -1)
            m_myListCtrl.SetHoverTime(1000);
```

## <a name="clistctrlgetimagelist"></a><a name="getimagelist"></a> CListCtrl：： GetImageList

抓取用來繪製清單視圖專案的影像清單控制碼。

```
CImageList* GetImageList(int nImageList) const;
```

### <a name="parameters"></a>參數

*nImageList*<br/>
值，指定要取出的影像清單。 其可以是下列其中一個值：

- 具有大型圖示的 LVSIL_NORMAL 影像清單。

- 具有小圖示的 LVSIL_SMALL 影像清單。

- 具有狀態影像的 LVSIL_STATE 映射清單。

### <a name="return-value"></a>傳回值

用來繪製清單視圖專案之影像清單的指標。

### <a name="example"></a>範例

```cpp
        ASSERT(m_myListCtrl.GetImageList(LVSIL_NORMAL) == NULL);
        m_myListCtrl.SetImageList(&m_lcImageList, LVSIL_NORMAL);
        ASSERT(m_myListCtrl.GetImageList(LVSIL_NORMAL) == &m_lcImageList);
```

## <a name="clistctrlgetinsertmark"></a><a name="getinsertmark"></a> CListCtrl：： GetInsertMark

抓取插入標記的目前位置。

```
BOOL GetInsertMark(LPLVINSERTMARK plvim) const;
```

### <a name="parameters"></a>參數

*plvim*<br/>
[LVINSERTMARK](/windows/win32/api/commctrl/ns-commctrl-lvinsertmark)結構的指標，其中包含插入標記的資訊。

### <a name="return-value"></a>傳回值

如果成功，則傳回 TRUE，否則傳回 FALSE。 如果結構成員中的大小不 `cbSize` 等於結構的實際大小，就會傳回 FALSE `LVINSERTMARK` 。

### <a name="remarks"></a>備註

此成員函式會模擬 [LVM_GETINSERTMARK](/windows/win32/Controls/lvm-getinsertmark) 訊息的功能，如 Windows SDK 中所述。

## <a name="clistctrlgetinsertmarkcolor"></a><a name="getinsertmarkcolor"></a> CListCtrl：： GetInsertMarkColor

抓取插入標記目前的色彩。

```
COLORREF GetInsertMarkColor() const;
```

### <a name="return-value"></a>傳回值

傳回 [COLORREF](/windows/win32/gdi/colorref) 結構，其中包含插入點的色彩。

### <a name="remarks"></a>備註

此成員函式會模擬 [LVM_GETINSERTMARKCOLOR](/windows/win32/Controls/lvm-getinsertmarkcolor) 訊息的功能，如 Windows SDK 中所述。

## <a name="clistctrlgetinsertmarkrect"></a><a name="getinsertmarkrect"></a> CListCtrl：： GetInsertMarkRect

抓取插入點界限的矩形。

```
int GetInsertMarkRect(LPRECT pRect) const;
```

### <a name="parameters"></a>參數

*pRect*<br/>
`RECT`結構的指標，其中包含圍繞插入點之矩形的座標。

### <a name="return-value"></a>傳回值

傳回下列其中一值：

- **0** 找不到插入點。

- 找到**1**個插入點。

### <a name="remarks"></a>備註

此成員函式會模擬 [LVM_GETINSERTMARKRECT](/windows/win32/Controls/lvm-getinsertmarkrect) 訊息的功能，如 Windows SDK 中所述。

## <a name="clistctrlgetitem"></a><a name="getitem"></a> CListCtrl：： GetItem

抓取部分或全部清單視圖專案的屬性。

```
BOOL GetItem(LVITEM* pItem) const;
```

### <a name="parameters"></a>參數

*pItem*<br/>
[LVITEM](/windows/win32/api/commctrl/ns-commctrl-lvitemw)結構的指標，此結構會接收專案的屬性。

### <a name="return-value"></a>傳回值

如果成功則不為零，否則為 0。

### <a name="remarks"></a>備註

`LVITEM`結構會指定或接收清單視圖專案的屬性。

## <a name="clistctrlgetitemcount"></a><a name="getitemcount"></a> CListCtrl：： GetItemCount

抓取清單視圖控制項中的專案數。

```
int GetItemCount() const;
```

### <a name="return-value"></a>傳回值

清單視圖控制項中的專案數。

### <a name="example"></a>範例

請參閱 CListCtrl 的範例 [：:D eleteitem](#deleteitem)。

## <a name="clistctrlgetitemdata"></a><a name="getitemdata"></a> CListCtrl：： GetItemData

抓取與所指定之專案相關聯的32位應用程式特定值 `nItem` 。

```
DWORD_PTR GetItemData(int nItem) const;
```

### <a name="parameters"></a>參數

*nItem*<br/>
要抓取其資料之清單專案的索引。

### <a name="return-value"></a>傳回值

與指定專案相關聯的32位應用程式專用值。

### <a name="remarks"></a>備註

這個值是 `lParam` [LVITEM](/windows/win32/api/commctrl/ns-commctrl-lvitemw) 結構的成員，如 Windows SDK 所述。

### <a name="example"></a>範例

```cpp
    // If any item's data is equal to zero then reset it to -1.
    for (int i=0; i < m_myListCtrl.GetItemCount(); i++)
    {
        if (m_myListCtrl.GetItemData(i) == 0)
        {
            m_myListCtrl.SetItemData(i, (DWORD) -1);
        }
    }
```

## <a name="clistctrlgetitemindexrect"></a><a name="getitemindexrect"></a> CListCtrl：： GetItemIndexRect

抓取目前清單視圖控制項中，所有或部分子部分的周框。

```
BOOL GetItemIndexRect(
    PLVITEMINDEX pItemIndex,
    int iColumn,
    int rectType,
    LPRECT pRect) const;
```

### <a name="parameters"></a>參數

*pItemIndex*\
在子專案父專案的 [LVITEMINDEX](/windows/win32/api/commctrl/ns-commctrl-lvitemindex) 結構指標。 呼叫端負責配置和設定 [LVITEMINDEX](/windows/win32/api/commctrl/ns-commctrl-lvitemindex) 結構的成員。 此參數不可以是 NULL。

*iColumn*\
在控制項中資料行以零為基底的索引。

*rectType*\
在要抓取周框的部分清單-view 子下拉式清單。 指定下列其中一個值：

- LVIR_BOUNDS-傳回整個子工作的周框，包括圖示和標籤。

- LVIR_ICON-傳回子工作圖示或小圖示的周框。

- LVIR_LABEL-傳回子文字的周框。

*pRect*\
擴展 [矩形](/windows/win32/api/windef/ns-windef-rect) 結構的指標，此結構會接收子內容周框的相關資訊。 呼叫端負責配置 [RECT](/windows/win32/api/windef/ns-windef-rect) 結構。 此參數不可以是 NULL。

### <a name="return-value"></a>傳回值

如果此方法成功，則為 TRUE;否則為 FALSE。

### <a name="remarks"></a>備註

這個方法會傳送 [LVM_GETITEMINDEXRECT](/windows/win32/Controls/lvm-getitemindexrect) 的訊息，如 Windows SDK 中所述。 如需詳細資訊，請參閱 [ListView_GetItemIndexRect 宏](/windows/win32/api/commctrl/nf-commctrl-listview_getitemindexrect)。

### <a name="example"></a>範例

下列程式碼範例 `m_listCtrl` 會定義用來存取目前清單視圖控制項的變數。 下一個範例中會使用此變數。

```cpp
public:
    // Variable used to access the list control.
    CListCtrl m_listCtrl;
```

### <a name="example"></a>範例

下列程式碼範例會示範 `GetGroupRect` 方法。 在輸入此程式碼範例之前，我們建立了一個清單視圖控制項，它會在報表檢視中顯示標題為 "ClientID" 和 "年級" 的兩個數據行。 下列程式碼範例會在兩個數據行中的第二個子欄位周圍繪製3D 矩形。

```cpp
    // GetItemIndexRect
    // Get the rectangle that bounds the second item in the first group.
    LVITEMINDEX lvItemIndex;
    lvItemIndex.iGroup = 0;
    lvItemIndex.iItem = 1;
    CRect rect;
    BOOL bRet = m_listCtrl.GetItemIndexRect(
        &lvItemIndex, 0, LVIR_BOUNDS, &rect);

    // Draw a red rectangle around the item.
    m_listCtrl.GetDC()->Draw3dRect( &rect, RGB(255, 0, 0), RGB(255, 0, 0) );
```

## <a name="clistctrlgetitemposition"></a><a name="getitemposition"></a> CListCtrl：： GetItemPosition

抓取清單視圖專案的位置。

```
BOOL GetItemPosition(
    int nItem,
    LPPOINT lpPoint) const;
```

### <a name="parameters"></a>參數

*nItem*<br/>
要取出其位置之專案的索引。

*lpPoint*<br/>
[點](/windows/win32/api/windef/ns-windef-point)結構的位址，這個結構會接收專案左上角的位置（在視圖座標中）。

### <a name="return-value"></a>傳回值

如果成功則不為零，否則為 0。

### <a name="example"></a>範例

```cpp
        POINT pt;

        // Move all items in the list control 100 pixels to the right.
        UINT i, nCount = m_myListCtrl.GetItemCount();

        for (i=0; i < nCount; i++)
        {
            m_myListCtrl.GetItemPosition(i, &pt);
            pt.x += 100;
            m_myListCtrl.SetItemPosition(i, pt);
        }
```

## <a name="clistctrlgetitemrect"></a><a name="getitemrect"></a> CListCtrl：： GetItemRect

抓取目前視圖中所有或部分專案的周框。

```
BOOL GetItemRect(
    int nItem,
    LPRECT lpRect,
    UINT nCode) const;
```

### <a name="parameters"></a>參數

*nItem*<br/>
要取出其位置之專案的索引。

*lpRect*<br/>
接收周框矩形的 [RECT](/windows/win32/api/windef/ns-windef-rect) 結構位址。

*nCode*<br/>
要取得周框矩形的清單視圖專案部分。 其可以是下列其中一個值：

- LVIR_BOUNDS 會傳回整個專案的周框，包括圖示和標籤。

- LVIR_ICON 傳回圖示或小圖示的周框。

- LVIR_LABEL 會傳回專案文字的周框。

### <a name="return-value"></a>傳回值

如果成功則不為零，否則為 0。

### <a name="example"></a>範例

```cpp
// OnClick is the handler for the NM_CLICK notification
void CListCtrlDlg::OnClick(NMHDR* pNMHDR, LRESULT* pResult)
{
    UNREFERENCED_PARAMETER(pResult);
    LPNMITEMACTIVATE pia = (LPNMITEMACTIVATE)pNMHDR;

    // Get the current mouse location and convert it to client
    // coordinates.
    CPoint pos( ::GetMessagePos() );
    ScreenToClient(&pos);

    // Get indexes of the first and last visible items in
    // the listview control.
    int index = m_myListCtrl.GetTopIndex();
    int last_visible_index = index + m_myListCtrl.GetCountPerPage();
    if (last_visible_index > m_myListCtrl.GetItemCount())
        last_visible_index = m_myListCtrl.GetItemCount();

    // Loop until number visible items has been reached.
    while (index <= last_visible_index)
    {
        // Get the bounding rectangle of an item. If the mouse
        // location is within the bounding rectangle of the item,
        // you know you have found the item that was being clicked.
        CRect r;
        m_myListCtrl.GetItemRect(index, &r, LVIR_BOUNDS);
        if (r.PtInRect(pia->ptAction))
        {
            UINT flag = LVIS_SELECTED | LVIS_FOCUSED;
            m_myListCtrl.SetItemState(index, flag, flag);
            break;
        }

        // Get the next item in listview control.
        index++;
    }
}
```

## <a name="clistctrlgetitemspacing"></a><a name="getitemspacing"></a> CListCtrl：： GetItemSpacing

計算目前清單視圖控制項中專案之間的間距。

```
BOOL GetItemSpacing(
    BOOL fSmall,
    int* pnHorzSpacing,
    int* pnVertSpacing) const;
```

### <a name="parameters"></a>參數

*fSmall*\
在要取得其專案間距的視圖。 針對小圖示視圖指定 TRUE，或針對圖示視圖指定 FALSE。

*pnHorzSpacing*\
擴展包含專案之間的水準間距。

*pnVertSpacing*\
擴展包含專案之間的垂直間距。

### <a name="return-value"></a>傳回值

如果此方法成功，則為 TRUE;否則為 FALSE。

### <a name="remarks"></a>備註

這個方法會傳送 [LVM_GETITEMSPACING](/windows/win32/Controls/lvm-getitemspacing) 的訊息，如 Windows SDK 中所述。

## <a name="clistctrlgetitemstate"></a><a name="getitemstate"></a> CListCtrl：： GetItemState

抓取清單視圖專案的狀態。

```
UINT GetItemState(
    int nItem,
    UINT nMask) const;
```

### <a name="parameters"></a>參數

*nItem*<br/>
要抓取其狀態之專案的索引。

*nMask*<br/>
指定要傳回之專案狀態旗標的遮罩。

### <a name="return-value"></a>傳回值

指定清單視圖專案的狀態旗標。

### <a name="remarks"></a>備註

專案的狀態是由 `state` [LVITEM](/windows/win32/api/commctrl/ns-commctrl-lvitemw) 結構的成員指定，如 Windows SDK 所述。 當您指定或變更專案的狀態時，該 `stateMask` 成員會指定您想要變更的狀態位。

### <a name="example"></a>範例

請參閱 [CListCtrl：： GetTopIndex](#gettopindex)的範例。

## <a name="clistctrlgetitemtext"></a><a name="getitemtext"></a> CListCtrl：： GetItemText

抓取清單視圖專案或子專案的文字。

```
int GetItemText(
    int nItem,
    int nSubItem,
    LPTSTR lpszText,
    int nLen) const;

CString GetItemText(
    int nItem,
    int nSubItem) const;
```

### <a name="parameters"></a>參數

*nItem*<br/>
要取出其文字之專案的索引。

*nSubItem*<br/>
指定要抓取其文字的子內容。

*lpszText*<br/>
要接收專案文字之字串的指標。

*nLen*<br/>
*LpszText*所指向的緩衝區長度。

### <a name="return-value"></a>傳回值

傳回的版本會傳回 **`int`** 所抓取字串的長度。

傳回的版本會傳回 `CString` 專案文字。

### <a name="remarks"></a>備註

如果 *nSubItem* 為零，則此函式會捕獲專案標籤;如果 *nSubItem* 為非零值，則會抓取子內容的文字。 如需子工作引數的詳細資訊，請參閱 Windows SDK 中的 [LVITEM](/windows/win32/api/commctrl/ns-commctrl-lvitemw) 結構討論。

## <a name="clistctrlgetnextitem"></a><a name="getnextitem"></a> CListCtrl：： GetNextItem

搜尋具有指定屬性且具有指定專案之指定關聯性的清單視圖專案。

```
int GetNextItem(
    int nItem,
    int nFlags) const;
```

### <a name="parameters"></a>參數

*nItem*<br/>
要開始搜尋的專案索引，或-1，以尋找符合指定旗標的第一個專案。 從搜尋中排除指定的專案本身。

*nFlags*<br/>
所要求專案與指定專案的幾何關聯性，以及所要求專案的狀態。 幾何關聯可以是下列其中一個值：

- LVNI_ABOVE 搜尋指定專案上方的專案。

- LVNI_ALL 會依索引 (預設值) 來搜尋後續專案。

- LVNI_BELOW 搜尋位於指定之專案底下的專案。

- LVNI_TOLEFT 搜尋指定專案左邊的專案。

- LVNI_TORIGHT 搜尋指定專案右邊的專案。

狀態可以是零，也可以是下列其中一個或多個值：

- LVNI_DROPHILITED 專案已設定 LVIS_DROPHILITED 狀態旗標。

- LVNI_FOCUSED 專案已設定 LVIS_FOCUSED 狀態旗標。

- LVNI_SELECTED 專案已設定 LVIS_SELECTED 狀態旗標。

如果專案未設定所有指定的狀態旗標，則會繼續搜尋下一個專案。

### <a name="return-value"></a>傳回值

如果成功，則為下一個專案的索引，否則為-1。

## <a name="clistctrlgetnextitemindex"></a><a name="getnextitemindex"></a> CListCtrl：： GetNextItemIndex

抓取目前清單視圖控制項中具有指定屬性集之專案的索引。

```
BOOL GetNextItemIndex(
    PLVITEMINDEX pItemIndex,
    int nFlags) const;
```

### <a name="parameters"></a>參數

*pItemIndex*\
[in，out]描述搜尋開始之專案的 [LVITEMINDEX](/windows/win32/api/commctrl/ns-commctrl-lvitemindex) 結構指標，或-1 可尋找符合 *nFlags* 參數中之旗標的第一個專案。 如果這個方法成功，結構會 `LVITEMINDEX` 描述搜尋所找到的專案。

*nFlags*\
在指定如何執行搜尋之旗標的位組合 (或) 。 搜尋可能取決於目標專案的索引、狀態或外觀，或相對於 *pItemIndex* 參數所指定之專案的目標專案實體位置。 如需詳細資訊，請參閱[LVM_GETNEXTITEMINDEX](/windows/win32/controls/lvm-getnextitemindex)訊息中的*flags*參數。

### <a name="return-value"></a>傳回值

如果此方法成功，則為 TRUE;否則為 FALSE。

### <a name="remarks"></a>備註

呼叫端負責配置和設定 `LVITEMINDEX` *pItemIndex* 參數所指向之結構的成員。

這個方法會傳送 [LVM_GETNEXTITEMINDEX](/windows/win32/controls/lvm-getnextitemindex) 的訊息，如 Windows SDK 中所述。

## <a name="clistctrlgetnextselecteditem"></a><a name="getnextselecteditem"></a> CListCtrl：： GetNextSelectedItem

取得 *pos*所識別之清單專案的索引，然後將 *POS* 設定為位置值。

```
int GetNextSelectedItem(POSITION& pos) const;
```

### <a name="parameters"></a>參數

*Pos*<br/>
對或之前的呼叫所傳回之位置值的參考 `GetNextSelectedItem` `GetFirstSelectedItemPosition` 。 此呼叫會將此值更新為下一個位置。

### <a name="return-value"></a>傳回值

*Pos*所識別之清單專案的索引。

### <a name="remarks"></a>備註

`GetNextSelectedItem`如果您使用呼叫來建立初始位置，可以在正向反復專案迴圈中使用 `GetFirstSelectedItemPosition` 。

您必須確定您的位置值有效。 如果無效，則為 MFC 程式庫判斷提示的偵錯工具版本。

### <a name="example"></a>範例

下列程式碼範例將示範此函式的使用方式。

```cpp
        POSITION pos = m_myListCtrl.GetFirstSelectedItemPosition();
        if (pos == NULL)
        {
            TRACE(_T("No items were selected!\n"));
        }
        else
        {
            while (pos)
            {
                int nItem = m_myListCtrl.GetNextSelectedItem(pos);
                TRACE(_T("Item %d was selected!\n"), nItem);
                // you could do your own processing on nItem here
            }
        }
```

## <a name="clistctrlgetnumberofworkareas"></a><a name="getnumberofworkareas"></a> CListCtrl：： GetNumberOfWorkAreas

抓取清單視圖控制項目前的工作區數目。

```
UINT GetNumberOfWorkAreas() const;
```

### <a name="return-value"></a>傳回值

目前未使用。

### <a name="remarks"></a>備註

此成員函式會依照 Windows SDK 所述，執行 Win32 宏 [ListView_GetNumberOfWorkAreas](/windows/win32/api/commctrl/nf-commctrl-listview_getnumberofworkareas)的行為。

### <a name="example"></a>範例

```cpp
        UINT i, uCount = m_myListCtrl.GetNumberOfWorkAreas();
        LPRECT lpRects = (LPRECT) malloc(uCount*sizeof(RECT));

        if (lpRects != NULL)
        {
            // Dump all of the work area dimensions.
            m_myListCtrl.GetWorkAreas(uCount, lpRects);

            for (i=0; i < uCount; i++)
            {
                TRACE(_T("Work area %d; left = %d, top = %d, right = %d, ")
                    _T("bottom = %d\r\n"),
                    i, lpRects[i].left, lpRects[i].top, lpRects[i].right,
                    lpRects[i].bottom);
            }

            free(lpRects);
        }
        else
        {
            TRACE(_T("Couldn't allocate enough memory!"));
        }
```

## <a name="clistctrlgetoutlinecolor"></a><a name="getoutlinecolor"></a> CListCtrl：： GetOutlineColor

抓取清單視圖控制項的框線色彩。

```
COLORREF GetOutlineColor() const;
```

### <a name="return-value"></a>傳回值

傳回 [COLORREF](/windows/win32/gdi/colorref) 結構，其中包含外框色彩。

### <a name="remarks"></a>備註

此成員函式會模擬 [LVM_GETOUTLINECOLOR](/windows/win32/Controls/lvm-getoutlinecolor) 訊息的功能，如 Windows SDK 中所述。

## <a name="clistctrlgetorigin"></a><a name="getorigin"></a> CListCtrl：： GetOrigin

抓取清單視圖控制項的目前視圖原點。

```
BOOL GetOrigin(LPPOINT lpPoint) const;
```

### <a name="parameters"></a>參數

*lpPoint*<br/>
接收視圖來源的 [點](/windows/win32/api/windef/ns-windef-point) 結構位址。

### <a name="return-value"></a>傳回值

如果成功則不為零，否則為 0。 但是，如果控制項在報表檢視中，則傳回值一律為零。

## <a name="clistctrlgetselectedcolumn"></a><a name="getselectedcolumn"></a> CListCtrl：： GetSelectedColumn

抓取清單控制項中目前所選資料行的索引。

```
UINT GetSelectedColumn() const;
```

### <a name="return-value"></a>傳回值

所選資料行的索引。

### <a name="remarks"></a>備註

此成員函式會模擬 [LVM_GETSELECTEDCOLUMN](/windows/win32/Controls/lvm-getselectedcolumn) 訊息的功能，如 Windows SDK 中所述。

## <a name="clistctrlgetselectedcount"></a><a name="getselectedcount"></a> CListCtrl：： GetSelectedCount

抓取清單視圖控制項中選取的專案數目。

```
UINT GetSelectedCount() const;
```

### <a name="return-value"></a>傳回值

清單視圖控制項中選取的專案數目。

### <a name="example"></a>範例

```cpp
        UINT i, uSelectedCount = m_myListCtrl.GetSelectedCount();
        int  nItem = -1;

        // Update all of the selected items.
        if (uSelectedCount > 0)
        {
            for (i=0; i < uSelectedCount; i++)
            {
                nItem = m_myListCtrl.GetNextItem(nItem, LVNI_SELECTED);
                ASSERT(nItem != -1);
                m_myListCtrl.Update(nItem);
            }
        }
```

## <a name="clistctrlgetselectionmark"></a><a name="getselectionmark"></a> CListCtrl：： GetSelectionMark

抓取清單視圖控制項的選取專案標記。

```
int GetSelectionMark();
```

### <a name="return-value"></a>傳回值

以零為基底的選取標記; 如果沒有選取專案標記，則為-1。

### <a name="remarks"></a>備註

此成員函式會依照 Windows SDK 所述，執行 Win32 宏 [ListView_GetSelectionMark](/windows/win32/api/commctrl/nf-commctrl-listview_getselectionmark)的行為。

### <a name="example"></a>範例

```cpp
    // Set the selection mark to the first item only if no other item is
    // selected.
    if (m_myListCtrl.GetSelectionMark() == -1)
        m_myListCtrl.SetSelectionMark(0);
```

## <a name="clistctrlgetstringwidth"></a><a name="getstringwidth"></a> CListCtrl：： GetStringWidth

決定顯示所有指定字串所需的最小資料行寬度。

```
int GetStringWidth(LPCTSTR lpsz) const;
```

### <a name="parameters"></a>參數

*lpsz*<br/>
要判斷其寬度之以 null 結束的字串位址。

### <a name="return-value"></a>傳回值

*Lpsz*所指向之字串的寬度（以圖元為單位）。

### <a name="remarks"></a>備註

傳回的寬度會將控制項目前的字型和資料行邊界（而非小圖示的寬度）納入考慮。

### <a name="example"></a>範例

```cpp
        CString strColumn;
        int nWidth;

        // Insert six columns in the list view control. Make the width of
        // the column be the width of the column header plus 50%.
        for (int i = 0; i < 6; i++)
        {
            strColumn.Format(_T("column %d"), i);
            nWidth = 3*m_myListCtrl.GetStringWidth(strColumn)/2;
            m_myListCtrl.InsertColumn(i, strColumn, LVCFMT_LEFT, nWidth);
        }
```

## <a name="clistctrlgetsubitemrect"></a><a name="getsubitemrect"></a> CListCtrl：： GetSubItemRect

抓取清單視圖控制項中專案的周框。

```
BOOL GetSubItemRect(
    int iItem,
    int iSubItem,
    int nArea,
    CRect& ref);
```

### <a name="parameters"></a>參數

*iItem*<br/>
子專案父專案的索引。

*iSubItem*<br/>
子索引的以一為基礎的索引。

*nArea*<br/>
決定要抓取之清單視圖子) 的周框矩形 (部分。 將位 OR 運算子套用至下列一或多個值，即可指定周框的部分 (圖示、標籤或這兩個) 的值：

- LVIR_BOUNDS 會傳回整個專案的周框，包括圖示和標籤。

- LVIR_ICON 傳回圖示或小圖示的周框。

- LVIR_LABEL 會傳回整個專案的周框，包括圖示和標籤。 這等同于 LVIR_BOUNDS。

*裁判*<br/>
[CRect](../../atl-mfc-shared/reference/crect-class.md)物件的參考，該物件包含子工作周框的座標。

### <a name="return-value"></a>傳回值

如果成功則不為零，否則為 0。

### <a name="remarks"></a>備註

此成員函式會依照 Windows SDK 所述，執行 Win32 宏 [ListView_GetSubItemRect](/windows/win32/api/commctrl/nf-commctrl-listview_getsubitemrect)的行為。

## <a name="clistctrlgettextbkcolor"></a><a name="gettextbkcolor"></a> CListCtrl：： GetTextBkColor

抓取清單視圖控制項的文字背景色彩。

```
COLORREF GetTextBkColor() const;
```

### <a name="return-value"></a>傳回值

用來指定 RGB 色彩的32位值。

### <a name="example"></a>範例

請參閱 [CListCtrl：： SetTextBkColor](#settextbkcolor)的範例。

## <a name="clistctrlgettextcolor"></a><a name="gettextcolor"></a> CListCtrl：： GetTextColor

抓取清單視圖控制項的文字色彩。

```
COLORREF GetTextColor() const;
```

### <a name="return-value"></a>傳回值

用來指定 RGB 色彩的32位值。

### <a name="example"></a>範例

請參閱 [CListCtrl：： SetTextColor](#settextcolor)的範例。

## <a name="clistctrlgettileinfo"></a><a name="gettileinfo"></a> CListCtrl：： GetTileInfo

抓取清單視圖控制項中的圖格相關資訊。

```
BOOL GetTileInfo(PLVTILEINFO plvti) const;
```

### <a name="parameters"></a>參數

*plvti*<br/>
[LVTILEINFO](/windows/win32/api/commctrl/ns-commctrl-lvtileinfo)結構的指標，此結構會接收磚資訊。

### <a name="return-value"></a>傳回值

未使用傳回值。

### <a name="remarks"></a>備註

此成員函式會模擬 [LVM_GETTILEINFO](/windows/win32/Controls/lvm-gettileinfo) 訊息的功能，如 Windows SDK 中所述。

## <a name="clistctrlgettileviewinfo"></a><a name="gettileviewinfo"></a> CListCtrl：： GetTileViewInfo

抓取並排顯示中清單視圖控制項的相關資訊。

```
BOOL GetTileViewInfo(PLVTILEVIEWINFO ptvi) const;
```

### <a name="parameters"></a>參數

*ptvi*<br/>
[LVTILEVIEWINFO](/windows/win32/api/commctrl/ns-commctrl-lvtileviewinfo)結構的指標，此結構會接收抓取的資訊。

### <a name="return-value"></a>傳回值

未使用傳回值。

### <a name="remarks"></a>備註

此成員函式會模擬 [LVM_GETTILEVIEWINFO](/windows/win32/Controls/lvm-gettileviewinfo) 訊息的功能，如 Windows SDK 中所述。

## <a name="clistctrlgettooltips"></a><a name="gettooltips"></a> CListCtrl：： GetToolTips

抓取清單視圖控制項用來顯示工具提示的工具提示控制項。

```
CToolTipCtrl* GetToolTips() const;
```

### <a name="return-value"></a>傳回值

要由清單控制項使用之 [CToolTipCtrl](ctooltipctrl-class.md) 物件的指標。 如果 [Create](#create) 成員函式使用樣式 LVS_NOTOOLTIPS，則不會使用任何工具提示，而且會傳回 Null。

### <a name="remarks"></a>備註

此成員函式會依照 Windows SDK 所述，執行 Win32 訊息 [LVM_GETTOOLTIPS](/windows/win32/Controls/lvm-gettooltips)的行為。 的 MFC 實 `GetToolTips` `CToolTipCtrl` 會傳回清單控制項所使用的物件，而不是工具提示控制項的控制碼。

### <a name="example"></a>範例

```cpp
        CToolTipCtrl* pTip = m_myListCtrl.GetToolTips();
        if (NULL != pTip)
        {
            pTip->UpdateTipText(_T("I'm a list view!"), &m_myListCtrl,
                IDD_MYLISTCTRL);
        }
```

## <a name="clistctrlgettopindex"></a><a name="gettopindex"></a> CListCtrl：： GetTopIndex

在清單視圖或報表檢視中，捕獲最上層可見專案的索引。

```
int GetTopIndex() const;
```

### <a name="return-value"></a>傳回值

最上層可見專案的索引。

### <a name="example"></a>範例

```cpp
        // Make sure the focus is set to the list view control.
        m_myListCtrl.SetFocus();

        // Select all of the items that are completely visible.
        int n = m_myListCtrl.GetTopIndex();
        int nLast = n + m_myListCtrl.GetCountPerPage();

        for (; n < nLast; n++)
        {
            m_myListCtrl.SetItemState(n, LVIS_SELECTED, LVIS_SELECTED);
            ASSERT(m_myListCtrl.GetItemState(n, LVIS_SELECTED) == LVIS_SELECTED);
        }
```

## <a name="clistctrlgetview"></a><a name="getview"></a> CListCtrl：： GetView

取得清單視圖控制項的視圖。

```
DWORD GetView() const;
```

### <a name="return-value"></a>傳回值

清單視圖控制項的目前視圖。

### <a name="remarks"></a>備註

此成員函式會模擬 [LVM_GETVIEW](/windows/win32/Controls/lvm-getview) 訊息的功能，如 Windows SDK 中所述。

## <a name="clistctrlgetviewrect"></a><a name="getviewrect"></a> CListCtrl：： GetViewRect

抓取清單視圖控制項中所有專案的周框。

```
BOOL GetViewRect(LPRECT lpRect) const;
```

### <a name="parameters"></a>參數

*lpRect*<br/>
[矩形](/windows/win32/api/windef/ns-windef-rect)結構的位址。

### <a name="return-value"></a>傳回值

如果成功則不為零，否則為 0。

### <a name="remarks"></a>備註

清單視圖必須在圖示視圖或小型圖示視圖中。

## <a name="clistctrlgetworkareas"></a><a name="getworkareas"></a> CListCtrl：： GetWorkAreas

抓取清單視圖控制項目前的工作區域。

```cpp
void GetWorkAreas(
    int nWorkAreas,
    LPRECT pRect) const;
```

### <a name="parameters"></a>參數

*nWorkAreas*<br/>
`RECT` *PRect*陣列中包含的結構數目。

*pRect*<br/>
結構陣列的指標， `RECT` (或 [CRect](../../atl-mfc-shared/reference/crect-class.md) 物件，) 接收清單視圖控制項的工作區域。 這些結構中的值是在用戶端座標中。

### <a name="remarks"></a>備註

此成員函式會依照 Windows SDK 所述，執行 Win32 宏 [ListView_GetWorkAreas](/windows/win32/api/commctrl/nf-commctrl-listview_getworkareas)的行為。

### <a name="example"></a>範例

請參閱 [CListCtrl：： GetNumberOfWorkAreas](#getnumberofworkareas)的範例。

## <a name="clistctrlhasgroup"></a><a name="hasgroup"></a> CListCtrl：： HasGroup

判斷清單視圖控制項是否有指定的群組。

```
BOOL HasGroup(int iGroupId) const;
```

### <a name="parameters"></a>參數

*iGroupId*<br/>
所要求之群組的識別碼。

### <a name="return-value"></a>傳回值

成功時傳回 TRUE，失敗時傳回 FALSE。

### <a name="remarks"></a>備註

此成員函式會模擬 [LVM_HASGROUP](/windows/win32/Controls/lvm-hasgroup) 訊息的功能，如 Windows SDK 中所述。

## <a name="clistctrlhittest"></a><a name="hittest"></a> CListCtrl：： System.windows.media.visualtreehelper.hittest

判斷哪一個清單視圖專案（如果有的話）位於指定的位置。

```
int HitTest(LVHITTESTINFO* pHitTestInfo) const;

int HitTest(
    CPoint pt,
    UINT* pFlags = NULL) const;
```

### <a name="parameters"></a>參數

*pHitTestInfo*<br/>
結構的位址 `LVHITTESTINFO` ，其中包含要點擊測試的位置，並接收點擊測試結果的相關資訊。

*pt*<br/>
要測試的點。

*pFlags*<br/>
整數的指標，該整數會接收測試結果的相關資訊。 請參閱 `flags` Windows SDK 中 [LVHITTESTINFO](/windows/win32/api/commctrl/ns-commctrl-lvhittestinfo) 結構成員的說明。

### <a name="return-value"></a>傳回值

在 *pHitTestInfo*指定的位置之專案的索引（如果有的話），否則為-1。

### <a name="remarks"></a>備註

您可以使用結構成員的 LVHT_ABOVE、LVHT_BELOW、LVHT_TOLEFT 和 LVHT_TORIGHT 值， `flag` 判斷是否要滾動清單視圖控制項的內容。 您可以結合這兩個旗標，例如，如果位置在工作區的上方和左邊。

您可以測試結構成員的 LVHT_ONITEM 值 `flag` ，以判斷指定的位置是否在清單視圖專案上。 此值是結構成員之 LVHT_ONITEMICON、LVHT_ONITEMLABEL 和 LVHT_ONITEMSTATEICON 值的位 OR 運算 `flag` 。

### <a name="example"></a>範例

```cpp
void CListCtrlDlg::OnRClick(NMHDR* pNMHDR, LRESULT* pResult)
{
    LPNMITEMACTIVATE pia = (LPNMITEMACTIVATE)pNMHDR;
    CPoint point(pia->ptAction);

    // Select the item the user clicked on.
    UINT uFlags;
    int nItem = m_myListCtrl.HitTest(point, &uFlags);

    if (uFlags & LVHT_ONITEMLABEL)
    {
        m_myListCtrl.SetItem(nItem, 0, LVIF_STATE, NULL, 0, LVIS_SELECTED,
            LVIS_SELECTED, 0);
    }

    *pResult = 0;
}
```

## <a name="clistctrlinsertcolumn"></a><a name="insertcolumn"></a> CListCtrl：： InsertColumn

在清單視圖控制項中插入新的資料行。

```
int InsertColumn(
    int nCol,
    const LVCOLUMN* pColumn);

int InsertColumn(
    int nCol,
    LPCTSTR lpszColumnHeading,
    int nFormat = LVCFMT_LEFT,
    int nWidth = -1,
    int nSubItem = -1);
```

### <a name="parameters"></a>參數

*nCol*<br/>
新資料行的索引。

*pColumn*<br/>
結構的位址 `LVCOLUMN` ，其中包含新資料行的屬性。

*lpszColumnHeading*<br/>
字串的位址，其中包含資料行的標題。

*nFormat*<br/>
指定資料行對齊的整數。 它可以是下列其中一個值： LVCFMT_LEFT、LVCFMT_RIGHT 或 LVCFMT_CENTER。

*nWidth*<br/>
資料行的寬度（以圖元為單位）。 如果此參數為-1，則不會設定資料行寬度。

*nSubItem*<br/>
與資料行相關聯之子索引的索引。 如果此參數為-1，則沒有任何子與資料行相關聯。

### <a name="return-value"></a>傳回值

如果成功，則為新資料行的索引，否則為-1。

### <a name="remarks"></a>備註

清單視圖控制項中最左邊的資料行必須靠左對齊。

[LVCOLUMN](/windows/win32/api/commctrl/ns-commctrl-lvcolumnw)結構包含報表檢視中資料行的屬性。 它也可以用來接收資料行的相關資訊。 Windows SDK 中說明此結構。

## <a name="clistctrlinsertgroup"></a><a name="insertgroup"></a> CListCtrl：： InsertGroup

將群組插入清單視圖控制項。

```
LRESULT InsertGroup(
    int index,
    PLVGROUP pgrp);
```

### <a name="parameters"></a>參數

*index*<br/>
要插入群組之專案的索引。

*pgrp*<br/>
[LVGROUP](/windows/win32/api/commctrl/ns-commctrl-lvgroup)結構的指標，其中包含要加入的群組。

### <a name="return-value"></a>傳回值

傳回群組已加入之專案的索引，如果作業失敗，則為-1。

### <a name="remarks"></a>備註

此成員函式會模擬 [LVM_INSERTGROUP](/windows/win32/Controls/lvm-insertgroup) 訊息的功能，如 Windows SDK 中所述。

## <a name="clistctrlinsertgroupsorted"></a><a name="insertgroupsorted"></a> CListCtrl：： InsertGroupSorted

將指定的群組插入群組的已排序清單中。

```
LRESULT InsertGroupSorted(PLVINSERTGROUPSORTED pStructInsert);
```

### <a name="parameters"></a>參數

*pStructInsert*<br/>
[LVINSERTGROUPSORTED](/windows/win32/api/commctrl/ns-commctrl-lvinsertgroupsorted)結構的指標，其中包含要插入的群組。

### <a name="return-value"></a>傳回值

未使用傳回值。

### <a name="remarks"></a>備註

此成員函式會模擬 [LVM_INSERTGROUPSORTED](/windows/win32/Controls/lvm-insertgroupsorted) 訊息的功能，如 Windows SDK 中所述。

## <a name="clistctrlinsertitem"></a><a name="insertitem"></a> CListCtrl：： InsertItem

將專案插入清單視圖控制項。

```
int InsertItem(const LVITEM* pItem);

int InsertItem(
    int nItem,
    LPCTSTR lpszItem);

int InsertItem(
    int nItem,
    LPCTSTR lpszItem,
    int nImage);

int InsertItem(
    UINT nMask,
    int nItem,
    LPCTSTR lpszItem,
    UINT nState,
    UINT nStateMask,
    int nImage,
    LPARAM lParam);
```

### <a name="parameters"></a>參數

*pItem*<br/>
[LVITEM](/windows/win32/api/commctrl/ns-commctrl-lvitemw)結構的指標，指定專案的屬性，如 Windows SDK 所述。

*nItem*<br/>
要插入之專案的索引。

*lpszItem*<br/>
包含專案標籤之字串的位址，如果專案是回呼專案，則為 LPSTR_TEXTCALLBACK。 如需回呼專案的詳細資訊，請參閱 [CListCtrl：： GetCallbackMask](#getcallbackmask)。

*n*<br/>
專案影像的索引，如果專案是回呼專案，則為 I_IMAGECALLBACK。 如需回呼專案的詳細資訊，請參閱 [CListCtrl：： GetCallbackMask](#getcallbackmask)。

*nMask*<br/>
*NMask*參數會指定傳遞做為參數的專案屬性是有效的。 它可以是 Windows SDK 中的 [LVITEM 結構](/windows/win32/api/commctrl/ns-commctrl-lvitemw) 中所描述的一或多個遮罩值。 有效的值可以與位 OR 運算子結合。

*nState*<br/>
指出專案的狀態、狀態影像和重迭影像。 如需詳細資訊，請參閱 Windows SDK 主題 [LVITEM 結構](/windows/win32/api/commctrl/ns-commctrl-lvitemw) 和 [清單視圖專案狀態](/windows/win32/Controls/list-view-item-states) ，以取得有效旗標清單。

*nStateMask*<br/>
指出將抓取或修改狀態成員的位。 如需詳細資訊，請參閱 Windows SDK 中的 [LVITEM 結構](/windows/win32/api/commctrl/ns-commctrl-lvitemw) 。

*lParam*<br/>
與專案相關聯的32位應用程式專用值。 如果指定這個參數，您必須將 *nMask* 屬性設定 LVIF_PARAM。

### <a name="return-value"></a>傳回值

如果成功，則為新專案的索引，否則為-1。

### <a name="remarks"></a>備註

呼叫這個方法可能會導致 LVM_INSERTITEM 訊息傳送到您的控制項視窗。 控制項相關聯的訊息處理常式可能無法在某些條件下設定專案文字 (例如使用視窗樣式，例如 LVS_OWNERDRAW) 。 如需有關這些條件的詳細資訊，請參閱 Windows SDK 中的 [LVM_INSERTITEM](/windows/win32/Controls/lvm-insertitem) 。

### <a name="example"></a>範例

```cpp
        CString strText;
        int nColumnCount = m_myListCtrl.GetHeaderCtrl()->GetItemCount();

        // Insert 10 items in the list view control.
        for (int i = 0; i < 10; i++)
        {
            strText.Format(TEXT("item %d"), i);

            // Insert the item, select every other item.
            m_myListCtrl.InsertItem(LVIF_TEXT | LVIF_STATE, i, strText,
                (i % 2) == 0 ? LVIS_SELECTED : 0, LVIS_SELECTED, 0, 0);

            // Initialize the text of the subitems.
            for (int j = 1; j < nColumnCount; j++)
            {
                strText.Format(TEXT("sub-item %d %d"), i, j);
                m_myListCtrl.SetItemText(i, j, strText);
            }
        }
```

## <a name="clistctrlinsertmarkhittest"></a><a name="insertmarkhittest"></a> CListCtrl：： InsertMarkHitTest

抓取最接近指定點的插入點。

```
int InsertMarkHitTest(
    LPPOINT pPoint,
    LPLVINSERTMARK plvim) const;
```

### <a name="parameters"></a>參數

*pPoint*<br/>
[點](/windows/win32/api/windef/ns-windef-point)結構的指標，其中包含點擊測試座標（相對於清單控制項的工作區）。

*plvim*<br/>
[LVINSERTMARK](/windows/win32/api/commctrl/ns-commctrl-lvinsertmark)結構的指標，指定最接近 point 參數所定義之座標的插入點。

### <a name="return-value"></a>傳回值

最接近指定點的插入點。

### <a name="remarks"></a>備註

此成員函式會模擬 [LVM_INSERTMARKHITTEST](/windows/win32/Controls/lvm-insertmarkhittest) 訊息的功能，如 Windows SDK 中所述。

## <a name="clistctrlisgroupviewenabled"></a><a name="isgroupviewenabled"></a> CListCtrl：： IsGroupViewEnabled

決定是否啟用清單視圖控制項的群組視圖。

```
BOOL IsGroupViewEnabled() const;
```

### <a name="return-value"></a>傳回值

如果已啟用群組視圖，則傳回 TRUE，否則傳回 FALSE。

### <a name="remarks"></a>備註

此成員函式會模擬 [LVM_ISGROUPVIEWENABLED](/windows/win32/Controls/lvm-isgroupviewenabled) 訊息的功能，如 Windows SDK 中所述。

## <a name="clistctrlisitemvisible"></a><a name="isitemvisible"></a> CListCtrl：： IsItemVisible

指出是否可以看到目前清單視圖控制項中的指定專案。

```
BOOL IsItemVisible(int index) const;
```

### <a name="parameters"></a>參數

*指數*\
在目前清單視圖控制項中專案的以零為基底的索引。

### <a name="return-value"></a>傳回值

如果可以看到指定的專案，則為 TRUE;否則為 FALSE。

### <a name="remarks"></a>備註

這個方法會傳送 [LVM_ISITEMVISIBLE](/windows/win32/Controls/lvm-isitemvisible) 的訊息，如 Windows SDK 中所述。

## <a name="clistctrlmapidtoindex"></a><a name="mapidtoindex"></a> CListCtrl：： MapIDToIndex

將目前清單視圖控制項中專案的唯一識別碼對應至索引。

```
UINT MapIDToIndex(UINT id) const;
```

### <a name="parameters"></a>參數

*Id*\
在專案的唯一識別碼。

### <a name="return-value"></a>傳回值

指定之識別碼的目前索引。

### <a name="remarks"></a>備註

清單視圖控制項會在內部依索引追蹤專案。 這可能會造成問題，因為索引可能會在控制項的存留期間變更。 清單視圖控制項可以在建立專案時標記具有識別碼的專案，而您可以使用此識別碼來保證在清單視圖控制項的存留期內的唯一性。

請注意，在多執行緒環境中，只會在裝載清單視圖控制項的執行緒上（而不是背景執行緒）保證索引。

這個方法會傳送 [LVM_MAPIDTOINDEX](/windows/win32/controls/lvm-mapidtoindex) 的訊息，如 Windows SDK 中所述。

## <a name="clistctrlmapindextoid"></a><a name="mapindextoid"></a> CListCtrl：： MapIndexToID

將目前清單視圖控制項中專案的索引對應至唯一識別碼。

```
UINT MapIndexToID(UINT index) const;
```

### <a name="parameters"></a>參數

*指數*\
在專案之以零為基底的索引。

### <a name="return-value"></a>傳回值

指定之專案的唯一識別碼。

### <a name="remarks"></a>備註

清單視圖控制項會在內部依索引追蹤專案。 這可能會造成問題，因為索引可能會在控制項的存留期間變更。 清單視圖控制項可以在建立專案時標記具有識別碼的專案。 您可以使用此識別碼，在清單視圖控制項的存留期記憶體取特定專案。

請注意，在多執行緒環境中，只會在裝載清單視圖控制項的執行緒上（而不是背景執行緒）保證索引。

這個方法會傳送 [LVM_MAPINDEXTOID](/windows/win32/Controls/lvm-mapindextoid) 的訊息，如 Windows SDK 中所述。

### <a name="example"></a>範例

下列程式碼範例 `m_listCtrl` 會定義用來存取目前清單視圖控制項的變數。 下一個範例中會使用此變數。

```cpp
public:
    // Variable used to access the list control.
    CListCtrl m_listCtrl;
```

### <a name="example"></a>範例

下列程式碼範例會示範 `MapIndexToID` 方法。 在此程式碼範例的先前章節中，我們建立了一個清單視圖控制項，它會在報表檢視中顯示標題為 "ClientID" 和 "年級" 的兩個數據行。 下列範例會將每個清單視圖專案的索引對應到識別碼，然後抓取每個識別碼的索引。 最後，此範例會報告是否已取出原始索引。

```cpp
    // MapIndexToID
    int iCount = m_listCtrl.GetItemCount();
    UINT nId = 0;
    UINT nIndex = 0;
    for (int iIndexOriginal = 0; iIndexOriginal < iCount; iIndexOriginal++)
    {
        // Map index to ID.
        nId = m_listCtrl.MapIndexToID((UINT)iIndexOriginal);

        // Map ID to index.
        nIndex = m_listCtrl.MapIDToIndex(nId);

        if (nIndex != (UINT)(iIndexOriginal))
        {
            CString str;
            str.Format(_T("Mapped index (%d) is not equal to original index (%d)"),
                nIndex, (UINT)(iIndexOriginal));
            AfxMessageBox(str);
            return;
        }
    }
    AfxMessageBox(_T("The mapped indexes and original indexes are equal."),
        MB_ICONINFORMATION);
```

## <a name="clistctrlmovegroup"></a><a name="movegroup"></a> CListCtrl：： MoveGroup

將指定的群組移至清單視圖控制項之以零為基底的指定索引。

```
LRESULT MoveGroup(
    int iGroupId,
    int toIndex);
```

### <a name="parameters"></a>參數

*iGroupId*<br/>
要移動之群組的識別碼。

*toIndex*<br/>
以零為基底的索引，這是要移動群組的位置。

### <a name="return-value"></a>傳回值

未使用傳回值。

### <a name="remarks"></a>備註

此成員函式會模擬 [LVM_MOVEGROUP](/windows/win32/Controls/lvm-movegroup) 訊息的功能，如 Windows SDK 中所述。

## <a name="clistctrlmoveitemtogroup"></a><a name="moveitemtogroup"></a> CListCtrl：： MoveItemToGroup

將指定的專案移至指定的群組。

```cpp
void MoveItemToGroup(
    int idItemFrom,
    int idGroupTo);
```

### <a name="parameters"></a>參數

*idItemFrom*<br/>
在要移動之專案的索引。

*idGroupTo*<br/>
在專案將移至的群組識別碼。

### <a name="remarks"></a>備註

> [!NOTE]
> 目前未執行此方法。

這個方法會模擬 [LVM_MOVEITEMTOGROUP](/windows/win32/Controls/lvm-moveitemtogroup) 訊息的功能，如 Windows SDK 中所述。

## <a name="clistctrlredrawitems"></a><a name="redrawitems"></a> CListCtrl：： RedrawItems

強制清單視圖控制項重新繪製專案的範圍。

```
BOOL RedrawItems(
    int nFirst,
    int nLast);
```

### <a name="parameters"></a>參數

*nFirst*<br/>
要重新繪製之第一個專案的索引。

*nLast*<br/>
要重新繪製之最後一個專案的索引。

### <a name="return-value"></a>傳回值

如果成功則不為零，否則為 0。

### <a name="remarks"></a>備註

在清單視圖視窗收到 WM_PAINT 訊息之前，不會實際重新繪製指定的專案。 若要立即重新繪製，請在使用此函數之後呼叫 Windows [UpdateWindow](/windows/win32/api/winuser/nf-winuser-updatewindow) 函式。

## <a name="clistctrlremoveallgroups"></a><a name="removeallgroups"></a> CListCtrl：： RemoveAllGroups

從清單視圖控制項移除所有群組。

```cpp
void RemoveAllGroups();
```

### <a name="remarks"></a>備註

此成員函式會模擬 [LVM_REMOVEALLGROUPS](/windows/win32/Controls/lvm-removeallgroups) 訊息的功能，如 Windows SDK 中所述。

## <a name="clistctrlremovegroup"></a><a name="removegroup"></a> CListCtrl：： RemoveGroup

從清單視圖控制項中移除指定的群組。

```
LRESULT RemoveGroup(int iGroupId);
```

### <a name="parameters"></a>參數

*iGroupId*<br/>
要移除之群組的識別碼。

### <a name="return-value"></a>傳回值

如果成功，則傳回群組的索引，否則傳回-1。

### <a name="remarks"></a>備註

此成員函式會模擬 [LVM_REMOVEGROUP](/windows/win32/Controls/lvm-removegroup) 訊息的功能，如 Windows SDK 中所述。

## <a name="clistctrlscroll"></a><a name="scroll"></a> CListCtrl：： Scroll

滾動清單視圖控制項的內容。

```
BOOL Scroll(CSize size);
```

### <a name="parameters"></a>參數

*size*<br/>
`CSize`物件，指定水準和垂直捲動的量（以圖元為單位）。 `y`*大小*的成員會除以清單視圖控制項之線條的高度（以圖元為單位），而且控制項會依產生的行數來滾動。

### <a name="return-value"></a>傳回值

如果成功則不為零，否則為 0。

## <a name="clistctrlsetbkcolor"></a><a name="setbkcolor"></a> CListCtrl：： SetBkColor

設定清單視圖控制項的背景色彩。

```
BOOL SetBkColor(COLORREF cr);
```

### <a name="parameters"></a>參數

*鉻*<br/>
要設定的背景色彩，或沒有背景色彩的 CLR_NONE 值。 使用背景色彩的清單視圖控制項，會比沒有背景色彩的控制項更快重繪。 如需詳細資訊，請參閱 Windows SDK 中的 [COLORREF](/windows/win32/gdi/colorref) 。

### <a name="return-value"></a>傳回值

如果成功則不為零，否則為 0。

### <a name="example"></a>範例

```cpp
        // Use the 3D button face color for the background.
        COLORREF crBkColor = ::GetSysColor(COLOR_3DFACE);
        m_myListCtrl.SetBkColor(crBkColor);
        ASSERT(m_myListCtrl.GetBkColor() == crBkColor);
```

## <a name="clistctrlsetbkimage"></a><a name="setbkimage"></a> CListCtrl：： SetBkImage

設定清單視圖控制項的背景影像。

```
BOOL SetBkImage(LVBKIMAGE* plvbkImage);

BOOL SetBkImage(
    HBITMAP hBitmap,
    BOOL fTile = TRUE,
    int xOffsetPercent = 0,
    int yOffsetPercent = 0);

BOOL SetBkImage(
    LPTSTR pszUrl,
    BOOL fTile = TRUE,
    int xOffsetPercent = 0,
    int yOffsetPercent = 0);
```

### <a name="parameters"></a>參數

*plvbkImage*<br/>
結構的位址 `LVBKIMAGE` ，其中包含新的背景影像資訊。

*hBitmap*<br/>
點陣圖的控制碼。

*pszUrl*<br/>
以 Null 終止的字串，其中包含背景影像的 URL。

*fTile*<br/>
如果影像要在清單視圖控制項的背景中並排顯示，則為非零值;否則為0。

*xOffsetPercent*<br/>
影像左邊緣的位移（以圖元為單位），從清單視圖控制項的來源開始。

*yOffsetPercent*<br/>
影像上邊緣的位移（以圖元為單位），從清單視圖控制項的來源開始。

### <a name="return-value"></a>傳回值

如果成功，則傳回非零，否則傳回零。

### <a name="remarks"></a>備註

> [!NOTE]
> 因為 `CListCtrl::SetBkImage` 使用 OLE COM 功能，所以必須在使用之前初始化 ole 程式庫 `SetBkImage` 。 當應用程式初始化時，最好將 COM 程式庫初始化，並在應用程式終止時解除初始化程式庫。 這會自動在使用 ActiveX 技術、OLE Automation、OLE 連結/內嵌或 ODBC/DAO 作業的 MFC 應用程式中進行。

### <a name="example"></a>範例

請參閱 [CListCtrl：： GetBkImage](#getbkimage)的範例。

## <a name="clistctrlsetcallbackmask"></a><a name="setcallbackmask"></a> CListCtrl：： SetCallbackMask

設定清單視圖控制項的回呼遮罩。

```
BOOL SetCallbackMask(UINT nMask);
```

### <a name="parameters"></a>參數

*nMask*<br/>
回呼遮罩的新值。

### <a name="return-value"></a>傳回值

如果成功則不為零，否則為 0。

### <a name="example"></a>範例

```cpp
    // Set the callback mask so that only the selected and focused states
    // are stored for each item.
    m_myListCtrl.SetCallbackMask(LVIS_SELECTED|LVIS_FOCUSED);
    ASSERT(m_myListCtrl.GetCallbackMask() ==
        (LVIS_SELECTED|LVIS_FOCUSED));
```

## <a name="clistctrlsetcheck"></a><a name="setcheck"></a> CListCtrl：： SetCheck

判斷清單控制項專案的狀態影像是否可見。

```
BOOL SetCheck(
    int nItem,
    BOOL fCheck = TRUE);
```

### <a name="parameters"></a>參數

*nItem*<br/>
清單控制項專案的以零為基底的索引。

*來*<br/>
指定是否應該顯示專案的狀態影像。 依預設， *來* 為 TRUE，而且狀態影像是可見的。 如果 *來* 為 FALSE，則不會顯示。

### <a name="return-value"></a>傳回值

如果已核取該專案，則為非零，否則為0。

### <a name="example"></a>範例

```cpp
        int nCount = m_myListCtrl.GetItemCount();
        BOOL fCheck = FALSE;

        // Set the check state of every other item to TRUE and
        // all others to FALSE.
        for (int i = 0; i < nCount; i++)
        {
            m_myListCtrl.SetCheck(i, fCheck);
            ASSERT((m_myListCtrl.GetCheck(i) && fCheck) ||
                (!m_myListCtrl.GetCheck(i) && !fCheck));
            fCheck = !fCheck;
        }
```

## <a name="clistctrlsetcolumn"></a><a name="setcolumn"></a> CListCtrl：： SetColumn

設定清單視圖資料行的屬性。

```
BOOL SetColumn(
    int nCol,
    const LVCOLUMN* pColumn);
```

### <a name="parameters"></a>參數

*nCol*<br/>
要設定其屬性之資料行的索引。

*pColumn*<br/>
[LVCOLUMN](/windows/win32/api/commctrl/ns-commctrl-lvcolumnw)結構的位址，其中包含新的資料行屬性，如 Windows SDK 所述。 結構的 `mask` 成員會指定要設定的資料行屬性。 如果 `mask` 成員指定 LVCF_TEXT 值，則結構的 `pszText` 成員是以 null 終止之字串的位址，而且 `cchTextMax` 會忽略結構的成員。

### <a name="return-value"></a>傳回值

如果成功則不為零，否則為 0。

### <a name="example"></a>範例

請參閱 [CListCtrl：： GetColumn](#getcolumn)的範例。

## <a name="clistctrlsetcolumnorderarray"></a><a name="setcolumnorderarray"></a> CListCtrl：： SetColumnOrderArray

將資料行順序設定 (從清單視圖控制項的左到右) 。

```
BOOL SetColumnOrderArray(
    int iCount,
    LPINT piArray);
```

### <a name="parameters"></a>參數

*piArray*<br/>
緩衝區的指標，其中包含清單視圖控制項中資料行的索引值， (從左至右) 。 緩衝區必須夠大，才能包含清單視圖控制項中的總數據行數。

*iCount*<br/>
清單視圖控制項中的資料行數目。

### <a name="return-value"></a>傳回值

如果成功則不為零，否則為 0。

### <a name="remarks"></a>備註

此成員函式會依照 Windows SDK 所述，執行 Win32 宏 [ListView_SetColumnOrderArray](/windows/win32/api/commctrl/nf-commctrl-listview_setcolumnorderarray)的行為。

### <a name="example"></a>範例

請參閱 [CListCtrl：： GetColumnOrderArray](#getcolumnorderarray)的範例。

## <a name="clistctrlsetcolumnwidth"></a><a name="setcolumnwidth"></a> CListCtrl：： SetColumnWidth

在報表檢視或清單視圖中變更資料行的寬度。

```
BOOL SetColumnWidth(
    int nCol,
    int cx);
```

### <a name="parameters"></a>參數

*nCol*<br/>
要設定其寬度之資料行的索引。 在清單視圖中，此參數必須是0。

*殘雪*<br/>
資料行的新寬度。 可以是 LVSCW_AUTOSIZE 或 LVSCW_AUTOSIZE_USEHEADER，如 Windows SDK [LVM_SETCOLUMNWIDTH](/windows/win32/Controls/lvm-setcolumnwidth) 中所述。

### <a name="return-value"></a>傳回值

如果成功則不為零，否則為 0。

## <a name="clistctrlsetextendedstyle"></a><a name="setextendedstyle"></a> CListCtrl：： SetExtendedStyle

設定清單視圖控制項目前的擴充樣式。

```
DWORD SetExtendedStyle(DWORD dwNewStyle);
```

### <a name="parameters"></a>參數

*dwNewStyle*<br/>
要由清單視圖控制項使用的擴充樣式組合。 如需這些樣式的描述性清單，請參閱 Windows SDK 中的 [擴充清單視圖樣式](/windows/win32/Controls/extended-list-view-styles) 主題。

### <a name="return-value"></a>傳回值

清單視圖控制項所使用的先前擴充樣式的組合。

### <a name="remarks"></a>備註

此成員函式會依照 Windows SDK 所述，執行 Win32 宏 [ListView_SetExtendedListViewStyle](/windows/win32/api/commctrl/nf-commctrl-listview_setextendedlistviewstyle)的行為。

### <a name="example"></a>範例

```cpp
    // Allow the header controls item to be movable by the user.
    m_myListCtrl.SetExtendedStyle
        (m_myListCtrl.GetExtendedStyle()|LVS_EX_HEADERDRAGDROP);
```

## <a name="clistctrlsetgroupinfo"></a><a name="setgroupinfo"></a> CListCtrl：： SetGroupInfo

設定描述目前清單視圖控制項之指定群組的資訊。

```
int SetGroupInfo(
    int iGroupId,
    PLVGROUP pgrp);
```

### <a name="parameters"></a>參數

*iGroupId*<br/>
設定其資訊之群組的識別碼。

*pgrp*<br/>
[LVGROUP](/windows/win32/api/commctrl/ns-commctrl-lvgroup)結構的指標，其中包含要設定的資訊。 呼叫端負責配置此結構並設定其成員。

### <a name="return-value"></a>傳回值

如果方法成功，則為群組的識別碼;否則為-1。

### <a name="remarks"></a>備註

這個方法會傳送 [LVM_SETGROUPINFO](/windows/win32/Controls/lvm-setgroupinfo) 的訊息，如 Windows SDK 中所述。

## <a name="clistctrlsetgroupmetrics"></a><a name="setgroupmetrics"></a> CListCtrl：： SetGroupMetrics

設定清單視圖控制項的群組度量。

```cpp
void SetGroupMetrics(PLVGROUPMETRICS pGroupMetrics);
```

### <a name="parameters"></a>參數

*pGroupMetrics*<br/>
[LVGROUPMETRICS](/windows/win32/api/commctrl/ns-commctrl-lvgroupmetrics)結構的指標，其中包含要設定的群組計量資訊。

### <a name="remarks"></a>備註

此成員函式會模擬 [LVM_SETGROUPMETRICS](/windows/win32/Controls/lvm-setgroupmetrics) 訊息的功能，如 Windows SDK 中所述。

## <a name="clistctrlsethotcursor"></a><a name="sethotcursor"></a> CListCtrl：： SetHotCursor

設定當針對清單視圖控制項啟用熱追蹤時，所使用的資料指標。

```
HCURSOR SetHotCursor(HCURSOR hc);
```

### <a name="parameters"></a>參數

*Hc*<br/>
資料指標資源的控制碼，用來表示熱資料指標。

### <a name="return-value"></a>傳回值

清單視圖控制項所使用之先前作用中資料指標資源的控制碼。

### <a name="remarks"></a>備註

此成員函式會依照 Windows SDK 所述，執行 Win32 宏 [ListView_SetHotCursor](/windows/win32/api/commctrl/nf-commctrl-listview_sethotcursor)的行為。

只有在啟用暫止選取專案時，才會顯示作用中游標，因為游標會在任何清單視圖專案上傳遞。 藉由設定 LVS_EX_TRACKSELECT 擴充樣式來啟用暫止選取專案。

### <a name="example"></a>範例

請參閱 [CListCtrl：： GetHotCursor](#gethotcursor)的範例。

## <a name="clistctrlsethotitem"></a><a name="sethotitem"></a> CListCtrl：： SetHotItem

設定清單視圖控制項的目前熱專案。

```
int SetHotItem(int iIndex);
```

### <a name="parameters"></a>參數

*iIndex*<br/>
以零為基底的索引，這是要設定為熱專案的專案。

### <a name="return-value"></a>傳回值

先前熱專案的以零為基底的索引。

### <a name="remarks"></a>備註

此成員函式會依照 Windows SDK 所述，執行 Win32 宏 [ListView_SetHotItem](/windows/win32/api/commctrl/nf-commctrl-listview_sethotitem)的行為。

### <a name="example"></a>範例

請參閱 [CListCtrl：： GetHotItem](#gethotitem)的範例。

## <a name="clistctrlsethovertime"></a><a name="sethovertime"></a> CListCtrl：： SetHoverTime

設定清單視圖控制項目前的停留時間。

```
DWORD SetHoverTime(DWORD dwHoverTime = (DWORD)-1);
```

### <a name="parameters"></a>參數

*dwHoverTime*<br/>
新的延遲（以毫秒為單位），在選取之前，滑鼠游標必須將滑鼠游標停留在專案上。 如果傳遞的是預設值，則會將時間設定為預設的停留時間。

### <a name="return-value"></a>傳回值

先前的停留時間（以毫秒為單位）。

### <a name="remarks"></a>備註

此成員函式會依照 Windows SDK 所述，執行 Win32 宏 [ListView_SetHoverTime](/windows/win32/api/commctrl/nf-commctrl-listview_sethovertime)的行為。

### <a name="example"></a>範例

請參閱 [CListCtrl：： GetHoverTime](#gethovertime)的範例。

## <a name="clistctrlseticonspacing"></a><a name="seticonspacing"></a> CListCtrl：： SetIconSpacing

在清單視圖控制項中設定圖示之間的間距。

```
CSize SetIconSpacing(
    int cx,
    int cy);

CSize SetIconSpacing(CSize size);
```

### <a name="parameters"></a>參數

*殘雪*<br/>
X 軸上圖示之間的距離 (以圖元為單位) 。

*cy*<br/>
Y 軸上圖示之間的距離 (以圖元為單位) 。

*size*<br/>
`CSize`物件，指定 X 軸和 y 軸上的圖示之間的距離（以圖元為單位） () 。

### <a name="return-value"></a>傳回值

[CSize](../../atl-mfc-shared/reference/csize-class.md)物件，其中包含圖示間距的先前值。

### <a name="remarks"></a>備註

此成員函式會依照 Windows SDK 所述，執行 Win32 宏 [ListView_SetIconSpacing](/windows/win32/api/commctrl/nf-commctrl-listview_seticonspacing)的行為。

### <a name="example"></a>範例

```cpp
    // Leave lots of space between icons.
    m_myListCtrl.SetIconSpacing(CSize(100, 100));
```

## <a name="clistctrlsetimagelist"></a><a name="setimagelist"></a> CListCtrl：： SetImageList

將影像清單指派給清單視圖控制項。

```
CImageList* SetImageList(
    CImageList* pImageList,
    int nImageListType);
```

### <a name="parameters"></a>參數

*pImageList*<br/>
要指派之影像清單的指標。

*nImageListType*<br/>
影像清單的類型。 其可以是下列其中一個值：

- 具有大型圖示的 LVSIL_NORMAL 影像清單。

- 具有小圖示的 LVSIL_SMALL 影像清單。

- 具有狀態影像的 LVSIL_STATE 映射清單。

### <a name="return-value"></a>傳回值

上一個影像清單的指標。

### <a name="example"></a>範例

請參閱 [CListCtrl：： GetImageList](#getimagelist)的範例。

## <a name="clistctrlsetinfotip"></a><a name="setinfotip"></a> CListCtrl：： SetInfoTip

設定工具提示文字。

```
BOOL SetInfoTip(PLVSETINFOTIP plvInfoTip);
```

### <a name="parameters"></a>參數

*plvInfoTip*<br/>
[LVFSETINFOTIP](/windows/win32/api/commctrl/ns-commctrl-lvsetinfotip)結構的指標，其中包含要設定的資訊。

### <a name="return-value"></a>傳回值

成功時傳回 TRUE，失敗時傳回 FALSE。

### <a name="remarks"></a>備註

此成員函式會模擬 [LVM_SETINFOTIP](/windows/win32/Controls/lvm-setinfotip) 訊息的功能，如 Windows SDK 中所述。

## <a name="clistctrlsetinsertmark"></a><a name="setinsertmark"></a> CListCtrl：： SetInsertMark

將插入點設定為已定義的位置。

```
BOOL SetInsertMark(LPLVINSERTMARK plvim);
```

### <a name="parameters"></a>參數

*plvim*<br/>
[LVINSERTMARK](/windows/win32/api/commctrl/ns-commctrl-lvinsertmark)結構的指標，指定要設定插入點的位置。

### <a name="return-value"></a>傳回值

如果成功，則傳回 TRUE，否則傳回 FALSE。 如果結構成員中的大小不 `cbSize` `LVINSERTMARK` 等於結構的實際大小，或當插入點不適用於目前的視圖時，則會傳回 FALSE。

### <a name="remarks"></a>備註

此成員函式會模擬 [LVM_SETINSERTMARK](/windows/win32/Controls/lvm-setinsertmark) 訊息的功能，如 Windows SDK 中所述。

## <a name="clistctrlsetinsertmarkcolor"></a><a name="setinsertmarkcolor"></a> CListCtrl：： SetInsertMarkColor

設定插入點的色彩。

```
COLORREF SetInsertMarkColor(COLORREF color);
```

### <a name="parameters"></a>參數

*color*<br/>
[COLORREF](/windows/win32/gdi/colorref)結構，指定要設定插入點的色彩。

### <a name="return-value"></a>傳回值

傳回 `COLORREF` 包含先前色彩的結構。

### <a name="remarks"></a>備註

此成員函式會模擬 [LVM_SETINSERTMARKCOLOR](/windows/win32/Controls/lvm-setinsertmarkcolor) 訊息的功能，如 Windows SDK 中所述。

## <a name="clistctrlsetitem"></a><a name="setitem"></a> CListCtrl：： SetItem

設定部分或全部清單視圖專案的屬性。

```
BOOL SetItem(const LVITEM* pItem);

BOOL SetItem(
    int nItem,
    int nSubItem,
    UINT nMask,
    LPCTSTR lpszItem,
    int nImage,
    UINT nState,
    UINT nStateMask,
    LPARAM lParam);

BOOL SetItem(
    int nItem,
    int nSubItem,
    UINT nMask,
    LPCTSTR lpszItem,
    int nImage,
    UINT nState,
    UINT nStateMask,
    LPARAM lParam,
    int nIndent);
```

### <a name="parameters"></a>參數

*pItem*<br/>
包含新專案屬性之 [LVITEM](/windows/win32/api/commctrl/ns-commctrl-lvitemw) 結構的位址，如 Windows SDK 所述。 結構的 `iItem` 和 `iSubItem` 成員會識別專案或子專案，而結構的 `mask` 成員會指定要設定的屬性。 如需成員的詳細資訊 `mask` ，請參閱 **備註**。

*nItem*<br/>
要設定其屬性之專案的索引。

*nSubItem*<br/>
要設定其屬性之子集合的索引。

*nMask*<br/>
指定要設定的屬性 (查看備註) 。

*lpszItem*<br/>
指定專案標籤之以 null 終止之字串的位址。

*n*<br/>
影像清單中專案影像的索引。

*nState*<br/>
指定要變更之狀態的值 (請參閱備註) 。

*nStateMask*<br/>
指定要變更的狀態 (查看備註) 。

*lParam*<br/>
要與專案相關聯的32位應用程式專用值。

*nIndent*<br/>
縮排的寬度（以圖元為單位）。 如果 *nIndent* 小於系統定義的最小寬度，則新寬度會設定為系統定義的最小值

### <a name="return-value"></a>傳回值

如果成功則不為零，否則為 0。

### <a name="remarks"></a>備註

`iItem`結構和 `iSubItem` `LVITEM` *nItem*和*nSubItem*參數的和成員會識別要設定其屬性的專案和子專案。

`mask`結構的成員 `LVITEM` 和*nMask*參數會指定要設定的專案屬性：

- LVIF_TEXT `pszText` 成員或 *lpszItem* 參數是以 null 終止之字串的位址，則 `cchTextMax` 會忽略成員。

- LVIF_STATE `stateMask` member 或 *nStateMask* 參數會指定要變更的專案狀態，且 `state` 成員或 *nState* 參數包含這些狀態的值。

### <a name="example"></a>範例

請參閱 [CListCtrl：： system.windows.media.visualtreehelper.hittest](#hittest)的範例。

## <a name="clistctrlsetitemcount"></a><a name="setitemcount"></a> CListCtrl：： SetItemCount

準備清單視圖控制項以加入大量專案。

```cpp
void SetItemCount(int nItems);
```

### <a name="parameters"></a>參數

*nItems*<br/>
控制項最後將包含的專案數目。

### <a name="remarks"></a>備註

若要設定虛擬清單視圖控制項的專案計數，請參閱 [CListCtrl：： SetItemCountEx](#setitemcountex)。

### <a name="remarks"></a>備註

此成員函式會依照 Windows SDK 所述，執行 Win32 宏 [ListView_SetItemCount](/windows/win32/api/commctrl/nf-commctrl-listview_setitemcount)的行為。

### <a name="example"></a>範例

```cpp
        CString str;

        // Add 1024 items to the list view control.
        m_myListCtrl.SetItemCount(1024);

        for (int i = 0; i < 1024; i++)
        {
            str.Format(TEXT("item %d"), i);
            m_myListCtrl.InsertItem(i, str);
        }
```

## <a name="clistctrlsetitemcountex"></a><a name="setitemcountex"></a> CListCtrl：： SetItemCountEx

設定虛擬清單視圖控制項的專案計數。

```
BOOL SetItemCountEx(
    int iCount,
    DWORD dwFlags = LVSICF_NOINVALIDATEALL);
```

### <a name="parameters"></a>參數

*iCount*<br/>
控制項最後將包含的專案數目。

*dwFlags*<br/>
指定在重設專案計數之後，清單視圖控制項的行為。 這個值可以是下列各項的組合：

- 除非受影響的專案目前為 view，否則不會重新繪製清單視圖控制項 LVSICF_NOINVALIDATEALL。 這是預設值。

- LVSICF_NOSCROLL 清單視圖控制項不會在專案計數變更時變更捲軸位置。

### <a name="return-value"></a>傳回值

如果成功則不為零，否則為 0。

### <a name="remarks"></a>備註

此成員函式會根據 Windows SDKand 中所述 [ListView_SetItemCountEx](/windows/win32/api/commctrl/nf-commctrl-listview_setitemcountex)，執行 Win32 宏的行為，而該行為只應針對虛擬清單視圖呼叫。

### <a name="example"></a>範例

```cpp
        CString str;

        // Add 1024 items to the list view control.

        // Force my virtual list view control to allocate
        // enough memory for my 1024 items.
        m_myVirtualListCtrl.SetItemCountEx(1024, LVSICF_NOSCROLL|
            LVSICF_NOINVALIDATEALL);

        for (int i = 0; i < 1024; i++)
        {
            str.Format(TEXT("item %d"), i);
            m_myVirtualListCtrl.InsertItem(i, str);
        }
```

## <a name="clistctrlsetitemdata"></a><a name="setitemdata"></a> CListCtrl：： SetItemData

設定與 *nItem*指定之專案相關聯的32位應用程式特定值。

```
BOOL SetItemData(int nItem, DWORD_PTR dwData);
```

### <a name="parameters"></a>參數

*nItem*<br/>
要設定其資料之清單專案的索引。

*dwData*<br/>
要與專案相關聯的32位值。

### <a name="return-value"></a>傳回值

如果成功則為非零；否則為 0。

### <a name="remarks"></a>備註

這個值是 `lParam` [LVITEM](/windows/win32/api/commctrl/ns-commctrl-lvitemw) 結構的成員，如 Windows SDK 所述。

### <a name="example"></a>範例

```cpp
    // Set the data of each item to be equal to its index.
    for (int i = 0; i < m_myListCtrl.GetItemCount(); i++)
    {
        m_myListCtrl.SetItemData(i, i);
    }
```

## <a name="clistctrlsetitemindexstate"></a><a name="setitemindexstate"></a> CListCtrl：： SetItemIndexState

設定目前清單視圖控制項中專案的狀態。

```
BOOL SetItemIndexState(
    PLVITEMINDEX pItemIndex,
    DWORD dwState,
    DWORD dwMask) const;
```

### <a name="parameters"></a>參數

*pItemIndex*\
在描述專案之 [LVITEMINDEX](/windows/win32/api/commctrl/ns-commctrl-lvitemindex) 結構的指標。 呼叫端負責配置此結構並設定其成員。

*dwState*\
在要設定專案的狀態，也就是 [清單視圖專案狀態](/windows/win32/Controls/list-view-item-states)的位元組合。 指定零可重設，或要設定一個狀態。

*dwMask*\
在 *DwState* 參數所指定之狀態有效位的遮罩。 指定 [清單視圖專案狀態](/windows/win32/Controls/list-view-item-states) (或) 的位組合。

### <a name="return-value"></a>傳回值

如果此方法成功，則為 TRUE;否則為 FALSE。

### <a name="remarks"></a>備註

如需 *dwState* 參數的詳細資訊，請參閱 [清單視圖專案狀態](/windows/win32/Controls/list-view-item-states)。

如需*dwMask*參數的詳細資訊，請參閱[LVITEM](/windows/win32/api/commctrl/ns-commctrl-lvitemw)結構的*stateMask*成員。

這個方法會傳送 [LVM_SETITEMINDEXSTATE](/windows/win32/Controls/lvm-setitemindexstate) 的訊息，如 Windows SDK 中所述。

## <a name="clistctrlsetitemposition"></a><a name="setitemposition"></a> CListCtrl：： SetItemPosition

將專案移至清單視圖控制項中的指定位置。

```
BOOL SetItemPosition(
    int nItem,
    POINT pt);
```

### <a name="parameters"></a>參數

*nItem*<br/>
要設定其位置之專案的索引。

*pt*<br/>
[點](/windows/win32/api/windef/ns-windef-point)結構，指定專案左上角的新位置（以視圖座標為單位）。

### <a name="return-value"></a>傳回值

如果成功則不為零，否則為 0。

### <a name="remarks"></a>備註

控制項必須在圖示或小型圖示視圖中。

如果清單視圖控制項有 LVS_AUTOARRANGE 樣式，則會在設定專案的位置之後排列清單視圖。

### <a name="example"></a>範例

請參閱 [CListCtrl：： GetItemPosition](#getitemposition)的範例。

## <a name="clistctrlsetitemstate"></a><a name="setitemstate"></a> CListCtrl：： SetItemState

變更清單視圖控制項中專案的狀態。

```
BOOL SetItemState(
    int nItem,
    LVITEM* pItem);

BOOL SetItemState(
    int nItem,
    UINT nState,
    UINT nMask);
```

### <a name="parameters"></a>參數

*nItem*<br/>
要設定其狀態之專案的索引。

*pItem*<br/>
[LVITEM](/windows/win32/api/commctrl/ns-commctrl-lvitemw)結構的位址，如 Windows SDK 所述。 結構的 `stateMask` 成員會指定要變更的狀態位，且結構的 `state` 成員會包含這些位的新值。 其他成員則會被忽略。

*nState*<br/>
狀態位的新值。 如需可能值的清單，請參閱 [CListCtrl：： GetNextItem](#getnextitem) 和 [LVITEM](/windows/win32/api/commctrl/ns-commctrl-lvitemw) 狀態成員。

*nMask*<br/>
指定要變更之狀態位的遮罩。 這個值會對應至 [LVITEM](/windows/win32/api/commctrl/ns-commctrl-lvitemw) 結構的 stateMask 成員。

### <a name="return-value"></a>傳回值

如果成功則不為零，否則為 0。

### <a name="remarks"></a>備註

專案的「狀態」是一個值，可指定專案的可用性、指出使用者動作，或是反映專案的狀態。 清單視圖控制項會變更某些狀態位，例如使用者選取專案時。 應用程式可能會變更其他狀態位，以停用或隱藏專案，或指定重迭影像或狀態影像。

### <a name="example"></a>範例

請參閱 [CListCtrl：： GetTopIndex](#gettopindex)的範例。

## <a name="clistctrlsetitemtext"></a><a name="setitemtext"></a> CListCtrl：： SetItemText

變更清單視圖專案或子專案的文字。

```
BOOL SetItemText(
    int nItem,
    int nSubItem,
    LPCTSTR lpszText);
```

### <a name="parameters"></a>參數

*nItem*<br/>
要設定其文字之專案的索引。

*nSubItem*<br/>
子專案的索引，或設定為零以設定專案標籤。

*lpszText*<br/>
包含新專案文字之字串的指標。

### <a name="return-value"></a>傳回值

如果成功則不為零，否則為 0。

### <a name="remarks"></a>備註

這個方法不適合搭配包含 LVS_OWNERDATA 視窗樣式的控制項使用 (事實上，這會導致) 的偵錯工具中出現判斷提示。 如需此清單控制項樣式的詳細資訊，請參閱 [清單視圖控制項總覽](/windows/win32/Controls/list-view-controls-overview)。

### <a name="example"></a>範例

請參閱 [CListCtrl：： InsertItem](#insertitem)的範例。

## <a name="clistctrlsetoutlinecolor"></a><a name="setoutlinecolor"></a> CListCtrl：： SetOutlineColor

設定清單視圖控制項框線的色彩（如果已設定 [LVS_EX_BORDERSELECT](/windows/win32/Controls/list-view-window-styles) 延伸視窗樣式）。

```
COLORREF SetOutlineColor(COLORREF color);
```

### <a name="parameters"></a>參數

*color*<br/>
包含外框色彩的新 [COLORREF](/windows/win32/gdi/colorref) 結構。

### <a name="return-value"></a>傳回值

`COLORREF`包含外框色彩的上一個結構

### <a name="remarks"></a>備註

此成員函式會模擬 [LVM_SETOUTLINECOLOR](/windows/win32/Controls/lvm-setoutlinecolor) 訊息的功能，如 Windows SDK 中所述。

## <a name="clistctrlsetselectedcolumn"></a><a name="setselectedcolumn"></a> CListCtrl：： SetSelectedColumn

設定清單視圖控制項的選定資料行。

```
LRESULT SetSelectedColumn(int iCol);
```

### <a name="parameters"></a>參數

*iCol*<br/>
要選取之資料行的索引。

### <a name="return-value"></a>傳回值

未使用傳回值。

### <a name="remarks"></a>備註

此成員函式會模擬 [LVM_SETSELECTEDCOLUMN](/windows/win32/Controls/lvm-setselectedcolumn) 訊息的功能，如 Windows SDK 中所述。

## <a name="clistctrlsetselectionmark"></a><a name="setselectionmark"></a> CListCtrl：： SetSelectionMark

設定清單視圖控制項的選取專案標記。

```
int SetSelectionMark(int iIndex);
```

### <a name="parameters"></a>參數

*iIndex*<br/>
多重選取範圍中第一個專案以零為起始的索引。

### <a name="return-value"></a>傳回值

先前的選取專案標記; 如果沒有選取專案標記，則為-1。

### <a name="remarks"></a>備註

此成員函式會依照 Windows SDK 所述，執行 Win32 宏 [ListView_SetSelectionMark](/windows/win32/api/commctrl/nf-commctrl-listview_setselectionmark)的行為。

### <a name="example"></a>範例

請參閱 [CListCtrl：： GetSelectionMark](#getselectionmark)的範例。

## <a name="clistctrlsettextbkcolor"></a><a name="settextbkcolor"></a> CListCtrl：： SetTextBkColor

設定清單視圖控制項中文字的背景色彩。

```
BOOL SetTextBkColor(COLORREF cr);
```

### <a name="parameters"></a>參數

*鉻*<br/>
COLORREF，指定新的文字背景色彩。 如需詳細資訊，請參閱 Windows SDK 中的 [COLORREF](/windows/win32/gdi/colorref) 。

### <a name="return-value"></a>傳回值

如果成功則不為零，否則為 0。

### <a name="example"></a>範例

```cpp
        // Use the 3D button face color for the background.
        COLORREF crBkColor = ::GetSysColor(COLOR_3DFACE);
        m_myListCtrl.SetTextBkColor(crBkColor);
        ASSERT(m_myListCtrl.GetTextBkColor() == crBkColor);
```

## <a name="clistctrlsettextcolor"></a><a name="settextcolor"></a> CListCtrl：： SetTextColor

設定清單視圖控制項的文字色彩。

```
BOOL SetTextColor(COLORREF cr);
```

### <a name="parameters"></a>參數

*鉻*<br/>
COLORREF，指定新的文字色彩。 如需詳細資訊，請參閱 Windows SDK 中的 [COLORREF](/windows/win32/gdi/colorref) 。

### <a name="return-value"></a>傳回值

如果成功則不為零，否則為 0。

### <a name="example"></a>範例

```cpp
    // Use the window text color for
    // the item text of the list view control.
    COLORREF crTextColor = ::GetSysColor(COLOR_WINDOWTEXT);
    m_myListCtrl.SetTextColor(crTextColor);
    ASSERT(m_myListCtrl.GetTextColor() == crTextColor);
```

## <a name="clistctrlsettileinfo"></a><a name="settileinfo"></a> CListCtrl：： SetTileInfo

設定清單視圖控制項圖格的資訊。

```
BOOL SetTileInfo(PLVTILEINFO pTileInfo);
```

### <a name="parameters"></a>參數

*pTileInfo*<br/>
[LVTILEINFO](/windows/win32/api/commctrl/ns-commctrl-lvtileinfo)結構的指標，其中包含要設定的資訊。

### <a name="return-value"></a>傳回值

成功時傳回 TRUE，失敗時傳回 FALSE。

### <a name="remarks"></a>備註

此成員函式會模擬 [LVM_SETTILEINFO](/windows/win32/Controls/lvm-settileinfo) 訊息的功能，如 Windows SDK 中所述。

## <a name="clistctrlsettileviewinfo"></a><a name="settileviewinfo"></a> CListCtrl：： SetTileViewInfo

設定清單視圖控制項在並排顯示中使用的資訊。

```
BOOL SetTileViewInfo(PLVTILEVIEWINFO ptvi);
```

### <a name="parameters"></a>參數

*ptvi*<br/>
[LVTILEVIEWINFO](/windows/win32/api/commctrl/ns-commctrl-lvtileviewinfo)結構的指標，其中包含要設定的資訊。

### <a name="return-value"></a>傳回值

成功時傳回 TRUE，失敗時傳回 FALSE。

### <a name="remarks"></a>備註

此成員函式會模擬 [LVM_SETTILEVIEWINFO](/windows/win32/Controls/lvm-settileviewinfo) 訊息的功能，如 Windows SDK 中所述。

## <a name="clistctrlsettooltips"></a><a name="settooltips"></a> CListCtrl：： SetToolTips

設定 [清單視圖] 控制項將用來顯示工具提示的工具提示控制項。

```
CToolTipCtrl* SetToolTips(CToolTipCtrl* pWndTip);
```

### <a name="parameters"></a>參數

*pWndTip*<br/>
`CToolTipCtrl`清單控制項將使用的物件指標。

### <a name="return-value"></a>傳回值

[CToolTipCtrl](ctooltipctrl-class.md)物件的指標，其中包含控制項先前使用的工具提示，如果先前未使用工具提示，則為 Null。

### <a name="remarks"></a>備註

此成員函式會依照 Windows SDK 所述，執行 Win32 訊息 [LVM_SETTOOLTIPS](/windows/win32/Controls/lvm-settooltips)的行為。

若不要使用工具提示，請在建立物件時指出 LVS_NOTOOLTIPS 的樣式 `CListCtrl` 。

## <a name="clistctrlsetview"></a><a name="setview"></a> CListCtrl：： SetView

設定清單視圖控制項的視圖。

```
DWORD SetView(int iView);
```

### <a name="parameters"></a>參數

*iView*<br/>
要選取的視圖。

### <a name="return-value"></a>傳回值

如果成功，則傳回1，否則傳回-1。 例如，如果視圖無效，則會傳回-1。

### <a name="remarks"></a>備註

此成員函式會模擬 [LVM_SETVIEW](/windows/win32/Controls/lvm-setview) 訊息的功能，如 Windows SDK 中所述。

## <a name="clistctrlsetworkareas"></a><a name="setworkareas"></a> CListCtrl：： SetWorkAreas

設定可在清單視圖控制項中顯示圖示的區域。

```cpp
void SetWorkAreas(
    int nWorkAreas,
    LPRECT lpRect);
```

### <a name="parameters"></a>參數

*nWorkAreas*<br/>
`RECT`在*lpRect*所指向的陣列中， (或[CRect](../../atl-mfc-shared/reference/crect-class.md)物件) 的結構數目。

*lpRect*<br/>
`RECT`結構陣列 (或物件的位址 `CRect` ，) 指定清單視圖控制項的新工作區。 這些區域必須以用戶端座標指定。 如果這個參數為 Null，工作區將會設定為控制項的工作區。

### <a name="remarks"></a>備註

此成員函式會依照 Windows SDK 所述，執行 Win32 宏 [ListView_SetWorkAreas](/windows/win32/api/commctrl/nf-commctrl-listview_setworkareas)的行為。

### <a name="example"></a>範例

```cpp
    // Remove all working areas.
    m_myListCtrl.SetWorkAreas(0, NULL);
```

## <a name="clistctrlsortgroups"></a><a name="sortgroups"></a> CListCtrl：： SortGroups

使用應用程式定義的比較函式，在清單視圖控制項內依識別碼排序群組。

```
BOOL SortGroups(
    PFNLVGROUPCOMPARE _pfnGroupCompare,
    LPVOID _plv);
```

### <a name="parameters"></a>參數

*_pfnGroupCompare*<br/>
群組比較函數的指標。

*_plv*<br/>
Void 指標。

### <a name="return-value"></a>傳回值

成功時傳回 TRUE，失敗時傳回 FALSE。

### <a name="remarks"></a>備註

此成員函式會模擬 [LVM_SORTGROUPS](/windows/win32/Controls/lvm-sortgroups) 訊息的功能，如 Windows SDK 中所述。

## <a name="clistctrlsortitems"></a><a name="sortitems"></a> CListCtrl：： SortItems

使用應用程式定義的比較函數排序清單視圖專案。

```
BOOL SortItems(
    PFNLVCOMPARE pfnCompare,
    DWORD_PTR dwData);
```

### <a name="parameters"></a>參數

*pfnCompare*<br/>
在應用程式定義的比較函式的位址。

排序作業會在每次需要判斷兩個清單專案的相對順序時，呼叫比較函數。 比較函式必須是類別的靜態成員，或是非任何類別成員的獨立函式。

*dwData*<br/>
在傳遞給比較函數的應用程式定義值。

### <a name="return-value"></a>傳回值

如果方法成功，則為 TRUE;否則為 FALSE。

### <a name="remarks"></a>備註

這個方法會變更每個專案的索引，以反映新的序列。

比較函數 *pfnCompare*具有下列形式：

```
int CALLBACK CompareFunc(LPARAM lParam1,
    LPARAM lParam2,
    LPARAM lParamSort);
```

如果第一個專案應該在第二個專案之前，比較函式必須傳回負值，如果第一個專案應接在第二個專案，則為正值，如果兩個專案相等，則為零。

*LParam1*參數是與比較的第一個專案相關聯的32位值，而*lParam2*參數則是與第二個專案相關聯的值。 這些值是在專案插入清單中時，在專案的[LVITEM](/windows/win32/api/commctrl/ns-commctrl-lvitemw)結構的*lParam*成員中指定的值。 *LParamSort*參數與*dwData*值相同。

這個方法會傳送 [LVM_SORTITEMS](/windows/win32/Controls/lvm-sortitems) 的訊息，如 Windows SDK 中所述。

### <a name="example"></a>範例

以下是簡單的比較函式，它會產生依其 *lParam* 值排序的專案。

```cpp
// Sort items by associated lParam
int CALLBACK CListCtrlDlg::MyCompareProc(LPARAM lParam1, LPARAM lParam2,
    LPARAM lParamSort)
{
    UNREFERENCED_PARAMETER(lParamSort);
    return (int)(lParam1 - lParam2);
}
```

```cpp
// Sort the items by passing in the comparison function.
void CListCtrlDlg::Sort()
{
    m_myListCtrl.SortItems(&CListCtrlDlg::MyCompareProc, 0);
}
```

## <a name="clistctrlsortitemsex"></a><a name="sortitemsex"></a> CListCtrl：： SortItemsEx

使用應用程式定義的比較函式，排序目前清單視圖控制項的專案。

```
BOOL SortItemsEx(
    PFNLVCOMPARE pfnCompare,
    DWORD_PTR dwData);
```

### <a name="parameters"></a>參數

*pfnCompare*\
在應用程式定義的比較函式的位址。 排序作業會在每次需要判斷兩個清單專案的相對順序時，呼叫比較函數。 比較函式必須是類別的靜態成員，或是非任何類別成員的獨立函式。

*dwData*\
在傳遞給比較函數的應用程式定義值。

### <a name="return-value"></a>傳回值

如果此方法成功，則為 TRUE;否則為 FALSE。

### <a name="remarks"></a>備註

這個方法會變更每個專案的索引，以反映新的序列。

比較函數 *pfnCompare*具有下列形式：

```
int CALLBACK CompareFunc(LPARAM lParam1,
    LPARAM lParam2,
    LPARAM lParamSort);
```

這則訊息類似 [LVM_SORTITEMS](/windows/win32/Controls/lvm-sortitems)，但傳遞給比較函數的資訊類型除外。 在 [LVM_SORTITEMS](/windows/win32/Controls/lvm-sortitems)中， *lParam1* 和 *lParam2* 是要比較之專案的值。 在 [LVM_SORTITEMSEX](/windows/win32/Controls/lvm-sortitemsex)中， *lParam1* 是第一個要比較的專案目前的索引，而 *lParam2* 是第二個專案的目前索引。 您可以傳送 [LVM_GETITEMTEXT](/windows/win32/Controls/lvm-getitemtext) 訊息來取得專案的詳細資訊。

如果第一個專案應該在第二個專案之前，比較函式必須傳回負值，如果第一個專案應接在第二個專案，則為正值，如果兩個專案相等，則為零。

> [!NOTE]
> 在排序過程中，清單視圖內容不穩定。 如果回呼函式將任何訊息傳送至 [LVM_GETITEM](/windows/win32/Controls/lvm-getitem)以外的清單視圖控制項，則結果為無法預期的結果。

這個方法會傳送 [LVM_SORTITEMSEX](/windows/win32/Controls/lvm-sortitemsex) 的訊息，如 Windows SDK 中所述。

### <a name="example"></a>範例

下列程式碼範例 `m_listCtrl` 會定義用來存取目前清單視圖控制項的變數。 下一個範例中會使用此變數。

```cpp
public:
    // Variable used to access the list control.
    CListCtrl m_listCtrl;
```

### <a name="example"></a>範例

下列程式碼範例會示範 `SortItemEx` 方法。 在此程式碼範例的先前章節中，我們建立了一個清單視圖控制項，它會在報表檢視中顯示標題為 "ClientID" 和 "年級" 的兩個數據行。 下列程式碼範例會使用「成績」資料行中的值來排序資料表。

```cpp
// The ListCompareFunc() method is a global function used by SortItemEx().
int CALLBACK ListCompareFunc(
                             LPARAM lParam1,
                             LPARAM lParam2,
                             LPARAM lParamSort)
{
    CListCtrl* pListCtrl = (CListCtrl*) lParamSort;
    CString    strItem1 = pListCtrl->GetItemText(static_cast<int>(lParam1), 1);
    CString    strItem2 = pListCtrl->GetItemText(static_cast<int>(lParam2), 1)
    int x1 = _tstoi(strItem1.GetBuffer());
    int x2 = _tstoi(strItem2.GetBuffer());
    int result = 0;
    if ((x1 - x2) < 0)
        result = -1;
    else if ((x1 - x2) == 0)
        result = 0;
    else
        result = 1;

    return result;
}

void CCListCtrl_s2Dlg::OnBnClickedButton1()
{
    // SortItemsEx
    m_listCtrl.SortItemsEx( ListCompareFunc, (LPARAM)&m_listCtrl );
}
```

## <a name="clistctrlsubitemhittest"></a><a name="subitemhittest"></a> CListCtrl：： SubItemHitTest

判斷哪一個清單視圖專案（如果有的話）位於指定的位置。

```
int SubItemHitTest(LPLVHITTESTINFO pInfo);
```

### <a name="parameters"></a>參數

*pInfo*<br/>
[LVHITTESTINFO](/windows/win32/api/commctrl/ns-commctrl-lvhittestinfo)結構的指標。

### <a name="return-value"></a>傳回值

如果有任何) ，則為所 (測試之專案或子專案的以一為起始的索引，否則為-1; 否則為-1。

### <a name="remarks"></a>備註

此成員函式會依照 Windows SDK 所述，執行 Win32 宏 [ListView_SubItemHitTest](/windows/win32/api/commctrl/nf-commctrl-listview_subitemhittest)的行為。

### <a name="example"></a>範例

```cpp
void CListCtrlDlg::OnDblClk(NMHDR* pNMHDR, LRESULT* pResult)
{
    UNREFERENCED_PARAMETER(pResult);
    LPNMITEMACTIVATE pia = (LPNMITEMACTIVATE)pNMHDR;
    LVHITTESTINFO lvhti;

    // Clear the subitem text the user clicked on.
    lvhti.pt = pia->ptAction;
    m_myListCtrl.SubItemHitTest(&lvhti);

    if (lvhti.flags & LVHT_ONITEMLABEL)
    {
        m_myListCtrl.SetItemText(lvhti.iItem, lvhti.iSubItem, NULL);
    }
}
```

## <a name="clistctrlupdate"></a><a name="update"></a> CListCtrl：： Update

強制清單視圖控制項重新繪製 *nItem*所指定的專案。

```
BOOL Update(int nItem);
```

### <a name="parameters"></a>參數

*nItem*<br/>
要更新之專案的索引。

### <a name="return-value"></a>傳回值

如果成功則不為零，否則為 0。

### <a name="remarks"></a>備註

如果有 LVS_AUTOARRANGE 的樣式，此函式也會排列清單視圖控制項。

### <a name="example"></a>範例

請參閱 [CListCtrl：： GetSelectedCount](#getselectedcount)的範例。

## <a name="see-also"></a>另請參閱

[MFC 範例 ROWLIST](../../overview/visual-cpp-samples.md)<br/>
[CWnd 類別](cwnd-class.md)<br/>
[階層架構圖表](../hierarchy-chart.md)<br/>
[CImageList 類別](cimagelist-class.md)
