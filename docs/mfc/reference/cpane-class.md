---
title: CPane Class
ms.date: 11/04/2016
f1_keywords:
- CPane
- AFXPANE/CPane
- AFXPANE/CPane::AdjustSizeImmediate
- AFXPANE/CPane::AllocElements
- AFXPANE/CPane::AllowShowOnPaneMenu
- AFXPANE/CPane::CalcAvailableSize
- AFXPANE/CPane::CalcInsideRect
- AFXPANE/CPane::CalcRecentDockedRect
- AFXPANE/CPane::CalcSize
- AFXPANE/CPane::CanBeDocked
- AFXPANE/CPane::CanBeTabbedDocument
- AFXPANE/CPane::ConvertToTabbedDocument
- AFXPANE/CPane::CopyState
- AFXPANE/CPane::Create
- AFXPANE/CPane::CreateDefaultMiniframe
- AFXPANE/CPane::CreateEx
- AFXPANE/CPane::DockByMouse
- AFXPANE/CPane::DockPane
- AFXPANE/CPane::DockPaneStandard
- AFXPANE/CPane::DockToFrameWindow
- AFXPANE/CPane::DoesAllowSiblingBars
- AFXPANE/CPane::FloatPane
- AFXPANE/CPane::GetAvailableExpandSize
- AFXPANE/CPane::GetAvailableStretchSize
- AFXPANE/CPane::GetBorders
- AFXPANE/CPane::GetClientHotSpot
- AFXPANE/CPane::GetDockSiteRow
- AFXPANE/CPane::GetExclusiveRowMode
- AFXPANE/CPane::GetHotSpot
- AFXPANE/CPane::GetMinSize
- AFXPANE/CPane::GetPaneName
- AFXPANE/CPane::GetVirtualRect
- AFXPANE/CPane::IsChangeState
- AFXPANE/CPane::IsDragMode
- AFXPANE/CPane::IsInFloatingMultiPaneFrameWnd
- AFXPANE/CPane::IsLeftOf
- AFXPANE/CPane::IsResizable
- AFXPANE/CPane::IsTabbed
- AFXPANE/CPane::LoadState
- AFXPANE/CPane::MoveByAlignment
- AFXPANE/CPane::MovePane
- AFXPANE/CPane::OnAfterChangeParent
- AFXPANE/CPane::OnBeforeChangeParent
- AFXPANE/CPane::OnPressCloseButton
- AFXPANE/CPane::OnShowControlBarMenu
- AFXPANE/CPane::RecalcLayout
- AFXPANE/CPane::SaveState
- AFXPANE/CPane::SetActiveInGroup
- AFXPANE/CPane::SetBorders
- AFXPANE/CPane::SetClientHotSpot
- AFXPANE/CPane::SetDockState
- AFXPANE/CPane::SetExclusiveRowMode
- AFXPANE/CPane::SetMiniFrameRTC
- AFXPANE/CPane::SetMinSize
- AFXPANE/CPane::SetVirtualRect
- AFXPANE/CPane::StretchPaneDeferWndPos
- AFXPANE/CPane::ToggleAutoHide
- AFXPANE/CPane::UndockPane
- AFXPANE/CPane::UpdateVirtualRect
- AFXPANE/CPane::OnAfterDock
- AFXPANE/CPane::OnAfterFloat
- AFXPANE/CPane::OnBeforeDock
- AFXPANE/CPane::OnBeforeFloat
- AFXPANE/CPane::m_bHandleMinSize
- AFXPANE/CPane::m_recentDockInfo
helpviewer_keywords:
- CPane [MFC], AdjustSizeImmediate
- CPane [MFC], AllocElements
- CPane [MFC], AllowShowOnPaneMenu
- CPane [MFC], CalcAvailableSize
- CPane [MFC], CalcInsideRect
- CPane [MFC], CalcRecentDockedRect
- CPane [MFC], CalcSize
- CPane [MFC], CanBeDocked
- CPane [MFC], CanBeTabbedDocument
- CPane [MFC], ConvertToTabbedDocument
- CPane [MFC], CopyState
- CPane [MFC], Create
- CPane [MFC], CreateDefaultMiniframe
- CPane [MFC], CreateEx
- CPane [MFC], DockByMouse
- CPane [MFC], DockPane
- CPane [MFC], DockPaneStandard
- CPane [MFC], DockToFrameWindow
- CPane [MFC], DoesAllowSiblingBars
- CPane [MFC], FloatPane
- CPane [MFC], GetAvailableExpandSize
- CPane [MFC], GetAvailableStretchSize
- CPane [MFC], GetBorders
- CPane [MFC], GetClientHotSpot
- CPane [MFC], GetDockSiteRow
- CPane [MFC], GetExclusiveRowMode
- CPane [MFC], GetHotSpot
- CPane [MFC], GetMinSize
- CPane [MFC], GetPaneName
- CPane [MFC], GetVirtualRect
- CPane [MFC], IsChangeState
- CPane [MFC], IsDragMode
- CPane [MFC], IsInFloatingMultiPaneFrameWnd
- CPane [MFC], IsLeftOf
- CPane [MFC], IsResizable
- CPane [MFC], IsTabbed
- CPane [MFC], LoadState
- CPane [MFC], MoveByAlignment
- CPane [MFC], MovePane
- CPane [MFC], OnAfterChangeParent
- CPane [MFC], OnBeforeChangeParent
- CPane [MFC], OnPressCloseButton
- CPane [MFC], OnShowControlBarMenu
- CPane [MFC], OnShowControlBarMenu
- CPane [MFC], RecalcLayout
- CPane [MFC], SaveState
- CPane [MFC], SetActiveInGroup
- CPane [MFC], SetBorders
- CPane [MFC], SetClientHotSpot
- CPane [MFC], SetDockState
- CPane [MFC], SetExclusiveRowMode
- CPane [MFC], SetMiniFrameRTC
- CPane [MFC], SetMinSize
- CPane [MFC], SetVirtualRect
- CPane [MFC], StretchPaneDeferWndPos
- CPane [MFC], ToggleAutoHide
- CPane [MFC], UndockPane
- CPane [MFC], UpdateVirtualRect
- CPane [MFC], OnAfterDock
- CPane [MFC], OnAfterFloat
- CPane [MFC], OnBeforeDock
- CPane [MFC], OnBeforeFloat
- CPane [MFC], m_bHandleMinSize
- CPane [MFC], m_recentDockInfo
ms.assetid: 5c651a64-3c79-4d94-9676-45f6402a6bc5
ms.openlocfilehash: 9d6a408b6ed7e7ab6f3dd138a4222b262978fd6c
ms.sourcegitcommit: 3e8fa01f323bc5043a48a0c18b855d38af3648d4
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 03/06/2020
ms.locfileid: "78883915"
---
# <a name="cpane-class"></a>CPane Class

`CPane` 類別是[CControlBar 類別](../../mfc/reference/ccontrolbar-class.md)的增強功能。 如果您要升級現有的 MFC 專案，請將所有出現的 `CControlBar` 取代為 `CPane`。

## <a name="syntax"></a>語法

```
class CPane : public CBasePane
```

## <a name="members"></a>成員

### <a name="public-constructors"></a>公用建構函式

|名稱|描述|
|----------|-----------------|
|`CPane::~CPane`|解構函式。|

### <a name="public-methods"></a>公用方法

|名稱|描述|
|----------|-----------------|
|[CPane：： AdjustSizeImmediate](#adjustsizeimmediate)|立即重新計算窗格的版面配置。|
|[CPane：： AllocElements](#allocelements)|配置用於內部使用的儲存體。|
|[CPane：： AllowShowOnPaneMenu](#allowshowonpanemenu)|指定窗格是否列在應用程式的執行時間產生的窗格清單中。|
|[CPane：： CalcAvailableSize](#calcavailablesize)|計算指定之矩形和目前視窗矩形的大小差異。|
|[CPane：： CalcInsideRect](#calcinsiderect)|計算窗格的內矩形，並將邊界和 grippers 納入考慮。|
|[CPane：： CalcRecentDockedRect](#calcrecentdockedrect)|計算最近的固定矩形。|
|[CPane：： CalcSize](#calcsize)|計算窗格的大小。|
|[CPane：： CanBeDocked](#canbedocked)|決定窗格是否可以停駐在指定的基底窗格。|
|[CPane：： CanBeTabbedDocument](#canbetabbeddocument)|決定窗格是否可以轉換成索引標籤式檔。|
|[CPane：： ConvertToTabbedDocument](#converttotabbeddocument)|將可停駐的窗格轉換成索引標籤式檔。|
|[CPane：： CopyState](#copystate)|複製窗格的狀態。 （覆寫[CBasePane：： CopyState](../../mfc/reference/cbasepane-class.md#copystate)。）|
|[CPane：： Create](#create)|建立控制列，並將它附加至 `CPane` 物件。|
|[CPane：： CreateDefaultMiniframe](#createdefaultminiframe)|建立浮動窗格的迷你框架視窗。|
|[CPane：： CreateEx](#createex)|建立控制列，並將它附加至 `CPane` 物件。|
|`CPane::CreateObject`|由建立此類別類型的動態執行個體架構所使用。|
|[CPane：:D ockByMouse](#dockbymouse)|使用滑鼠停駐方法來停駐窗格。|
|[CPane：:D ockPane](#dockpane)|將浮動窗格停駐于基底窗格。|
|[CPane：:D ockPaneStandard](#dockpanestandard)|使用大綱（標準）銜接停駐窗格。|
|[CPane：:D ockToFrameWindow](#docktoframewindow)|將可停駐的窗格停駐在框架上。 (覆寫 `CBasePane::DockToFrameWindow`)。|
|[CPane：:D oesAllowSiblingBars](#doesallowsiblingbars)|指出您是否可以將另一個窗格固定在目前窗格停駐所在的相同資料列上。|
|[CPane：： FloatPane](#floatpane)|將窗格浮動。|
|[CPane：： GetAvailableExpandSize](#getavailableexpandsize)|傳回窗格可以展開的量（以圖元為單位）。|
|[CPane：： GetAvailableStretchSize](#getavailablestretchsize)|傳回窗格可以縮小的量（以圖元為單位）。|
|[CPane：：可以 getborders 擷取](#getborders)|傳回窗格框線的寬度。|
|[CPane：： GetClientHotSpot](#getclienthotspot)|傳回窗格的*作用點*。|
|[CPane：： GetDockSiteRow](#getdocksiterow)|傳回停駐窗格的固定資料列。|
|[CPane：： GetExclusiveRowMode](#getexclusiverowmode)|判斷窗格是否為獨佔資料列模式。|
|[CPane：： GetHotSpot](#gethotspot)|傳回儲存在基礎 `CMFCDragFrameImpl` 物件中的作用點。|
|[CPane：： GetMinSize](#getminsize)|抓取窗格所允許的最小大小。|
|[CPane：： GetPaneName](#getpanename)|抓取窗格的標題。|
|`CPane::GetResizeStep`|內部使用。|
|`CPane::GetThisClass`|供架構用來取得與這個類別類型相關聯之[CRuntimeClass](../../mfc/reference/cruntimeclass-structure.md)物件的指標。|
|[CPane：： GetVirtualRect](#getvirtualrect)|抓取窗格的*虛擬矩形*。|
|[CPane：： IsChangeState](#ischangestate)|當移動窗格時，這個方法會分析窗格相對於其他窗格、停駐列和迷你框架視窗的位置，並傳回適當的 AFX_CS_STATUS 值。|
|[CPane：： IsDragMode](#isdragmode)|指定是否正在拖曳窗格。|
|[CPane：： IsInFloatingMultiPaneFrameWnd](#isinfloatingmultipaneframewnd)|指定窗格是否在多窗格框架視窗中。 (覆寫 `CBasePane::IsInFloatingMultiPaneFrameWnd`)。|
|[CPane：： IsLeftOf](#isleftof)|判斷窗格是否停留在指定的矩形中（或以上）。|
|[CPane：： IsResizable](#isresizable)|決定是否可以調整窗格的大小。 （覆寫[CBasePane：： IsResizable](../../mfc/reference/cbasepane-class.md#isresizable)。）|
|[CPane：： IsTabbed](#istabbed)|決定窗格是否已插入索引標籤式視窗的索引標籤控制項中。 （覆寫[CBasePane：： IsTabbed](../../mfc/reference/cbasepane-class.md#istabbed)。）|
|[CPane：： LoadState](#loadstate)|從登錄載入窗格的狀態。 （覆寫[CBasePane：： LoadState](../../mfc/reference/cbasepane-class.md#loadstate)。）|
|[CPane：： MoveByAlignment](#movebyalignment)|依據指定的數量移動窗格和虛擬矩形。|
|[CPane：： MovePane](#movepane)|將窗格移至指定的矩形。|
|[CPane：： OnAfterChangeParent](#onafterchangeparent)|當窗格的父系已變更時由架構呼叫。|
|[CPane：： OnBeforeChangeParent](#onbeforechangeparent)|當窗格的父系即將變更時由架構呼叫。|
|[CPane：： OnPressCloseButton](#onpressclosebutton)|當使用者在窗格的標題上選擇 [關閉] 按鈕時由架構呼叫。|
|`CPane::OnProcessDblClk`|內部使用。|
|[CPane：： OnShowControlBarMenu](#onshowcontrolbarmenu)|當特殊窗格功能表即將顯示時由架構呼叫。|
|[CPane：： OnShowControlBarMenu](#onshowcontrolbarmenu)|當特殊窗格功能表即將顯示時由架構呼叫。|
|`CPane::PrepareToDock`|內部使用。|
|[CPane：： RecalcLayout](#recalclayout)|重新計算窗格的版面配置資訊。 （覆寫[CBasePane：： RecalcLayout](../../mfc/reference/cbasepane-class.md#recalclayout)。）|
|[CPane：： SaveState](#savestate)|將窗格的狀態儲存至登錄。 （覆寫[CBasePane：： SaveState](../../mfc/reference/cbasepane-class.md#savestate)。）|
|[CPane：： SetActiveInGroup](#setactiveingroup)|將窗格標示為使用中。|
|[CPane：： SetBorders](#setborders)|設定窗格的框線值。|
|[CPane：： SetClientHotSpot](#setclienthotspot)|設定窗格的作用點。|
|[CPane：： SetDockState](#setdockstate)|還原窗格的銜接狀態資訊。|
|[CPane：： SetExclusiveRowMode](#setexclusiverowmode)|啟用或停用獨佔資料列模式。|
|[CPane：： SetMiniFrameRTC](#setminiframertc)|設定預設迷你框架視窗的執行時間類別資訊。|
|[CPane：： SetMinSize](#setminsize)|設定窗格所允許的最小大小。|
|[CPane：： SetVirtualRect](#setvirtualrect)|設定窗格的*虛擬矩形*。|
|[CPane：： StretchPaneDeferWndPos](#stretchpanedeferwndpos)|根據停駐樣式，垂直或水準擴充窗格。|
|[CPane：： ToggleAutoHide](#toggleautohide)|切換自動隱藏模式。|
|[CPane：： UndockPane](#undockpane)|從 dock 網站、預設滑杆或迷你框架視窗中移除該窗格，其目前為停駐位置。 （覆寫[CBasePane：： UndockPane](../../mfc/reference/cbasepane-class.md#undockpane)。）|
|[CPane：： UpdateVirtualRect](#updatevirtualrect)|更新虛擬矩形。|

### <a name="protected-methods"></a>受保護的方法

|名稱|描述|
|----------|-----------------|
|[CPane：： OnAfterDock](#onafterdock)|當窗格已停駐時由架構呼叫。|
|[CPane：： OnAfterFloat](#onafterfloat)|當窗格已浮動時由架構呼叫。|
|[CPane：： OnBeforeDock](#onbeforedock)|當窗格即將停駐時由架構呼叫。|
|[CPane：： OnBeforeFloat](#onbeforefloat)|當窗格即將浮動時，由架構呼叫。|

### <a name="data-members"></a>資料成員

|名稱|描述|
|----------|-----------------|
|[CPane：： m_bHandleMinSize](#m_bhandleminsize)|能夠一致地處理窗格的最小大小。|
|[CPane：： m_recentDockInfo](#m_recentdockinfo)|包含最近的銜接資訊。|

## <a name="remarks"></a>備註

一般來說，`CPane` 物件不會直接具現化。 如果您需要具有銜接功能的窗格，請從[CDockablePane](../../mfc/reference/cdockablepane-class.md)衍生您的物件。 如果您需要工具列功能，請從[CMFCToolBar](../../mfc/reference/cmfctoolbar-class.md)衍生您的物件。

當您從 `CPane`衍生類別時，它可以停駐在[CDockSite](../../mfc/reference/cdocksite-class.md)中，而且可以在[CPaneFrameWnd](../../mfc/reference/cpaneframewnd-class.md)中浮動。

## <a name="inheritance-hierarchy"></a>繼承階層

[CObject](../../mfc/reference/cobject-class.md)

[CCmdTarget](../../mfc/reference/ccmdtarget-class.md)

[CWnd](../../mfc/reference/cwnd-class.md)

[CBasePane](../../mfc/reference/cbasepane-class.md)

[CPane](../../mfc/reference/cpane-class.md)

## <a name="requirements"></a>需求

**標頭：** afxPane。h

##  <a name="adjustsizeimmediate"></a>CPane：： AdjustSizeImmediate

立即重新計算窗格的版面配置。

```
virtual void AdjustSizeImmediate(BOOL bRecalcLayout = TRUE);
```

### <a name="parameters"></a>參數

*bRecalcLayout*<br/>
在TRUE 表示自動重新計算窗格的版面配置;否則為 FALSE。

### <a name="remarks"></a>備註

當您動態變更窗格的版面配置時，請呼叫這個方法。 例如，您可能會想要在隱藏或顯示工具列按鈕時呼叫這個方法。

##  <a name="allocelements"></a>CPane：： AllocElements

配置用於內部使用的儲存體。

```
BOOL AllocElements(
    int nElements,
    int cbElement);
```

### <a name="parameters"></a>參數

*nElements*<br/>
在要配置儲存區的元素數目。

*cbElement*<br/>
在元素的大小（以位元組為單位）。

### <a name="return-value"></a>傳回值

如果記憶體配置失敗，則為 FALSE;否則為 TRUE。

##  <a name="allowshowonpanemenu"></a>CPane：： AllowShowOnPaneMenu

指定窗格是否列在應用程式的執行時間產生的窗格清單中。

```
virtual BOOL AllowShowOnPaneMenu() const;
```

### <a name="return-value"></a>傳回值

如果窗格顯示在清單中，則為 TRUE;否則為 FALSE。 基底的執行一律會傳回 TRUE。

### <a name="remarks"></a>備註

應用程式產生的應用程式包含一個功能表選項，其中列出它所包含的窗格。 這個方法會決定窗格是否顯示在清單中。

##  <a name="calcavailablesize"></a>CPane：： CalcAvailableSize

計算指定之矩形和目前視窗矩形的大小差異。

```
virtual CSize CalcAvailableSize(CRect rectRequired);
```

### <a name="parameters"></a>參數

*rectRequired*<br/>
在必要的矩形。

### <a name="return-value"></a>傳回值

*RectRequired*與目前視窗矩形之間的寬度和高度差異。

##  <a name="calcinsiderect"></a>CPane：： CalcInsideRect

計算窗格的內矩形，包括框線和 grippers。

```
void CalcInsideRect(
    CRect& rect,
    BOOL bHorz) const;
```

### <a name="parameters"></a>參數

*各種*<br/>
脫銷包含窗格中工作區的大小和位移。

*bHorz*<br/>
在如果窗格是水準方向，則為 TRUE;否則為 FALSE。

### <a name="remarks"></a>備註

當此方法必須重新計算窗格的版面配置時，會由架構呼叫。 *Rect*參數會填入窗格中工作區的大小和位移。 這包括其邊界和 grippers。

##  <a name="calcrecentdockedrect"></a>CPane：： CalcRecentDockedRect

計算最近的固定矩形。

```
void CalcRecentDockedRect();
```

### <a name="remarks"></a>備註

這個方法會更新[CPane：： m_recentDockInfo](#m_recentdockinfo)。

##  <a name="calcsize"></a>CPane：： CalcSize

計算窗格的大小。

```
virtual CSize CalcSize(BOOL bVertDock);
```

### <a name="parameters"></a>參數

*bVertDock*<br/>
在如果窗格已垂直停駐，則為 TRUE，否則為 FALSE。

### <a name="return-value"></a>傳回值

這個方法的預設實值會傳回（0，0）的大小。

### <a name="remarks"></a>備註

衍生類別應該覆寫這個方法。

##  <a name="canbedocked"></a>CPane：： CanBeDocked

決定窗格是否可以停駐在指定的基底窗格。

```
virtual BOOL CanBeDocked(CBasePane* pDockBar) const;
```

### <a name="parameters"></a>參數

*pDockBar*<br/>
在指定要停駐此窗格的窗格。

### <a name="return-value"></a>傳回值

若此窗格可停駐于指定的停駐窗格，則為 TRUE;否則為 FALSE。

### <a name="remarks"></a>備註

這個方法通常會由架構呼叫，以判斷窗格是否可以停駐于指定的停駐窗格。 若要判斷窗格是否可以停駐，方法會評估窗格目前已啟用的停駐對齊。

您可以藉由呼叫[CBasePane：： EnableDocking](../../mfc/reference/cbasepane-class.md#enabledocking)，讓停駐在框架視窗的各個邊。

##  <a name="canbetabbeddocument"></a>CPane：： CanBeTabbedDocument

決定窗格是否可以轉換成索引標籤式檔。

```
virtual BOOL CanBeTabbedDocument() const;
```

### <a name="return-value"></a>傳回值

如果窗格可以轉換成索引標籤式檔，則為 TRUE;否則為 FALSE。

### <a name="remarks"></a>備註

覆寫衍生類別中的這個方法，如果您想要防止窗格轉換成索引標籤式檔，則傳回 FALSE。 索引標籤式檔不會列在 [視窗位置] 功能表中。

##  <a name="converttotabbeddocument"></a>CPane：： ConvertToTabbedDocument

將可停駐的窗格轉換成索引標籤式檔。

```
virtual void ConvertToTabbedDocument(BOOL bActiveTabOnly = TRUE);
```

### <a name="parameters"></a>參數

*bActiveTabOnly*<br/>
在未在 `CPane::ConvertToTabbedDocument`中使用。

### <a name="remarks"></a>備註

只有可停駐的窗格可以轉換成索引標籤式檔。 如需相關資訊，請參閱[CDockablePane：： ConvertToTabbedDocument](../../mfc/reference/cdockablepane-class.md#converttotabbeddocument)。

##  <a name="copystate"></a>CPane：： CopyState

複製窗格的狀態。

```
virtual void CopyState(CPane* pOrgBar);
```

### <a name="parameters"></a>參數

*pOrgBar*<br/>
在窗格的指標。

### <a name="remarks"></a>備註

這個方法會將*pOrgBar*的狀態複製到目前的窗格。

##  <a name="create"></a>CPane：： Create

建立控制列，並將它附加至[CPane](../../mfc/reference/cpane-class.md)物件。

```
virtual BOOL Create(
    LPCTSTR lpszClassName,
    DWORD dwStyle,
    const RECT& rect,
    CWnd* pParentWnd,
    UINT nID,
    DWORD dwControlBarStyle = AFX_DEFAULT_PANE_STYLE,
    CCreateContext* pContext = NULL);
```

### <a name="parameters"></a>參數

*lpszClassName*<br/>
在指定 Windows 類別的名稱。

*dwStyle*<br/>
在指定視窗樣式屬性。 如需詳細資訊，請參閱[視窗樣式](../../mfc/reference/styles-used-by-mfc.md#window-styles)。

*各種*<br/>
在指定*pParentWnd*視窗的初始大小和位置（以工作區座標表示）。

*pParentWnd*<br/>
[in、out]指定此窗格的父視窗。

*nID*<br/>
在指定窗格的識別碼。

*dwControlBarStyle*<br/>
在指定窗格的樣式。 如需詳細資訊，請參閱[CBasePane：： CreateEx](../../mfc/reference/cbasepane-class.md#createex)。

*pContext*<br/>
[in、out]指定窗格的建立內容。

### <a name="return-value"></a>傳回值

如果已成功建立窗格，則為 TRUE;否則為 FALSE。

### <a name="remarks"></a>備註

這個方法會建立 Windows 窗格，並將它附加至 `CPane` 物件。

如果您在呼叫 `Create`之前尚未明確初始化[CPane：： m_recentDockInfo](#m_recentdockinfo) ，則在將窗格浮動或停駐時，會使用參數*rect*作為矩形。

##  <a name="createdefaultminiframe"></a>CPane：： CreateDefaultMiniframe

建立浮動窗格的迷你框架視窗。

```
virtual CPaneFrameWnd* CreateDefaultMiniframe(CRect rectInitial);
```

### <a name="parameters"></a>參數

*rectInitial*<br/>
在指定要建立之迷你框架視窗的初始大小和位置（以螢幕座標為單位）。

### <a name="return-value"></a>傳回值

新建立的迷你框架視窗。

### <a name="remarks"></a>備註

這個方法是由架構呼叫，在窗格浮動時建立迷你框架視窗。 迷你框架視窗的類型可以是[CPaneFrameWnd](../../mfc/reference/cpaneframewnd-class.md)或類型為[CMultiPaneFrameWnd](../../mfc/reference/cmultipaneframewnd-class.md)。 如果窗格具有 AFX_CBRS_FLOAT_MULTI 樣式，則會建立多個迷你框架視窗。

迷你框架視窗的執行時間類別資訊會儲存在 `CPane::m_pMiniFrameRTC` 成員中。 如果您決定要建立自訂的迷你框架視窗，您可以使用衍生類別來設定這個成員。

##  <a name="createex"></a>CPane：： CreateEx

建立控制列，並將它附加至[CPane](../../mfc/reference/cpane-class.md)物件。

```
virtual BOOL CreateEx(
    DWORD dwStyleEx,
    LPCTSTR lpszClassName,
    DWORD dwStyle,
    const RECT& rect,
    CWnd* pParentWnd,
    UINT nID,
    DWORD dwControlBarStyle = AFX_DEFAULT_PANE_STYLE,
    CCreateContext* pContext = NULL);
```

### <a name="parameters"></a>參數

*dwStyleEx*<br/>
在指定擴充的視窗樣式屬性。 如需詳細資訊，請參閱[擴充的視窗樣式](../../mfc/reference/styles-used-by-mfc.md#extended-window-styles)。

*lpszClassName*<br/>
在指定 Windows 類別的名稱。

*dwStyle*<br/>
在指定視窗樣式屬性。 如需詳細資訊，請參閱[視窗樣式](../../mfc/reference/styles-used-by-mfc.md#window-styles)。

*各種*<br/>
在指定*pParentWnd*視窗的初始大小和位置（以工作區座標表示）。

*pParentWnd*<br/>
[in、out]指定此窗格的父視窗。

*nID*<br/>
在指定窗格的識別碼。

*dwControlBarStyle*<br/>
在指定窗格的樣式。 如需詳細資訊，請參閱[CBasePane：： CreateEx](../../mfc/reference/cbasepane-class.md#createex)。

*pContext*<br/>
[in、out]指定窗格的建立內容。

### <a name="return-value"></a>傳回值

如果已成功建立窗格，則為 TRUE;否則為 FALSE。

### <a name="remarks"></a>備註

這個方法會建立 Windows 窗格，並將它附加至 `CPane` 物件。

如果您在呼叫 `CreateEx`之前尚未明確初始化[CPane：： m_recentDockInfo](#m_recentdockinfo) ，則在將窗格浮動或停駐時，會使用參數*rect*作為矩形。

##  <a name="dockbymouse"></a>CPane：:D ockByMouse

使用滑鼠停駐窗格。

```
virtual BOOL DockByMouse(CBasePane* pDockBar);
```

### <a name="parameters"></a>參數

*pDockBar*<br/>
在指定要停駐此窗格的基底窗格。

### <a name="return-value"></a>傳回值

如果已成功停駐窗格，則為 TRUE;否則為 FALSE。

##  <a name="dockpane"></a>CPane：:D ockPane

將浮動窗格停駐于基底窗格。

```
virtual BOOL DockPane(
    CBasePane* pDockBar,
    LPCRECT lpRect,
    AFX_DOCK_METHOD dockMethod);
```

### <a name="parameters"></a>參數

*pDockBar*<br/>
[in、out]指定要將此窗格停駐的基底窗格。

*lpRect*<br/>
在指定基底窗格上要停駐此窗格的矩形。

*dockMethod*<br/>
在指定要使用的銜接方法。 可用的選項如下：

|選項|描述|
|------------|-----------------|
|DM_UNKNOWN|當停駐方法不明時，此架構會使用此選項。 窗格不會儲存其最近的浮動位置。 當您不需要儲存最近的浮動位置時，您也可以使用這個選項，以程式設計方式停駐窗格。|
|DM_MOUSE|內部使用。|
|DM_DBL_CLICK|此選項是在按兩下控制項時使用。 窗格會重新置放在其最近的銜接位置。 如果按兩下滑鼠停駐窗格，則窗格會重新置放在其最近的浮動位置。|
|DM_SHOW|這個選項可以用來以程式設計方式停駐窗格。 窗格會儲存其最新的浮動位置。|
|DM_RECT|窗格會停駐在*lpRect*所指定的區域中。|
|DM_STANDARD|當您使用此選項時，架構會在移動時將窗格繪製為外框框架。|

### <a name="return-value"></a>傳回值

如果已成功停駐窗格，則為 TRUE;否則為 FALSE。

### <a name="remarks"></a>備註

這個方法會將窗格停駐在*pDockBar*參數所指定的基底窗格。 您必須先呼叫[CBasePane：： EnableDocking](../../mfc/reference/cbasepane-class.md#enabledocking)來啟用銜接。

##  <a name="dockpanestandard"></a>CPane：:D ockPaneStandard

使用大綱（標準）銜接停駐窗格。

```
virtual CPane* DockPaneStandard(BOOL& bWasDocked);
```

### <a name="parameters"></a>參數

*bWasDocked*<br/>
在如果已成功停駐窗格，則為 TRUE;否則為 FALSE。

### <a name="return-value"></a>傳回值

這個方法一律會傳回**this**指標。

### <a name="remarks"></a>備註

這個方法只會用於衍生自[CDockablePane 類別](../../mfc/reference/cdockablepane-class.md)的窗格。 如需詳細資訊，請參閱[CDockablePane：:D ockpanestandard](../../mfc/reference/cdockablepane-class.md#dockpanestandard)。

##  <a name="docktoframewindow"></a>CPane：:D ockToFrameWindow

將可停駐的窗格停駐在框架上。

```
virtual BOOL DockToFrameWindow(
    DWORD dwAlignment,
    LPCRECT lpRect = NULL,
    DWORD dwDockFlags = DT_DOCK_LAST,
    CBasePane* pRelativeBar = NULL,
    int nRelativeIndex = -1,
    BOOL bOuterEdge = FALSE);
```

### <a name="parameters"></a>參數

*dwAlignment*<br/>
在您想要將窗格停駐到的父框架側邊。

*lpRect*<br/>
在指定的大小。

*dwDockFlags*<br/>
在忽略.

*pRelativeBar*<br/>
在忽略.

*nRelativeIndex*<br/>
在忽略.

*bOuterEdge*<br/>
在若為 TRUE，而且*dwAlignment*所指定的旁邊還有其他可停駐的窗格，則窗格會停駐在其他窗格之外，靠近父框架的邊緣。 如果為 FALSE，則窗格會停駐在靠近工作區的中央。

### <a name="return-value"></a>傳回值

如果無法建立窗格分隔線（ [CPaneDivider 類別](../../mfc/reference/cpanedivider-class.md)），則為 FALSE;否則為 TRUE。

### <a name="remarks"></a>備註

##  <a name="doesallowsiblingbars"></a>CPane：:D oesAllowSiblingBars

指出您是否可以將另一個窗格固定在目前窗格停駐所在的相同資料列上。

```
virtual BOOL DoesAllowSiblingBars() const;
```

### <a name="return-value"></a>傳回值

如果這個窗格可以停駐在相同資料列上的另一個窗格，則為 TRUE;否則為 FALSE。

### <a name="remarks"></a>備註

您可以藉由呼叫[CPane：： SetExclusiveRowMode](#setexclusiverowmode)來啟用或停用此行為。

根據預設，工具列會停用獨佔資料列模式，而且功能表列已啟用獨佔資料列模式。

##  <a name="floatpane"></a>CPane：： FloatPane

將窗格浮動。

```
virtual BOOL FloatPane(
    CRect rectFloat,
    AFX_DOCK_METHOD dockMethod = DM_UNKNOWN,
    bool bShow = true);
```

### <a name="parameters"></a>參數

*rectFloat*<br/>
在指定位置（以螢幕座標表示），以在視窗浮動時定位。

*dockMethod*<br/>
在指定當窗格浮動時要使用的銜接方法。 如需可能值的清單，請參閱[CPane：:D ockpane](#dockpane)。

*bShow*<br/>
在TRUE 表示在浮動時顯示窗格;否則為 FALSE。

### <a name="return-value"></a>傳回值

如果窗格已成功浮動或無法浮動窗格，則為 TRUE，因為[CBasePane：： CanFloat](../../mfc/reference/cbasepane-class.md#canfloat)會傳回 FALSE;否則為 FALSE。

### <a name="remarks"></a>備註

呼叫這個方法，將窗格浮動在*rectFloat*參數所指定的位置。 這個方法會自動建立窗格的父迷你框架視窗。

##  <a name="getavailableexpandsize"></a>CPane：： GetAvailableExpandSize

傳回窗格可以展開的量（以圖元為單位）。

```
virtual int GetAvailableExpandSize() const;
```

### <a name="return-value"></a>傳回值

如果窗格是以水準方式停駐，則傳回值會是可用的寬度。否則，傳回值就是可用的高度。

### <a name="remarks"></a>備註

##  <a name="getavailablestretchsize"></a>CPane：： GetAvailableStretchSize

傳回窗格可以縮小的量（以圖元為單位）。

```
virtual int GetAvailableStretchSize() const;
```

### <a name="return-value"></a>傳回值

窗格可以縮小的數量（以圖元為單位）。 如果窗格是以水準方式停駐，此數量就是可用的寬度;否則，它是可用的高度。

### <a name="remarks"></a>備註

可用的延展大小計算方式是從目前的大小減去窗格（ [CPane：： GetMinSize](#getminsize)）的最小允許大小（ [CWnd：： GetWindowRect](../../mfc/reference/cwnd-class.md#getwindowrect)）。

##  <a name="getborders"></a>CPane：：可以 getborders 擷取

傳回窗格框線的寬度。

```
CRect GetBorders() const;
```

### <a name="return-value"></a>傳回值

[CRect](../../atl-mfc-shared/reference/crect-class.md)物件，包含窗格每一邊的目前寬度（以圖元為單位）。 例如，`CRect` 物件之 `left` 成員的值就是左邊框的寬度。

### <a name="remarks"></a>備註

若要設定框線的大小，請呼叫[CPane：： SetBorders](#setborders)。

##  <a name="getclienthotspot"></a>CPane：： GetClientHotSpot

傳回窗格的*作用點*。

```
CPoint GetClientHotSpot() const;
```

### <a name="return-value"></a>傳回值

### <a name="remarks"></a>備註

*作用*點是使用者選取並保留以移動窗格的窗格上的點。 當窗格從停駐的位置移動時，作用點會用於平滑動畫。

##  <a name="getdocksiterow"></a>CPane：： GetDockSiteRow

傳回停駐窗格的固定資料列（ [CDockingPanesRow 類別](../../mfc/reference/cdockingpanesrow-class.md)）。

```
CDockingPanesRow* GetDockSiteRow() const;
```

### <a name="return-value"></a>傳回值

`CDockingPanesRow`*，指向停駐窗格所在的 dock 資料列，如果窗格未停駐則為 Null。

##  <a name="getexclusiverowmode"></a>CPane：： GetExclusiveRowMode

判斷窗格是否為獨佔資料列模式。

```
virtual BOOL GetExclusiveRowMode() const;
```

### <a name="return-value"></a>傳回值

如果窗格處於獨佔資料列模式，則為 TRUE;否則為 FALSE。

### <a name="remarks"></a>備註

如需獨佔資料列模式的詳細資訊，請參閱[CPane：： SetExclusiveRowMode](#setexclusiverowmode)。

##  <a name="gethotspot"></a>CPane：： GetHotSpot

傳回儲存在基礎 `CMFCDragFrameImpl` 物件中的作用點。

```
CPoint GetHotSpot() const;
```

### <a name="return-value"></a>傳回值

### <a name="remarks"></a>備註

`CPane` 類別包含 `CMFCDragFrameImpl` 物件 `m_dragFrameImpl`，負責繪製使用者在標準銜接模式下移動窗格時所顯示的矩形。 作用點是用來在使用者移動窗格時，繪製相對於目前滑鼠位置的矩形。

##  <a name="getminsize"></a>CPane：： GetMinSize

抓取窗格所允許的最小大小。

```
virtual void GetMinSize(CSize& size) const;
```

### <a name="parameters"></a>參數

*size*<br/>
脫銷填入允許大小下限的 `CSize` 物件。

### <a name="remarks"></a>備註

##  <a name="getpanename"></a>CPane：： GetPaneName

抓取窗格的標題。

```
virtual void GetPaneName(CString& strName) const;
```

### <a name="parameters"></a>參數

*strName*<br/>
脫銷填入標題名稱的 `CString` 物件。

### <a name="remarks"></a>備註

當窗格停駐或浮動時，窗格標題會顯示在標題區域中。 如果窗格是索引標籤式群組的一部分，標題會顯示在 [索引標籤] 區域中。 如果窗格處於自動隱藏模式，標題會顯示在 `CMFCAutoHideButton`上。

##  <a name="getvirtualrect"></a>CPane：： GetVirtualRect

抓取窗格的*虛擬矩形*。

```
void GetVirtualRect(CRect& rectVirtual) const;
```

### <a name="parameters"></a>參數

*rectVirtual*<br/>
脫銷填入虛擬矩形的 `CRect` 物件。

### <a name="remarks"></a>備註

移動窗格時，架構會將窗格的原始位置儲存在虛擬矩形中。 此架構可以使用虛擬矩形來還原窗格的原始位置。

除非您要以程式設計方式移動窗格，否則請不要呼叫與虛擬矩形相關的方法。

##  <a name="ischangestate"></a>CPane：： IsChangeState

移動窗格時，這個方法會分析其相對於其他窗格、停駐列和迷你框架視窗的位置，並傳回適當的 AFX_CS_STATUS 值。

```
virtual AFX_CS_STATUS IsChangeState(
    int nOffset,
    CBasePane** ppTargetBar) const;
```

### <a name="parameters"></a>參數

*nOffset*<br/>
在指定停駐敏感度。 例如，從停駐資料列的*nOffset*圖元內移動的窗格將會固定。

*ppTargetBar*<br/>
在當此方法傳回時， *ppTargetBar*會包含要停駐目前窗格之物件的指標，如果不應進行銜接則為 Null。

### <a name="return-value"></a>傳回值

下列其中一個 AFX_CS_STATUS 值：

|值|描述|
|-----------|-----------------|
|CS_NOTHING|窗格不在停駐網站的附近。 此架構不會停駐窗格。|
|CS_DOCK_IMMEDIATELY|此窗格位於停駐的網站上，且已啟用 DT_IMMEDIATE 樣式。 架構會立即將窗格停駐。|
|CS_DELAY_DOCK|此窗格會在停駐的網站上，也就是另一個固定窗格或主要畫面格的邊緣。 當使用者放開移動時，架構會將窗格停駐。|
|CS_DELAY_DOCK_TO_TAB|此窗格位於停駐在索引標籤式視窗中的 dock 網站上。 當窗格位於另一個停駐窗格的標題上方，或在索引標籤式窗格的索引標籤區域上方時，就會發生這種情況。 當使用者放開移動時，架構會將窗格停駐。|

##  <a name="isdragmode"></a>CPane：： IsDragMode

指定是否要移動窗格。

```
virtual BOOL IsDragMode() const;
```

### <a name="return-value"></a>傳回值

如果要移動窗格，則為 TRUE;否則為 FALSE。

### <a name="remarks"></a>備註

##  <a name="isinfloatingmultipaneframewnd"></a>CPane：： IsInFloatingMultiPaneFrameWnd

指定窗格是否在多窗格框架視窗（ [CMultiPaneFrameWnd 類別](../../mfc/reference/cmultipaneframewnd-class.md)）中。

```
virtual BOOL IsInFloatingMultiPaneFrameWnd() const;
```

### <a name="return-value"></a>傳回值

如果窗格位於多窗格框架視窗中，則為 TRUE;否則為 FALSE。

### <a name="remarks"></a>備註

只有可停駐的窗格可以浮動在多窗格框架視窗中。 因此，`CPane::IsInFloatingMultiPaneFrameWnd` 一律會傳回 FALSE。

##  <a name="isleftof"></a>CPane：： IsLeftOf

判斷窗格是否停留在指定的矩形中（或以上）。

```
bool IsLeftOf(
    CRect rect,
    bool bWindowRect = true) const;
```

### <a name="parameters"></a>參數

*各種*<br/>
在用於比較的 `CRect` 物件。

*bWindowRect*<br/>
在若為 TRUE，則假設*矩形*包含螢幕座標;如果為 FALSE，則假設*rect*包含用戶端座標。

### <a name="return-value"></a>傳回值

### <a name="remarks"></a>備註

如果窗格是以水準方式停駐，這個方法會檢查其位置是否為*矩形*的左邊。 否則，這個方法會檢查位置是否大於*rect*。

##  <a name="isresizable"></a>CPane：： IsResizable

指定窗格是否可調整大小。

```
virtual BOOL IsResizable() const;
```

### <a name="return-value"></a>傳回值

如果窗格可調整大小，則為 TRUE;否則為 FALSE。

### <a name="remarks"></a>備註

基底 `CPane` 物件無法調整大小。

停駐管理員會使用可調整大小的旗標來判斷窗格版面配置。 不可調整大小的窗格一律位於父框架的外部邊緣。

不可調整大小的窗格不能位於停駐的容器中。

##  <a name="istabbed"></a>CPane：： IsTabbed

決定窗格是否已插入索引標籤式視窗的索引標籤控制項中。

```
virtual BOOL IsTabbed() const;
```

### <a name="return-value"></a>傳回值

如果窗格是索引標籤，則為 TRUE;否則為 FALSE。

### <a name="remarks"></a>備註

索引標籤式狀態會與浮動、停駐和自動隱藏的狀態分開處理。

##  <a name="loadstate"></a>CPane：： LoadState

從登錄載入窗格的狀態。

```
virtual BOOL LoadState(
    LPCTSTR lpszProfileName = NULL,
    int nIndex = -1,
    UINT uiID = (UINT) -1);
```

### <a name="parameters"></a>參數

*lpszProfileName*<br/>
在設定檔名稱。

*nIndex*<br/>
在設定檔索引。

*uiID*<br/>
在窗格識別碼。

### <a name="return-value"></a>傳回值

如果已成功載入窗格狀態，則為 TRUE;否則為 FALSE。

### <a name="remarks"></a>備註

此架構會呼叫這個方法，從登錄載入窗格狀態。 在衍生類別中覆寫它，以載入[CPane：： SaveState](#savestate)所儲存的其他資訊。

當您覆寫這個方法時，也請呼叫基底方法，如果基底方法傳回 FALSE，則傳回 FALSE。

##  <a name="m_bhandleminsize"></a>CPane：： m_bHandleMinSize

啟用最小窗格大小的一致處理。

```
AFX_IMPORT_DATA static BOOL m_bHandleMinSize;
```

### <a name="remarks"></a>備註

如果應用程式中的一個或多個停駐窗格覆寫 `GetMinSize`，或如果您的應用程式呼叫 `SetMinSize`，您可能會想要將此靜態成員設定為 TRUE，以便讓架構一致地處理窗格的大小。

如果此值設定為 TRUE，則會裁剪其大小小於其大小下限的所有窗格。 因為架構會使用視窗區域來進行窗格大小調整，所以如果此值設定為 TRUE，請勿變更停駐窗格的視窗區域大小。

##  <a name="m_recentdockinfo"></a>CPane：： m_recentDockInfo

包含最近的銜接資訊。

```
CRecentDockSiteInfo m_recentDockInfo;
```

### <a name="remarks"></a>備註

架構會將窗格的最新銜接狀態資訊儲存在這個成員中。

##  <a name="movebyalignment"></a>CPane：： MoveByAlignment

依據指定的數量移動窗格和虛擬矩形。

```
BOOL MoveByAlignment(
    DWORD dwAlignment,
    int nOffset);
```

### <a name="parameters"></a>參數

*dwAlignment*<br/>
在指定窗格對齊方式。

*nOffset*<br/>
在用來移動窗格和虛擬矩形的數量（以圖元為單位）。

### <a name="return-value"></a>傳回值

### <a name="remarks"></a>備註

*dwAlignment*可以是下列任何一個值：

|值|描述|
|-----------|-----------------|
|CBRS_ALIGN_TOP|讓窗格停駐在框架視窗的工作區頂端。|
|CBRS_ALIGN_BOTTOM|讓窗格停駐在框架視窗的工作區底部。|
|CBRS_ALIGN_LEFT|讓窗格停駐在框架視窗的工作區左邊。|
|CBRS_ALIGN_RIGHT|讓窗格停駐在框架視窗工作區的右側。|
|CBRS_ALIGN_ANY|讓窗格停駐在框架視窗的工作區的任何一邊。|

如果*dwAlignment*包含 CBRS_ALIGN_LEFT 或 CBRS_ALIGN_RIGHT 旗標，則會以水準方式移動窗格和虛擬矩形;否則，如果*dwAlignment*包含 CBRS_ALIGN_TOP 或 CBRS_ALIGN_BOTTOM 旗標，則會垂直移動窗格和虛擬矩形。

##  <a name="movepane"></a>CPane：： MovePane

將窗格移至指定的矩形。

```
virtual CSize MovePane(
    CRect rectNew,
    BOOL bForceMove,
    HDWP& hdwp);
```

### <a name="parameters"></a>參數

*rectNew*<br/>
在指定窗格的新矩形。

*bForceMove*<br/>
在若為 TRUE，這個方法會忽略允許的窗格大小下限（ [CPane：： GetMinSize](#getminsize)）;否則，視需要調整窗格，以確保它至少是所允許的最小值。

*hdwp*<br/>
在未使用。

### <a name="return-value"></a>傳回值

`CSize` 物件，其中包含新的和舊矩形（舊的矩形- *rectNew*）之間的寬度和高度差異。

### <a name="remarks"></a>備註

這個方法僅適用于可停駐窗格。

##  <a name="onafterchangeparent"></a>CPane：： OnAfterChangeParent

當窗格的父系已變更時由架構呼叫。

```
virtual void OnAfterChangeParent(CWnd* pWndOldParent);
```

### <a name="parameters"></a>參數

*pWndOldParent*<br/>
[in、out]窗格的先前父視窗。

### <a name="remarks"></a>備註

當窗格的父系因為銜接或浮動作業而變更時，架構會呼叫這個方法。

##  <a name="onafterdock"></a>CPane：： OnAfterDock

當窗格已停駐時由架構呼叫。

```
virtual void OnAfterDock(
    CBasePane* pBar,
    LPCRECT lpRect,
    AFX_DOCK_METHOD dockMethod);
```

### <a name="parameters"></a>參數

*pBar*<br/>
在不使用這個參數。

*lpRect*<br/>
在不使用這個參數。

*dockMethod*<br/>
在不使用這個參數。

##  <a name="onafterfloat"></a>CPane：： OnAfterFloat

在窗格浮動之後由架構呼叫。

```
virtual void OnAfterFloat();
```

### <a name="remarks"></a>備註

如果您想要在窗格浮動之後執行任何處理，您可以在衍生類別中覆寫這個方法。

##  <a name="onbeforechangeparent"></a>CPane：： OnBeforeChangeParent

當窗格的父系即將變更時由架構呼叫。

```
virtual void OnBeforeChangeParent(
    CWnd* pWndNewParent,
    BOOL bDelay = FALSE);
```

### <a name="parameters"></a>參數

*pWndNewParent*<br/>
[in、out]指定新的父視窗。

*bDelay*<br/>
在TRUE 表示延遲全域銜接版面配置調整;否則為 FALSE。

### <a name="remarks"></a>備註

當窗格的父系即將變更時，架構會呼叫這個方法，因為該窗格會停駐或浮動。

根據預設，窗格會藉由呼叫 `CDockSite::RemovePane`，在停駐窗格中取消註冊。

##  <a name="onbeforedock"></a>CPane：： OnBeforeDock

當窗格即將停駐時由架構呼叫。

```
virtual BOOL OnBeforeDock(
    CBasePane** ppDockBar,
    LPCRECT lpRect,
    AFX_DOCK_METHOD dockMethod);
```

### <a name="parameters"></a>參數

*ppDockBar*<br/>
[in、out]指定此窗格停駐的窗格。

*lpRect*<br/>
在指定停駐矩形。

*dockMethod*<br/>
在指定停駐方法。

### <a name="return-value"></a>傳回值

如果窗格可以停駐，則為 TRUE。 如果函數傳回 FALSE，則停駐作業將會中止。

### <a name="remarks"></a>備註

當窗格即將停駐時，架構會呼叫這個方法。 如果您想要在最後一個窗格停駐之前執行任何處理，您可以在衍生類別中覆寫這個方法。

##  <a name="onbeforefloat"></a>CPane：： OnBeforeFloat

當窗格即將浮動時，由架構呼叫。

```
virtual BOOL OnBeforeFloat(
    CRect& rectFloat,
    AFX_DOCK_METHOD dockMethod);
```

### <a name="parameters"></a>參數

*rectFloat*<br/>
在指定當窗格處於浮動狀態時的位置和大小。

*dockMethod*<br/>
在指定窗格的停駐方法。

### <a name="return-value"></a>傳回值

如果窗格可以浮動，則為 TRUE;否則為 FALSE。

### <a name="remarks"></a>備註

當窗格即將浮動時，架構會呼叫這個方法。 如果您想要在窗格最後浮動之前執行任何處理，您可以在衍生類別中覆寫這個方法。

##  <a name="onpressclosebutton"></a>CPane：： OnPressCloseButton

當使用者在窗格的標題上按下 [關閉] 按鈕時由架構呼叫。

```
virtual void OnPressCloseButton();
```

### <a name="remarks"></a>備註

當使用者按下窗格標題上的 [**關閉**] 按鈕時，架構會呼叫這個方法。 若要接收有關**關閉**事件的通知，您可以在衍生類別中覆寫這個方法。

##  <a name="onshowcontrolbarmenu"></a>CPane：： OnShowControlBarMenu

當特殊窗格功能表即將顯示時由架構呼叫。

```
virtual BOOL OnShowControlBarMenu(CPoint point);
```

### <a name="parameters"></a>參數

*此處*<br/>
在指定功能表位置。

### <a name="return-value"></a>傳回值

如果可以顯示功能表，則為 TRUE;否則為 FALSE。

### <a name="remarks"></a>備註

此功能表包含數個專案，可讓您指定窗格的行為，也就是：**浮動** **、停駐、自動**隱藏**和** **隱藏**。 您可以藉由呼叫[CDockingManager：： EnableDockSiteMenu](../../mfc/reference/cdockingmanager-class.md#enabledocksitemenu)，為所有窗格啟用此功能表。

##  <a name="recalclayout"></a>CPane：： RecalcLayout

重新計算窗格的版面配置資訊。

```
virtual void RecalcLayout();
```

### <a name="remarks"></a>備註

如果窗格停駐，這個方法會將窗格的 [大小] 設定為目前窗格的大小，藉此更新窗格的虛擬矩形。

如果窗格是浮動的，這個方法會通知父系迷你框架，將窗格的大小調整成迷你框架的大小。 此架構可確保迷你框架至少為窗格所允許的最小大小（ [CPane：： GetMinSize](#getminsize)），並視需要調整迷你框架的大小。

##  <a name="savestate"></a>CPane：： SaveState

將窗格的狀態儲存至登錄。

```
virtual BOOL SaveState(
    LPCTSTR lpszProfileName = NULL,
    int nIndex = -1,
    UINT uiID = (UINT) -1);
```

### <a name="parameters"></a>參數

*lpszProfileName*<br/>
在設定檔名稱。

*nIndex*<br/>
在設定檔索引。

*uiID*<br/>
在窗格識別碼。

### <a name="return-value"></a>傳回值

如果已成功儲存狀態，則為 TRUE;否則為 FALSE。

### <a name="remarks"></a>備註

架構會在將窗格的狀態儲存至登錄時呼叫這個方法。 覆寫衍生類別中的 `SaveState`，以儲存其他資訊。

當您覆寫這個方法時，也請呼叫基底方法，如果基底方法傳回 FALSE，則傳回 FALSE。

##  <a name="setactiveingroup"></a>CPane：： SetActiveInGroup

將窗格標示為使用中。

```
virtual void SetActiveInGroup(BOOL bActive);
```

### <a name="parameters"></a>參數

*bActive*<br/>
在布林值，指定窗格是否標示為使用中。

### <a name="remarks"></a>備註

當顯示 [可停駐] 窗格或選擇自動隱藏按鈕時，對應的自動隱藏窗格會標示為 [使用中]。

與窗格相關聯的自動隱藏按鈕外觀是以兩個因素為基礎。 如果窗格處於作用中狀態，而且 `static BOOL CMFCAutoHideButton::m_bOverlappingTabs` 為 TRUE，則架構會將自動隱藏按鈕顯示為圖示和標籤。 若為非作用中窗格，架構只會顯示自動隱藏圖示。

如果 `CMFCAutoHideButton::m_bOverlappingTabs` 為 FALSE，或如果窗格不位於群組中，則架構會將相關聯的自動隱藏按鈕顯示為圖示和標籤。

##  <a name="setborders"></a>CPane：： SetBorders

設定窗格的框線值。

```
void SetBorders(
    int cxLeft = 0,
    int cyTop = 0,
    int cxRight = 0,
    int cyBottom = 0);

void SetBorders(LPCRECT lpRect);
```

### <a name="parameters"></a>參數

*cxLeft*<br/>
在指定窗格左邊框的寬度（以圖元為單位）。

*cyTop*<br/>
在指定窗格上框線的寬度（以圖元為單位）。

*cxRight*<br/>
在指定窗格右框線的寬度（以圖元為單位）。

*cyBottom*<br/>
在指定窗格下框線的寬度（以圖元為單位）。

*lpRect*<br/>
在[CRect](../../atl-mfc-shared/reference/crect-class.md)物件，包含窗格中每個框線的寬度（以圖元為單位）。

### <a name="remarks"></a>備註

呼叫此函式可設定窗格框線的大小。

##  <a name="setclienthotspot"></a>CPane：： SetClientHotSpot

設定窗格的*作用點*。

```
void SetClientHotSpot(const CPoint& ptNew);
```

### <a name="parameters"></a>參數

*ptNew*<br/>
在指定新作用點的 `CPoint` 物件。

### <a name="remarks"></a>備註

*作用*點是使用者選取並保留以移動窗格的窗格上的點。 當窗格從停駐的位置拖曳時，作用點會用於平滑動畫。

##  <a name="setdockstate"></a>CPane：： SetDockState

還原窗格的銜接狀態資訊。

```
virtual void SetDockState(CDockingManager* pDockManager);
```

### <a name="parameters"></a>參數

*pDockManager*<br/>
在主框架視窗之銜接管理員的指標。

### <a name="remarks"></a>備註

這個方法是由架構呼叫，以還原窗格的最近停駐狀態資訊。 窗格會將最近的銜接狀態資訊儲存在[CPane：： m_recentDockInfo](#m_recentdockinfo)中。 如需詳細資訊，請參閱[CRecentDockSiteInfo 類別](../../mfc/reference/crecentdocksiteinfo-class.md)。

當您從外部來源載入窗格資訊時，也可以呼叫這個方法來設定停駐狀態。

##  <a name="setexclusiverowmode"></a>CPane：： SetExclusiveRowMode

啟用或停用獨佔資料列模式。

```
virtual void SetExclusiveRowMode(BOOL bExclusive = TRUE);
```

### <a name="parameters"></a>參數

*bExclusive*<br/>
在TRUE 表示啟用獨佔資料列模式;否則為 FALSE。

### <a name="remarks"></a>備註

呼叫這個方法來啟用或停用獨佔資料列模式。 當窗格處於獨佔資料列模式時，它無法與任何其他工具列共用相同的資料列。

根據預設，所有工具列都已停用獨佔資料列模式，而且功能表列已啟用獨佔資料列模式。

##  <a name="setminsize"></a>CPane：： SetMinSize

設定窗格所允許的最小大小。

```
void SetMinSize(const CSize& size);
```

### <a name="parameters"></a>參數

*size*<br/>
在`CSize` 物件，其中包含窗格所允許的最小大小。

### <a name="remarks"></a>備註

##  <a name="setvirtualrect"></a>CPane：： SetVirtualRect

設定窗格的*虛擬矩形*。

```
void SetVirtualRect(
    const CRect& rect,
    BOOL bMapToParent = TRUE);
```

### <a name="parameters"></a>參數

*各種*<br/>
在`CRect` 物件，指定要設定的虛擬矩形。

*bMapToParent*<br/>
在如果*矩形*包含相對於父視窗的點，請指定 TRUE。

### <a name="remarks"></a>備註

當移動時，*虛擬矩形*會儲存窗格的原始位置。 此架構可以使用虛擬矩形來還原原始位置。

除非您要以程式設計方式移動窗格，否則請不要呼叫與虛擬矩形相關的方法。

##  <a name="setminiframertc"></a>CPane：： SetMiniFrameRTC

設定預設迷你框架視窗的執行時間類別資訊。

```
void SetMiniFrameRTC(CRuntimeClass* pClass);
```

### <a name="parameters"></a>參數

*pClass*<br/>
[in、out]指定迷你框架視窗的執行時間類別資訊。

### <a name="remarks"></a>備註

當窗格浮動時，它會放在[CPaneFrameWnd](../../mfc/reference/cpaneframewnd-class.md) （迷你框架）視窗上。 您可以提供自訂的 `CPaneFrameWnd`衍生類別，以在呼叫[CPane：： CreateDefaultMiniframe](#createdefaultminiframe)時使用。

##  <a name="stretchpanedeferwndpos"></a>CPane：： StretchPaneDeferWndPos

根據停駐樣式，垂直或水準擴充窗格。

```
virtual int StretchPaneDeferWndPos(
    int nStretchSize,
    HDWP& hdwp);
```

### <a name="parameters"></a>參數

*nStretchSize*<br/>
在要延展窗格的量（以圖元為單位）。 使用負值來縮小窗格的值。

*hdwp*<br/>
在未使用。

### <a name="return-value"></a>傳回值

擴展窗格的實際量（單位為圖元）。

### <a name="remarks"></a>備註

如有必要，這個方法會修改*nStretchSize* ，以確保窗格不會超過大小限制。 這些限制是藉由呼叫[CPane：： GetAvailableStretchSize](#getavailablestretchsize)和[CPane：： GetAvailableExpandSize](#getavailableexpandsize)取得。

##  <a name="toggleautohide"></a>CPane：： ToggleAutoHide

切換自動隱藏模式。

```
virtual void ToggleAutoHide();
```

### <a name="remarks"></a>備註

呼叫這個方法來切換自動隱藏模式。 窗格必須停駐于主框架視窗，才能切換為自動隱藏模式。

##  <a name="undockpane"></a>CPane：： UndockPane

從 dock 網站、預設滑杆或迷你框架視窗中移除該窗格，其目前為停駐位置。

```
virtual void UndockPane(BOOL bDelay = FALSE);
```

### <a name="parameters"></a>參數

*bDelay*<br/>
在如果為 FALSE，則架構會呼叫[CBasePane：： AdjustDockingLayout](../../mfc/reference/cbasepane-class.md#adjustdockinglayout)來調整停駐版面配置。

### <a name="remarks"></a>備註

使用此方法，以程式設計方式停用窗格。

##  <a name="updatevirtualrect"></a>CPane：： UpdateVirtualRect

更新虛擬矩形。

```
void UpdateVirtualRect();
void UpdateVirtualRect(CPoint ptOffset);
void UpdateVirtualRect(CSize sizeNew);
```

### <a name="parameters"></a>參數

*ptOffset*<br/>
在`CPoint` 物件，指定要移位窗格的位移。

*sizeNew*<br/>
在`CSize` 物件，指定窗格的新大小。

### <a name="remarks"></a>備註

第一個多載會使用窗格目前的位置和大小來設定虛擬矩形。

第二個多載會依照*ptOffset*所指定的數量來移動虛擬矩形。

第三個多載會使用窗格的目前位置和*sizeNew*所指定的大小來設定虛擬矩形。

## <a name="see-also"></a>另請參閱

[階層架構圖表](../../mfc/hierarchy-chart.md)<br/>
[類別](../../mfc/reference/mfc-classes.md)<br/>
[CBasePane 類別](../../mfc/reference/cbasepane-class.md)
