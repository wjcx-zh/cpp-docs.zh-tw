---
title: CWinApp 類別
ms.date: 07/15/2019
f1_keywords:
- CWinApp
- AFXWIN/CWinApp
- AFXWIN/CWinApp::CWinApp
- AFXWIN/CWinApp::AddDocTemplate
- AFXWIN/CWinApp::AddToRecentFileList
- AFXWIN/CWinApp::ApplicationRecoveryCallback
- AFXWIN/CWinApp::CloseAllDocuments
- AFXWIN/CWinApp::CreatePrinterDC
- AFXWIN/CWinApp::DelRegTree
- AFXWIN/CWinApp::DoMessageBox
- AFXWIN/CWinApp::DoWaitCursor
- AFXWIN/CWinApp::EnableD2DSupport
- AFXWIN/CWinApp::EnableHtmlHelp
- AFXWIN/CWinApp::EnableTaskbarInteraction
- AFXWIN/CWinApp::ExitInstance
- AFXWIN/CWinApp::GetApplicationRecoveryParameter
- AFXWIN/CWinApp::GetApplicationRecoveryPingInterval
- AFXWIN/CWinApp::GetApplicationRestartFlags
- AFXWIN/CWinApp::GetAppRegistryKey
- AFXWIN/CWinApp::GetDataRecoveryHandler
- AFXWIN/CWinApp::GetFirstDocTemplatePosition
- AFXWIN/CWinApp::GetHelpMode
- AFXWIN/CWinApp::GetNextDocTemplate
- AFXWIN/CWinApp::GetPrinterDeviceDefaults
- AFXWIN/CWinApp::GetProfileBinary
- AFXWIN/CWinApp::GetProfileInt
- AFXWIN/CWinApp::GetProfileString
- AFXWIN/CWinApp::GetSectionKey
- AFXWIN/CWinApp::HideApplication
- AFXWIN/CWinApp::HtmlHelp
- AFXWIN/CWinApp::InitInstance
- AFXWIN/CWinApp::IsTaskbarInteractionEnabled
- AFXWIN/CWinApp::LoadCursor
- AFXWIN/CWinApp::LoadIcon
- AFXWIN/CWinApp::LoadOEMCursor
- AFXWIN/CWinApp::LoadOEMIcon
- AFXWIN/CWinApp::LoadStandardCursor
- AFXWIN/CWinApp::LoadStandardIcon
- AFXWIN/CWinApp::OnDDECommand
- AFXWIN/CWinApp::OnIdle
- AFXWIN/CWinApp::OpenDocumentFile
- AFXWIN/CWinApp::ParseCommandLine
- AFXWIN/CWinApp::PreTranslateMessage
- AFXWIN/CWinApp::ProcessMessageFilter
- AFXWIN/CWinApp::ProcessShellCommand
- AFXWIN/CWinApp::ProcessWndProcException
- AFXWIN/CWinApp::Register
- AFXWIN/CWinApp::RegisterWithRestartManager
- AFXWIN/CWinApp::ReopenPreviousFilesAtRestart
- AFXWIN/CWinApp::RestartInstance
- AFXWIN/CWinApp::RestoreAutosavedFilesAtRestart
- AFXWIN/CWinApp::Run
- AFXWIN/CWinApp::RunAutomated
- AFXWIN/CWinApp::RunEmbedded
- AFXWIN/CWinApp::SaveAllModified
- AFXWIN/CWinApp::SelectPrinter
- AFXWIN/CWinApp::SetHelpMode
- AFXWIN/CWinApp::SupportsApplicationRecovery
- AFXWIN/CWinApp::SupportsAutosaveAtInterval
- AFXWIN/CWinApp::SupportsAutosaveAtRestart
- AFXWIN/CWinApp::SupportsRestartManager
- AFXWIN/CWinApp::Unregister
- AFXWIN/CWinApp::WinHelp
- AFXWIN/CWinApp::WriteProfileBinary
- AFXWIN/CWinApp::WriteProfileInt
- AFXWIN/CWinApp::WriteProfileString
- AFXWIN/CWinApp::EnableShellOpen
- AFXWIN/CWinApp::LoadStdProfileSettings
- AFXWIN/CWinApp::OnContextHelp
- AFXWIN/CWinApp::OnFileNew
- AFXWIN/CWinApp::OnFileOpen
- AFXWIN/CWinApp::OnFilePrintSetup
- AFXWIN/CWinApp::OnHelp
- AFXWIN/CWinApp::OnHelpFinder
- AFXWIN/CWinApp::OnHelpIndex
- AFXWIN/CWinApp::OnHelpUsing
- AFXWIN/CWinApp::RegisterShellFileTypes
- AFXWIN/CWinApp::SetAppID
- AFXWIN/CWinApp::SetRegistryKey
- AFXWIN/CWinApp::UnregisterShellFileTypes
- AFXWIN/CWinApp::m_bHelpMode
- AFXWIN/CWinApp::m_eHelpType
- AFXWIN/CWinApp::m_hInstance
- AFXWIN/CWinApp::m_lpCmdLine
- AFXWIN/CWinApp::m_nCmdShow
- AFXWIN/CWinApp::m_pActiveWnd
- AFXWIN/CWinApp::m_pszAppID
- AFXWIN/CWinApp::m_pszAppName
- AFXWIN/CWinApp::m_pszExeName
- AFXWIN/CWinApp::m_pszHelpFilePath
- AFXWIN/CWinApp::m_pszProfileName
- AFXWIN/CWinApp::m_pszRegistryKey
- AFXWIN/CWinApp::m_dwRestartManagerSupportFlags
- AFXWIN/CWinApp::m_nAutosaveInterval
- AFXWIN/CWinApp::m_pDataRecoveryHandler
helpviewer_keywords:
- CWinApp [MFC], CWinApp
- CWinApp [MFC], AddDocTemplate
- CWinApp [MFC], AddToRecentFileList
- CWinApp [MFC], ApplicationRecoveryCallback
- CWinApp [MFC], CloseAllDocuments
- CWinApp [MFC], CreatePrinterDC
- CWinApp [MFC], DelRegTree
- CWinApp [MFC], DoMessageBox
- CWinApp [MFC], DoWaitCursor
- CWinApp [MFC], EnableD2DSupport
- CWinApp [MFC], EnableHtmlHelp
- CWinApp [MFC], EnableTaskbarInteraction
- CWinApp [MFC], ExitInstance
- CWinApp [MFC], GetApplicationRecoveryParameter
- CWinApp [MFC], GetApplicationRecoveryPingInterval
- CWinApp [MFC], GetApplicationRestartFlags
- CWinApp [MFC], GetAppRegistryKey
- CWinApp [MFC], GetDataRecoveryHandler
- CWinApp [MFC], GetFirstDocTemplatePosition
- CWinApp [MFC], GetHelpMode
- CWinApp [MFC], GetNextDocTemplate
- CWinApp [MFC], GetPrinterDeviceDefaults
- CWinApp [MFC], GetProfileBinary
- CWinApp [MFC], GetProfileInt
- CWinApp [MFC], GetProfileString
- CWinApp [MFC], GetSectionKey
- CWinApp [MFC], HideApplication
- CWinApp [MFC], HtmlHelp
- CWinApp [MFC], InitInstance
- CWinApp [MFC], IsTaskbarInteractionEnabled
- CWinApp [MFC], LoadCursor
- CWinApp [MFC], LoadIcon
- CWinApp [MFC], LoadOEMCursor
- CWinApp [MFC], LoadOEMIcon
- CWinApp [MFC], LoadStandardCursor
- CWinApp [MFC], LoadStandardIcon
- CWinApp [MFC], OnDDECommand
- CWinApp [MFC], OnIdle
- CWinApp [MFC], OpenDocumentFile
- CWinApp [MFC], ParseCommandLine
- CWinApp [MFC], PreTranslateMessage
- CWinApp [MFC], ProcessMessageFilter
- CWinApp [MFC], ProcessShellCommand
- CWinApp [MFC], ProcessWndProcException
- CWinApp [MFC], Register
- CWinApp [MFC], RegisterWithRestartManager
- CWinApp [MFC], ReopenPreviousFilesAtRestart
- CWinApp [MFC], RestartInstance
- CWinApp [MFC], RestoreAutosavedFilesAtRestart
- CWinApp [MFC], Run
- CWinApp [MFC], RunAutomated
- CWinApp [MFC], RunEmbedded
- CWinApp [MFC], SaveAllModified
- CWinApp [MFC], SelectPrinter
- CWinApp [MFC], SetHelpMode
- CWinApp [MFC], SupportsApplicationRecovery
- CWinApp [MFC], SupportsAutosaveAtInterval
- CWinApp [MFC], SupportsAutosaveAtRestart
- CWinApp [MFC], SupportsRestartManager
- CWinApp [MFC], Unregister
- CWinApp [MFC], WinHelp
- CWinApp [MFC], WriteProfileBinary
- CWinApp [MFC], WriteProfileInt
- CWinApp [MFC], WriteProfileString
- CWinApp [MFC], EnableShellOpen
- CWinApp [MFC], LoadStdProfileSettings
- CWinApp [MFC], OnContextHelp
- CWinApp [MFC], OnFileNew
- CWinApp [MFC], OnFileOpen
- CWinApp [MFC], OnFilePrintSetup
- CWinApp [MFC], OnHelp
- CWinApp [MFC], OnHelpFinder
- CWinApp [MFC], OnHelpIndex
- CWinApp [MFC], OnHelpUsing
- CWinApp [MFC], RegisterShellFileTypes
- CWinApp [MFC], SetAppID
- CWinApp [MFC], SetRegistryKey
- CWinApp [MFC], UnregisterShellFileTypes
- CWinApp [MFC], m_bHelpMode
- CWinApp [MFC], m_eHelpType
- CWinApp [MFC], m_hInstance
- CWinApp [MFC], m_lpCmdLine
- CWinApp [MFC], m_nCmdShow
- CWinApp [MFC], m_pActiveWnd
- CWinApp [MFC], m_pszAppID
- CWinApp [MFC], m_pszAppName
- CWinApp [MFC], m_pszExeName
- CWinApp [MFC], m_pszHelpFilePath
- CWinApp [MFC], m_pszProfileName
- CWinApp [MFC], m_pszRegistryKey
- CWinApp [MFC], m_dwRestartManagerSupportFlags
- CWinApp [MFC], m_nAutosaveInterval
- CWinApp [MFC], m_pDataRecoveryHandler
ms.assetid: e426a3cd-0d15-40d6-bd55-beaa5feb2343
ms.openlocfilehash: e65ad8b5d8b14ff747adc55b517d9e695d9cbb66
ms.sourcegitcommit: 7ecd91d8ce18088a956917cdaf3a3565bd128510
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 03/16/2020
ms.locfileid: "79420999"
---
# <a name="cwinapp-class"></a>CWinApp 類別

Windows 應用程式物件所衍生自的基底類別。

## <a name="syntax"></a>語法

```
class CWinApp : public CWinThread
```

## <a name="members"></a>成員

### <a name="public-constructors"></a>公用建構函式

|名稱|描述|
|----------|-----------------|
|[CWinApp：： CWinApp](#cwinapp)|建構 `CWinApp` 物件。|

### <a name="public-methods"></a>公用方法

|名稱|描述|
|----------|-----------------|
|[CWinApp：： AddDocTemplate](#adddoctemplate)|將檔範本新增至應用程式的可用檔範本清單。|
|[CWinApp：： AddToRecentFileList](#addtorecentfilelist)|將檔案名加入至最近使用的（MRU）檔案清單。|
|[CWinApp：： ApplicationRecoveryCallback](#applicationrecoverycallback)|當應用程式意外結束時，由架構呼叫。|
|[CWinApp：： CloseAllDocuments](#closealldocuments)|關閉所有開啟的檔。|
|[CWinApp：： CreatePrinterDC](#createprinterdc)|建立印表機裝置內容。|
|[CWinApp：:D elRegTree](#delregtree)|刪除指定的索引鍵和其所有子機碼。|
|[CWinApp：:D oMessageBox](#domessagebox)|為應用程式執行[AfxMessageBox](cstring-formatting-and-message-box-display.md#afxmessagebox) 。|
|[CWinApp：:D oWaitCursor](#dowaitcursor)|開啟和關閉等待游標。|
|[CWinApp：： EnableD2DSupport](#enabled2dsupport)|啟用應用程式 D2D 支援。 初始化主視窗之前先呼叫這個方法。|
|[CWinApp：： EnableHtmlHelp](#enablehtmlhelp)|執行應用程式的 HTMLHelp，而不是 WinHelp。|
|[CWinApp：： EnableTaskbarInteraction](#enabletaskbarinteraction)|啟用工作列互動。|
|[CWinApp：： ExitInstance](#exitinstance)|覆寫以在應用程式終止時清除。|
|[CWinApp：： GetApplicationRecoveryParameter](#getapplicationrecoveryparameter)|捕獲應用程式復原方法的輸入參數。|
|[CWinApp：： GetApplicationRecoveryPingInterval](#getapplicationrecoverypinginterval)|傳回重新開機管理員等待復原回呼函數傳回的時間長度。|
|[CWinApp：： GetApplicationRestartFlags](#getapplicationrestartflags)|傳回重新開機管理員的旗標。|
|[CWinApp：： GetAppRegistryKey](#getappregistrykey)|傳回 HKEY_CURRENT_USER\\"Software" \RegistryKey\ProfileName. 的索引鍵|
|[CWinApp：： GetDataRecoveryHandler](#getdatarecoveryhandler)|取得此應用程式實例的資料修復處理常式。|
|[CWinApp：： GetFirstDocTemplatePosition](#getfirstdoctemplateposition)|抓取第一個檔範本的位置。|
|[CWinApp：： GetHelpMode](#gethelpmode)|捕獲應用程式所使用的說明類型。|
|[CWinApp：： GetNextDocTemplate](#getnextdoctemplate)|抓取檔範本的位置。 可以遞迴方式使用。|
|[CWinApp：： GetPrinterDeviceDefaults](#getprinterdevicedefaults)|抓取印表機裝置的預設值。|
|[CWinApp：： GetProfileBinary](#getprofilebinary)|從應用程式中的專案抓取二進位資料。INI 檔案。|
|[CWinApp：： GetProfileInt](#getprofileint)|從應用程式的專案中抓取整數。INI 檔案。|
|[CWinApp：： GetProfileString](#getprofilestring)|從應用程式的專案中抓取字串。INI 檔案。|
|[CWinApp：： GetSectionKey](#getsectionkey)|傳回 HKEY_CURRENT_USER\\"Software" \RegistryKey\AppName\lpszSection. 的索引鍵|
|[CWinApp：： HideApplication](#hideapplication)|關閉所有檔之前，隱藏應用程式。|
|[CWinApp：： HtmlHelp](#htmlhelp)|呼叫 `HTMLHelp` Windows 函式。|
|[CWinApp：： InitInstance](#initinstance)|覆寫以執行 Windows 實例初始化，例如建立視窗物件。|
|[CWinApp：： IsTaskbarInteractionEnabled](#istaskbarinteractionenabled)|指出是否已啟用 Windows 7 工作列互動。|
|[CWinApp：： LoadCursor](#loadcursor)|載入資料指標資源。|
|[CWinApp：： LoadIcon](#loadicon)|載入圖示資源。|
|[CWinApp：： LoadOEMCursor](#loadoemcursor)|載入 windows OEM 預先定義的資料指標， **OCR_** 常數在 windows 中指定。H.|
|[CWinApp：： LoadOEMIcon](#loadoemicon)|載入**OIC_** 常數在 windows 中指定的 windows OEM 預先定義圖示。H.|
|[CWinApp：： LoadStandardCursor](#loadstandardcursor)|載入**IDC_** 常數在 windows 中指定的 windows 預先定義的資料指標。H.|
|[CWinApp：： LoadStandardIcon](#loadstandardicon)|載入**IDI_** 常數在 windows 中指定的 windows 預先定義圖示。H.|
|[CWinApp：： OnDDECommand](#onddecommand)|由架構呼叫以回應動態資料交換（DDE）執行命令。|
|[CWinApp：： OnIdle](#onidle)|覆寫以執行應用程式特定的閒置時間處理。|
|[CWinApp：： OpenDocumentFile](#opendocumentfile)|由架構呼叫，以從檔案開啟檔。|
|[CWinApp：:P arseCommandLine](#parsecommandline)|剖析命令列中的個別參數和旗標。|
|[CWinApp：:P reTranslateMessage](#pretranslatemessage)|在訊息分派至 Windows 函式[TranslateMessage](/windows/win32/api/winuser/nf-winuser-translatemessage)和[DispatchMessage](/windows/win32/api/winuser/nf-winuser-dispatchmessage)之前，先進行篩選。|
|[CWinApp：:P rocessMessageFilter](#processmessagefilter)|攔截特定訊息，然後再到達應用程式。|
|[CWinApp：:P rocessShellCommand](#processshellcommand)|處理命令列引數和旗標。|
|[CWinApp：:P rocessWndProcException](#processwndprocexception)|攔截應用程式的訊息和命令處理常式擲回的所有未處理的例外狀況。|
|[CWinApp：： Register](#register)|執行自訂註冊。|
|[CWinApp：： RegisterWithRestartManager](#registerwithrestartmanager)|向重新開機管理員註冊應用程式。|
|[CWinApp：： ReopenPreviousFilesAtRestart](#reopenpreviousfilesatrestart)|判斷當應用程式意外結束時，重新開機管理員是否重新開啟已開啟的檔案。|
|[CWinApp：： RestartInstance](#restartinstance)|處理重新開機管理員起始的應用程式重新開機。|
|[CWinApp：： RestoreAutosavedFilesAtRestart](#restoreautosavedfilesatrestart)|判斷重新開機管理員是否會在重新開機應用程式時，還原自動儲存的檔案。|
|[CWinApp：： Run](#run)|執行預設訊息迴圈。 覆寫以自訂訊息迴圈。|
|[CWinApp：： RunAutomated](#runautomated)|測試應用程式在 **/Automation**選項中的命令列。 已經過時： 請改為在呼叫[ParseCommandLine](#parsecommandline)之後，使用[CCommandLineInfo：： m_bRunAutomated](../../mfc/reference/ccommandlineinfo-class.md#m_brunautomated)中的值。|
|[CWinApp：： RunEmbedded](#runembedded)|測試應用程式在 **/Embedding**選項中的命令列。 已經過時： 請改為在呼叫[ParseCommandLine](#parsecommandline)之後，使用[CCommandLineInfo：： m_bRunEmbedded](../../mfc/reference/ccommandlineinfo-class.md#m_brunembedded)中的值。|
|[CWinApp：： SaveAllModified](#saveallmodified)|提示使用者儲存所有修改過的檔。|
|[CWinApp：： SelectPrinter](#selectprinter)|選取使用者先前透過 [列印] 對話方塊所表示的印表機。|
|[CWinApp：： SetHelpMode](#sethelpmode)|設定及初始化應用程式所使用的說明類型。|
|[CWinApp：： SupportsApplicationRecovery](#supportsapplicationrecovery)|判斷重新開機管理員是否要復原意外結束的應用程式。|
|[CWinApp：： SupportsAutosaveAtInterval](#supportsautosaveatinterval)|判斷重新開機管理員是否定期 autosaves 開啟檔。|
|[CWinApp：： SupportsAutosaveAtRestart](#supportsautosaveatrestart)|判斷重新開機管理員是否會在應用程式重新開機時 autosaves 任何開啟的檔。|
|[CWinApp：： SupportsRestartManager](#supportsrestartmanager)|判斷應用程式是否支援重新開機管理員。|
|[CWinApp：：取消註冊](#unregister)|取消註冊所有已知由 `CWinApp` 物件註冊的專案。|
|[CWinApp：： WinHelp](#winhelp)|呼叫 `WinHelp` Windows 函式。|
|[CWinApp：： WriteProfileBinary](#writeprofilebinary)|將二進位資料寫入應用程式中的專案。INI 檔案。|
|[CWinApp：： WriteProfileInt](#writeprofileint)|將整數寫入應用程式中的專案。INI 檔案。|
|[CWinApp：： WriteProfileString](#writeprofilestring)|將字串寫入應用程式中的專案。INI 檔案。|

### <a name="protected-methods"></a>受保護的方法

|名稱|描述|
|----------|-----------------|
|[CWinApp：：新增 enableshellopen](#enableshellopen)|允許使用者從 Windows 檔案管理員開啟資料檔案。|
|[CWinApp：： LoadStdProfileSettings](#loadstdprofilesettings)|載入標準。INI 檔案設定，並啟用 [MRU 檔案清單] 功能。|
|[CWinApp：： OnCoNtextHelp](#oncontexthelp)|處理應用程式內的 SHIFT + F1 說明。|
|[CWinApp：： OnFileNew](#onfilenew)|執行 ID_FILE_NEW 命令。|
|[CWinApp：： OnFileOpen](#onfileopen)|執行 ID_FILE_OPEN 命令。|
|[CWinApp：： OnFilePrintSetup](#onfileprintsetup)|執行 ID_FILE_PRINT_SETUP 命令。|
|[CWinApp：： OnHelp](#onhelp)|在應用程式 (使用目前的內容) 中處理 F1 說明。|
|[CWinApp：： OnHelpFinder](#onhelpfinder)|處理 ID_HELP_FINDER 和 ID_DEFAULT_HELP 命令。|
|[CWinApp：： OnHelpIndex](#onhelpindex)|處理 ID_HELP_INDEX 命令，並提供預設說明主題。|
|[CWinApp：： OnHelpUsing](#onhelpusing)|處理 ID_HELP_USING 命令。|
|[CWinApp：： RegisterShellFileTypes](#registershellfiletypes)|使用 Windows 檔案管理員註冊所有應用程式的檔案類型。|
|[CWinApp：： SetAppID](#setappid)|明確設定應用程式的應用程式使用者模型識別碼。 應該先呼叫這個方法，然後才向使用者呈現任何使用者介面（最好的地方就是應用程式的構造函式）。|
|[CWinApp：： SetRegistryKey](#setregistrykey)|導致應用程式設定儲存在登錄中，而不是。INI 檔案。|
|[CWinApp：： UnregisterShellFileTypes](#unregistershellfiletypes)|使用 Windows 檔案管理員取消註冊所有應用程式檔案類型。|

### <a name="public-data-members"></a>公用資料成員

|名稱|描述|
|----------|-----------------|
|[CWinApp：： m_bHelpMode](#m_bhelpmode)|指出使用者是否處於說明內容模式（通常是使用 SHIFT + F1 叫用）。|
|[CWinApp：： m_eHelpType](#m_ehelptype)|指定應用程式所使用的說明類型。|
|[CWinApp：： m_hInstance](#m_hinstance)|識別應用程式的目前實例。|
|[CWinApp：： m_lpCmdLine](#m_lpcmdline)|指向以 null 終止的字串，指定應用程式的命令列。|
|[CWinApp：： m_nCmdShow](#m_ncmdshow)|指定一開始要顯示的視窗。|
|[CWinApp：： m_pActiveWnd](#m_pactivewnd)|當 OLE 伺服器為就地作用中時，容器應用程式主視窗的指標。|
|[CWinApp：： m_pszAppID](#m_pszappid)|應用程式使用者模型識別碼。|
|[CWinApp：： m_pszAppName](#m_pszappname)|指定應用程式的名稱。|
|[CWinApp：： m_pszExeName](#m_pszexename)|應用程式的模組名稱。|
|[CWinApp：： m_pszHelpFilePath](#m_pszhelpfilepath)|應用程式說明檔的路徑。|
|[CWinApp：： m_pszProfileName](#m_pszprofilename)|應用程式的。INI 檔案名。|
|[CWinApp：： m_pszRegistryKey](#m_pszregistrykey)|用來判斷用來儲存應用程式佈建檔設定的完整登錄機碼。|

### <a name="protected-data-members"></a>受保護的資料成員

|名稱|描述|
|----------|-----------------|
|[CWinApp：： m_dwRestartManagerSupportFlags](#m_dwrestartmanagersupportflags)|判斷重新開機管理員運作方式的旗標。|
|[CWinApp：： m_nAutosaveInterval](#m_nautosaveinterval)|Autosaves 之間的時間長度（以毫秒為單位）。|
|[CWinApp：： m_pDataRecoveryHandler](#m_pdatarecoveryhandler)|應用程式之資料復原處理常式的指標。|

## <a name="remarks"></a>備註

應用程式物件會提供成員函式，以便初始化您的應用程式（和它的每個實例），以及執行應用程式。

使用 Microsoft Foundation 類別的每個應用程式都只能包含一個衍生自 `CWinApp`的物件。 這個物件是在建立其他C++全域物件時所建立，而且當 Windows 呼叫由 MFC 程式庫所提供的 `WinMain` 函式時，它已經可以使用。 在全域層級宣告您的衍生 `CWinApp` 物件。

當您從 `CWinApp`衍生應用程式類別時，請覆寫[InitInstance](#initinstance)成員函式，以建立應用程式的主視窗物件。

除了 `CWinApp` 成員函式之外，MFC 程式庫還提供下列全域函式來存取您的 `CWinApp` 物件和其他全域資訊：

- [AfxGetApp](application-information-and-management.md#afxgetapp)取得 `CWinApp` 物件的指標。

- [AfxGetInstanceHandle](application-information-and-management.md#afxgetinstancehandle)取得目前應用程式實例的控制碼。

- [AfxGetResourceHandle](application-information-and-management.md#afxgetresourcehandle)取得應用程式資源的控制碼。

- [AfxGetAppName](application-information-and-management.md#afxgetappname)取得包含應用程式名稱之字串的指標。 或者，如果您有 `CWinApp` 物件的指標，請使用 `m_pszExeName` 來取得應用程式的名稱。

如需 `CWinApp` 類別的詳細資訊，請參閱[CWinApp：應用程式類別](../../mfc/cwinapp-the-application-class.md)，包括下列各項的總覽：

- 應用程式精靈所撰寫的 `CWinApp`衍生程式碼。

- `CWinApp`在應用程式的執行順序中的角色。

- `CWinApp`的預設成員函式實作為。

- `CWinApp`的金鑰 overridables。

`m_hPrevInstance` 的資料成員已不存在。 若要判斷應用程式的另一個實例是否正在執行，請使用已命名的 mutex。 如果開啟 mutex 失敗，則不會有任何其他的應用程式實例正在執行。

## <a name="inheritance-hierarchy"></a>繼承階層

[CObject](../../mfc/reference/cobject-class.md)

[CCmdTarget](../../mfc/reference/ccmdtarget-class.md)

[CWinThread](../../mfc/reference/cwinthread-class.md)

`CWinApp`

## <a name="requirements"></a>需求

**標題:** afxwin.h

##  <a name="adddoctemplate"></a>CWinApp：： AddDocTemplate

呼叫這個成員函式，將檔範本加入應用程式所維護的可用檔範本清單中。

```
void AddDocTemplate(CDocTemplate* pTemplate);
```

### <a name="parameters"></a>參數

*pTemplate*<br/>
要加入之 `CDocTemplate` 的指標。

### <a name="remarks"></a>備註

在呼叫[RegisterShellFileTypes](#registershellfiletypes)之前，您應該先將所有檔範本新增至應用程式。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#35](../../mfc/reference/codesnippet/cpp/cwinapp-class_1.cpp)]

##  <a name="addtorecentfilelist"></a>CWinApp：： AddToRecentFileList

呼叫這個成員函式，將*lpszPathName*加入至 MRU 檔案清單。

```
virtual void AddToRecentFileList(LPCTSTR lpszPathName);
```

### <a name="parameters"></a>參數

*lpszPathName*<br/>
檔案的路徑。

### <a name="remarks"></a>備註

在使用這個成員函式之前，您應該呼叫[LoadStdProfileSettings](#loadstdprofilesettings)成員函式來載入目前的 MRU 檔案清單。

此架構會在開啟檔案或執行 [另存新檔] 命令時呼叫這個成員函式，以儲存具有新名稱的檔案。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#36](../../mfc/reference/codesnippet/cpp/cwinapp-class_2.cpp)]

##  <a name="applicationrecoverycallback"></a>CWinApp：： ApplicationRecoveryCallback

當應用程式意外結束時，由架構呼叫。

```
virtual DWORD ApplicationRecoveryCallback(LPVOID lpvParam);
```

### <a name="parameters"></a>參數

*lpvParam*<br/>
在保留供日後使用。

### <a name="return-value"></a>傳回值

若此方法成功，則為 0;如果發生錯誤，則為非零值。

### <a name="remarks"></a>備註

如果您的應用程式支援重新開機管理員，當您的應用程式意外結束時，架構會呼叫這個函式。

`ApplicationRecoveryCallback` 的預設執行會使用 `CDataRecoveryHandler`，將目前開啟的檔案清單儲存至登錄中。 這個方法不會自動儲存任何檔案。

若要自訂行為，請在衍生的[CWinApp 類別](../../mfc/reference/cwinapp-class.md)中覆寫此函式，或將您自己的應用程式復原方法當做參數傳遞至[CWinApp：： RegisterWithRestartManager](#registerwithrestartmanager)。

##  <a name="closealldocuments"></a>CWinApp：： CloseAllDocuments

呼叫這個成員函式可在結束之前，關閉所有開啟的檔。

```
void CloseAllDocuments(BOOL bEndSession);
```

### <a name="parameters"></a>參數

*bEndSession*<br/>
指定是否要結束 Windows 會話。 如果會話已結束，則為 TRUE;否則為 FALSE。

### <a name="remarks"></a>備註

請先呼叫[HideApplication](#hideapplication) ，然後再呼叫 `CloseAllDocuments`。

##  <a name="createprinterdc"></a>CWinApp：： CreatePrinterDC

呼叫此成員函式，從選取的印表機建立印表機裝置內容（DC）。

```
BOOL CreatePrinterDC(CDC& dc);
```

### <a name="parameters"></a>參數

*dc*<br/>
印表機裝置內容的參考。

### <a name="return-value"></a>傳回值

如果成功建立印表機裝置內容，則為非零;否則為0。

### <a name="remarks"></a>備註

`CreatePrinterDC` 會初始化您以傳址方式傳入的裝置內容，因此您可以使用它來列印。

如果函式成功，則當您完成列印時，您必須終結裝置內容。 您可以讓[CDC](../../mfc/reference/cdc-class.md)物件的「析構函式」執行它，也可以藉由呼叫[Cdc：:D eletedc](../../mfc/reference/cdc-class.md#deletedc)來明確地執行此動作。

##  <a name="cwinapp"></a>CWinApp：： CWinApp

建立 `CWinApp` 物件，並傳遞*lpszAppName*以儲存為應用程式名稱。

```
CWinApp(LPCTSTR lpszAppName = NULL);
```

### <a name="parameters"></a>參數

*lpszAppName*<br/>
以 null 終止的字串，其中包含 Windows 所使用的應用程式名稱。 如果未提供這個引數或其為 Null，`CWinApp` 會使用資源字串 AFX_IDS_APP_TITLE 或可執行檔的檔案名。

### <a name="remarks"></a>備註

您應該為 `CWinApp`衍生的類別，建立一個全域物件。 您的應用程式中只能有一個 `CWinApp` 物件。 此函式會儲存 `CWinApp` 物件的指標，讓 `WinMain` 可以呼叫物件的成員函式來初始化和執行應用程式。

##  <a name="delregtree"></a>CWinApp：:D elRegTree

刪除特定登錄機碼及其所有子機碼。

```
LONG DelRegTree(
    HKEY hParentKey,
    const CString& strKeyName);

LONG DelRegTree(
    HKEY hParentKey,
    const CString& strKeyName,
    CAtlTransactionManager* pTM = NULL);
```

### <a name="parameters"></a>參數

*hParentKey*<br/>
登錄機碼的控制碼。

*strKeyName*<br/>
要刪除之登錄機碼的名稱。

*pTM*<br/>
CAtlTransactionManager 物件的指標。

### <a name="return-value"></a>傳回值

如果函式成功，則傳回值為 ERROR_SUCCESS。 如果函式失敗，則傳回值為 Winerror.h 中定義的非零錯誤碼。

### <a name="remarks"></a>備註

呼叫此函式可刪除指定的索引鍵和其子機碼。

##  <a name="domessagebox"></a>CWinApp：:D oMessageBox

架構會呼叫這個成員函式，以執行全域函數[AfxMessageBox](cstring-formatting-and-message-box-display.md#afxmessagebox)的訊息方塊。

```
virtual int DoMessageBox(
    LPCTSTR lpszPrompt,
    UINT nType,
    UINT nIDPrompt);
```

### <a name="parameters"></a>參數

*lpszPrompt*<br/>
訊息方塊中的文字位址。

*nType*<br/>
訊息方塊[樣式](../../mfc/reference/styles-used-by-mfc.md#message-box-styles)。

*nIDPrompt*<br/>
說明內容字串的索引。

### <a name="return-value"></a>傳回值

傳回與 `AfxMessageBox`相同的值。

### <a name="remarks"></a>備註

請勿呼叫這個成員函式來開啟訊息方塊;請改用 `AfxMessageBox`。

覆寫此成員函式，以自訂整個應用程式的 `AfxMessageBox` 呼叫處理。

##  <a name="dowaitcursor"></a>CWinApp：:D oWaitCursor

此成員函式是由架構呼叫，以執行[CWaitCursor](../../mfc/reference/cwaitcursor-class.md)、 [CCmdTarget：： BeginWaitCursor](../../mfc/reference/ccmdtarget-class.md#beginwaitcursor)、 [CCmdTarget：： EndWaitCursor](../../mfc/reference/ccmdtarget-class.md#endwaitcursor)和[CCmdTarget：： RestoreWaitCursor](../../mfc/reference/ccmdtarget-class.md#restorewaitcursor)。

```
virtual void DoWaitCursor(int nCode);
```

### <a name="parameters"></a>參數

*nCode*<br/>
如果這個參數是1，就會出現等待游標。 如果為0，則會還原等候資料指標，而不會遞增參考計數。 如果為-1，則等待游標結束。

### <a name="remarks"></a>備註

預設會實行沙漏游標。 `DoWaitCursor` 維護參考計數。 若為正數，則會顯示沙漏游標。

雖然您通常不會直接呼叫 `DoWaitCursor`，但您可以覆寫這個成員函式來變更等待游標，或在顯示等候游標時執行其他處理。

如需更簡單、更有效率的方式來執行等候游標，請使用 `CWaitCursor`。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#37](../../mfc/reference/codesnippet/cpp/cwinapp-class_3.cpp)]

##  <a name="enabled2dsupport"></a>CWinApp：： EnableD2DSupport

必須有 Visual Studio 2010 SP1。

啟用應用程式 D2D 支援。 初始化主視窗之前先呼叫這個方法。

```
BOOL EnableD2DSupport(
    D2D1_FACTORY_TYPE d2dFactoryType = D2D1_FACTORY_TYPE_SINGLE_THREADED,
    DWRITE_FACTORY_TYPE writeFactoryType = DWRITE_FACTORY_TYPE_SHARED);
```

### <a name="parameters"></a>參數

*d2dFactoryType*<br/>
D2D factory 的執行緒模型和它所建立的資源。

*writeFactoryType*<br/>
值，指定是否要共用或隔離寫入 factory 物件

### <a name="return-value"></a>傳回值

如果已啟用 D2D 支援，則傳回 TRUE，否則傳回 FALSE。

##  <a name="enablehtmlhelp"></a>CWinApp：： EnableHtmlHelp

從 `CWinApp`衍生類別的函式內呼叫這個成員函式，以使用 HTMLHelp 作為應用程式的說明。

```
void EnableHtmlHelp();
```

### <a name="remarks"></a>備註

##  <a name="enableshellopen"></a>CWinApp：：新增 enableshellopen

呼叫此函式（通常是從您的 `InitInstance` 覆寫），讓應用程式的使用者在 Windows 檔案管理員中按兩下檔案時，可以開啟資料檔案。

```
void EnableShellOpen();
```

### <a name="remarks"></a>備註

呼叫 `RegisterShellFileTypes` 成員函式搭配此函式，或提供。具有應用程式的 REG 檔案，以手動方式註冊檔案類型。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#38](../../mfc/reference/codesnippet/cpp/cwinapp-class_4.cpp)]

##  <a name="enabletaskbarinteraction"></a>CWinApp：： EnableTaskbarInteraction

啟用工作列互動。

```
BOOL EnableTaskbarInteraction(BOOL bEnable = TRUE);
```

### <a name="parameters"></a>參數

*bEnable*<br/>
指定是否要啟用與 Windows 7 工作列的互動（TRUE），或停用（FALSE）。

### <a name="return-value"></a>傳回值

如果可以啟用或停用工作列互動，則傳回 TRUE。

### <a name="remarks"></a>備註

必須先呼叫這個方法，然後再建立主視窗，否則它會判斷提示並傳回 FALSE。

##  <a name="exitinstance"></a>CWinApp：： ExitInstance

由架構從 `Run` 成員函式中呼叫，以結束應用程式的這個實例。

```
virtual int ExitInstance();
```

### <a name="return-value"></a>傳回值

應用程式的結束代碼;0表示沒有錯誤，而大於0的值表示發生錯誤。 這個值會用來做為 `WinMain`的傳回值。

### <a name="remarks"></a>備註

請勿在 `Run` 成員函式內的任何位置呼叫此成員函式。

此函式的預設實作用會將架構選項寫入應用程式的。INI 檔案。 當應用程式終止時，覆寫此函式以進行清除。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#39](../../mfc/reference/codesnippet/cpp/cwinapp-class_5.cpp)]

##  <a name="getapplicationrecoveryparameter"></a>CWinApp：： GetApplicationRecoveryParameter

捕獲應用程式復原方法的輸入參數。

```
virtual LPVOID GetApplicationRecoveryParameter();
```

### <a name="return-value"></a>傳回值

應用程式復原方法的預設輸入參數。

### <a name="remarks"></a>備註

此函式的預設行為會傳回 Null。

如需詳細資訊，請參閱[CWinApp：： ApplicationRecoveryCallback](#applicationrecoverycallback)。

##  <a name="getapplicationrecoverypinginterval"></a>CWinApp：： GetApplicationRecoveryPingInterval

傳回重新開機管理員等待復原回呼函數傳回的時間長度。

```
virtual DWORD GetApplicationRecoveryPingInterval();
```

### <a name="return-value"></a>傳回值

時間長度（以毫秒為單位）。

### <a name="remarks"></a>備註

向重新開機管理員註冊的應用程式意外結束時，應用程式會嘗試儲存開啟的檔，並呼叫修復回呼函式。 預設的復原回呼函式為[CWinApp：： ApplicationRecoveryCallback](#applicationrecoverycallback)。

架構等候復原回呼函式傳回的時間長度是 ping 間隔。 您可以藉由覆寫 `CWinApp::GetApplicationRecoveryPingInterval` 或提供自訂值來 `RegisterWithRestartManager`，來自訂 ping 間隔。

##  <a name="getapplicationrestartflags"></a>CWinApp：： GetApplicationRestartFlags

傳回重新開機管理員的旗標。

```
virtual DWORD GetApplicationRestartFlags();
```

### <a name="return-value"></a>傳回值

重新開機管理員的旗標。 預設的實值會傳回0。

### <a name="remarks"></a>備註

重新開機管理員的旗標不會影響預設的執行。 提供給未來使用。

當您使用[CWinApp：： RegisterWithRestartManager](#registerwithrestartmanager)向重新開機管理員註冊應用程式時，您可以設定旗標。

重新開機管理員旗標的可能值如下所示：

- RESTART_NO_CRASH

- RESTART_NO_HANG

- RESTART_NO_PATCH

- RESTART_NO_REBOOT

##  <a name="getappregistrykey"></a>CWinApp：： GetAppRegistryKey

傳回 HKEY_CURRENT_USER\\"Software" \RegistryKey\ProfileName. 的金鑰

```
HKEY GetAppRegistryKey(CAtlTransactionManager* pTM = NULL);
```

### <a name="parameters"></a>參數

*pTM*<br/>
指向 `CAtlTransactionManager` 物件的指標。

### <a name="return-value"></a>傳回值

如果函式成功，則為應用程式金鑰;否則為 Null。

### <a name="remarks"></a>備註

##  <a name="getdatarecoveryhandler"></a>CWinApp：： GetDataRecoveryHandler

取得此應用程式實例的資料修復處理常式。

```
virtual CDataRecoveryHandler *GetDataRecoveryHandler();
```

### <a name="return-value"></a>傳回值

此應用程式實例的資料修復處理常式。

### <a name="remarks"></a>備註

使用重新開機管理員的每個應用程式都必須有一個[CDataRecoveryHandler 類別](../../mfc/reference/cdatarecoveryhandler-class.md)的實例。 這個類別負責監視開啟的檔和自動儲存檔。 `CDataRecoveryHandler` 的行為取決於重新開機管理員的設定。 如需詳細資訊，請參閱[CDataRecoveryHandler 類別](../../mfc/reference/cdatarecoveryhandler-class.md)。

在 Windows Vista 之前的作業系統上，這個方法會傳回 Null。 Windows Vista 之前的作業系統不支援重新開機管理員。

如果應用程式目前沒有資料復原處理常式，則這個方法會建立一個，並傳回它的指標。

##  <a name="getfirstdoctemplateposition"></a>CWinApp：： GetFirstDocTemplatePosition

取得應用程式中第一個檔範本的位置。

```
POSITION GetFirstDocTemplatePosition() const;
```

### <a name="return-value"></a>傳回值

可用於反復專案或物件指標抓取的位置值;如果清單是空的，則為 Null。

### <a name="remarks"></a>備註

使用[GetNextDocTemplate](#getnextdoctemplate)呼叫中所傳回的 POSITION 值，以取得第一個[CDocTemplate](../../mfc/reference/cdoctemplate-class.md)物件。

##  <a name="gethelpmode"></a>CWinApp：： GetHelpMode

捕獲應用程式所使用的說明類型。

```
AFX_HELP_TYPE GetHelpMode();
```

### <a name="return-value"></a>傳回值

應用程式所使用的說明類型。 如需詳細資訊，請參閱[CWinApp：： m_eHelpType](#m_ehelptype) 。

##  <a name="getnextdoctemplate"></a>CWinApp：： GetNextDocTemplate

取得*pos*所識別的檔範本，然後將*POS*設定為位置值。

```
CDocTemplate* GetNextDocTemplate(POSITION& pos) const;
```

### <a name="parameters"></a>參數

*pos*<br/>
先前呼叫 `GetNextDocTemplate` 或[GetFirstDocTemplatePosition](#getfirstdoctemplateposition)所傳回之位置值的參考。 這個呼叫會將值更新為下一個位置。

### <a name="return-value"></a>傳回值

[CDocTemplate](../../mfc/reference/cdoctemplate-class.md)物件的指標。

### <a name="remarks"></a>備註

如果您在呼叫 `GetFirstDocTemplatePosition`時建立初始位置，可以在正向反復專案迴圈中使用 `GetNextDocTemplate`。

您必須確定您的位置值有效。 如果無效，則 MFC 程式庫判斷提示的 Debug 版本。

如果抓取的檔範本是最後可用的，則*pos*的新值會設為 Null。

##  <a name="getprinterdevicedefaults"></a>CWinApp：： GetPrinterDeviceDefaults

呼叫此成員函式以準備印表機裝置內容以進行列印。

```
BOOL GetPrinterDeviceDefaults(struct tagPDA* pPrintDlg);
```

### <a name="parameters"></a>參數

*pPrintDlg*<br/>
[PRINTDLG](/windows/win32/api/commdlg/ns-commdlg-printdlga)結構的指標。

### <a name="return-value"></a>傳回值

如果成功則為非零；否則為 0。

### <a name="remarks"></a>備註

從 Windows 抓取目前的印表機預設值。INI 檔案，或使用 [列印設定] 中使用者所設定的最後一部印表機設定。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#40](../../mfc/reference/codesnippet/cpp/cwinapp-class_6.cpp)]

##  <a name="getprofilebinary"></a>CWinApp：： GetProfileBinary

呼叫這個成員函式，從應用程式的登錄或的指定區段內的專案中取出二進位資料。INI 檔案。

```
BOOL GetProfileBinary(
    LPCTSTR lpszSection,
    LPCTSTR lpszEntry,
    LPBYTE* ppData,
    UINT* pBytes);
```

### <a name="parameters"></a>參數

*lpszSection*<br/>
指向以 null 終止的字串，這個字串指定包含項目的區段。

*lpszEntry*<br/>
指向以 null 終止的字串，其中包含要擷取其值的項目。

*ppData*<br/>
指向將接收資料位址的指標。

*pBytes*<br/>
指向將接收資料大小的 UINT （以位元組為單位）。

### <a name="return-value"></a>傳回值

如果成功則為非零；否則為 0。

### <a name="remarks"></a>備註

此成員函式不區分大小寫，因此*lpszSection*和*lpszEntry*參數中的字串在大小寫上可能會有所不同。

> [!NOTE]
> `GetProfileBinary` 會配置緩衝區，並傳回其在 \* *ppData*中的位址。 呼叫端負責使用**delete []** 釋放緩衝區。

> [!IMPORTANT]
> 這個函式傳回的資料不一定是以 NULL 終止，因此，呼叫端必須執行驗證。 如需詳細資訊，請參閱 [Avoiding Buffer Overruns (避免緩衝區滿溢)](/windows/win32/SecBP/avoiding-buffer-overruns)。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#41](../../mfc/reference/codesnippet/cpp/cwinapp-class_7.cpp)]

如需其他範例，請參閱[CWinApp：： WriteProfileBinary](#writeprofilebinary)。

##  <a name="getprofileint"></a>CWinApp：： GetProfileInt

呼叫此成員函式，從應用程式登錄檔或 .INI 檔中指定的區段內的項目擷取整數的值。

```
UINT GetProfileInt(
    LPCTSTR lpszSection,
    LPCTSTR lpszEntry,
    int nDefault);
```

### <a name="parameters"></a>參數

*lpszSection*<br/>
指向以 null 終止的字串，這個字串指定包含項目的區段。

*lpszEntry*<br/>
指向以 null 終止的字串，其中包含要擷取其值的項目。

*nDefault*<br/>
指定架構找不到項目時要傳回的預設值。

### <a name="return-value"></a>傳回值

如果函式成功，在指定項目後面之字串的整數值。 如果函數找不到專案，則傳回值會是*nDefault*參數的值。 如果對應到指定項目的值不是整數，則傳回值為 0。

此成員函式支援 .INI 檔中值的十六進位標記法。 當您取出帶正負號的整數時，您應該將值轉換成**int**。

### <a name="remarks"></a>備註

此成員函式不區分大小寫，因此*lpszSection*和*lpszEntry*參數中的字串在大小寫上可能會有所不同。

> [!IMPORTANT]
> 這個函式傳回的資料不一定是以 NULL 終止，因此，呼叫端必須執行驗證。 如需詳細資訊，請參閱 [Avoiding Buffer Overruns (避免緩衝區滿溢)](/windows/win32/SecBP/avoiding-buffer-overruns)。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#42](../../mfc/reference/codesnippet/cpp/cwinapp-class_8.cpp)]

如需其他範例，請參閱[CWinApp：： WriteProfileInt](#writeprofileint)。

##  <a name="getprofilestring"></a>CWinApp：： GetProfileString

呼叫這個成員函式可在應用程式的登錄或中，抓取與指定區段內專案相關聯的字串。INI 檔案。

```
CString GetProfileString(
    LPCTSTR lpszSection,
    LPCTSTR lpszEntry,
    LPCTSTR lpszDefault = NULL);
```

### <a name="parameters"></a>參數

*lpszSection*<br/>
指向以 null 終止的字串，這個字串指定包含項目的區段。

*lpszEntry*<br/>
指向以 null 終止的字串，其中包含要抓取其字串的專案。 此值不得為 Null。

*lpszDefault*<br/>
指向指定專案的預設字串值（如果在初始化檔中找不到專案）。

### <a name="return-value"></a>傳回值

傳回值是來自應用程式之的字串。如果找不到字串，則為 INI 檔案或*lpszDefault* 。 架構支援的最大字串長度為 _MAX_PATH。 如果*lpszDefault*為 Null，則傳回值為空字串。

### <a name="remarks"></a>備註

> [!IMPORTANT]
> 這個函式傳回的資料不一定是以 NULL 終止，因此，呼叫端必須執行驗證。 如需詳細資訊，請參閱 [Avoiding Buffer Overruns (避免緩衝區滿溢)](/windows/win32/SecBP/avoiding-buffer-overruns)。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#43](../../mfc/reference/codesnippet/cpp/cwinapp-class_9.cpp)]

如需其他範例，請參閱[CWinApp：： GetProfileInt](#getprofileint)的範例。

##  <a name="getsectionkey"></a>CWinApp：： GetSectionKey

傳回 HKEY_CURRENT_USER\\"Software" \RegistryKey\AppName\lpszSection. 的金鑰

```
HKEY GetSectionKey(
    LPCTSTR lpszSection,
    CAtlTransactionManager* pTM = NULL);
```

### <a name="parameters"></a>參數

*lpszSection*<br/>
要取得的索引鍵名稱。

*pTM*<br/>
指向 `CAtlTransactionManager` 物件的指標。

### <a name="return-value"></a>傳回值

如果函式成功，則為區段索引鍵;否則為 Null。

### <a name="remarks"></a>備註

##  <a name="hideapplication"></a>CWinApp：： HideApplication

在關閉開啟的檔之前，呼叫這個成員函式來隱藏應用程式。

```
void HideApplication();
```

##  <a name="htmlhelp"></a>CWinApp：： HtmlHelp

呼叫這個成員函式來叫用 HTMLHelp 應用程式。

```
virtual void HtmlHelp(
    DWORD_PTR dwData,
    UINT nCmd = 0x000F);
```

### <a name="parameters"></a>參數

*dwData*<br/>
指定其他資料。 使用的值取決於*nCmd*參數的值。 預設為 `0x000F` 表示[HH_HELP_CONTEXT](/previous-versions/windows/desktop/htmlhelp/hh-help-context-command)。

*nCmd*<br/>
指定要求的說明類型。 如需可能值的清單，以及它們如何影響*dwData*參數，請參閱 Windows SDK 的[HtmlHelpW](/windows/win32/api/htmlhelp/nf-htmlhelp-htmlhelpw)或[HtmlHelpA](/windows/win32/api/htmlhelp/nf-htmlhelp-htmlhelpa) API 函式中所述的*uCommand*參數。 

### <a name="remarks"></a>備註

此架構也會呼叫這個函式來叫用 HTMLHelp 應用程式。

當您的應用程式終止時，架構會自動關閉 HTMLHelp 應用程式。

##  <a name="initinstance"></a>CWinApp：： InitInstance

Windows 允許相同程式的數個複本同時執行。

```
virtual BOOL InitInstance();
```

### <a name="return-value"></a>傳回值

如果初始化成功，則為非零;否則為0。

### <a name="remarks"></a>備註

應用程式初始化在概念上分成兩個部分：第一次執行程式時完成的一次性應用程式初始化，以及在每次執行程式時執行的實例初始化，包括第一次。 架構的 `WinMain` 的執行會呼叫這個函式。

覆寫 `InitInstance`，以初始化在 Windows 下執行之應用程式的每個新實例。 一般來說，您會覆寫 `InitInstance` 來建立主視窗物件，並將 `CWinThread::m_pMainWnd` 資料成員設定為指向該視窗。 如需覆寫此成員函式的詳細資訊，請參閱[CWinApp：應用程式類別](../../mfc/cwinapp-the-application-class.md)。

> [!NOTE]
> MFC 應用程式必須初始化為單一執行緒單元（STA）。 如果您在 `InitInstance` 覆寫中呼叫[CoInitializeEx](/windows/win32/api/combaseapi/nf-combaseapi-coinitializeex) ，請指定 COINIT_APARTMENTTHREADED （而不是 COINIT_MULTITHREADED）。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCListView#9](../../atl/reference/codesnippet/cpp/cwinapp-class_10.cpp)]

##  <a name="istaskbarinteractionenabled"></a>CWinApp：： IsTaskbarInteractionEnabled

指出是否已啟用 Windows 7 工作列互動。

```
virtual BOOL IsTaskbarInteractionEnabled();
```

### <a name="return-value"></a>傳回值

如果已呼叫 `EnableTaskbarInteraction`，而且作業系統是 Windows 7 或更新版本，則傳回 TRUE。

### <a name="remarks"></a>備註

工作列互動表示 MDI 應用程式會在滑鼠指標停留在應用程式工作列按鈕上方時，顯示個別索引標籤式縮圖中的 MDI 子系內容。

##  <a name="loadcursor"></a>CWinApp：： LoadCursor

載入由*lpszResourceName*命名的資料指標資源，或由*nIDResource*從目前的可執行檔指定。

```
HCURSOR LoadCursor(LPCTSTR lpszResourceName) const;  HCURSOR LoadCursor(UINT nIDResource) const;
```

### <a name="parameters"></a>參數

*lpszResourceName*<br/>
指向以 null 終止的字串，其中包含資料指標資源的名稱。 您可以使用這個引數的 `CString`。

*nIDResource*<br/>
資料指標資源的識別碼。 如需資源的清單，請參閱 Windows SDK 中的[LoadCursor](/windows/win32/api/winuser/nf-winuser-loadcursorw) 。

### <a name="return-value"></a>傳回值

如果成功，則為數據指標的控制碼;否則為 Null。

### <a name="remarks"></a>備註

`LoadCursor` 只有在先前尚未載入時，才會將資料指標載入至記憶體;否則，它會抓取現有資源的控制碼。

使用[LoadStandardCursor](#loadstandardcursor)或[LoadOEMCursor](#loadoemcursor)成員函式來存取預先定義的 Windows 資料指標。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#44](../../mfc/reference/codesnippet/cpp/cwinapp-class_11.cpp)]

##  <a name="loadicon"></a>CWinApp：： LoadIcon

載入*lpszResourceName*所命名的圖示資源，或由*nIDResource*從可執行檔指定。

```
HICON LoadIcon(LPCTSTR lpszResourceName) const;  HICON LoadIcon(UINT nIDResource) const;
```

### <a name="parameters"></a>參數

*lpszResourceName*<br/>
指向以 null 終止的字串，其中包含圖示資源的名稱。 您也可以使用這個引數的 `CString`。

*nIDResource*<br/>
圖示資源的識別碼。

### <a name="return-value"></a>傳回值

如果成功，則為圖示的控制碼;否則為 Null。

### <a name="remarks"></a>備註

`LoadIcon` 只會載入先前尚未載入的圖示;否則，它會抓取現有資源的控制碼。

您可以使用[LoadStandardIcon](#loadstandardicon)或[LoadOEMIcon](#loadoemicon)成員函式來存取預先定義的 Windows 圖示。

> [!NOTE]
> 此成員函式會呼叫 WIN32 API 函式[LoadIcon](/windows/win32/api/winuser/nf-winuser-loadiconw)，它只能載入大小符合 SM_CXICON 的圖示，並 SM_CYICON 系統度量值。

##  <a name="loadoemcursor"></a>CWinApp：： LoadOEMCursor

載入*nIDCursor*指定的 Windows 預先定義的資料指標資源。

```
HCURSOR LoadOEMCursor(UINT nIDCursor) const;
```

### <a name="parameters"></a>參數

*nIDCursor*<br/>
指定預先定義之 Windows 資料指標的**OCR_** 資訊清單常數識別碼。 您必須先擁有 `#define OEMRESOURCE`，才能 `#include \<afxwin.h>` 取得 WINDOWS 中**OCR_** 常數的存取權。H.

### <a name="return-value"></a>傳回值

如果成功，則為數據指標的控制碼;否則為 Null。

### <a name="remarks"></a>備註

使用 `LoadOEMCursor` 或[LoadStandardCursor](#loadstandardcursor)成員函式來存取預先定義的 Windows 資料指標。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#45](../../mfc/reference/codesnippet/cpp/cwinapp-class_12.h)]

[!code-cpp[NVC_MFCWindowing#46](../../mfc/reference/codesnippet/cpp/cwinapp-class_13.cpp)]

##  <a name="loadoemicon"></a>CWinApp：： LoadOEMIcon

載入*nIDIcon*指定的 Windows 預先定義圖示資源。

```
HICON LoadOEMIcon(UINT nIDIcon) const;
```

### <a name="parameters"></a>參數

*nIDIcon*<br/>
**OIC_** 的資訊清單常數識別碼，指定預先定義的 Windows 圖示。 您必須先擁有 `#define OEMRESOURCE`，才能 `#include \<afxwin.h>` 存取 WINDOWS 中的**OIC_** 常數。H.

### <a name="return-value"></a>傳回值

如果成功，則為圖示的控制碼;否則為 Null。

### <a name="remarks"></a>備註

使用 `LoadOEMIcon` 或[LoadStandardIcon](#loadstandardicon)成員函式來存取預先定義的 Windows 圖示。

##  <a name="loadstandardcursor"></a>CWinApp：： LoadStandardCursor

載入*lpszCursorName*指定的 Windows 預先定義的資料指標資源。

```
HCURSOR LoadStandardCursor(LPCTSTR lpszCursorName) const;
```

### <a name="parameters"></a>參數

*lpszCursorName*<br/>
指定預先定義之 Windows 資料指標的**IDC_** 資訊清單常數識別碼。 這些識別碼會在 WINDOWS 中定義。H. 下列清單顯示*lpszCursorName*的可能預先定義值和意義：

- IDC_ARROW 標準箭號游標

- IDC_IBEAM 標準文字插入游標

- 當 Windows 執行耗時的工作時，使用 IDC_WAIT 沙漏游標

- IDC_CROSS 選取範圍的交叉線游標

- IDC_UPARROW 箭號

- IDC_SIZE 已淘汰且不受支援;使用 IDC_SIZEALL

- IDC_SIZEALL 四個指向的箭號。 要用來調整視窗大小的游標。

- IDC_ICON 已淘汰且不受支援。 使用 IDC_ARROW。

- IDC_SIZENWSE 雙向箭號，結尾為左上方和右下方

- IDC_SIZENESW 雙向箭號，其結尾為右上和左下方

- IDC_SIZEWE 水準雙箭頭

- IDC_SIZENS 垂直雙箭頭

### <a name="return-value"></a>傳回值

如果成功，則為數據指標的控制碼;否則為 Null。

### <a name="remarks"></a>備註

使用 `LoadStandardCursor` 或[LoadOEMCursor](#loadoemcursor)成員函式來存取預先定義的 Windows 資料指標。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#47](../../mfc/reference/codesnippet/cpp/cwinapp-class_14.cpp)]

##  <a name="loadstandardicon"></a>CWinApp：： LoadStandardIcon

載入*lpszIconName*指定的 Windows 預先定義圖示資源。

```
HICON LoadStandardIcon(LPCTSTR lpszIconName) const;
```

### <a name="parameters"></a>參數

*lpszIconName*<br/>
資訊清單常數識別碼，指定預先定義的 Windows 圖示。 這些識別碼會在 WINDOWS 中定義。H. 如需可能預先定義的值及其描述的清單，請參閱 Windows SDK 中[LoadIcon](/windows/win32/api/winuser/nf-winuser-loadiconw)的*lpIconName*參數。

### <a name="return-value"></a>傳回值

如果成功，則為圖示的控制碼;否則為 Null。

### <a name="remarks"></a>備註

使用 `LoadStandardIcon` 或[LoadOEMIcon](#loadoemicon)成員函式來存取預先定義的 Windows 圖示。

##  <a name="loadstdprofilesettings"></a>CWinApp：： LoadStdProfileSettings

從[InitInstance](#initinstance)成員函式中呼叫這個成員函式，以啟用和載入最近使用過的（MRU）檔案和上次預覽狀態的清單。

```
void LoadStdProfileSettings(UINT nMaxMRU = _AFX_MRU_COUNT);
```

### <a name="parameters"></a>參數

*nMaxMRU*<br/>
要追蹤的最近使用的檔案數目。

### <a name="remarks"></a>備註

如果*nMaxMRU*為0，則不會維護任何 MRU 清單。

##  <a name="m_bhelpmode"></a>CWinApp：： m_bHelpMode

如果應用程式處於說明內容模式（使用 SHIFT + F1 來叫用），則為 TRUE;否則為 FALSE。

```
BOOL m_bHelpMode;
```

### <a name="remarks"></a>備註

在說明內容模式中，游標會變成問號，使用者可以將它移到畫面上。 如果您想要在 [說明] 模式中執行特殊處理，請檢查此旗標。 `m_bHelpMode` 是 BOOL 類型的公用變數。

##  <a name="m_dwrestartmanagersupportflags"></a>CWinApp：： m_dwRestartManagerSupportFlags

判斷重新開機管理員運作方式的旗標。

```
DWORD m_dwRestartManagerSupportFlags;
```

### <a name="remarks"></a>備註

若要啟用重新開機管理員，請將 `m_dwRestartManagerSupportFlags` 設為您想要的行為。 下表顯示可用的旗標。

|||
|-|-|
|旗標|描述|
|AFX_RESTART_MANAGER_SUPPORT_RESTART|應用程式是使用[CWinApp：： RegisterWithRestartManager](#registerwithrestartmanager)進行註冊。 重新開機管理員會負責重新開機應用程式（如果它意外結束）。|
|-AFX_RESTART_MANAGER_SUPPORT_RECOVERY|應用程式會向重新開機管理員註冊，而重新開機管理員會在重新開機應用程式時呼叫修復回呼函式。 預設的復原回呼函式為[CWinApp：： ApplicationRecoveryCallback](#applicationrecoverycallback)。|
|-AFX_RESTART_MANAGER_AUTOSAVE_AT_RESTART|[自動儲存] 已啟用，而重新開機管理員會在應用程式重新開機時 autosaves 任何開啟的檔。|
|-AFX_RESTART_MANAGER_AUTOSAVE_AT_INTERVAL|[自動儲存] 已啟用，而重新開機管理員會定期 autosaves 任何開啟的檔。 間隔是由[CWinApp：： m_nAutosaveInterval](#m_nautosaveinterval)所定義。|
|-AFX_RESTART_MANAGER_REOPEN_PREVIOUS_FILES|重新開機管理員會在從非預期的結束重新開機應用程式之後，開啟先前開啟的檔。 [CDataRecoveryHandler 類別](../../mfc/reference/cdatarecoveryhandler-class.md)會處理已開啟檔的清單，並加以還原。|
|-AFX_RESTART_MANAGER_RESTORE_AUTOSAVED_FILES|重新開機管理員會在重新開機應用程式後提示使用者還原自動儲存的檔案。 `CDataRecoveryHandler` 類別會查詢使用者。|
|-AFX_RESTART_MANAGER_SUPPORT_NO_AUTOSAVE|AFX_RESTART_MANAGER_SUPPORT_RESTART、AFX_RESTART_MANAGER_SUPPORT_RECOVER 和 AFX_RESTART_MANAGER_REOPEN_PREVIOUS_FILES 的聯集。|
|-AFX_RESTART_MANAGER_SUPPORT_ALL_ASPECTS|AFX_RESTART_MANAGER_SUPPORT_NO_AUTOSAVE、AFX_RESTART_MANAGER_AUTOSAVE_AT_RESTART、AFX_RESTART_MANAGER_AUTOSAVE_AT_INTERVAL 和 AFX_RESTART_MANAGER_RESTORE_AUTOSAVED_FILES 的聯集。|
|-AFX_RESTART_MANAGER_SUPPORT_RESTART_ASPECTS|AFX_RESTART_MANAGER_SUPPORT_RESTART、AFX_RESTART_MANAGER_AUTOSAVE_AT_RESTART、AFX_RESTART_MANAGER_REOPEN_PREVIOUS_FILES 和 AFX_RESTART_MANAGER_RESTORE_AUTOSAVED_FILES 的聯集。|
|-AFX_RESTART_MANAGER_SUPPORT_RECOVERY_ASPECTS|聯集 ofAFX_RESTART_MANAGER_SUPPORT_RECOVERY、AFX_RESTART_MANAGER_AUTOSAVE_AT_INTERVAL、AFX_RESTART_MANAGER_REOPEN_PREVIOUS_FILES 和 AFX_RESTART_MANAGER_RESTORE_AUTOSAVED_FILES。|

##  <a name="m_ehelptype"></a>CWinApp：： m_eHelpType

這個資料成員的型別是 AFX_HELP_TYPE 的列舉型別，它是在 `CWinApp` 類別內定義的。

```
AFX_HELP_TYPE m_eHelpType;
```

### <a name="remarks"></a>備註

AFX_HELP_TYPE 列舉的定義如下：

```
enum AFX_HELP_TYPE {
    afxWinHelp = 0,
    afxHTMLHelp = 1
    };
```

- 若要將應用程式的說明設定為 HTML 說明，請呼叫[SetHelpMode](#sethelpmode)並指定 `afxHTMLHelp`。

- 若要將應用程式的說明設定為 WinHelp，請呼叫 `SetHelpMode` 並指定 `afxWinHelp`。

##  <a name="m_hinstance"></a>CWinApp：： m_hInstance

對應至 Windows 傳遞給 `WinMain`的*hInstance*參數。

```
HINSTANCE m_hInstance;
```

### <a name="remarks"></a>備註

`m_hInstance` 資料成員是在 Windows 下執行之應用程式的目前實例的控制碼。 這是由全域函數[AfxGetInstanceHandle](application-information-and-management.md#afxgetinstancehandle)傳回。 `m_hInstance` 是 HINSTANCE 類型的公用變數。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#55](../../mfc/reference/codesnippet/cpp/cwinapp-class_15.cpp)]

##  <a name="m_lpcmdline"></a>CWinApp：： m_lpCmdLine

對應至 Windows 傳遞給 `WinMain`的*lpCmdLine*參數。

```
LPTSTR m_lpCmdLine;
```

### <a name="remarks"></a>備註

指向以 null 終止的字串，指定應用程式的命令列。 使用 `m_lpCmdLine` 來存取使用者在啟動應用程式時所輸入的任何命令列引數。 `m_lpCmdLine` 是 LPTSTR 類型的公用變數。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#52](../../mfc/reference/codesnippet/cpp/cwinapp-class_16.cpp)]

##  <a name="m_nautosaveinterval"></a>CWinApp：： m_nAutosaveInterval

Autosaves 之間的時間長度（以毫秒為單位）。

```
int m_nAutosaveInterval;
```

### <a name="remarks"></a>備註

您可以設定 [重新開機管理員]，以設定的間隔自動儲存開啟的檔。 如果您的應用程式不會自動儲存檔案，則此參數不會有任何作用。

##  <a name="m_ncmdshow"></a>CWinApp：： m_nCmdShow

對應至 Windows 傳遞給 `WinMain`的*nCmdShow*參數。

```
int m_nCmdShow;
```

### <a name="remarks"></a>備註

當您針對應用程式的主視窗呼叫[CWnd：： ShowWindow](../../mfc/reference/cwnd-class.md#showwindow)時，應該傳遞 `m_nCmdShow` 做為引數。 `m_nCmdShow` 是**int**類型的公用變數。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#56](../../mfc/reference/codesnippet/cpp/cwinapp-class_17.cpp)]

##  <a name="m_pactivewnd"></a>CWinApp：： m_pActiveWnd

您可以使用這個資料成員，將指標儲存至 OLE 容器應用程式的主視窗中，並讓您的 OLE 伺服器應用程式就地啟用。

### <a name="remarks"></a>備註

如果此資料成員為 Null，應用程式就不會就地啟用。

當框架視窗是由 OLE 容器應用程式就地啟用時，此架構會設定這個成員變數。

##  <a name="m_pdatarecoveryhandler"></a>CWinApp：： m_pDataRecoveryHandler

應用程式之資料復原處理常式的指標。

```
CDataRecoveryHandler* m_pDataRecoveryHandler;
```

### <a name="remarks"></a>備註

應用程式的資料修復處理常式會監視開啟的檔，並加以 autosaves。 當應用程式意外結束後重新開機時，此架構會使用資料復原處理常式來還原自動儲存的檔案。 如需詳細資訊，請參閱[CDataRecoveryHandler 類別](../../mfc/reference/cdatarecoveryhandler-class.md)。

##  <a name="m_pszappname"></a>CWinApp：： m_pszAppName

指定應用程式的名稱。

```
LPCTSTR m_pszAppName;
```

### <a name="remarks"></a>備註

應用程式名稱可以來自傳遞至[CWinApp](#cwinapp)函式的參數，或如果未指定，則會是識別碼為 AFX_IDS_APP_TITLE 的資源字串。 如果在資源中找不到應用程式名稱，則來自程式的。EXE 檔案名。

由全域函數[AfxGetAppName](application-information-and-management.md#afxgetappname)傳回。 `m_pszAppName` 是**const char** <strong>\*</strong>類型的公用變數。

> [!NOTE]
> 如果您將值指派給 `m_pszAppName`，它就必須在堆積上動態配置。 `CWinApp` 的析構函式會使用這個指標呼叫**free**（）。 您想要使用 `_tcsdup`（）執行時間程式庫函式來進行配置。 此外，在指派新值之前，請先釋放與目前指標相關聯的記憶體。 例如，

[!code-cpp[NVC_MFCWindowing#57](../../mfc/reference/codesnippet/cpp/cwinapp-class_18.cpp)]

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#65](../../mfc/reference/codesnippet/cpp/cwinapp-class_19.cpp)]

##  <a name="m_pszexename"></a>CWinApp：： m_pszExeName

包含應用程式可執行檔的名稱，但不含副檔名。

```
LPCTSTR m_pszExeName;
```

### <a name="remarks"></a>備註

不同于[m_pszAppName](#m_pszappname)，此名稱不能包含空白。 `m_pszExeName` 是**const char** <strong>\*</strong>類型的公用變數。

> [!NOTE]
> 如果您將值指派給 `m_pszExeName`，它就必須在堆積上動態配置。 `CWinApp` 的析構函式會使用這個指標呼叫**free**（）。 您想要使用 `_tcsdup`（）執行時間程式庫函式來進行配置。 此外，在指派新值之前，請先釋放與目前指標相關聯的記憶體。 例如，

[!code-cpp[NVC_MFCWindowing#58](../../mfc/reference/codesnippet/cpp/cwinapp-class_20.cpp)]

##  <a name="m_pszhelpfilepath"></a>CWinApp：： m_pszHelpFilePath

包含應用程式說明檔的路徑。

```
LPCTSTR m_pszHelpFilePath;
```

### <a name="remarks"></a>備註

根據預設，架構會將 `m_pszHelpFilePath` 初始化為具有 "的應用程式名稱。未附加的「.HLP」。 若要變更說明檔的名稱，請將 `m_pszHelpFilePath` 設定為指向包含所需說明檔完整名稱的字串。 執行此動作的方便位置是在應用程式的[InitInstance](#initinstance)函數中。 `m_pszHelpFilePath` 是**const char** <strong>\*</strong>類型的公用變數。

> [!NOTE]
> 如果您將值指派給 `m_pszHelpFilePath`，它就必須在堆積上動態配置。 `CWinApp` 的析構函式會使用這個指標呼叫**free**（）。 您想要使用 `_tcsdup`（）執行時間程式庫函式來進行配置。 此外，在指派新值之前，請先釋放與目前指標相關聯的記憶體。 例如，

[!code-cpp[NVC_MFCWindowing#59](../../mfc/reference/codesnippet/cpp/cwinapp-class_21.cpp)]

##  <a name="m_pszprofilename"></a>CWinApp：： m_pszProfileName

包含應用程式的名稱。INI 檔案。

```
LPCTSTR m_pszProfileName;
```

### <a name="remarks"></a>備註

`m_pszProfileName` 是**const char** <strong>\*</strong>類型的公用變數。

> [!NOTE]
> 如果您將值指派給 `m_pszProfileName`，它就必須在堆積上動態配置。 `CWinApp` 的析構函式會使用這個指標呼叫**free**（）。 您想要使用 `_tcsdup`（）執行時間程式庫函式來進行配置。 此外，在指派新值之前，請先釋放與目前指標相關聯的記憶體。 例如，

[!code-cpp[NVC_MFCWindowing#60](../../mfc/reference/codesnippet/cpp/cwinapp-class_22.cpp)]

##  <a name="m_pszregistrykey"></a>CWinApp：： m_pszRegistryKey

用來判斷在登錄或 INI 檔案中，應用程式佈建檔設定的儲存位置。

```
LPCTSTR m_pszRegistryKey;
```

### <a name="remarks"></a>備註

一般來說，此資料成員會被視為唯讀。

- 值會儲存在登錄機碼中。 應用程式佈建檔設定的名稱會附加至下列登錄機碼： HKEY_CURRENT_USER/Software/LocalAppWizard-Generated/。

如果您將值指派給 `m_pszRegistryKey`，它就必須在堆積上動態配置。 `CWinApp` 的析構函式會使用這個指標呼叫**free**（）。 您想要使用 `_tcsdup`（）執行時間程式庫函式來進行配置。 此外，在指派新值之前，請先釋放與目前指標相關聯的記憶體。 例如，

[!code-cpp[NVC_MFCWindowing#61](../../mfc/reference/codesnippet/cpp/cwinapp-class_23.cpp)]

##  <a name="m_pszappid"></a>CWinApp：： m_pszAppID

應用程式使用者模型識別碼。

```
LPCTSTR m_pszAppID;
```

### <a name="remarks"></a>備註

##  <a name="oncontexthelp"></a>CWinApp：： OnCoNtextHelp

處理應用程式內的 SHIFT + F1 說明。

```
afx_msg void OnContextHelp();
```

### <a name="remarks"></a>備註

您必須將 `ON_COMMAND( ID_CONTEXT_HELP, OnContextHelp )` 語句加入至 `CWinApp` 類別訊息對應，同時加入快速鍵對應表專案（通常是 SHIFT + F1），才能啟用此成員函式。

`OnContextHelp` 會讓應用程式進入說明模式。 游標會變更為箭號和問號，然後使用者可以移動滑鼠指標，然後按下滑鼠左鍵，以選取對話方塊、視窗、功能表或命令按鈕。 此成員函式會抓取游標底下物件的說明內容，並使用該說明內容呼叫 Windows 函式 WinHelp。

##  <a name="onddecommand"></a>CWinApp：： OnDDECommand

當主框架視窗收到 DDE 執行訊息時，由架構呼叫。

```
virtual BOOL OnDDECommand(LPTSTR lpszCommand);
```

### <a name="parameters"></a>參數

*lpszCommand*<br/>
指向應用程式收到的 DDE 命令字串。

### <a name="return-value"></a>傳回值

如果已處理此命令，則為非零值。否則為0。

### <a name="remarks"></a>備註

預設的執行會檢查命令是否為開啟檔的要求，如果是，則會開啟指定的檔。 當使用者按兩下資料檔案時，Windows 檔案管理員通常會傳送這類 DDE 命令字串。 覆寫此函式以處理其他 DDE 執行命令，例如要列印的命令。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#48](../../mfc/reference/codesnippet/cpp/cwinapp-class_24.cpp)]

##  <a name="onfilenew"></a>CWinApp：： OnFileNew

執行 ID_FILE_NEW 命令。

```
afx_msg void OnFileNew();
```

### <a name="remarks"></a>備註

您必須將 `ON_COMMAND( ID_FILE_NEW, OnFileNew )` 語句加入 `CWinApp` 類別訊息對應中，才能啟用此成員函式。 啟用時，此函式會處理檔案 New 命令的執行。

如需預設行為的資訊，以及如何覆寫此成員函式的指引，請參閱[技術提示 22](../../mfc/tn022-standard-commands-implementation.md) 。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#49](../../mfc/reference/codesnippet/cpp/cwinapp-class_25.cpp)]

[!code-cpp[NVC_MFCWindowing#50](../../mfc/reference/codesnippet/cpp/cwinapp-class_26.cpp)]

##  <a name="onfileopen"></a>CWinApp：： OnFileOpen

執行 ID_FILE_OPEN 命令。

```
afx_msg void OnFileOpen();
```

### <a name="remarks"></a>備註

您必須將 `ON_COMMAND( ID_FILE_OPEN, OnFileOpen )` 語句加入 `CWinApp` 類別訊息對應中，才能啟用此成員函式。 若啟用此函式，此函式會處理檔案 Open 命令的執行。

如需有關如何覆寫此成員函式的預設行為和指引的詳細資訊，請參閱[技術提示 22](../../mfc/tn022-standard-commands-implementation.md)。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#49](../../mfc/reference/codesnippet/cpp/cwinapp-class_25.cpp)]

[!code-cpp[NVC_MFCWindowing#50](../../mfc/reference/codesnippet/cpp/cwinapp-class_26.cpp)]

##  <a name="onfileprintsetup"></a>CWinApp：： OnFilePrintSetup

執行 ID_FILE_PRINT_SETUP 命令。

```
afx_msg void OnFilePrintSetup();
```

### <a name="remarks"></a>備註

您必須將 `ON_COMMAND( ID_FILE_PRINT_SETUP, OnFilePrintSetup )` 語句加入 `CWinApp` 類別訊息對應中，才能啟用此成員函式。 啟用時，此函式會處理檔案列印命令的執行。

如需有關如何覆寫此成員函式的預設行為和指引的詳細資訊，請參閱[技術提示 22](../../mfc/tn022-standard-commands-implementation.md)。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#49](../../mfc/reference/codesnippet/cpp/cwinapp-class_25.cpp)]

[!code-cpp[NVC_MFCWindowing#50](../../mfc/reference/codesnippet/cpp/cwinapp-class_26.cpp)]

##  <a name="onhelp"></a>CWinApp：： OnHelp

在應用程式 (使用目前的內容) 中處理 F1 說明。

```
afx_msg void OnHelp();
```

### <a name="remarks"></a>備註

通常您也會加入 F1 鍵的快速鍵專案。 啟用 F1 鍵只是慣例，不是必要條件。

您必須將 `ON_COMMAND( ID_HELP, OnHelp )` 語句加入 `CWinApp` 類別訊息對應中，才能啟用此成員函式。 啟用時，由架構在使用者按下 F1 鍵時呼叫。

這個訊息處理常式函式的預設執行會決定對應至目前視窗、對話方塊或功能表項目的說明內容，然後呼叫 WINHELP。CONVERT.EXE. 如果目前沒有可用的內容，此函數會使用預設內容。

覆寫這個成員函式，將說明內容設定為視窗、對話方塊、功能表項目或工具列按鈕（目前具有焦點）以外的內容。 使用所需的說明內容識別碼來呼叫 `WinHelp`。

##  <a name="onhelpfinder"></a>CWinApp：： OnHelpFinder

處理 ID_HELP_FINDER 和 ID_DEFAULT_HELP 命令。

```
afx_msg void OnHelpFinder();
```

### <a name="remarks"></a>備註

您必須將 `ON_COMMAND( ID_HELP_FINDER, OnHelpFinder )` 語句加入 `CWinApp` 類別訊息對應中，才能啟用此成員函式。 啟用時，當應用程式的使用者選取 [說明搜尋工具] 命令來叫用標準**HELP_FINDER**主題的 `WinHelp` 時，架構會呼叫這個訊息處理常式函式。

##  <a name="onhelpindex"></a>CWinApp：： OnHelpIndex

處理 ID_HELP_INDEX 命令，並提供預設說明主題。

```
afx_msg void OnHelpIndex();
```

### <a name="remarks"></a>備註

您必須將 `ON_COMMAND( ID_HELP_INDEX, OnHelpIndex )` 語句加入 `CWinApp` 類別訊息對應中，才能啟用此成員函式。 啟用時，當應用程式的使用者選取 [說明索引] 命令來叫用標準**HELP_INDEX**主題的 `WinHelp` 時，架構會呼叫這個訊息處理常式函式。

##  <a name="onhelpusing"></a>CWinApp：： OnHelpUsing

處理 ID_HELP_USING 命令。

```
afx_msg void OnHelpUsing();
```

### <a name="remarks"></a>備註

您必須將 `ON_COMMAND( ID_HELP_USING, OnHelpUsing )` 語句加入 `CWinApp` 類別訊息對應中，才能啟用此成員函式。 當您應用程式的使用者使用命令來叫用 `WinHelp` 應用程式時，架構會呼叫這個訊息處理常式函式，以標準**HELP_HELPONHELP**主題。

##  <a name="onidle"></a>CWinApp：： OnIdle

覆寫此成員函式以執行閒置時間處理。

```
virtual BOOL OnIdle(LONG lCount);
```

### <a name="parameters"></a>參數

*lCount*<br/>
當應用程式的訊息佇列是空的時，每次呼叫 `OnIdle` 時，計數器就會遞增。 每次處理新訊息時，此計數就會重設為0。 您可以使用*lCount*參數來判斷應用程式閒置而不處理訊息的相對時間長度。

### <a name="return-value"></a>傳回值

非零以接收更多閒置處理時間;如果不需要更多閒置時間，則為0。

### <a name="remarks"></a>備註

當應用程式的訊息佇列是空的時，會在預設訊息迴圈中呼叫 `OnIdle`。 使用您的覆寫來呼叫您自己的背景閒置處理常式工作。

`OnIdle` 應傳回0，表示不需要閒置處理時間。 每當訊息佇列為空白時， *lCount*參數會 `OnIdle` 遞增，而且每次處理新訊息時，都會重設為0。 您可以根據此計數來呼叫不同的閒置常式。

以下摘要說明閒置迴圈處理：

1. 如果 MFC 程式庫中的訊息迴圈檢查訊息佇列並找不到擱置中的訊息，它會呼叫應用程式物件的 `OnIdle`，並提供0作為*lCount*引數。

2. `OnIdle` 會執行一些處理，並傳回非零值，以指出應該再次呼叫它來執行進一步的處理。

3. 訊息迴圈會再次檢查訊息佇列。 如果沒有擱置中的訊息，它會再次呼叫 `OnIdle`，遞增*lCount*引數。

4. 最後，`OnIdle` 會完成其所有閒置工作的處理，並傳回0。 這會告知訊息迴圈停止呼叫 `OnIdle`，直到從訊息佇列接收下一個訊息為止，此時會重新開機閒置迴圈，並將引數設定為0。

請不要在 `OnIdle` 期間執行冗長的工作，因為您的應用程式無法處理使用者輸入，直到 `OnIdle` 傳回為止。

> [!NOTE]
> `OnIdle` 的預設執行會更新命令使用者介面物件（例如功能表項目和工具列按鈕），並執行內部資料結構清除。 因此，如果您覆寫 `OnIdle`，就必須使用覆寫版本中的 `lCount` 來呼叫 `CWinApp::OnIdle`。 首先呼叫所有的基類閒置處理（也就是，直到基類 `OnIdle` 傳回0）。 如果您需要在基類處理完成之前執行工作，請檢查基類的執行，以選取適當的*lCount* ，在此期間執行您的工作。

如果您不想要在每次從訊息佇列中抓取訊息時呼叫 `OnIdle`，您可以覆寫[CWinThreadIsIdleMessage](../../mfc/reference/cwinthread-class.md#isidlemessage)。 如果應用程式已設定非常短的計時器，或系統正在傳送 WM_SYSTIMER 訊息，則 `OnIdle` 會重複呼叫，並降低效能。

### <a name="example"></a>範例

下列兩個範例示範如何使用 `OnIdle`。 第一個範例會使用*lCount*引數來處理兩個閒置工作，以排定工作的優先順序。 第一個工作是高優先順序，而且您應該盡可能執行。 第二個工作較不重要，只有在使用者輸入中有長時間暫停時才會執行。 請注意 `OnIdle`的基類版本呼叫。 第二個範例會管理具有不同優先順序的閒置工作群組。

[!code-cpp[NVC_MFCWindowing#51](../../mfc/reference/codesnippet/cpp/cwinapp-class_27.cpp)]

##  <a name="opendocumentfile"></a>CWinApp：： OpenDocumentFile

架構會呼叫這個方法來開啟應用程式的已命名[CDocument](../../mfc/reference/cdocument-class.md)檔。

```
virtual CDocument* OpenDocumentFile(
    LPCTSTR lpszFileName
    BOOL bAddToMRU = TRUE);
```

### <a name="parameters"></a>參數

*lpszFileName*<br/>
在要開啟的檔案名。

*bAddToMRU*<br/>
在TRUE 表示檔是最新的其中一個檔案;FALSE 表示檔不是其中一個最新的檔案。

### <a name="return-value"></a>傳回值

如果成功，則為 `CDocument` 的指標;否則為 Null。

### <a name="remarks"></a>備註

如果已經開啟具有該名稱的檔，則包含該檔的第一個框架視窗將會取得焦點。 如果應用程式支援多個檔範本，則架構會使用副檔名來尋找適當的檔範本，以便嘗試載入檔。 如果成功，檔範本會接著建立檔的框架視窗和視圖。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#52](../../mfc/reference/codesnippet/cpp/cwinapp-class_16.cpp)]

##  <a name="parsecommandline"></a>CWinApp：:P arseCommandLine

呼叫這個成員函式來剖析命令列，並將參數一次傳送至[CCommandLineInfo：:P arseparam](../../mfc/reference/ccommandlineinfo-class.md#parseparam)。

```
void ParseCommandLine(CCommandLineInfo& rCmdInfo);
```

### <a name="parameters"></a>參數

*rCmdInfo*<br/>
[CCommandLineInfo](../../mfc/reference/ccommandlineinfo-class.md)物件的參考。

### <a name="remarks"></a>備註

當您使用應用程式精靈啟動新的 MFC 專案時，應用程式精靈將會建立 `CCommandLineInfo`的本機實例，然後在[InitInstance](#initinstance)成員函式中呼叫 `ProcessShellCommand` 和 `ParseCommandLine`。 命令列會遵循下面所述的路由：

1. 在 `InitInstance`中建立之後，`CCommandLineInfo` 物件會傳遞至 `ParseCommandLine`。

2. `ParseCommandLine` 接著會針對每個參數重複呼叫 `CCommandLineInfo::ParseParam`。

3. `ParseParam` 會填滿 `CCommandLineInfo` 物件，然後將它傳遞給[ProcessShellCommand](#processshellcommand)。

4. `ProcessShellCommand` 會處理命令列引數和旗標。

請注意，您可以視需要直接呼叫 `ParseCommandLine`。

如需命令列旗標的說明，請參閱[CCommandLineInfo：： m_nShellCommand](../../mfc/reference/ccommandlineinfo-class.md#m_nshellcommand)。

##  <a name="pretranslatemessage"></a>CWinApp：:P reTranslateMessage

覆寫此函式以在將視窗訊息分派至 Windows 函式[TranslateMessage](/windows/win32/api/winuser/nf-winuser-translatemessage)之前進行篩選，並[DispatchMessage](/windows/win32/api/winuser/nf-winuser-dispatchmessage)預設的實作用會執行快速鍵轉譯，因此您必須在覆寫的版本中呼叫 `CWinApp::PreTranslateMessage` 成員函式。

```
virtual BOOL PreTranslateMessage(MSG* pMsg);
```

### <a name="parameters"></a>參數

*pMsg*<br/>
包含要處理之訊息的[MSG](/windows/win32/api/winuser/ns-winuser-msg)結構的指標。

### <a name="return-value"></a>傳回值

如果訊息已在 `PreTranslateMessage` 中完整處理，則為非零值，不應進一步處理。 如果應該以正常方式處理訊息，則為零。

##  <a name="processmessagefilter"></a>CWinApp：:P rocessMessageFilter

架構的攔截函式會呼叫這個成員函式來篩選和回應特定的 Windows 訊息。

```
virtual BOOL ProcessMessageFilter(
    int code,
    LPMSG lpMsg);
```

### <a name="parameters"></a>參數

*code*<br/>
指定勾點碼。 此成員函式會使用程式碼來判斷如何處理*lpMsg。*

*lpMsg*<br/>
Windows [MSG](/windows/win32/api/winuser/ns-winuser-msg)結構 t) 的指標。

### <a name="return-value"></a>傳回值

如果已處理訊息，則為非零值;否則為0。

### <a name="remarks"></a>備註

攔截函式會在事件傳送至應用程式的一般訊息處理之前，先處理它們。

如果您覆寫這個先進的功能，請務必呼叫基類版本來維護架構的攔截處理。

##  <a name="processshellcommand"></a>CWinApp：:P rocessShellCommand

[InitInstance](#initinstance)會呼叫這個成員函式，以接受從*rCmdInfo*所識別的 `CCommandLineInfo` 物件傳遞的參數，並執行指定的動作。

```
BOOL ProcessShellCommand(CCommandLineInfo& rCmdInfo);
```

### <a name="parameters"></a>參數

*rCmdInfo*<br/>
[CCommandLineInfo](../../mfc/reference/ccommandlineinfo-class.md)物件的參考。

### <a name="return-value"></a>傳回值

如果成功處理 shell 命令，則為非零。 如果是0，則從[InitInstance](#initinstance)傳回 FALSE。

### <a name="remarks"></a>備註

當您使用應用程式精靈啟動新的 MFC 專案時，應用程式精靈將會建立 `CCommandLineInfo`的本機實例，然後在 `InitInstance` 成員函式中呼叫 `ProcessShellCommand` 和[ParseCommandLine](#parsecommandline) 。 命令列會遵循下面所述的路由：

1. 在 `InitInstance`中建立之後，`CCommandLineInfo` 物件會傳遞至 `ParseCommandLine`。

2. `ParseCommandLine` 接著會針對每個參數重複呼叫[CCommandLineInfo：:P arseparam](../../mfc/reference/ccommandlineinfo-class.md#parseparam) 。

3. `ParseParam` 會填滿 `CCommandLineInfo` 物件，然後傳遞至 `ProcessShellCommand`。

4. `ProcessShellCommand` 會處理命令列引數和旗標。

[CCommandLineInfo：： m_nShellCommand](../../mfc/reference/ccommandlineinfo-class.md#m_nshellcommand)所識別之 `CCommandLineInfo` 物件的資料成員，屬於下列列舉類型，這是在 `CCommandLineInfo` 類別內定義的。

```
enum {
    FileNew,
    FileOpen,
    FilePrint,
    FilePrintTo,
    FileDDE
    };
```

如需每個值的簡短描述，請參閱 `CCommandLineInfo::m_nShellCommand`。

##  <a name="processwndprocexception"></a>CWinApp：:P rocessWndProcException

每當處理常式未攔截到您的其中一個應用程式訊息或命令處理常式中擲回的例外狀況時，架構就會呼叫這個成員函式。

```
virtual LRESULT ProcessWndProcException(
    CException* e,
    const MSG* pMsg);
```

### <a name="parameters"></a>參數

*e*<br/>
未攔截之例外狀況的指標。

*pMsg*<br/>
訊息[結構 t)，](/windows/win32/api/winuser/ns-winuser-msg)其中包含導致架構擲回例外狀況之 windows 訊息的相關資訊。

### <a name="return-value"></a>傳回值

應該傳回給 Windows 的值。 一般來說，這是 0L windows 訊息，1L （TRUE）的命令訊息。

### <a name="remarks"></a>備註

請勿直接呼叫此成員函式。

這個成員函式的預設實作用會建立訊息方塊。 如果未攔截的例外狀況是由功能表、工具列或快速鍵命令失敗所產生，則訊息方塊會顯示「命令失敗」訊息;否則，它會顯示「內部應用程式錯誤」訊息。

覆寫這個成員函式，以提供例外狀況的全域處理。 只有在您想要顯示訊息方塊時，才呼叫基底功能。

##  <a name="register"></a>CWinApp：： Register

執行 `RegisterShellFileTypes`未處理的任何註冊工作。

```
virtual BOOL Register();
```

### <a name="return-value"></a>傳回值

非零成功，否則為 0。

### <a name="remarks"></a>備註

預設的執行方式只會傳回 TRUE。 覆寫此函式以提供任何自訂的註冊步驟。

##  <a name="registershellfiletypes"></a>CWinApp：： RegisterShellFileTypes

呼叫此成員函式，以使用 Windows 檔案管理員來註冊您所有的應用程式檔案類型。

```
void RegisterShellFileTypes(BOOL bCompat = FALSE);
```

### <a name="parameters"></a>參數

*bCompat*<br/>
在TRUE 會將 shell 命令的註冊專案列印和列印到，讓使用者可以直接從 shell 列印檔案，或將檔案拖曳至印表機物件。 它也會新增 DefaultIcon 鍵。 根據預設，此參數為 FALSE 以提供回溯相容性。

### <a name="remarks"></a>備註

這可讓使用者在 [檔案管理員] 中按兩下，以開啟您的應用程式所建立的資料檔案。 在您針對應用程式中的每個檔範本呼叫[AddDocTemplate](#adddoctemplate)之後，請呼叫 `RegisterShellFileTypes`。 當您呼叫 `RegisterShellFileTypes`時，也會呼叫[新增 enableshellopen](#enableshellopen)成員函式。

`RegisterShellFileTypes` 會逐一查看應用程式所維護的[CDocTemplate](../../mfc/reference/cdoctemplate-class.md)物件清單，並針對每個檔範本，將專案新增至 Windows 為檔案關聯維護的註冊資料庫。 當使用者按兩下資料檔案時，檔案管理員會使用這些專案來開啟該檔案。 這樣就不需要寄送。REG 檔案與您的應用程式。

> [!NOTE]
> `RegisterShellFileTypes` 只有在使用者以系統管理員許可權執行程式時才有效。 如果程式沒有系統管理員許可權，就無法改變登錄機碼。

如果註冊資料庫已經將指定的副檔名與另一個檔案類型產生關聯，則不會建立新的關聯。 請參閱 `CDocTemplate` 類別，以取得註冊此資訊所需的字串格式。

##  <a name="registerwithrestartmanager"></a>CWinApp：： RegisterWithRestartManager

向重新開機管理員註冊應用程式。

```
virtual HRESULT RegisterWithRestartManager(
    BOOL bRegisterRecoveryCallback,
    const CString& strRestartIdentifier);

virtual HRESULT RegisterWithRestartManager(
    LPCWSTR pwzCommandLineArgs,
    DWORD dwRestartFlags,
    APPLICATION_RECOVERY_CALLBACK pRecoveryCallback,
    LPVOID lpvParam,
    DWORD dwPingInterval,
    DWORD dwCallbackFlags);
```

### <a name="parameters"></a>參數

|||
|-|-|
|參數|描述|
|*bRegisterRecoveryCallback*|在TRUE 表示應用程式的這個實例使用修復回呼函式;FALSE 表示它不是。 當應用程式意外結束時，架構會呼叫修復回呼函式。 如需詳細資訊，請參閱[CWinApp：： ApplicationRecoveryCallback](#applicationrecoverycallback)。|
|*strRestartIdentifier*|在識別重新開機管理員實例的唯一字串。 重新開機管理員識別碼對應用程式的每個實例而言是唯一的。|
|*pwzCommandLineArgs*|在字串，其中包含來自命令列的任何額外引數。|
|*dwRestartFlags*|在重新開機管理員的選擇性旗標。 如需詳細資訊，請參閱＜備註＞一節。|
|*pRecoveryCallback*|在復原回呼函數。 此函式必須接受 LPVOID 參數作為輸入，並傳回 DWORD。 預設的復原回呼函式為 `CWinApp::ApplicationRecoveryCallback`。|
|*lpvParam*|在復原回呼函數的輸入參數。 如需詳細資訊，請參閱[CWinApp：： ApplicationRecoveryCallback](#applicationrecoverycallback)。|
|*dwPingInterval*|在重新開機管理員等待復原回呼函數傳回的時間長度。 這個參數是以毫秒為單位。|
|*dwCallbackFlags*|在傳遞至修復回呼函式的旗標。 保留供未來使用。|

### <a name="return-value"></a>傳回值

如果方法成功，則 S_OK;否則為錯誤碼。

### <a name="remarks"></a>備註

如果您的應用程式使用自動儲存檔的預設 MFC 執行，您應該使用簡單版本的 `RegisterWithRestartManager`。 如果您想要自訂應用程式的自動儲存行為，請使用 `RegisterWithRestartManager` 的複雜版本。

如果您使用*strRestartIdentifier*的空字串來呼叫這個方法，`RegisterWithRestartManager` 會為重新啟動管理員的這個實例建立唯一的識別碼字串。

當應用程式意外結束時，重新開機管理員會從命令列重新開機應用程式，並提供唯一的重新開機識別碼做為選擇性引數。 在此案例中，架構會呼叫兩次 `RegisterWithRestartManager`。 第一次呼叫的來源是[CWinApp：： InitInstance](#initinstance) ，其字串識別碼為空字串。 然後，方法[CWinApp：:P rocessshellcommand](#processshellcommand)會以唯一的重新開機識別碼呼叫 `RegisterWithRestartManager`。

當您使用重新開機管理員註冊應用程式之後，重新開機管理員會監視應用程式。 如果應用程式意外結束，重新開機管理員會在關機程式期間呼叫復原回呼函式。 重新開機管理員會等待來自復原回呼函式的回應*dwPingInterval* 。 如果復原回呼函式在這段時間內沒有回應，應用程式就會結束，而不會執行復原回呼函數。

根據預設，不支援 dwRestartFlags，但提供供未來使用。 *DwRestartFlags*的可能值如下所示：

- RESTART_NO_CRASH

- RESTART_NO_HANG

- RESTART_NO_PATCH

- RESTART_NO_REBOOT

##  <a name="reopenpreviousfilesatrestart"></a>CWinApp：： ReopenPreviousFilesAtRestart

判斷當應用程式意外結束時，重新開機管理員是否重新開啟已開啟的檔案。

```
virtual BOOL ReopenPreviousFilesAtRestart() const;
```

### <a name="return-value"></a>傳回值

TRUE 表示重新開機管理員重新開啟先前開啟的檔案;FALSE 表示重新開機管理員不是。

##  <a name="restartinstance"></a>CWinApp：： RestartInstance

處理重新開機管理員起始的應用程式重新開機。

```
virtual BOOL CWinApp::RestartInstance();
```

### <a name="return-value"></a>傳回值

如果資料復原處理常式開啟先前開啟的檔，則為 TRUE;如果資料復原處理常式發生錯誤，或沒有先前開啟的檔，則為 FALSE。

### <a name="remarks"></a>備註

當重新開機管理員重新開機應用程式時，架構會呼叫這個方法。 這個方法會抓取資料修復處理常式，並還原自動儲存的檔案。 這個方法會呼叫[CDataRecoveryHandler：： RestoreAutosavedDocuments](../../mfc/reference/cdatarecoveryhandler-class.md#restoreautosaveddocuments)來判斷使用者是否想要還原自動儲存的檔案。

如果[CDataRecoveryHandler](../../mfc/reference/cdatarecoveryhandler-class.md)判斷沒有開啟的檔，這個方法會傳回 FALSE。 如果沒有開啟的檔，應用程式通常會啟動。

##  <a name="restoreautosavedfilesatrestart"></a>CWinApp：： RestoreAutosavedFilesAtRestart

判斷重新開機管理員是否會在重新開機應用程式時，還原自動儲存的檔案。

```
virtual BOOL RestoreAutosavedFilesAtRestart() const;
```

### <a name="return-value"></a>傳回值

TRUE 表示重新開機管理員會還原自動儲存的檔案;FALSE 表示重新開機管理員不是。

##  <a name="run"></a>CWinApp：： Run

提供預設訊息迴圈。

```
virtual int Run();
```

### <a name="return-value"></a>傳回值

`WinMain`傳回的**int**值。

### <a name="remarks"></a>備註

`Run` 取得和分派 Windows 訊息，直到應用程式收到 WM_QUIT 訊息為止。 如果應用程式的訊息佇列目前未包含任何訊息，`Run` 會呼叫[OnIdle](#onidle)來執行閒置時間處理。 傳入訊息會移至[PreTranslateMessage](#pretranslatemessage)成員函式進行特殊處理，然後傳送至 Windows 函式 `TranslateMessage` 進行標準鍵盤轉譯;最後，會呼叫 `DispatchMessage` Windows 函式。

`Run` 很少遭到覆寫，但是您可以覆寫它來提供特殊的行為。

##  <a name="runautomated"></a>CWinApp：： RunAutomated

呼叫此函式可判斷 " **/Automation**" 或 " **-Automation**" 選項是否存在，這表示用戶端應用程式是否啟動伺服器應用程式。

```
BOOL RunAutomated();
```

### <a name="return-value"></a>傳回值

如果找到選項，則為非零;否則為0。

### <a name="remarks"></a>備註

如果存在，則會從命令列中移除選項。 如需 OLE Automation 的詳細資訊，請參閱[Automation 伺服器](../../mfc/automation-servers.md)一文。

##  <a name="runembedded"></a>CWinApp：： RunEmbedded

呼叫此函式可判斷 " **/Embedding**" 或 " **-** 內嵌" 選項是否存在，這表示用戶端應用程式是否啟動伺服器應用程式。

```
BOOL RunEmbedded();
```

### <a name="return-value"></a>傳回值

如果找到選項，則為非零;否則為0。

### <a name="remarks"></a>備註

如果存在，則會從命令列中移除選項。 如需有關內嵌的詳細資訊，請參閱[伺服器：執行伺服器一](../../mfc/servers-implementing-a-server.md)文。

##  <a name="saveallmodified"></a>CWinApp：： SaveAllModified

由架構呼叫，以在應用程式的主框架視窗關閉時儲存所有檔，或透過 WM_QUERYENDSESSION 訊息。

```
virtual BOOL SaveAllModified();
```

### <a name="return-value"></a>傳回值

如果可以安全地終止應用程式，則為非零值。0，表示不安全地終止應用程式。

### <a name="remarks"></a>備註

此成員函式的預設執行會針對應用程式中所有已修改的檔，依次呼叫[CDocument：： SaveModified](../../mfc/reference/cdocument-class.md#savemodified)成員函式。

##  <a name="selectprinter"></a>CWinApp：： SelectPrinter

呼叫此成員函式來選取特定的印表機，並放開先前在 [列印] 對話方塊中選取的印表機。

```
void SelectPrinter(
    HANDLE hDevNames,
    HANDLE hDevMode,
    BOOL bFreeOld = TRUE);
```

### <a name="parameters"></a>參數

*hDevNames*<br/>
[DEVNAMES](/windows/win32/api/commdlg/ns-commdlg-devnames)結構 t) 的控制碼，可識別特定印表機的驅動程式、裝置和輸出埠名稱。

*hDevMode*<br/>
[DEVMODE](/windows/win32/api/wingdi/ns-wingdi-devmodea)結構的控制碼，指定印表機的裝置初始化和環境的相關資訊。

*bFreeOld*<br/>
釋放先前選取的印表機。

### <a name="remarks"></a>備註

如果*hDevMode*和*HDEVNAMES*都是 Null，`SelectPrinter` 會使用目前的預設印表機。

##  <a name="sethelpmode"></a>CWinApp：： SetHelpMode

設定應用程式的說明類型。

```
void SetHelpMode(AFX_HELP_TYPE eHelpType);
```

### <a name="parameters"></a>參數

*eHelpType*<br/>
指定要使用的說明類型。 如需詳細資訊，請參閱[CWinApp：： m_eHelpType](#m_ehelptype) 。

### <a name="remarks"></a>備註

設定應用程式的說明類型。

若要將應用程式的說明類型設定為 HTMLHelp，您可以呼叫[EnableHTMLHelp](#enablehtmlhelp)。 呼叫 `EnableHTMLHelp`之後，您的應用程式必須使用 HTMLHelp 作為其說明應用程式。 如果您想要變更為使用 WinHelp，您可以呼叫 `SetHelpMode`，並將*eHelpType*設定為 `afxWinHelp`。

##  <a name="setregistrykey"></a>CWinApp：： SetRegistryKey

導致應用程式設定儲存在登錄中，而不是 INI 檔案。

```
void SetRegistryKey(LPCTSTR lpszRegistryKey);
void SetRegistryKey(UINT nIDRegistryKey);
```

### <a name="parameters"></a>參數

*lpszRegistryKey*<br/>
包含索引鍵名稱之字串的指標。

*nIDRegistryKey*<br/>
包含登錄機碼名稱的字串資源識別碼。

### <a name="remarks"></a>備註

此函式會設定*m_pszRegistryKey*，然後由 `WriteProfileString` 的 `GetProfileInt`、`GetProfileString`、`WriteProfileInt`和 `CWinApp`成員函式使用此功能。 如果已呼叫此函式，則最近使用的（MRU）檔案清單也會儲存在登錄中。 登錄機碼通常是公司的名稱。 它會儲存在下列形式的索引鍵中： HKEY_CURRENT_USER \Software\\< 公司名稱\>\\< 應用程式名稱\>\\< 區段名稱\>\\< 值名稱\>。

##  <a name="supportsapplicationrecovery"></a>CWinApp：： SupportsApplicationRecovery

判斷重新開機管理員是否要復原意外結束的應用程式。

```
virtual BOOL SupportsApplicationRecovery() const;
```

### <a name="return-value"></a>傳回值

TRUE 表示重新開機管理員會復原應用程式;FALSE 表示重新開機管理員不是。

##  <a name="supportsautosaveatinterval"></a>CWinApp：： SupportsAutosaveAtInterval

判斷重新開機管理員是否定期 autosaves 開啟檔。

```
virtual BOOL SupportsAutosaveAtInterval() const;
```

### <a name="return-value"></a>傳回值

TRUE 表示重新開機管理員 autosaves 開啟的檔;FALSE 表示重新開機管理員不是。

##  <a name="supportsautosaveatrestart"></a>CWinApp：： SupportsAutosaveAtRestart

判斷重新開機管理員是否會在應用程式重新開機時 autosaves 任何開啟的檔。

```
virtual BOOL SupportsAutosaveAtRestart() const;
```

### <a name="return-value"></a>傳回值

TRUE 表示重新開機管理員在應用程式重新開機時 autosaves 開啟的檔;FALSE 表示重新開機管理員不是。

##  <a name="supportsrestartmanager"></a>CWinApp：： SupportsRestartManager

判斷應用程式是否支援重新開機管理員。

```
virtual BOOL SupportsRestartManager() const;
```

### <a name="return-value"></a>傳回值

TRUE 表示應用程式支援重新開機管理員;FALSE 表示應用程式不存在。

##  <a name="unregister"></a>CWinApp：：取消註冊

將應用程式物件註冊的所有檔案取消註冊。

```
virtual BOOL Unregister();
```

### <a name="return-value"></a>傳回值

非零成功，否則為 0。

### <a name="remarks"></a>備註

`Unregister` 函式會復原應用程式物件和[Register](#register)函數所執行的註冊。 一般來說，MFC 會以隱含方式呼叫這兩個函式，因此不會出現在您的程式碼中。

覆寫此函式以執行自訂取消註冊步驟。

##  <a name="unregistershellfiletypes"></a>CWinApp：： UnregisterShellFileTypes

呼叫這個成員函式，使用 Windows 檔案管理員取消註冊您所有的應用程式檔案類型。

```
void UnregisterShellFileTypes();
```

##  <a name="winhelp"></a>CWinApp：： WinHelp

呼叫這個成員函式來叫用 WinHelp 應用程式。

```
virtual void WinHelp(
    DWORD_PTR dwData,
    UINT nCmd = HELP_CONTEXT);
```

### <a name="parameters"></a>參數

*dwData*<br/>
指定其他資料。 使用的值取決於*nCmd*參數的值。

*nCmd*<br/>
指定要求的說明類型。 如需可能值的清單，以及它們如何影響*dwData*參數，請參閱[WinHelp](/windows/win32/api/winuser/nf-winuser-winhelpw) Windows 函式。

### <a name="remarks"></a>備註

此架構也會呼叫這個函式來叫用 WinHelp 應用程式。

當您的應用程式終止時，架構會自動關閉 WinHelp 應用程式。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#53](../../mfc/reference/codesnippet/cpp/cwinapp-class_28.cpp)]

##  <a name="writeprofilebinary"></a>CWinApp：： WriteProfileBinary

呼叫這個成員函式，將二進位資料寫入應用程式登錄或的指定區段。INI 檔案。

```
BOOL WriteProfileBinary(
    LPCTSTR lpszSection,
    LPCTSTR lpszEntry,
    LPBYTE pData,
    UINT nBytes);
```

### <a name="parameters"></a>參數

*lpszSection*<br/>
指向以 null 終止的字串，這個字串指定包含項目的區段。 如果區段不存在，則會加以建立。 區段的名稱不區分大小寫;字串可以是大寫和小寫字母的任意組合。

*lpszEntry*<br/>
指向以 null 終止的字串，其中包含要寫入值的專案。 如果專案不存在於指定的區段中，則會建立它。

*pData*<br/>
指向要寫入的資料。

*nBytes*<br/>
包含要寫入的位元組數目。

### <a name="return-value"></a>傳回值

如果成功則為非零；否則為 0。

### <a name="example"></a>範例

這個範例會使用 `CWinApp* pApp = AfxGetApp();` 來取得 CWinApp 類別，其中說明可從 MFC 應用程式中的任何函式使用 `WriteProfileBinary` 和 `GetProfileBinary` 的方式。

[!code-cpp[NVC_MFCWindowing#54](../../mfc/reference/codesnippet/cpp/cwinapp-class_29.cpp)]

如需其他範例，請參閱[CWinApp：： GetProfileBinary](#getprofilebinary)的範例。

##  <a name="writeprofileint"></a>CWinApp：： WriteProfileInt

呼叫這個成員函式，將指定的值寫入應用程式的登錄或的指定區段。INI 檔案。

```
BOOL WriteProfileInt(
    LPCTSTR lpszSection,
    LPCTSTR lpszEntry,
    int nValue);
```

### <a name="parameters"></a>參數

*lpszSection*<br/>
指向以 null 終止的字串，這個字串指定包含項目的區段。 如果區段不存在，則會加以建立。 區段的名稱不區分大小寫;字串可以是大寫和小寫字母的任意組合。

*lpszEntry*<br/>
指向以 null 終止的字串，其中包含要寫入值的專案。 如果專案不存在於指定的區段中，則會建立它。

*N 值*<br/>
包含要寫入的值。

### <a name="return-value"></a>傳回值

如果成功則為非零；否則為 0。

### <a name="example"></a>範例

這個範例會使用 `CWinApp* pApp = AfxGetApp();` 來取得 CWinApp 類別，其中說明可從 MFC 應用程式中的任何函式使用 `WriteProfileString`、`WriteProfileInt`、`GetProfileString`和 `GetProfileInt` 的方式。

[!code-cpp[NVC_MFCWindowing#43](../../mfc/reference/codesnippet/cpp/cwinapp-class_9.cpp)]

如需其他範例，請參閱[CWinApp：： GetProfileInt](#getprofileint)的範例。

##  <a name="writeprofilestring"></a>CWinApp：： WriteProfileString

呼叫這個成員函式，將指定的字串寫入應用程式的登錄或的指定區段。INI 檔案。

```
BOOL WriteProfileString(
    LPCTSTR lpszSection,
    LPCTSTR lpszEntry,
    LPCTSTR lpszValue);
```

### <a name="parameters"></a>參數

*lpszSection*<br/>
指向以 null 終止的字串，這個字串指定包含項目的區段。 如果區段不存在，則會加以建立。 區段的名稱不區分大小寫;字串可以是大寫和小寫字母的任意組合。

*lpszEntry*<br/>
指向以 null 終止的字串，其中包含要寫入值的專案。 如果專案不存在於指定的區段中，則會建立它。 如果此參數為 Null，則會刪除*lpszSection*所指定的區段。

*lpszValue*<br/>
指向要寫入的字串。 如果此參數為 Null，則會刪除*lpszEntry*參數所指定的專案。

### <a name="return-value"></a>傳回值

如果成功則為非零；否則為 0。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#43](../../mfc/reference/codesnippet/cpp/cwinapp-class_9.cpp)]

如需其他範例，請參閱[CWinApp：： GetProfileInt](#getprofileint)的範例。

##  <a name="setappid"></a>CWinApp：： SetAppID

明確設定應用程式的應用程式使用者模型識別碼。 在向使用者呈現任何使用者介面之前，應該先呼叫這個方法（最好的地方是應用程式的「構造函式」）。

```
void SetAppID(LPCTSTR lpcszAppID);
```

### <a name="parameters"></a>參數

*lpcszAppID*<br/>
指定應用程式使用者模型識別碼。

### <a name="remarks"></a>備註

## <a name="see-also"></a>另請參閱

[CWinThread 類別](../../mfc/reference/cwinthread-class.md)<br/>
[階層架構圖表](../../mfc/hierarchy-chart.md)<br/>
[如何：新增重新啟動管理員支援](../../mfc/how-to-add-restart-manager-support.md)
