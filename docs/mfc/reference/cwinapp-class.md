---
title: CWinApp 類別
ms.date: 07/15/2019
f1_keywords:
- CWinApp
- AFXWIN/CWinApp
- AFXWIN/CWinApp::CWinApp
- AFXWIN/CWinApp::AddDocTemplate
- AFXWIN/CWinApp::AddToRecentFileList
- AFXWIN/CWinApp::ApplicationRecoveryCallback
- AFXWIN/CWinApp::CloseAllDocuments
- AFXWIN/CWinApp::CreatePrinterDC
- AFXWIN/CWinApp::DelRegTree
- AFXWIN/CWinApp::DoMessageBox
- AFXWIN/CWinApp::DoWaitCursor
- AFXWIN/CWinApp::EnableD2DSupport
- AFXWIN/CWinApp::EnableHtmlHelp
- AFXWIN/CWinApp::EnableTaskbarInteraction
- AFXWIN/CWinApp::ExitInstance
- AFXWIN/CWinApp::GetApplicationRecoveryParameter
- AFXWIN/CWinApp::GetApplicationRecoveryPingInterval
- AFXWIN/CWinApp::GetApplicationRestartFlags
- AFXWIN/CWinApp::GetAppRegistryKey
- AFXWIN/CWinApp::GetDataRecoveryHandler
- AFXWIN/CWinApp::GetFirstDocTemplatePosition
- AFXWIN/CWinApp::GetHelpMode
- AFXWIN/CWinApp::GetNextDocTemplate
- AFXWIN/CWinApp::GetPrinterDeviceDefaults
- AFXWIN/CWinApp::GetProfileBinary
- AFXWIN/CWinApp::GetProfileInt
- AFXWIN/CWinApp::GetProfileString
- AFXWIN/CWinApp::GetSectionKey
- AFXWIN/CWinApp::HideApplication
- AFXWIN/CWinApp::HtmlHelp
- AFXWIN/CWinApp::InitInstance
- AFXWIN/CWinApp::IsTaskbarInteractionEnabled
- AFXWIN/CWinApp::LoadCursor
- AFXWIN/CWinApp::LoadIcon
- AFXWIN/CWinApp::LoadOEMCursor
- AFXWIN/CWinApp::LoadOEMIcon
- AFXWIN/CWinApp::LoadStandardCursor
- AFXWIN/CWinApp::LoadStandardIcon
- AFXWIN/CWinApp::OnDDECommand
- AFXWIN/CWinApp::OnIdle
- AFXWIN/CWinApp::OpenDocumentFile
- AFXWIN/CWinApp::ParseCommandLine
- AFXWIN/CWinApp::PreTranslateMessage
- AFXWIN/CWinApp::ProcessMessageFilter
- AFXWIN/CWinApp::ProcessShellCommand
- AFXWIN/CWinApp::ProcessWndProcException
- AFXWIN/CWinApp::Register
- AFXWIN/CWinApp::RegisterWithRestartManager
- AFXWIN/CWinApp::ReopenPreviousFilesAtRestart
- AFXWIN/CWinApp::RestartInstance
- AFXWIN/CWinApp::RestoreAutosavedFilesAtRestart
- AFXWIN/CWinApp::Run
- AFXWIN/CWinApp::RunAutomated
- AFXWIN/CWinApp::RunEmbedded
- AFXWIN/CWinApp::SaveAllModified
- AFXWIN/CWinApp::SelectPrinter
- AFXWIN/CWinApp::SetHelpMode
- AFXWIN/CWinApp::SupportsApplicationRecovery
- AFXWIN/CWinApp::SupportsAutosaveAtInterval
- AFXWIN/CWinApp::SupportsAutosaveAtRestart
- AFXWIN/CWinApp::SupportsRestartManager
- AFXWIN/CWinApp::Unregister
- AFXWIN/CWinApp::WinHelp
- AFXWIN/CWinApp::WriteProfileBinary
- AFXWIN/CWinApp::WriteProfileInt
- AFXWIN/CWinApp::WriteProfileString
- AFXWIN/CWinApp::EnableShellOpen
- AFXWIN/CWinApp::LoadStdProfileSettings
- AFXWIN/CWinApp::OnContextHelp
- AFXWIN/CWinApp::OnFileNew
- AFXWIN/CWinApp::OnFileOpen
- AFXWIN/CWinApp::OnFilePrintSetup
- AFXWIN/CWinApp::OnHelp
- AFXWIN/CWinApp::OnHelpFinder
- AFXWIN/CWinApp::OnHelpIndex
- AFXWIN/CWinApp::OnHelpUsing
- AFXWIN/CWinApp::RegisterShellFileTypes
- AFXWIN/CWinApp::SetAppID
- AFXWIN/CWinApp::SetRegistryKey
- AFXWIN/CWinApp::UnregisterShellFileTypes
- AFXWIN/CWinApp::m_bHelpMode
- AFXWIN/CWinApp::m_eHelpType
- AFXWIN/CWinApp::m_hInstance
- AFXWIN/CWinApp::m_lpCmdLine
- AFXWIN/CWinApp::m_nCmdShow
- AFXWIN/CWinApp::m_pActiveWnd
- AFXWIN/CWinApp::m_pszAppID
- AFXWIN/CWinApp::m_pszAppName
- AFXWIN/CWinApp::m_pszExeName
- AFXWIN/CWinApp::m_pszHelpFilePath
- AFXWIN/CWinApp::m_pszProfileName
- AFXWIN/CWinApp::m_pszRegistryKey
- AFXWIN/CWinApp::m_dwRestartManagerSupportFlags
- AFXWIN/CWinApp::m_nAutosaveInterval
- AFXWIN/CWinApp::m_pDataRecoveryHandler
helpviewer_keywords:
- CWinApp [MFC], CWinApp
- CWinApp [MFC], AddDocTemplate
- CWinApp [MFC], AddToRecentFileList
- CWinApp [MFC], ApplicationRecoveryCallback
- CWinApp [MFC], CloseAllDocuments
- CWinApp [MFC], CreatePrinterDC
- CWinApp [MFC], DelRegTree
- CWinApp [MFC], DoMessageBox
- CWinApp [MFC], DoWaitCursor
- CWinApp [MFC], EnableD2DSupport
- CWinApp [MFC], EnableHtmlHelp
- CWinApp [MFC], EnableTaskbarInteraction
- CWinApp [MFC], ExitInstance
- CWinApp [MFC], GetApplicationRecoveryParameter
- CWinApp [MFC], GetApplicationRecoveryPingInterval
- CWinApp [MFC], GetApplicationRestartFlags
- CWinApp [MFC], GetAppRegistryKey
- CWinApp [MFC], GetDataRecoveryHandler
- CWinApp [MFC], GetFirstDocTemplatePosition
- CWinApp [MFC], GetHelpMode
- CWinApp [MFC], GetNextDocTemplate
- CWinApp [MFC], GetPrinterDeviceDefaults
- CWinApp [MFC], GetProfileBinary
- CWinApp [MFC], GetProfileInt
- CWinApp [MFC], GetProfileString
- CWinApp [MFC], GetSectionKey
- CWinApp [MFC], HideApplication
- CWinApp [MFC], HtmlHelp
- CWinApp [MFC], InitInstance
- CWinApp [MFC], IsTaskbarInteractionEnabled
- CWinApp [MFC], LoadCursor
- CWinApp [MFC], LoadIcon
- CWinApp [MFC], LoadOEMCursor
- CWinApp [MFC], LoadOEMIcon
- CWinApp [MFC], LoadStandardCursor
- CWinApp [MFC], LoadStandardIcon
- CWinApp [MFC], OnDDECommand
- CWinApp [MFC], OnIdle
- CWinApp [MFC], OpenDocumentFile
- CWinApp [MFC], ParseCommandLine
- CWinApp [MFC], PreTranslateMessage
- CWinApp [MFC], ProcessMessageFilter
- CWinApp [MFC], ProcessShellCommand
- CWinApp [MFC], ProcessWndProcException
- CWinApp [MFC], Register
- CWinApp [MFC], RegisterWithRestartManager
- CWinApp [MFC], ReopenPreviousFilesAtRestart
- CWinApp [MFC], RestartInstance
- CWinApp [MFC], RestoreAutosavedFilesAtRestart
- CWinApp [MFC], Run
- CWinApp [MFC], RunAutomated
- CWinApp [MFC], RunEmbedded
- CWinApp [MFC], SaveAllModified
- CWinApp [MFC], SelectPrinter
- CWinApp [MFC], SetHelpMode
- CWinApp [MFC], SupportsApplicationRecovery
- CWinApp [MFC], SupportsAutosaveAtInterval
- CWinApp [MFC], SupportsAutosaveAtRestart
- CWinApp [MFC], SupportsRestartManager
- CWinApp [MFC], Unregister
- CWinApp [MFC], WinHelp
- CWinApp [MFC], WriteProfileBinary
- CWinApp [MFC], WriteProfileInt
- CWinApp [MFC], WriteProfileString
- CWinApp [MFC], EnableShellOpen
- CWinApp [MFC], LoadStdProfileSettings
- CWinApp [MFC], OnContextHelp
- CWinApp [MFC], OnFileNew
- CWinApp [MFC], OnFileOpen
- CWinApp [MFC], OnFilePrintSetup
- CWinApp [MFC], OnHelp
- CWinApp [MFC], OnHelpFinder
- CWinApp [MFC], OnHelpIndex
- CWinApp [MFC], OnHelpUsing
- CWinApp [MFC], RegisterShellFileTypes
- CWinApp [MFC], SetAppID
- CWinApp [MFC], SetRegistryKey
- CWinApp [MFC], UnregisterShellFileTypes
- CWinApp [MFC], m_bHelpMode
- CWinApp [MFC], m_eHelpType
- CWinApp [MFC], m_hInstance
- CWinApp [MFC], m_lpCmdLine
- CWinApp [MFC], m_nCmdShow
- CWinApp [MFC], m_pActiveWnd
- CWinApp [MFC], m_pszAppID
- CWinApp [MFC], m_pszAppName
- CWinApp [MFC], m_pszExeName
- CWinApp [MFC], m_pszHelpFilePath
- CWinApp [MFC], m_pszProfileName
- CWinApp [MFC], m_pszRegistryKey
- CWinApp [MFC], m_dwRestartManagerSupportFlags
- CWinApp [MFC], m_nAutosaveInterval
- CWinApp [MFC], m_pDataRecoveryHandler
ms.assetid: e426a3cd-0d15-40d6-bd55-beaa5feb2343
ms.openlocfilehash: f8ca4ad2023902d40a1f63c881a8dd2fd38a9ae9
ms.sourcegitcommit: ec6dd97ef3d10b44e0fedaa8e53f41696f49ac7b
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/25/2020
ms.locfileid: "88837602"
---
# <a name="cwinapp-class"></a>CWinApp 類別

Windows 應用程式物件所衍生自的基底類別。

## <a name="syntax"></a>語法

```
class CWinApp : public CWinThread
```

## <a name="members"></a>成員

### <a name="public-constructors"></a>公用建構函式

|名稱|描述|
|----------|-----------------|
|[CWinApp：： CWinApp](#cwinapp)|建構 `CWinApp` 物件。|

### <a name="public-methods"></a>公用方法

|名稱|描述|
|----------|-----------------|
|[CWinApp：： AddDocTemplate](#adddoctemplate)|將檔範本加入至應用程式的可用檔範本清單。|
|[CWinApp：： AddToRecentFileList](#addtorecentfilelist)|將檔案名加入最近使用的 (MRU) 檔案清單中。|
|[CWinApp：： ApplicationRecoveryCallback](#applicationrecoverycallback)|當應用程式意外結束時，由架構呼叫。|
|[CWinApp：： CloseAllDocuments](#closealldocuments)|關閉所有開啟的檔。|
|[CWinApp：： CreatePrinterDC](#createprinterdc)|建立印表機裝置內容。|
|[CWinApp：:D elRegTree](#delregtree)|刪除指定的機碼及其所有子機碼。|
|[CWinApp：:D oMessageBox](#domessagebox)|為應用程式執行 [AfxMessageBox](cstring-formatting-and-message-box-display.md#afxmessagebox) 。|
|[CWinApp：:D oWaitCursor](#dowaitcursor)|開啟和關閉等候游標。|
|[CWinApp：： EnableD2DSupport](#enabled2dsupport)|啟用應用程式 D2D 支援。 初始化主視窗之前先呼叫這個方法。|
|[CWinApp：： EnableHtmlHelp](#enablehtmlhelp)|針對應用程式執行 HTMLHelp，而不是 WinHelp。|
|[CWinApp：： EnableTaskbarInteraction](#enabletaskbarinteraction)|啟用工作列互動。|
|[CWinApp：： ExitInstance](#exitinstance)|當應用程式終止時，覆寫以進行清除。|
|[CWinApp：： GetApplicationRecoveryParameter](#getapplicationrecoveryparameter)|抓取應用程式修復方法的輸入參數。|
|[CWinApp：： GetApplicationRecoveryPingInterval](#getapplicationrecoverypinginterval)|傳回重新開機管理員等候復原回呼函數傳回的時間長度。|
|[CWinApp：： GetApplicationRestartFlags](#getapplicationrestartflags)|傳回重新開機管理員的旗標。|
|[CWinApp：： GetAppRegistryKey](#getappregistrykey)|傳回 HKEY_CURRENT_USER \\ "Software" \RegistryKey\ProfileName. 的金鑰|
|[CWinApp：： GetDataRecoveryHandler](#getdatarecoveryhandler)|取得這個應用程式實例的資料修復處理常式。|
|[CWinApp：： GetFirstDocTemplatePosition](#getfirstdoctemplateposition)|抓取第一個檔範本的位置。|
|[CWinApp：： GetHelpMode](#gethelpmode)|抓取應用程式所使用的說明類型。|
|[CWinApp：： GetNextDocTemplate](#getnextdoctemplate)|抓取檔範本的位置。 可以遞迴方式使用。|
|[CWinApp：： GetPrinterDeviceDefaults](#getprinterdevicedefaults)|抓取印表機裝置的預設值。|
|[CWinApp：： GetProfileBinary](#getprofilebinary)|從應用程式的專案中抓取二進位資料。INI 檔案。|
|[CWinApp：： GetProfileInt](#getprofileint)|從應用程式的專案中抓取整數。INI 檔案。|
|[CWinApp：： GetProfileString](#getprofilestring)|從應用程式的專案中抓取字串。INI 檔案。|
|[CWinApp：： GetSectionKey](#getsectionkey)|傳回 HKEY_CURRENT_USER \\ "Software" \RegistryKey\AppName\lpszSection. 的金鑰|
|[CWinApp：： HideApplication](#hideapplication)|關閉所有檔之前隱藏應用程式。|
|[CWinApp：： HtmlHelp](#htmlhelp)|呼叫 `HTMLHelp` Windows 函數。|
|[CWinApp：： InitInstance](#initinstance)|覆寫以執行 Windows 實例初始化，例如建立視窗物件。|
|[CWinApp：： IsTaskbarInteractionEnabled](#istaskbarinteractionenabled)|指出是否已啟用 Windows 7 工作列互動。|
|[CWinApp：： LoadCursor](#loadcursor)|載入資料指標資源。|
|[CWinApp：： LoadIcon](#loadicon)|載入圖示資源。|
|[CWinApp：： LoadOEMCursor](#loadoemcursor)|載入 windows OEM 預先定義的資料指標， **OCR_** 常數在 windows 中指定。H。|
|[CWinApp：： LoadOEMIcon](#loadoemicon)|載入 windows OEM 預先定義圖示， **OIC_** 常數在 windows 中指定。H。|
|[CWinApp：： LoadStandardCursor](#loadstandardcursor)|載入 **IDC_** 常數在 windows 中指定的 windows 預先定義游標。H。|
|[CWinApp：： LoadStandardIcon](#loadstandardicon)|載入 windows 預先定義的圖示， **IDI_** 常數在 windows 中指定。H。|
|[CWinApp：： OnDDECommand](#onddecommand)|由架構呼叫以回應動態資料交換 (DDE) execute 命令。|
|[CWinApp：： OnIdle](#onidle)|覆寫以執行應用程式特定的閒置時間處理。|
|[CWinApp：： OpenDocumentFile](#opendocumentfile)|由架構呼叫以開啟檔案中的檔。|
|[CWinApp：:P arseCommandLine](#parsecommandline)|剖析命令列中的個別參數和旗標。|
|[CWinApp：:P reTranslateMessage](#pretranslatemessage)|在訊息分派至 Windows 函式 [TranslateMessage](/windows/win32/api/winuser/nf-winuser-translatemessage) 和 [DispatchMessage](/windows/win32/api/winuser/nf-winuser-dispatchmessage)之前，先篩選訊息。|
|[CWinApp：:P rocessMessageFilter](#processmessagefilter)|在訊息到達應用程式之前攔截某些訊息。|
|[CWinApp：:P rocessShellCommand](#processshellcommand)|處理命令列引數和旗標。|
|[CWinApp：:P rocessWndProcException](#processwndprocexception)|攔截應用程式訊息和命令處理常式擲回的所有未處理例外狀況。|
|[CWinApp：： Register](#register)|執行自訂的註冊。|
|[CWinApp：： RegisterWithRestartManager](#registerwithrestartmanager)|使用重新開機管理員來註冊應用程式。|
|[CWinApp：： ReopenPreviousFilesAtRestart](#reopenpreviousfilesatrestart)|決定當應用程式意外結束時，重新開機管理員是否重新開啟已開啟的檔案。|
|[CWinApp：： RestartInstance](#restartinstance)|處理重新開機管理員所起始的應用程式重新開機。|
|[CWinApp：： RestoreAutosavedFilesAtRestart](#restoreautosavedfilesatrestart)|決定重新開機管理員在重新開機應用程式時是否還原自動儲存的檔案。|
|[CWinApp：： Run](#run)|執行預設訊息迴圈。 覆寫以自訂訊息迴圈。|
|[CWinApp：： RunAutomated](#runautomated)|針對 **/Automation** 選項測試應用程式的命令列。 已過時。 請改為在呼叫[ParseCommandLine](#parsecommandline)之後，使用[CCommandLineInfo：： m_bRunAutomated](../../mfc/reference/ccommandlineinfo-class.md#m_brunautomated)中的值。|
|[CWinApp：： RunEmbedded](#runembedded)|針對 **/Embedding** 選項測試應用程式的命令列。 已過時。 請改為在呼叫[ParseCommandLine](#parsecommandline)之後，使用[CCommandLineInfo：： m_bRunEmbedded](../../mfc/reference/ccommandlineinfo-class.md#m_brunembedded)中的值。|
|[CWinApp：： SaveAllModified](#saveallmodified)|提示使用者儲存所有修改過的檔。|
|[CWinApp：： SelectPrinter](#selectprinter)|選取使用者先前透過 [列印] 對話方塊指出的印表機。|
|[CWinApp：： SetHelpMode](#sethelpmode)|設定並初始化應用程式所使用的說明類型。|
|[CWinApp：： SupportsApplicationRecovery](#supportsapplicationrecovery)|判斷重新開機管理員是否復原意外結束的應用程式。|
|[CWinApp：： SupportsAutosaveAtInterval](#supportsautosaveatinterval)|判斷重新開機管理員是否 autosaves 定期開啟檔。|
|[CWinApp：： SupportsAutosaveAtRestart](#supportsautosaveatrestart)|決定當應用程式重新開機時，重新開機管理員是否 autosaves 任何開啟的檔。|
|[CWinApp：： SupportsRestartManager](#supportsrestartmanager)|判斷應用程式是否支援重新開機管理員。|
|[CWinApp：：取消註冊](#unregister)|取消註冊所有已知由物件註冊的專案 `CWinApp` 。|
|[CWinApp：： WinHelp](#winhelp)|呼叫 `WinHelp` Windows 函數。|
|[CWinApp：： WriteProfileBinary](#writeprofilebinary)|將二進位資料寫入至應用程式的專案。INI 檔案。|
|[CWinApp：： WriteProfileInt](#writeprofileint)|將整數寫入至應用程式的專案。INI 檔案。|
|[CWinApp：： WriteProfileString](#writeprofilestring)|將字串寫入至應用程式的專案。INI 檔案。|

### <a name="protected-methods"></a>保護方法

|名稱|描述|
|----------|-----------------|
|[CWinApp：：新增 enableshellopen](#enableshellopen)|可讓使用者從 Windows 檔案管理員開啟資料檔案。|
|[CWinApp：： LoadStdProfileSettings](#loadstdprofilesettings)|載入標準。INI 檔案設定，並啟用 MRU 檔案清單功能。|
|[CWinApp：： OnCoNtextHelp](#oncontexthelp)|處理應用程式內的 SHIFT + F1 說明。|
|[CWinApp：： OnFileNew](#onfilenew)|實行 ID_FILE_NEW 命令。|
|[CWinApp：： OnFileOpen](#onfileopen)|實行 ID_FILE_OPEN 命令。|
|[CWinApp：： OnFilePrintSetup](#onfileprintsetup)|實行 ID_FILE_PRINT_SETUP 命令。|
|[CWinApp：： OnHelp](#onhelp)|在應用程式 (使用目前的內容) 中處理 F1 說明。|
|[CWinApp：： OnHelpFinder](#onhelpfinder)|處理 ID_HELP_FINDER 和 ID_DEFAULT_HELP 命令。|
|[CWinApp：： OnHelpIndex](#onhelpindex)|處理 ID_HELP_INDEX 命令，並提供預設說明主題。|
|[CWinApp：： OnHelpUsing](#onhelpusing)|處理 ID_HELP_USING 命令。|
|[CWinApp：： RegisterShellFileTypes](#registershellfiletypes)|使用 Windows 檔案管理員註冊所有應用程式的檔案類型。|
|[CWinApp：： SetAppID](#setappid)|明確地設定應用程式的應用程式使用者模型識別碼。 在對使用者呈現任何使用者介面之前，應該先呼叫這個方法 (最好的地方就是) 應用程式。|
|[CWinApp：： SetRegistryKey](#setregistrykey)|會導致應用程式設定儲存在登錄中，而不是儲存在登錄中。INI 檔案。|
|[CWinApp：： UnregisterShellFileTypes](#unregistershellfiletypes)|使用 Windows 檔案管理員，取消註冊所有應用程式的檔案類型。|

### <a name="public-data-members"></a>公用資料成員

|名稱|描述|
|----------|-----------------|
|[CWinApp：： m_bHelpMode](#m_bhelpmode)|指出使用者是否處於說明內容模式 (通常會使用 SHIFT + F1) 來叫用。|
|[CWinApp：： m_eHelpType](#m_ehelptype)|指定應用程式所使用的說明類型。|
|[CWinApp：： m_hInstance](#m_hinstance)|識別應用程式目前的實例。|
|[CWinApp：： m_lpCmdLine](#m_lpcmdline)|指向以 null 終止的字串，這個字串會指定應用程式的命令列。|
|[CWinApp：： m_nCmdShow](#m_ncmdshow)|指定如何一開始就顯示視窗。|
|[CWinApp：： m_pActiveWnd](#m_pactivewnd)|當 OLE 伺服器為就地使用中時，容器應用程式主視窗的指標。|
|[CWinApp：： m_pszAppID](#m_pszappid)|應用程式使用者模型識別碼。|
|[CWinApp：： m_pszAppName](#m_pszappname)|指定應用程式的名稱。|
|[CWinApp：： m_pszExeName](#m_pszexename)|應用程式的模組名稱。|
|[CWinApp：： m_pszHelpFilePath](#m_pszhelpfilepath)|應用程式說明檔的路徑。|
|[CWinApp：： m_pszProfileName](#m_pszprofilename)|應用程式的。INI 檔案名。|
|[CWinApp：： m_pszRegistryKey](#m_pszregistrykey)|用來判斷用來儲存應用程式佈建檔設定的完整登錄機碼。|

### <a name="protected-data-members"></a>受保護的資料成員

|名稱|描述|
|----------|-----------------|
|[CWinApp：： m_dwRestartManagerSupportFlags](#m_dwrestartmanagersupportflags)|決定重新開機管理員運作方式的旗標。|
|[CWinApp：： m_nAutosaveInterval](#m_nautosaveinterval)|Autosaves 之間的時間長度（以毫秒為單位）。|
|[CWinApp：： m_pDataRecoveryHandler](#m_pdatarecoveryhandler)|應用程式資料修復處理常式的指標。|

## <a name="remarks"></a>備註

應用程式物件會提供用來將應用程式初始化 (的成員函式，以及每個實例的) 和執行應用程式的實例。

使用 Microsoft Foundation 類別的每個應用程式只能包含一個衍生自的物件 `CWinApp` 。 當建立其他 c + + 全域物件時，會建立此物件，當 Windows 呼叫 MFC 程式庫所提供的函式時，就會使用這個物件 `WinMain` 。 `CWinApp`在全域層級宣告您的衍生物件。

當您從衍生應用程式類別時 `CWinApp` ，請覆寫 [InitInstance](#initinstance) 成員函式，以建立應用程式的主視窗物件。

除了成員函式之外 `CWinApp` ，MFC 程式庫還提供下列全域函式，以存取您的 `CWinApp` 物件和其他全域資訊：

- [AfxGetApp](application-information-and-management.md#afxgetapp) 取得物件的指標 `CWinApp` 。

- [AfxGetInstanceHandle](application-information-and-management.md#afxgetinstancehandle) 取得目前應用程式實例的控制碼。

- [AfxGetResourceHandle](application-information-and-management.md#afxgetresourcehandle) 取得應用程式資源的控制碼。

- [AfxGetAppName](application-information-and-management.md#afxgetappname) 取得包含應用程式名稱之字串的指標。 或者，如果您有物件的指標 `CWinApp` ，請使用 `m_pszExeName` 來取得應用程式的名稱。

如需類別的詳細資訊，請參閱 [CWinApp：應用程式類別](../../mfc/cwinapp-the-application-class.md) `CWinApp` ，包括下列各項的總覽：

- `CWinApp`-應用程式精靈所撰寫的衍生程式碼。

- `CWinApp`在應用程式執行順序中的角色。

- `CWinApp`的預設成員函式實作為。

- `CWinApp`的關鍵 overridables。

`m_hPrevInstance`資料成員不再存在。 若要判斷應用程式的另一個實例是否正在執行，請使用已命名的 mutex。 如果開啟 mutex 失敗，則表示應用程式沒有其他實例正在執行。

## <a name="inheritance-hierarchy"></a>繼承階層架構

[CObject](../../mfc/reference/cobject-class.md)

[CCmdTarget](../../mfc/reference/ccmdtarget-class.md)

[CWinThread](../../mfc/reference/cwinthread-class.md)

`CWinApp`

## <a name="requirements"></a>規格需求

**標題:** afxwin.h

## <a name="cwinappadddoctemplate"></a><a name="adddoctemplate"></a> CWinApp：： AddDocTemplate

呼叫這個成員函式，將檔範本加入至應用程式所維護的可用檔範本清單。

```cpp
void AddDocTemplate(CDocTemplate* pTemplate);
```

### <a name="parameters"></a>參數

*pTemplate*<br/>
要 `CDocTemplate` 加入之的指標。

### <a name="remarks"></a>備註

您應該先將所有檔範本加入至應用程式，然後再呼叫 [RegisterShellFileTypes](#registershellfiletypes)。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#35](../../mfc/reference/codesnippet/cpp/cwinapp-class_1.cpp)]

## <a name="cwinappaddtorecentfilelist"></a><a name="addtorecentfilelist"></a> CWinApp：： AddToRecentFileList

呼叫這個成員函式，將 *lpszPathName* 加入至 MRU 檔案清單。

```
virtual void AddToRecentFileList(LPCTSTR lpszPathName);
```

### <a name="parameters"></a>參數

*lpszPathName*<br/>
檔案的路徑。

### <a name="remarks"></a>備註

在使用這個成員函式之前，您應該呼叫 [LoadStdProfileSettings](#loadstdprofilesettings) 成員函式來載入目前的 MRU 檔案清單。

架構在開啟檔案或執行 [另存新檔] 命令來儲存具有新名稱的檔案時，會呼叫此成員函式。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#36](../../mfc/reference/codesnippet/cpp/cwinapp-class_2.cpp)]

## <a name="cwinappapplicationrecoverycallback"></a><a name="applicationrecoverycallback"></a> CWinApp：： ApplicationRecoveryCallback

當應用程式意外結束時，由架構呼叫。

```
virtual DWORD ApplicationRecoveryCallback(LPVOID lpvParam);
```

### <a name="parameters"></a>參數

*lpvParam*<br/>
在保留供日後使用。

### <a name="return-value"></a>傳回值

如果此方法成功，則為 0;如果發生錯誤，則為非零。

### <a name="remarks"></a>備註

如果您的應用程式支援重新開機管理員，則當您的應用程式意外結束時，架構會呼叫這個函數。

的預設執行會 `ApplicationRecoveryCallback` 使用將 `CDataRecoveryHandler` 目前開啟的檔案清單儲存至登錄。 這個方法不會自動儲存任何檔案。

若要自訂行為，請在衍生的 [CWinApp 類別](../../mfc/reference/cwinapp-class.md) 中覆寫此函式，或將您自己的應用程式復原方法作為參數傳遞至 [CWinApp：： RegisterWithRestartManager](#registerwithrestartmanager)。

## <a name="cwinappclosealldocuments"></a><a name="closealldocuments"></a> CWinApp：： CloseAllDocuments

在結束之前，呼叫此成員函式以關閉所有開啟的檔。

```cpp
void CloseAllDocuments(BOOL bEndSession);
```

### <a name="parameters"></a>參數

*bEndSession*<br/>
指定是否結束 Windows 會話。 如果會話已結束，則為 TRUE;否則為 FALSE。

### <a name="remarks"></a>備註

呼叫 [HideApplication](#hideapplication) 之前呼叫 `CloseAllDocuments` 。

## <a name="cwinappcreateprinterdc"></a><a name="createprinterdc"></a> CWinApp：： CreatePrinterDC

呼叫此成員函式，以從選取的印表機 (DC) 建立印表機裝置內容。

```
BOOL CreatePrinterDC(CDC& dc);
```

### <a name="parameters"></a>參數

*直流*<br/>
印表機裝置內容的參考。

### <a name="return-value"></a>傳回值

如果成功建立印表機裝置內容，則為非零;否則為0。

### <a name="remarks"></a>備註

`CreatePrinterDC` 初始化您以傳址方式傳入的裝置內容，讓您可以使用它來列印。

如果函式成功，則當您完成列印時，必須終結裝置內容。 您可以讓 [cdc](../../mfc/reference/cdc-class.md) 物件的「函式」進行這項作業，或者您可以藉由呼叫 [Cdc：:D eletedc](../../mfc/reference/cdc-class.md#deletedc)來明確地執行此動作。

## <a name="cwinappcwinapp"></a><a name="cwinapp"></a> CWinApp：： CWinApp

會建立 `CWinApp` 物件，並傳遞要儲存為應用程式名稱的 *lpszAppName* 。

```
CWinApp(LPCTSTR lpszAppName = NULL);
```

### <a name="parameters"></a>參數

*lpszAppName*<br/>
以 null 終止的字串，其中包含 Windows 使用的應用程式名稱。 如果未提供這個引數或為 Null，則會 `CWinApp` 使用資源字串 AFX_IDS_APP_TITLE 或可執行檔的檔案名。

### <a name="remarks"></a>備註

您應該為衍生類別建立一個全域物件 `CWinApp` 。 您 `CWinApp` 的應用程式中只能有一個物件。 此函式會儲存物件的指標， `CWinApp` 以便 `WinMain` 呼叫物件的成員函式來初始化和執行應用程式。

## <a name="cwinappdelregtree"></a><a name="delregtree"></a> CWinApp：:D elRegTree

刪除特定的登錄機碼及其所有子機碼。

```
LONG DelRegTree(
    HKEY hParentKey,
    const CString& strKeyName);

LONG DelRegTree(
    HKEY hParentKey,
    const CString& strKeyName,
    CAtlTransactionManager* pTM = NULL);
```

### <a name="parameters"></a>參數

*hParentKey*<br/>
登錄機碼的控制碼。

*strKeyName*<br/>
要刪除之登錄機碼的名稱。

*pTM*<br/>
CAtlTransactionManager 物件的指標。

### <a name="return-value"></a>傳回值

如果函式成功，則傳回值為 ERROR_SUCCESS。 如果函式失敗，則傳回值為 Winerror.h 中定義的非零錯誤碼。

### <a name="remarks"></a>備註

呼叫此函式可刪除指定的機碼及其子機碼。

## <a name="cwinappdomessagebox"></a><a name="domessagebox"></a> CWinApp：:D oMessageBox

架構會呼叫這個成員函式，以執行全域函式 [AfxMessageBox](cstring-formatting-and-message-box-display.md#afxmessagebox)的訊息方塊。

```
virtual int DoMessageBox(
    LPCTSTR lpszPrompt,
    UINT nType,
    UINT nIDPrompt);
```

### <a name="parameters"></a>參數

*lpszPrompt*<br/>
訊息方塊中的文字位址。

*nType*<br/>
訊息方塊 [樣式](../../mfc/reference/styles-used-by-mfc.md#message-box-styles)。

*nIDPrompt*<br/>
說明內容字串的索引。

### <a name="return-value"></a>傳回值

傳回與相同的值 `AfxMessageBox` 。

### <a name="remarks"></a>備註

請勿呼叫這個成員函式來開啟訊息方塊;請改用 `AfxMessageBox` 。

覆寫這個成員函式，以自訂整個應用程式的 `AfxMessageBox` 呼叫處理。

## <a name="cwinappdowaitcursor"></a><a name="dowaitcursor"></a> CWinApp：:D oWaitCursor

架構會呼叫這個成員函式來執行 [CWaitCursor](../../mfc/reference/cwaitcursor-class.md)、 [CCmdTarget：： BeginWaitCursor](../../mfc/reference/ccmdtarget-class.md#beginwaitcursor)、 [CCmdTarget：： EndWaitCursor](../../mfc/reference/ccmdtarget-class.md#endwaitcursor)和 [CCmdTarget：： RestoreWaitCursor](../../mfc/reference/ccmdtarget-class.md#restorewaitcursor)。

```
virtual void DoWaitCursor(int nCode);
```

### <a name="parameters"></a>參數

*nCode*<br/>
如果這個參數是1，則會出現等候游標。 如果是0，則會還原等候資料指標，而不會遞增參考計數。 如果為-1，則等候資料指標結束。

### <a name="remarks"></a>備註

預設會執行沙漏游標。 `DoWaitCursor` 維護參考計數。 如果是正數，則會顯示沙漏游標。

雖然通常不會直接呼叫 `DoWaitCursor` ，但您可以覆寫這個成員函式來變更等候游標，或在顯示等候游標時進行額外的處理。

為了更簡單、更簡單的方法來執行等候資料指標，請使用 `CWaitCursor` 。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#37](../../mfc/reference/codesnippet/cpp/cwinapp-class_3.cpp)]

## <a name="cwinappenabled2dsupport"></a><a name="enabled2dsupport"></a> CWinApp：： EnableD2DSupport

必須有 Visual Studio 2010 SP1。

啟用應用程式 D2D 支援。 初始化主視窗之前先呼叫這個方法。

```
BOOL EnableD2DSupport(
    D2D1_FACTORY_TYPE d2dFactoryType = D2D1_FACTORY_TYPE_SINGLE_THREADED,
    DWRITE_FACTORY_TYPE writeFactoryType = DWRITE_FACTORY_TYPE_SHARED);
```

### <a name="parameters"></a>參數

*d2dFactoryType*<br/>
D2D factory 的執行緒模型和它所建立的資源。

*writeFactoryType*<br/>
值，這個值會指定是否要共用或隔離寫入 factory 物件。

### <a name="return-value"></a>傳回值

如果已啟用 D2D 支援，則傳回 TRUE，否則傳回 FALSE。

## <a name="cwinappenablehtmlhelp"></a><a name="enablehtmlhelp"></a> CWinApp：： EnableHtmlHelp

從衍生類別的函式中呼叫這個成員函 `CWinApp` 式，以針對您的應用程式說明使用 HTMLHelp。

```cpp
void EnableHtmlHelp();
```

### <a name="remarks"></a>備註

## <a name="cwinappenableshellopen"></a><a name="enableshellopen"></a> CWinApp：：新增 enableshellopen

呼叫此函式（通常是從覆 `InitInstance` 寫），讓應用程式的使用者在從 Windows 檔管理程式中按兩下檔案時，開啟資料檔案。

```cpp
void EnableShellOpen();
```

### <a name="remarks"></a>備註

請將 `RegisterShellFileTypes` 成員函式與此函式一起呼叫，或提供。使用應用程式的 REG 檔案，以手動方式註冊檔案類型。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#38](../../mfc/reference/codesnippet/cpp/cwinapp-class_4.cpp)]

## <a name="cwinappenabletaskbarinteraction"></a><a name="enabletaskbarinteraction"></a> CWinApp：： EnableTaskbarInteraction

啟用工作列互動。

```
BOOL EnableTaskbarInteraction(BOOL bEnable = TRUE);
```

### <a name="parameters"></a>參數

*bEnable*<br/>
指定是否應啟用與 Windows 7 工作列的互動 (TRUE) ，或停用 (FALSE) 。

### <a name="return-value"></a>傳回值

如果可以啟用或停用工作列互動，則傳回 TRUE。

### <a name="remarks"></a>備註

您必須在建立主視窗之前呼叫這個方法，否則它會判斷提示並傳回 FALSE。

## <a name="cwinappexitinstance"></a><a name="exitinstance"></a> CWinApp：： ExitInstance

由架構在成員函式中呼叫 `Run` ，以結束此應用程式的實例。

```
virtual int ExitInstance();
```

### <a name="return-value"></a>傳回值

應用程式的結束代碼;0表示沒有錯誤，且大於0的值表示錯誤。 這個值是用來做為的傳回值 `WinMain` 。

### <a name="remarks"></a>備註

請勿從成員函式內的任何位置呼叫這個成員函式 `Run` 。

這個函式的預設執行會將架構選項寫入應用程式。INI 檔案。 覆寫此函式，以在應用程式終止時進行清除。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#39](../../mfc/reference/codesnippet/cpp/cwinapp-class_5.cpp)]

## <a name="cwinappgetapplicationrecoveryparameter"></a><a name="getapplicationrecoveryparameter"></a> CWinApp：： GetApplicationRecoveryParameter

抓取應用程式修復方法的輸入參數。

```
virtual LPVOID GetApplicationRecoveryParameter();
```

### <a name="return-value"></a>傳回值

應用程式修復方法的預設輸入參數。

### <a name="remarks"></a>備註

此函數的預設行為會傳回 Null。

如需詳細資訊，請參閱 [CWinApp：： ApplicationRecoveryCallback](#applicationrecoverycallback)。

## <a name="cwinappgetapplicationrecoverypinginterval"></a><a name="getapplicationrecoverypinginterval"></a> CWinApp：： GetApplicationRecoveryPingInterval

傳回重新開機管理員等候復原回呼函數傳回的時間長度。

```
virtual DWORD GetApplicationRecoveryPingInterval();
```

### <a name="return-value"></a>傳回值

時間長度（以毫秒為單位）。

### <a name="remarks"></a>備註

當以重新開機管理員註冊的應用程式意外結束時，應用程式會嘗試儲存開啟的檔，並呼叫復原回呼函式。 預設的復原回呼函式為 [CWinApp：： ApplicationRecoveryCallback](#applicationrecoverycallback)。

架構等候復原回呼函式傳回的時間長度是 ping 間隔。 您可以藉由覆寫 `CWinApp::GetApplicationRecoveryPingInterval` 或提供自訂值給來自訂 ping 間隔 `RegisterWithRestartManager` 。

## <a name="cwinappgetapplicationrestartflags"></a><a name="getapplicationrestartflags"></a> CWinApp：： GetApplicationRestartFlags

傳回重新開機管理員的旗標。

```
virtual DWORD GetApplicationRestartFlags();
```

### <a name="return-value"></a>傳回值

重新開機管理員的旗標。 預設的實值會傳回0。

### <a name="remarks"></a>備註

重新開機管理員的旗標對預設的執行沒有任何作用。 提供這些使用者以供日後使用。

當您使用 [CWinApp：： RegisterWithRestartManager](#registerwithrestartmanager)向重新開機管理員註冊應用程式時，會設定旗標。

重新開機管理員旗標的可能值如下：

- RESTART_NO_CRASH

- RESTART_NO_HANG

- RESTART_NO_PATCH

- RESTART_NO_REBOOT

## <a name="cwinappgetappregistrykey"></a><a name="getappregistrykey"></a> CWinApp：： GetAppRegistryKey

傳回 HKEY_CURRENT_USER \\ "Software" 的金鑰 \RegistryKey\ProfileName。

```
HKEY GetAppRegistryKey(CAtlTransactionManager* pTM = NULL);
```

### <a name="parameters"></a>參數

*pTM*<br/>
指向 `CAtlTransactionManager` 物件的指標。

### <a name="return-value"></a>傳回值

如果函式成功，則為應用程式金鑰;否則為 Null。

### <a name="remarks"></a>備註

## <a name="cwinappgetdatarecoveryhandler"></a><a name="getdatarecoveryhandler"></a> CWinApp：： GetDataRecoveryHandler

取得這個應用程式實例的資料修復處理常式。

```
virtual CDataRecoveryHandler *GetDataRecoveryHandler();
```

### <a name="return-value"></a>傳回值

此應用程式實例的資料修復處理常式。

### <a name="remarks"></a>備註

使用重新開機管理員的每個應用程式都必須有一個 [CDataRecoveryHandler 類別](../../mfc/reference/cdatarecoveryhandler-class.md)的實例。 此類別負責監視開啟的檔和自動儲存檔。 的行為 `CDataRecoveryHandler` 取決於重新開機管理員的設定。 如需詳細資訊，請參閱 [CDataRecoveryHandler 類別](../../mfc/reference/cdatarecoveryhandler-class.md)。

在 Windows Vista 之前的作業系統上，這個方法會傳回 Null。 Windows Vista 之前的作業系統不支援重新開機管理員。

如果應用程式目前沒有資料復原處理常式，這個方法會建立一個，並傳回其指標。

## <a name="cwinappgetfirstdoctemplateposition"></a><a name="getfirstdoctemplateposition"></a> CWinApp：： GetFirstDocTemplatePosition

取得應用程式中第一個檔範本的位置。

```
POSITION GetFirstDocTemplatePosition() const;
```

### <a name="return-value"></a>傳回值

可用於反復專案或物件指標抓取的位置值;如果清單是空的，則為 Null。

### <a name="remarks"></a>備註

使用呼叫 [GetNextDocTemplate](#getnextdoctemplate) 時所傳回的位置值，取得第一個 [CDocTemplate](../../mfc/reference/cdoctemplate-class.md) 物件。

## <a name="cwinappgethelpmode"></a><a name="gethelpmode"></a> CWinApp：： GetHelpMode

抓取應用程式所使用的說明類型。

```
AFX_HELP_TYPE GetHelpMode();
```

### <a name="return-value"></a>傳回值

應用程式所使用的說明類型。 如需詳細資訊，請參閱 [CWinApp：： m_eHelpType](#m_ehelptype) 。

## <a name="cwinappgetnextdoctemplate"></a><a name="getnextdoctemplate"></a> CWinApp：： GetNextDocTemplate

取得 *pos*所識別的檔範本，然後將 *POS* 設定為位置值。

```
CDocTemplate* GetNextDocTemplate(POSITION& pos) const;
```

### <a name="parameters"></a>參數

*Pos*<br/>
先前呼叫或 GetFirstDocTemplatePosition 所傳回之位置值的參考 `GetNextDocTemplate` 。 [GetFirstDocTemplatePosition](#getfirstdoctemplateposition) 此呼叫會將此值更新為下一個位置。

### <a name="return-value"></a>傳回值

[CDocTemplate](../../mfc/reference/cdoctemplate-class.md)物件的指標。

### <a name="remarks"></a>備註

`GetNextDocTemplate`如果您使用呼叫來建立初始位置，可以在正向反復專案迴圈中使用 `GetFirstDocTemplatePosition` 。

您必須確定您的位置值有效。 如果無效，則為 MFC 程式庫判斷提示的偵錯工具版本。

如果取出的檔範本是最後一個可用的，則會將 *pos* 的新值設定為 Null。

## <a name="cwinappgetprinterdevicedefaults"></a><a name="getprinterdevicedefaults"></a> CWinApp：： GetPrinterDeviceDefaults

呼叫此成員函式來準備印表機裝置內容以進行列印。

```
BOOL GetPrinterDeviceDefaults(struct tagPDA* pPrintDlg);
```

### <a name="parameters"></a>參數

*pPrintDlg*<br/>
[PRINTDLG](/windows/win32/api/commdlg/ns-commdlg-printdlga)結構的指標。

### <a name="return-value"></a>傳回值

如果成功則為非零；否則為 0。

### <a name="remarks"></a>備註

從 Windows 抓取目前的印表機預設值。INI 檔案，或使用列印設定中使用者所設定的最後一個印表機設定。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#40](../../mfc/reference/codesnippet/cpp/cwinapp-class_6.cpp)]

## <a name="cwinappgetprofilebinary"></a><a name="getprofilebinary"></a> CWinApp：： GetProfileBinary

呼叫此成員函式，以從應用程式登錄或的指定區段內的專案中取出二進位資料。INI 檔案。

```
BOOL GetProfileBinary(
    LPCTSTR lpszSection,
    LPCTSTR lpszEntry,
    LPBYTE* ppData,
    UINT* pBytes);
```

### <a name="parameters"></a>參數

*lpszSection*<br/>
指向以 null 終止的字串，這個字串指定包含項目的區段。

*lpszEntry*<br/>
指向以 null 終止的字串，其中包含要擷取其值的項目。

*ppData*<br/>
指向將接收資料位址的指標。

*pBytes*<br/>
指向將接收資料大小 (位元組) 的 UINT。

### <a name="return-value"></a>傳回值

如果成功則為非零；否則為 0。

### <a name="remarks"></a>備註

此成員函式不區分大小寫，因此 *lpszSection* 和 *lpszEntry* 參數中的字串在大小寫上可能不同。

> [!NOTE]
> `GetProfileBinary` 配置緩衝區，並在 ppData 中傳回其位址 \* * *。 呼叫端負責使用 **delete []** 釋放緩衝區。

> [!IMPORTANT]
> 這個函式傳回的資料不一定是以 NULL 終止，因此，呼叫端必須執行驗證。 如需詳細資訊，請參閱 [Avoiding Buffer Overruns (避免緩衝區滿溢)](/windows/win32/SecBP/avoiding-buffer-overruns)。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#41](../../mfc/reference/codesnippet/cpp/cwinapp-class_7.cpp)]

如需其他範例，請參閱 [CWinApp：： WriteProfileBinary](#writeprofilebinary)。

## <a name="cwinappgetprofileint"></a><a name="getprofileint"></a> CWinApp：： GetProfileInt

呼叫此成員函式，從應用程式登錄檔或 .INI 檔中指定的區段內的項目擷取整數的值。

```
UINT GetProfileInt(
    LPCTSTR lpszSection,
    LPCTSTR lpszEntry,
    int nDefault);
```

### <a name="parameters"></a>參數

*lpszSection*<br/>
指向以 null 終止的字串，這個字串指定包含項目的區段。

*lpszEntry*<br/>
指向以 null 終止的字串，其中包含要擷取其值的項目。

*nDefault*<br/>
指定架構找不到項目時要傳回的預設值。

### <a name="return-value"></a>傳回值

如果函式成功，在指定項目後面之字串的整數值。 如果函式找不到專案，則傳回值為 *nDefault* 參數的值。 如果對應到指定項目的值不是整數，則傳回值為 0。

此成員函式支援 .INI 檔中值的十六進位標記法。 當您取出帶正負號的整數時，您應該將值轉換成 **`int`** 。

### <a name="remarks"></a>備註

此成員函式不區分大小寫，因此 *lpszSection* 和 *lpszEntry* 參數中的字串在大小寫上可能不同。

> [!IMPORTANT]
> 這個函式傳回的資料不一定是以 NULL 終止，因此，呼叫端必須執行驗證。 如需詳細資訊，請參閱 [Avoiding Buffer Overruns (避免緩衝區滿溢)](/windows/win32/SecBP/avoiding-buffer-overruns)。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#42](../../mfc/reference/codesnippet/cpp/cwinapp-class_8.cpp)]

如需其他範例，請參閱 [CWinApp：： WriteProfileInt](#writeprofileint)。

## <a name="cwinappgetprofilestring"></a><a name="getprofilestring"></a> CWinApp：： GetProfileString

呼叫這個成員函式，以抓取與應用程式登錄中指定區段內的專案相關聯的字串。INI 檔案。

```
CString GetProfileString(
    LPCTSTR lpszSection,
    LPCTSTR lpszEntry,
    LPCTSTR lpszDefault = NULL);
```

### <a name="parameters"></a>參數

*lpszSection*<br/>
指向以 null 終止的字串，這個字串指定包含項目的區段。

*lpszEntry*<br/>
指向以 null 終止的字串，其中包含要取出其字串的專案。 此值不得為 Null。

*lpszDefault*<br/>
如果在初始化檔中找不到專案，則指向指定專案的預設字串值。

### <a name="return-value"></a>傳回值

傳回值是來自應用程式的字串。如果找不到字串，則為 INI 檔或 *lpszDefault* 。 架構支援的最大字串長度是 _MAX_PATH。 如果 *lpszDefault* 為 Null，則傳回值為空字串。

### <a name="remarks"></a>備註

> [!IMPORTANT]
> 這個函式傳回的資料不一定是以 NULL 終止，因此，呼叫端必須執行驗證。 如需詳細資訊，請參閱 [Avoiding Buffer Overruns (避免緩衝區滿溢)](/windows/win32/SecBP/avoiding-buffer-overruns)。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#43](../../mfc/reference/codesnippet/cpp/cwinapp-class_9.cpp)]

如需其他範例，請參閱 [CWinApp：： GetProfileInt](#getprofileint)的範例。

## <a name="cwinappgetsectionkey"></a><a name="getsectionkey"></a> CWinApp：： GetSectionKey

傳回 HKEY_CURRENT_USER \\ "Software" 的金鑰 \RegistryKey\AppName\lpszSection。

```
HKEY GetSectionKey(
    LPCTSTR lpszSection,
    CAtlTransactionManager* pTM = NULL);
```

### <a name="parameters"></a>參數

*lpszSection*<br/>
要取得之金鑰的名稱。

*pTM*<br/>
指向 `CAtlTransactionManager` 物件的指標。

### <a name="return-value"></a>傳回值

如果函式成功，則為區段索引鍵;否則為 Null。

### <a name="remarks"></a>備註

## <a name="cwinapphideapplication"></a><a name="hideapplication"></a> CWinApp：： HideApplication

在關閉開啟的檔之前，呼叫此成員函式來隱藏應用程式。

```cpp
void HideApplication();
```

## <a name="cwinapphtmlhelp"></a><a name="htmlhelp"></a> CWinApp：： HtmlHelp

呼叫此成員函式來叫用 HTMLHelp 應用程式。

```
virtual void HtmlHelp(
    DWORD_PTR dwData,
    UINT nCmd = 0x000F);
```

### <a name="parameters"></a>參數

*dwData*<br/>
指定其他資料。 使用的值取決於 *nCmd* 參數的值。 預設值為， `0x000F` 表示 [HH_HELP_CONTEXT](/previous-versions/windows/desktop/htmlhelp/hh-help-context-command)。

*nCmd*<br/>
指定要求的說明類型。 如需可能值的清單，以及它們如何影響*dwData*參數，請參閱 Windows SDK 中的[HtmlHelpW](/windows/win32/api/htmlhelp/nf-htmlhelp-htmlhelpw)或[HtmlHelpA](/windows/win32/api/htmlhelp/nf-htmlhelp-htmlhelpa) API 函數中所述的*uCommand*參數。

### <a name="remarks"></a>備註

架構也會呼叫這個函式來叫用 HTMLHelp 應用程式。

當您的應用程式終止時，架構會自動關閉 HTMLHelp 應用程式。

## <a name="cwinappinitinstance"></a><a name="initinstance"></a> CWinApp：： InitInstance

Windows 可同時執行相同程式的數個複本。

```
virtual BOOL InitInstance();
```

### <a name="return-value"></a>傳回值

如果初始化成功，則為非零;否則為0。

### <a name="remarks"></a>備註

應用程式初始化概念分為兩個部分：第一次執行程式時執行的單次應用程式初始化，以及每次執行程式時執行的實例初始化，包括第一次執行。 架構的實作為 `WinMain` 呼叫這個函式。

覆寫 `InitInstance` 以初始化在 Windows 下執行的每個應用程式的新實例。 一般而言，您會覆寫 `InitInstance` 以建立主視窗物件，並設定 `CWinThread::m_pMainWnd` 資料成員以指向該視窗。 如需覆寫這個成員函式的詳細資訊，請參閱 [CWinApp：應用程式類別](../../mfc/cwinapp-the-application-class.md)。

> [!NOTE]
> MFC 應用程式必須初始化為單一執行緒的單元 (STA) 。 如果您在覆寫中呼叫 [CoInitializeEx](/windows/win32/api/combaseapi/nf-combaseapi-coinitializeex) `InitInstance` ，請指定 COINIT_APARTMENTTHREADED (，而非 COINIT_MULTITHREADED) 。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCListView#9](../../atl/reference/codesnippet/cpp/cwinapp-class_10.cpp)]

## <a name="cwinappistaskbarinteractionenabled"></a><a name="istaskbarinteractionenabled"></a> CWinApp：： IsTaskbarInteractionEnabled

指出是否已啟用 Windows 7 工作列互動。

```
virtual BOOL IsTaskbarInteractionEnabled();
```

### <a name="return-value"></a>傳回值

如果已 `EnableTaskbarInteraction` 呼叫，且作業系統是 Windows 7 或更高版本，則傳回 TRUE。

### <a name="remarks"></a>備註

工作列互動表示 MDI 應用程式會以個別索引標籤的縮圖顯示 MDI 子系的內容，並在滑鼠指標移至應用程式工作列按鈕時顯示。

## <a name="cwinapploadcursor"></a><a name="loadcursor"></a> CWinApp：： LoadCursor

載入 *lpszResourceName* 所命名的資料指標資源，或由 *nIDResource* 由目前的可執行檔指定。

```
HCURSOR LoadCursor(LPCTSTR lpszResourceName) const;  HCURSOR LoadCursor(UINT nIDResource) const;
```

### <a name="parameters"></a>參數

*lpszResourceName*<br/>
指向以 null 終止的字串，其中包含資料指標資源的名稱。 您可以 `CString` 針對這個引數使用。

*nIDResource*<br/>
資料指標資源的識別碼。 如需資源清單，請參閱 Windows SDK 中的 [LoadCursor](/windows/win32/api/winuser/nf-winuser-loadcursorw) 。

### <a name="return-value"></a>傳回值

如果成功，則為數據指標的控制碼;否則為 Null。

### <a name="remarks"></a>備註

`LoadCursor` 只有在先前尚未載入時，才會將資料指標載入至記憶體;否則，它會捕獲現有資源的控制碼。

使用 [LoadStandardCursor](#loadstandardcursor) 或 [LoadOEMCursor](#loadoemcursor) 成員函式來存取預先定義的 Windows 資料指標。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#44](../../mfc/reference/codesnippet/cpp/cwinapp-class_11.cpp)]

## <a name="cwinapploadicon"></a><a name="loadicon"></a> CWinApp：： LoadIcon

載入 *lpszResourceName* 所命名的圖示資源，或由 *nIDResource* 從可執行檔指定。

```
HICON LoadIcon(LPCTSTR lpszResourceName) const;  HICON LoadIcon(UINT nIDResource) const;
```

### <a name="parameters"></a>參數

*lpszResourceName*<br/>
指向以 null 終止的字串，其中包含圖示資源的名稱。 您也可以使用做 `CString` 為此引數。

*nIDResource*<br/>
圖示資源的識別碼。

### <a name="return-value"></a>傳回值

如果成功，則為圖示的控制碼;否則為 Null。

### <a name="remarks"></a>備註

`LoadIcon` 只有在先前尚未載入時，才會載入圖示;否則，它會捕獲現有資源的控制碼。

您可以使用 [LoadStandardIcon](#loadstandardicon) 或 [LoadOEMIcon](#loadoemicon) 成員函式來存取預先定義的 Windows 圖示。

> [!NOTE]
> 此成員函式會呼叫 WIN32 API 函式 [LoadIcon](/windows/win32/api/winuser/nf-winuser-loadiconw)，此函式只能載入大小符合 SM_CXICON 和 SM_CYICON 系統計量值的圖示。

## <a name="cwinapploadoemcursor"></a><a name="loadoemcursor"></a> CWinApp：： LoadOEMCursor

載入 *nIDCursor*所指定的 Windows 預先定義資料指標資源。

```
HCURSOR LoadOEMCursor(UINT nIDCursor) const;
```

### <a name="parameters"></a>參數

*nIDCursor*<br/>
指定預先定義之 Windows 游標的 **OCR_** 資訊清單常數識別碼。 您必須先擁有才能 `#define OEMRESOURCE` `#include \<afxwin.h>` 取得 WINDOWS 中 **OCR_** 常數的存取權。H。

### <a name="return-value"></a>傳回值

如果成功，則為數據指標的控制碼;否則為 Null。

### <a name="remarks"></a>備註

您 `LoadOEMCursor` 可以使用或 [LoadStandardCursor](#loadstandardcursor) 成員函式來存取預先定義的 Windows 資料指標。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#45](../../mfc/reference/codesnippet/cpp/cwinapp-class_12.h)]

[!code-cpp[NVC_MFCWindowing#46](../../mfc/reference/codesnippet/cpp/cwinapp-class_13.cpp)]

## <a name="cwinapploadoemicon"></a><a name="loadoemicon"></a> CWinApp：： LoadOEMIcon

載入 *nIDIcon*所指定的 Windows 預先定義圖示資源。

```
HICON LoadOEMIcon(UINT nIDIcon) const;
```

### <a name="parameters"></a>參數

*nIDIcon*<br/>
指定預先定義之 Windows 圖示的 **OIC_** 資訊清單常數識別碼。 您必須 `#define OEMRESOURCE` 先擁有才能 `#include \<afxwin.h>` 存取 WINDOWS 中的 **OIC_** 常數。H。

### <a name="return-value"></a>傳回值

如果成功，則為圖示的控制碼;否則為 Null。

### <a name="remarks"></a>備註

使用 `LoadOEMIcon` 或 [LoadStandardIcon](#loadstandardicon) 成員函式來存取預先定義的 Windows 圖示。

## <a name="cwinapploadstandardcursor"></a><a name="loadstandardcursor"></a> CWinApp：： LoadStandardCursor

載入 *lpszCursorName* 指定的 Windows 預先定義資料指標資源。

```
HCURSOR LoadStandardCursor(LPCTSTR lpszCursorName) const;
```

### <a name="parameters"></a>參數

*lpszCursorName*<br/>
指定預先定義之 Windows 游標的 **IDC_** 資訊清單常數識別碼。 這些識別碼是在 WINDOWS 中定義。H。 下列清單顯示 *lpszCursorName*的可能預先定義值和意義：

- IDC_ARROW 標準箭號游標

- IDC_IBEAM 標準文字插入資料指標

- 當 Windows 執行耗時的工作時，使用 IDC_WAIT 沙漏游標

- IDC_CROSS 選取範圍的交叉線游標

- IDC_UPARROW 箭號的箭號

- IDC_SIZE 已淘汰且不受支援;使用 IDC_SIZEALL

- IDC_SIZEALL 四個指向的箭號。 用來調整視窗大小的游標。

- IDC_ICON 已淘汰且不受支援。 使用 IDC_ARROW。

- IDC_SIZENWSE 雙向箭號，並在左上方和右下方結束

- IDC_SIZENESW 雙向箭號，並在右上方和左下方結束

- IDC_SIZEWE 水準雙向箭號

- IDC_SIZENS 垂直雙向箭號

### <a name="return-value"></a>傳回值

如果成功，則為數據指標的控制碼;否則為 Null。

### <a name="remarks"></a>備註

您 `LoadStandardCursor` 可以使用或 [LoadOEMCursor](#loadoemcursor) 成員函式來存取預先定義的 Windows 資料指標。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#47](../../mfc/reference/codesnippet/cpp/cwinapp-class_14.cpp)]

## <a name="cwinapploadstandardicon"></a><a name="loadstandardicon"></a> CWinApp：： LoadStandardIcon

載入 *lpszIconName* 指定的 Windows 預先定義圖示資源。

```
HICON LoadStandardIcon(LPCTSTR lpszIconName) const;
```

### <a name="parameters"></a>參數

*lpszIconName*<br/>
指定預先定義之 Windows 圖示的資訊清單常數識別碼。 這些識別碼是在 WINDOWS 中定義。H。 如需可能預先定義之值及其描述的清單，請參閱 Windows SDK 中[LoadIcon](/windows/win32/api/winuser/nf-winuser-loadiconw)的*lpIconName*參數。

### <a name="return-value"></a>傳回值

如果成功，則為圖示的控制碼;否則為 Null。

### <a name="remarks"></a>備註

使用 `LoadStandardIcon` 或 [LoadOEMIcon](#loadoemicon) 成員函式來存取預先定義的 Windows 圖示。

## <a name="cwinapploadstdprofilesettings"></a><a name="loadstdprofilesettings"></a> CWinApp：： LoadStdProfileSettings

從 [InitInstance](#initinstance) 成員函式中呼叫這個成員函式，以啟用並載入最近使用的 (MRU) 檔和上次預覽狀態的清單。

```cpp
void LoadStdProfileSettings(UINT nMaxMRU = _AFX_MRU_COUNT);
```

### <a name="parameters"></a>參數

*nMaxMRU*<br/>
要追蹤的最近使用的檔案數目。

### <a name="remarks"></a>備註

如果 *nMaxMRU* 為0，則不會維護任何 MRU 清單。

## <a name="cwinappm_bhelpmode"></a><a name="m_bhelpmode"></a> CWinApp：： m_bHelpMode

如果應用程式是在說明內容模式中，則為 TRUE， (使用 SHIFT + F1) 的傳統否則為 FALSE。

```
BOOL m_bHelpMode;
```

### <a name="remarks"></a>備註

在 [說明內容] 模式中，游標會變成問號，而使用者可以將它移到畫面上。 如果您想要在 [說明] 模式中執行特殊處理，請檢查此旗標。 `m_bHelpMode` 這是 BOOL 類型的公用變數。

## <a name="cwinappm_dwrestartmanagersupportflags"></a><a name="m_dwrestartmanagersupportflags"></a> CWinApp：： m_dwRestartManagerSupportFlags

決定重新開機管理員運作方式的旗標。

```
DWORD m_dwRestartManagerSupportFlags;
```

### <a name="remarks"></a>備註

若要啟用重新開機管理員，請將設定 `m_dwRestartManagerSupportFlags` 為您想要的行為。 下表顯示可用的旗標。

|旗標|描述|
|-|-|
|AFX_RESTART_MANAGER_SUPPORT_RESTART|應用程式是使用 [CWinApp：： RegisterWithRestartManager](#registerwithrestartmanager)來註冊。 如果應用程式意外結束，重新開機管理員會負責重新開機應用程式。|
|-AFX_RESTART_MANAGER_SUPPORT_RECOVERY|應用程式會向重新開機管理員註冊，而且重新開機管理員會在重新開機應用程式時呼叫復原回呼函式。 預設的復原回呼函式為 [CWinApp：： ApplicationRecoveryCallback](#applicationrecoverycallback)。|
|-AFX_RESTART_MANAGER_AUTOSAVE_AT_RESTART|自動儲存已啟用，重新開機管理員會在應用程式重新開機時 autosaves 任何開啟的檔。|
|-AFX_RESTART_MANAGER_AUTOSAVE_AT_INTERVAL|自動儲存會啟用，重新開機管理員會定期 autosaves 任何開啟的檔。 間隔是由 [CWinApp：： m_nAutosaveInterval](#m_nautosaveinterval)定義。|
|-AFX_RESTART_MANAGER_REOPEN_PREVIOUS_FILES|重新開機管理員會在從非預期的結束重新開機應用程式之後開啟先前開啟的檔。 [CDataRecoveryHandler 類別](../../mfc/reference/cdatarecoveryhandler-class.md)會處理開啟的檔案清單並加以還原。|
|-AFX_RESTART_MANAGER_RESTORE_AUTOSAVED_FILES|重新開機管理員會在重新開機應用程式之後提示使用者還原已保存的檔案。 `CDataRecoveryHandler`類別會查詢使用者。|
|-AFX_RESTART_MANAGER_SUPPORT_NO_AUTOSAVE|AFX_RESTART_MANAGER_SUPPORT_RESTART、AFX_RESTART_MANAGER_SUPPORT_RECOVER 和 AFX_RESTART_MANAGER_REOPEN_PREVIOUS_FILES 的聯集。|
|-AFX_RESTART_MANAGER_SUPPORT_ALL_ASPECTS|AFX_RESTART_MANAGER_SUPPORT_NO_AUTOSAVE、AFX_RESTART_MANAGER_AUTOSAVE_AT_RESTART、AFX_RESTART_MANAGER_AUTOSAVE_AT_INTERVAL 和 AFX_RESTART_MANAGER_RESTORE_AUTOSAVED_FILES 的聯集。|
|-AFX_RESTART_MANAGER_SUPPORT_RESTART_ASPECTS|AFX_RESTART_MANAGER_SUPPORT_RESTART、AFX_RESTART_MANAGER_AUTOSAVE_AT_RESTART、AFX_RESTART_MANAGER_REOPEN_PREVIOUS_FILES 和 AFX_RESTART_MANAGER_RESTORE_AUTOSAVED_FILES 的聯集。|
|-AFX_RESTART_MANAGER_SUPPORT_RECOVERY_ASPECTS|Union ofAFX_RESTART_MANAGER_SUPPORT_RECOVERY、AFX_RESTART_MANAGER_AUTOSAVE_AT_INTERVAL、AFX_RESTART_MANAGER_REOPEN_PREVIOUS_FILES 和 AFX_RESTART_MANAGER_RESTORE_AUTOSAVED_FILES。|

## <a name="cwinappm_ehelptype"></a><a name="m_ehelptype"></a> CWinApp：： m_eHelpType

此資料成員的類型是列舉型別 AFX_HELP_TYPE，在類別中定義 `CWinApp` 。

```
AFX_HELP_TYPE m_eHelpType;
```

### <a name="remarks"></a>備註

AFX_HELP_TYPE 列舉的定義如下：

```
enum AFX_HELP_TYPE {
    afxWinHelp = 0,
    afxHTMLHelp = 1
    };
```

- 若要將應用程式的說明設定為 HTML Help，請呼叫 [SetHelpMode](#sethelpmode) 並指定 `afxHTMLHelp` 。

- 若要將應用程式的說明設定為 WinHelp，請呼叫 `SetHelpMode` 並指定 `afxWinHelp` 。

## <a name="cwinappm_hinstance"></a><a name="m_hinstance"></a> CWinApp：： m_hInstance

對應至 Windows 傳遞到的 *hInstance* 參數 `WinMain` 。

```
HINSTANCE m_hInstance;
```

### <a name="remarks"></a>備註

`m_hInstance`資料成員是在 Windows 下執行之應用程式的目前實例的控制碼。 全域函式 [AfxGetInstanceHandle](application-information-and-management.md#afxgetinstancehandle)會傳回這項功能。 `m_hInstance` 這是 HINSTANCE 類型的公用變數。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#55](../../mfc/reference/codesnippet/cpp/cwinapp-class_15.cpp)]

## <a name="cwinappm_lpcmdline"></a><a name="m_lpcmdline"></a> CWinApp：： m_lpCmdLine

對應至 Windows 傳遞到的 *lpCmdLine* 參數 `WinMain` 。

```
LPTSTR m_lpCmdLine;
```

### <a name="remarks"></a>備註

指向以 null 終止的字串，這個字串會指定應用程式的命令列。 用 `m_lpCmdLine` 來存取使用者在啟動應用程式時所輸入的任何命令列引數。 `m_lpCmdLine` 這是 LPTSTR 類型的公用變數。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#52](../../mfc/reference/codesnippet/cpp/cwinapp-class_16.cpp)]

## <a name="cwinappm_nautosaveinterval"></a><a name="m_nautosaveinterval"></a> CWinApp：： m_nAutosaveInterval

Autosaves 之間的時間長度（以毫秒為單位）。

```
int m_nAutosaveInterval;
```

### <a name="remarks"></a>備註

您可以將重新開機管理員設定為在設定的間隔自動儲存開啟的檔。 如果您的應用程式不會自動儲存檔案，此參數不會有任何作用。

## <a name="cwinappm_ncmdshow"></a><a name="m_ncmdshow"></a> CWinApp：： m_nCmdShow

對應至 Windows 傳遞到的 *nCmdShow* 參數 `WinMain` 。

```
int m_nCmdShow;
```

### <a name="remarks"></a>備註

`m_nCmdShow`當您針對應用程式的主視窗呼叫[CWnd：： ShowWindow](../../mfc/reference/cwnd-class.md#showwindow)時，應該傳遞做為引數。 `m_nCmdShow` 這是類型的公用變數 **`int`** 。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#56](../../mfc/reference/codesnippet/cpp/cwinapp-class_17.cpp)]

## <a name="cwinappm_pactivewnd"></a><a name="m_pactivewnd"></a> CWinApp：： m_pActiveWnd

您可以使用此資料成員，將指標儲存至 OLE 容器應用程式的主視窗，此應用程式會就地啟用 OLE 伺服器應用程式。

### <a name="remarks"></a>備註

如果此資料成員為 Null，則應用程式不會就地啟用。

當框架視窗就地由 OLE 容器應用程式啟動時，架構會設定這個成員變數。

## <a name="cwinappm_pdatarecoveryhandler"></a><a name="m_pdatarecoveryhandler"></a> CWinApp：： m_pDataRecoveryHandler

應用程式資料修復處理常式的指標。

```
CDataRecoveryHandler* m_pDataRecoveryHandler;
```

### <a name="remarks"></a>備註

應用程式的資料復原處理常式會監視開啟的檔，並加以 autosaves。 當應用程式意外結束時，此架構會使用資料修復處理常式來還原自動儲存的檔案。 如需詳細資訊，請參閱 [CDataRecoveryHandler 類別](../../mfc/reference/cdatarecoveryhandler-class.md)。

## <a name="cwinappm_pszappname"></a><a name="m_pszappname"></a> CWinApp：： m_pszAppName

指定應用程式的名稱。

```
LPCTSTR m_pszAppName;
```

### <a name="remarks"></a>備註

應用程式名稱可以來自傳遞給 [CWinApp](#cwinapp) 的函式的參數，如果未指定，則為具有 AFX_IDS_APP_TITLE 識別碼的資源字串。 如果在資源中找不到應用程式名稱，則來自程式的。EXE 檔案名。

由全域函式 [AfxGetAppName](application-information-and-management.md#afxgetappname)傳回。 `m_pszAppName`這是**const char**類型的公用變數 <strong>\*</strong> 。

> [!NOTE]
> 如果您將值指派給 `m_pszAppName` ，則必須以動態方式配置在堆積上。 `CWinApp`此函式會使用這個指標來呼叫**free** ( ) 。 您需要使用 `_tcsdup` ( ) 執行時間程式庫函式來進行配置。 此外，在指派新值之前，請釋放與目前指標相關聯的記憶體。 例如：

[!code-cpp[NVC_MFCWindowing#57](../../mfc/reference/codesnippet/cpp/cwinapp-class_18.cpp)]

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#65](../../mfc/reference/codesnippet/cpp/cwinapp-class_19.cpp)]

## <a name="cwinappm_pszexename"></a><a name="m_pszexename"></a> CWinApp：： m_pszExeName

包含應用程式的可執行檔名稱，但不含副檔名。

```
LPCTSTR m_pszExeName;
```

### <a name="remarks"></a>備註

不同于 [m_pszAppName](#m_pszappname)，此名稱不能包含空白。 `m_pszExeName`這是**const char**類型的公用變數 <strong>\*</strong> 。

> [!NOTE]
> 如果您將值指派給 `m_pszExeName` ，則必須以動態方式配置在堆積上。 `CWinApp`此函式會使用這個指標來呼叫**free** ( ) 。 您需要使用 `_tcsdup` ( ) 執行時間程式庫函式來進行配置。 此外，在指派新值之前，請釋放與目前指標相關聯的記憶體。 例如：

[!code-cpp[NVC_MFCWindowing#58](../../mfc/reference/codesnippet/cpp/cwinapp-class_20.cpp)]

## <a name="cwinappm_pszhelpfilepath"></a><a name="m_pszhelpfilepath"></a> CWinApp：： m_pszHelpFilePath

包含應用程式說明檔的路徑。

```
LPCTSTR m_pszHelpFilePath;
```

### <a name="remarks"></a>備註

根據預設，架構會初始化 `m_pszHelpFilePath` 為具有 "的應用程式名稱。已附加了 [.HLP]。 若要變更說明檔的名稱，請將設定 `m_pszHelpFilePath` 為指向包含所需說明檔之完整名稱的字串。 在應用程式的 [InitInstance](#initinstance) 函式中，有一個方便的位置。 `m_pszHelpFilePath`這是**const char**類型的公用變數 <strong>\*</strong> 。

> [!NOTE]
> 如果您將值指派給 `m_pszHelpFilePath` ，則必須以動態方式配置在堆積上。 `CWinApp`此函式會使用這個指標來呼叫**free** ( ) 。 您需要使用 `_tcsdup` ( ) 執行時間程式庫函式來進行配置。 此外，在指派新值之前，請釋放與目前指標相關聯的記憶體。 例如：

[!code-cpp[NVC_MFCWindowing#59](../../mfc/reference/codesnippet/cpp/cwinapp-class_21.cpp)]

## <a name="cwinappm_pszprofilename"></a><a name="m_pszprofilename"></a> CWinApp：： m_pszProfileName

包含應用程式的名稱。INI 檔案。

```
LPCTSTR m_pszProfileName;
```

### <a name="remarks"></a>備註

`m_pszProfileName`這是**const char**類型的公用變數 <strong>\*</strong> 。

> [!NOTE]
> 如果您將值指派給 `m_pszProfileName` ，則必須以動態方式配置在堆積上。 `CWinApp`此函式會使用這個指標來呼叫**free** ( ) 。 您需要使用 `_tcsdup` ( ) 執行時間程式庫函式來進行配置。 此外，在指派新值之前，請釋放與目前指標相關聯的記憶體。 例如：

[!code-cpp[NVC_MFCWindowing#60](../../mfc/reference/codesnippet/cpp/cwinapp-class_22.cpp)]

## <a name="cwinappm_pszregistrykey"></a><a name="m_pszregistrykey"></a> CWinApp：： m_pszRegistryKey

用來判斷登錄或 INI 檔案中儲存應用程式佈建檔設定的位置。

```
LPCTSTR m_pszRegistryKey;
```

### <a name="remarks"></a>備註

一般來說，此資料成員會被視為唯讀。

- 值會儲存在登錄機碼中。 應用程式佈建檔設定的名稱會附加至下列登錄機碼： HKEY_CURRENT_USER/Software/LocalAppWizard-Generated/。

如果您將值指派給 `m_pszRegistryKey` ，則必須以動態方式配置在堆積上。 `CWinApp`此函式會使用這個指標來呼叫**free** ( ) 。 您需要使用 `_tcsdup` ( ) 執行時間程式庫函式來進行配置。 此外，在指派新值之前，請釋放與目前指標相關聯的記憶體。 例如：

[!code-cpp[NVC_MFCWindowing#61](../../mfc/reference/codesnippet/cpp/cwinapp-class_23.cpp)]

## <a name="cwinappm_pszappid"></a><a name="m_pszappid"></a> CWinApp：： m_pszAppID

應用程式使用者模型識別碼。

```
LPCTSTR m_pszAppID;
```

### <a name="remarks"></a>備註

## <a name="cwinapponcontexthelp"></a><a name="oncontexthelp"></a> CWinApp：： OnCoNtextHelp

處理應用程式內的 SHIFT + F1 說明。

```
afx_msg void OnContextHelp();
```

### <a name="remarks"></a>備註

您必須將 `ON_COMMAND( ID_CONTEXT_HELP, OnContextHelp )` 語句新增至您的 `CWinApp` 類別訊息對應，並同時加入快速鍵對應表專案（通常是 SHIFT + F1），才能啟用此成員函式。

`OnContextHelp` 讓應用程式進入說明模式。 游標會變成箭號和問號，然後使用者可以移動滑鼠指標，然後按下滑鼠左鍵，以選取對話方塊、視窗、功能表或命令按鈕。 此成員函式會在資料指標下抓取物件的說明內容，並以該說明內容呼叫 Windows 函式 WinHelp。

## <a name="cwinapponddecommand"></a><a name="onddecommand"></a> CWinApp：： OnDDECommand

當主框架視窗收到 DDE 執行訊息時，由架構呼叫。

```
virtual BOOL OnDDECommand(LPTSTR lpszCommand);
```

### <a name="parameters"></a>參數

*lpszCommand*<br/>
指向應用程式所接收的 DDE 命令字串。

### <a name="return-value"></a>傳回值

如果已處理命令，則為非零;否則為0。

### <a name="remarks"></a>備註

預設的執行會檢查命令是否為開啟檔的要求，如果是，則會開啟指定的檔。 當使用者按兩下資料檔案時，Windows 檔案管理員通常會傳送這類 DDE 命令字串。 覆寫此函式以處理其他 DDE execute 命令，例如要列印的命令。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#48](../../mfc/reference/codesnippet/cpp/cwinapp-class_24.cpp)]

## <a name="cwinapponfilenew"></a><a name="onfilenew"></a> CWinApp：： OnFileNew

實行 ID_FILE_NEW 命令。

```
afx_msg void OnFileNew();
```

### <a name="remarks"></a>備註

您必須將 `ON_COMMAND( ID_FILE_NEW, OnFileNew )` 語句加入至 `CWinApp` 類別的訊息對應，才能啟用這個成員函式。 若已啟用，此函式會處理 File New 命令的執行。

如需有關預設行為的資訊，以及如何覆寫此成員函式的指引，請參閱 [技術提示 22](../../mfc/tn022-standard-commands-implementation.md) 。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#49](../../mfc/reference/codesnippet/cpp/cwinapp-class_25.cpp)]

[!code-cpp[NVC_MFCWindowing#50](../../mfc/reference/codesnippet/cpp/cwinapp-class_26.cpp)]

## <a name="cwinapponfileopen"></a><a name="onfileopen"></a> CWinApp：： OnFileOpen

實行 ID_FILE_OPEN 命令。

```
afx_msg void OnFileOpen();
```

### <a name="remarks"></a>備註

您必須將 `ON_COMMAND( ID_FILE_OPEN, OnFileOpen )` 語句加入至 `CWinApp` 類別的訊息對應，才能啟用這個成員函式。 啟用時，此函式會處理檔案開啟命令的執行。

如需有關如何覆寫此成員函式之預設行為和指引的詳細資訊，請參閱 [技術附注 22](../../mfc/tn022-standard-commands-implementation.md)。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#49](../../mfc/reference/codesnippet/cpp/cwinapp-class_25.cpp)]

[!code-cpp[NVC_MFCWindowing#50](../../mfc/reference/codesnippet/cpp/cwinapp-class_26.cpp)]

## <a name="cwinapponfileprintsetup"></a><a name="onfileprintsetup"></a> CWinApp：： OnFilePrintSetup

實行 ID_FILE_PRINT_SETUP 命令。

```
afx_msg void OnFilePrintSetup();
```

### <a name="remarks"></a>備註

您必須將 `ON_COMMAND( ID_FILE_PRINT_SETUP, OnFilePrintSetup )` 語句加入至 `CWinApp` 類別的訊息對應，才能啟用這個成員函式。 啟用時，此函式會處理檔案列印命令的執行。

如需有關如何覆寫此成員函式之預設行為和指引的詳細資訊，請參閱 [技術附注 22](../../mfc/tn022-standard-commands-implementation.md)。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#49](../../mfc/reference/codesnippet/cpp/cwinapp-class_25.cpp)]

[!code-cpp[NVC_MFCWindowing#50](../../mfc/reference/codesnippet/cpp/cwinapp-class_26.cpp)]

## <a name="cwinapponhelp"></a><a name="onhelp"></a> CWinApp：： OnHelp

在應用程式 (使用目前的內容) 中處理 F1 說明。

```
afx_msg void OnHelp();
```

### <a name="remarks"></a>備註

通常，您也會新增 F1 鍵的快速鍵專案。 啟用 F1 鍵只是慣例，而不是必要條件。

您必須將 `ON_COMMAND( ID_HELP, OnHelp )` 語句加入至 `CWinApp` 類別的訊息對應，才能啟用這個成員函式。 啟用時，當使用者按下 F1 鍵時，由架構呼叫。

此訊息處理常式函式的預設執行會決定對應到目前視窗、對話方塊或功能表項目的說明內容，然後再呼叫 WINHELP.EXE。 如果目前沒有內容可用，則函式會使用預設內容。

覆寫這個成員函式，將說明內容設定為目前擁有焦點的視窗、對話方塊、功能表項目或工具列按鈕以外的內容。 `WinHelp`使用所需的說明內容識別碼來呼叫。

## <a name="cwinapponhelpfinder"></a><a name="onhelpfinder"></a> CWinApp：： OnHelpFinder

處理 ID_HELP_FINDER 和 ID_DEFAULT_HELP 命令。

```
afx_msg void OnHelpFinder();
```

### <a name="remarks"></a>備註

您必須將 `ON_COMMAND( ID_HELP_FINDER, OnHelpFinder )` 語句加入至 `CWinApp` 類別的訊息對應，才能啟用這個成員函式。 啟用時，架構會在應用程式的使用者選取說明搜尋工具命令以 `WinHelp` 使用標準 **HELP_FINDER** 主題來叫用時，呼叫此訊息處理函式。

## <a name="cwinapponhelpindex"></a><a name="onhelpindex"></a> CWinApp：： OnHelpIndex

處理 ID_HELP_INDEX 命令，並提供預設說明主題。

```
afx_msg void OnHelpIndex();
```

### <a name="remarks"></a>備註

您必須將 `ON_COMMAND( ID_HELP_INDEX, OnHelpIndex )` 語句加入至 `CWinApp` 類別的訊息對應，才能啟用這個成員函式。 啟用時，架構會在應用程式的使用者選取 [說明索引] 命令以 `WinHelp` 使用標準 **HELP_INDEX** 主題來叫用時，呼叫此訊息處理函式。

## <a name="cwinapponhelpusing"></a><a name="onhelpusing"></a> CWinApp：： OnHelpUsing

處理 ID_HELP_USING 命令。

```
afx_msg void OnHelpUsing();
```

### <a name="remarks"></a>備註

您必須將 `ON_COMMAND( ID_HELP_USING, OnHelpUsing )` 語句加入至 `CWinApp` 類別的訊息對應，才能啟用這個成員函式。 當您應用程式的使用者使用命令叫 `WinHelp` 用標準 **HELP_HELPONHELP** 主題來叫用應用程式時，架構會呼叫此訊息處理函式。

## <a name="cwinapponidle"></a><a name="onidle"></a> CWinApp：： OnIdle

覆寫此成員函式以執行閒置時間處理。

```
virtual BOOL OnIdle(LONG lCount);
```

### <a name="parameters"></a>參數

*lCount*<br/>
`OnIdle`當應用程式的訊息佇列是空的時，就會呼叫每次遞增的計數器。 每次處理新訊息時，此計數會重設為0。 您可以使用 *lCount* 參數來判斷應用程式閒置的相對時間長度，而不需要處理訊息。

### <a name="return-value"></a>傳回值

非零，以接收更多閒置處理時間;如果不需要更多閒置時間，則為0。

### <a name="remarks"></a>備註

`OnIdle` 當應用程式的訊息佇列是空的時，會在預設訊息迴圈中呼叫。 使用您的覆寫來呼叫您自己的背景閒置處理常式工作。

`OnIdle` 應傳回0，表示不需要閒置處理時間。 *lCount* `OnIdle` 當訊息佇列是空的時，每次呼叫 lCount 參數，並在每次處理新訊息時重設為0時，就會遞增。 您可以根據此計數來呼叫不同的閒置常式。

以下摘要說明閒置迴圈處理：

1. 如果 MFC 程式庫中的訊息迴圈檢查訊息佇列，而且找不到擱置中的訊息，則會呼叫 `OnIdle` 應用程式物件，並提供0作為 *lCount* 引數。

2. `OnIdle` 會執行一些處理，並傳回非零值，表示應該再次呼叫它來執行進一步的處理。

3. 訊息迴圈會再次檢查訊息佇列。 如果沒有擱置中的訊息，則會 `OnIdle` 再次呼叫，遞增 *lCount* 引數。

4. 最後，會 `OnIdle` 完成所有閒置工作的處理，並傳回0。 這會告知訊息迴圈停止呼叫 `OnIdle` ，直到從訊息佇列接收到下一個訊息為止，此時閒置迴圈會重新開機，並將引數設定為0。

請勿在期間執行冗長的 `OnIdle` 工作，因為您的應用程式在傳回之前無法處理使用者輸入 `OnIdle` 。

> [!NOTE]
> 的預設執行 `OnIdle` 會更新命令使用者介面物件（例如功能表項目和工具列按鈕），並執行內部資料結構清除。 因此，如果您覆寫 `OnIdle` ，就必須 `CWinApp::OnIdle` 使用覆 `lCount` 寫版本中的來呼叫。 先呼叫所有的基類閒置處理 (也就是，直到基類傳回 `OnIdle` 0) 為止。 如果您需要在基本類別處理完成之前執行工作，請檢查基類的執行，以選取要在哪一個 *lCount* 執行您的工作。

如果您不想在 `OnIdle` 每次從訊息佇列中取出訊息時呼叫，您可以覆寫 [CWinThreadIsIdleMessage](../../mfc/reference/cwinthread-class.md#isidlemessage)。 如果應用程式已設定非常短的計時器，或系統正在傳送 WM_SYSTIMER 訊息，則 `OnIdle` 會重複呼叫，並降低效能。

### <a name="example"></a>範例

下列兩個範例示範如何使用 `OnIdle` 。 第一個範例會使用 *lCount* 引數來處理兩個閒置工作，以排定工作的優先順序。 第一個工作是高優先順序，您應該盡可能地進行。 第二個工作較不重要，只有在使用者輸入中有很長的暫停時，才應該執行這項工作。 請注意基類版本的呼叫 `OnIdle` 。 第二個範例會使用不同的優先順序來管理一組閒置工作。

[!code-cpp[NVC_MFCWindowing#51](../../mfc/reference/codesnippet/cpp/cwinapp-class_27.cpp)]

## <a name="cwinappopendocumentfile"></a><a name="opendocumentfile"></a> CWinApp：： OpenDocumentFile

架構會呼叫這個方法來開啟應用程式的已命名 [CDocument](../../mfc/reference/cdocument-class.md) 檔。

```
virtual CDocument* OpenDocumentFile(
    LPCTSTR lpszFileName
    BOOL bAddToMRU = TRUE);
```

### <a name="parameters"></a>參數

*lpszFileName*<br/>
在要開啟的檔案名。

*bAddToMRU*<br/>
在TRUE 表示檔是最新的檔案之一;FALSE 表示檔不是最新的檔案之一。

### <a name="return-value"></a>傳回值

如果成功，則為的指標 `CDocument` ; 否則為 Null。

### <a name="remarks"></a>備註

如果已經開啟具有該名稱的檔，則包含該檔的第一個框架視窗將取得焦點。 如果應用程式支援多個檔範本，此架構會使用副檔名來尋找適當的檔範本，以嘗試載入檔。 如果成功，檔範本就會建立檔的框架視窗和查看。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#52](../../mfc/reference/codesnippet/cpp/cwinapp-class_16.cpp)]

## <a name="cwinappparsecommandline"></a><a name="parsecommandline"></a> CWinApp：:P arseCommandLine

呼叫此成員函式來剖析命令列，並一次將參數傳送至 [CCommandLineInfo：:P arseparam](../../mfc/reference/ccommandlineinfo-class.md#parseparam)。

```cpp
void ParseCommandLine(CCommandLineInfo& rCmdInfo);
```

### <a name="parameters"></a>參數

*rCmdInfo*<br/>
[CCommandLineInfo](../../mfc/reference/ccommandlineinfo-class.md)物件的參考。

### <a name="remarks"></a>備註

當您使用「應用程式精靈」來啟動新的 MFC 專案時，「應用程式精靈」會建立的本機實例 `CCommandLineInfo` ，然後 `ProcessShellCommand` `ParseCommandLine` 在 [InitInstance](#initinstance) 成員函數中呼叫和。 命令列會遵循如下所述的路由：

1. 在中建立之後 `InitInstance` ， `CCommandLineInfo` 會將物件傳遞至 `ParseCommandLine` 。

2. `ParseCommandLine` 然後 `CCommandLineInfo::ParseParam` 針對每個參數重複呼叫一次。

3. `ParseParam` 填滿 `CCommandLineInfo` 物件，該物件接著會傳遞至 [ProcessShellCommand](#processshellcommand)。

4. `ProcessShellCommand` 處理命令列引數和旗標。

請注意，您可以 `ParseCommandLine` 視需要直接呼叫。

如需命令列旗標的說明，請參閱 [CCommandLineInfo：： m_nShellCommand](../../mfc/reference/ccommandlineinfo-class.md#m_nshellcommand)。

## <a name="cwinapppretranslatemessage"></a><a name="pretranslatemessage"></a> CWinApp：:P reTranslateMessage

覆寫這個函式以在分派至 Windows 函式 [TranslateMessage](/windows/win32/api/winuser/nf-winuser-translatemessage) 之前篩選視窗訊息，並 [DispatchMessage](/windows/win32/api/winuser/nf-winuser-dispatchmessage) 預設的實執行快速鍵轉譯，因此您必須在覆 `CWinApp::PreTranslateMessage` 寫的版本中呼叫成員函式。

```
virtual BOOL PreTranslateMessage(MSG* pMsg);
```

### <a name="parameters"></a>參數

*pMsg*<br/>
包含要處理之訊息的 [MSG](/windows/win32/api/winuser/ns-winuser-msg) 結構指標。

### <a name="return-value"></a>傳回值

如果訊息是在中完整處理 `PreTranslateMessage` ，而不應該進一步處理，則為非零。 如果應該以正常方式處理訊息，則為零。

## <a name="cwinappprocessmessagefilter"></a><a name="processmessagefilter"></a> CWinApp：:P rocessMessageFilter

架構的攔截函式會呼叫這個成員函式，以篩選和回應特定的 Windows 訊息。

```
virtual BOOL ProcessMessageFilter(
    int code,
    LPMSG lpMsg);
```

### <a name="parameters"></a>參數

*code*<br/>
指定攔截程式碼。 此成員函式會使用程式碼來判斷如何處理 *lpMsg。*

*lpMsg*<br/>
指向 Windows [MSG](/windows/win32/api/winuser/ns-winuser-msg)結構 t) 的指標。

### <a name="return-value"></a>傳回值

如果已處理訊息，則為非零。否則為0。

### <a name="remarks"></a>備註

攔截函式會先處理事件，再將它們傳送至應用程式的一般訊息處理。

如果您覆寫這個先進的功能，請務必呼叫基類版本，以維護架構的攔截處理。

## <a name="cwinappprocessshellcommand"></a><a name="processshellcommand"></a> CWinApp：:P rocessShellCommand

[InitInstance](#initinstance)會呼叫這個成員函式，以接受從 rCmdInfo 所識別之物件傳遞的參數 `CCommandLineInfo` ，並執行指定的動作。 *rCmdInfo*

```
BOOL ProcessShellCommand(CCommandLineInfo& rCmdInfo);
```

### <a name="parameters"></a>參數

*rCmdInfo*<br/>
[CCommandLineInfo](../../mfc/reference/ccommandlineinfo-class.md)物件的參考。

### <a name="return-value"></a>傳回值

如果 shell 命令已成功處理，則為非零。 如果是0，則從 [InitInstance](#initinstance)傳回 FALSE。

### <a name="remarks"></a>備註

當您使用「應用程式精靈」來啟動新的 MFC 專案時，「應用程式精靈」會建立的本機實例 `CCommandLineInfo` ，然後 `ProcessShellCommand` 在成員函式中呼叫和 [ParseCommandLine](#parsecommandline) `InitInstance` 。 命令列會遵循如下所述的路由：

1. 在中建立之後 `InitInstance` ， `CCommandLineInfo` 會將物件傳遞至 `ParseCommandLine` 。

2. `ParseCommandLine` 然後針對每個參數重複呼叫 [CCommandLineInfo：:P arseparam](../../mfc/reference/ccommandlineinfo-class.md#parseparam) 。

3. `ParseParam` 填滿 `CCommandLineInfo` 物件，該物件接著會傳遞至 `ProcessShellCommand` 。

4. `ProcessShellCommand` 處理命令列引數和旗標。

物件的資料成員 `CCommandLineInfo` （由 [CCommandLineInfo：： m_nShellCommand](../../mfc/reference/ccommandlineinfo-class.md#m_nshellcommand)識別）屬於下列列舉型別，其定義于 `CCommandLineInfo` 類別中。

```
enum {
    FileNew,
    FileOpen,
    FilePrint,
    FilePrintTo,
    FileDDE
    };
```

如需每個值的簡短描述，請參閱 `CCommandLineInfo::m_nShellCommand` 。

## <a name="cwinappprocesswndprocexception"></a><a name="processwndprocexception"></a> CWinApp：:P rocessWndProcException

每當處理常式未攔截到您應用程式的其中一個訊息或命令處理常式中擲回的例外狀況時，架構就會呼叫這個成員函式。

```
virtual LRESULT ProcessWndProcException(
    CException* e,
    const MSG* pMsg);
```

### <a name="parameters"></a>參數

*pci-e*<br/>
未攔截之例外狀況的指標。

*pMsg*<br/>
包含導致架構擲回例外狀況之 windows 訊息相關資訊的 [MSG](/windows/win32/api/winuser/ns-winuser-msg)結構 t) 。

### <a name="return-value"></a>傳回值

應傳回給 Windows 的值。 一般來說，這是 windows 訊息的0L，1L ( TRUE) 的命令訊息。

### <a name="remarks"></a>備註

請勿直接呼叫此成員函式。

此成員函式的預設執行會建立訊息方塊。 如果未攔截到的例外狀況是由功能表、工具列或快速鍵命令失敗所產生，則訊息方塊會顯示「命令失敗」訊息;否則，它會顯示「內部應用程式錯誤」訊息。

覆寫這個成員函式，以提供例外狀況的全域處理。 如果您想要顯示訊息方塊，請只呼叫基底功能。

## <a name="cwinappregister"></a><a name="register"></a> CWinApp：： Register

執行任何未由處理的註冊工作 `RegisterShellFileTypes` 。

```
virtual BOOL Register();
```

### <a name="return-value"></a>傳回值

非零成功，否則為 0。

### <a name="remarks"></a>備註

預設的實值只會傳回 TRUE。 覆寫此函數以提供任何自訂的註冊步驟。

## <a name="cwinappregistershellfiletypes"></a><a name="registershellfiletypes"></a> CWinApp：： RegisterShellFileTypes

呼叫此成員函式，以使用 Windows 檔案管理員註冊您所有應用程式的檔案類型。

```cpp
void RegisterShellFileTypes(BOOL bCompat = FALSE);
```

### <a name="parameters"></a>參數

*bCompat*<br/>
在TRUE 會新增 shell 命令列印和列印的註冊專案，讓使用者可以直接從 shell 列印檔案，或將檔案拖曳至印表機物件。 它也會新增 DefaultIcon 索引鍵。 根據預設，此參數為 FALSE，以提供回溯相容性。

### <a name="remarks"></a>備註

這可讓使用者在 [檔案管理員] 中按兩下應用程式，以開啟應用程式所建立的資料檔案。 在 `RegisterShellFileTypes` 您針對應用程式中的每個檔範本呼叫 [AddDocTemplate](#adddoctemplate) 之後呼叫。 當您呼叫時，也請呼叫 [新增 enableshellopen](#enableshellopen) 成員函式 `RegisterShellFileTypes` 。

`RegisterShellFileTypes` 逐一查看應用程式所維護的 [CDocTemplate](../../mfc/reference/cdoctemplate-class.md) 物件清單，並針對每個檔範本，將專案加入至 Windows 為檔案關聯所維護的註冊資料庫。 當使用者按兩下資料檔案時，檔案管理員會使用這些專案來開啟資料檔。 這樣就不需要寄送。REG 檔案與您的應用程式。

> [!NOTE]
> `RegisterShellFileTypes` 只有在使用者以系統管理員許可權執行程式時，才會運作。 如果程式沒有系統管理員許可權，就無法改變登錄機碼。

如果註冊資料庫已將指定的副檔名與其他檔案類型產生關聯，則不會建立新的關聯。 `CDocTemplate`如需註冊此資訊所需的字串格式，請參閱類別。

## <a name="cwinappregisterwithrestartmanager"></a><a name="registerwithrestartmanager"></a> CWinApp：： RegisterWithRestartManager

使用重新開機管理員來註冊應用程式。

```
virtual HRESULT RegisterWithRestartManager(
    BOOL bRegisterRecoveryCallback,
    const CString& strRestartIdentifier);

virtual HRESULT RegisterWithRestartManager(
    LPCWSTR pwzCommandLineArgs,
    DWORD dwRestartFlags,
    APPLICATION_RECOVERY_CALLBACK pRecoveryCallback,
    LPVOID lpvParam,
    DWORD dwPingInterval,
    DWORD dwCallbackFlags);
```

### <a name="parameters"></a>參數

*bRegisterRecoveryCallback*\
在TRUE 表示此應用程式實例使用復原回呼函式;FALSE 表示它不存在。 當應用程式意外結束時，架構會呼叫復原回呼函數。 如需詳細資訊，請參閱 [CWinApp：： ApplicationRecoveryCallback](#applicationrecoverycallback)。

*strRestartIdentifier*\
在識別此重新開機管理員實例的唯一字串。 每個應用程式實例的重新開機管理員識別碼都是唯一的。

*pwzCommandLineArgs*\
在字串，包含命令列中的任何額外引數。

*dwRestartFlags*\
在重新開機管理員的選擇性旗標。 如需詳細資訊，請參閱＜備註＞一節。

*pRecoveryCallback*\
在復原回呼函數。 此函數必須採用 LPVOID 參數做為輸入，並傳回 DWORD。 預設的復原回呼函式為 `CWinApp::ApplicationRecoveryCallback` 。

*lpvParam*\
在復原回呼函數的輸入參數。 如需詳細資訊，請參閱 [CWinApp：： ApplicationRecoveryCallback](#applicationrecoverycallback)。

*dwPingInterval*\
在重新開機管理員等候復原回呼函數傳回的時間長度。 這個參數是以毫秒為單位。

*dwCallbackFlags*\
在傳遞至復原回呼函數的旗標。 保留供未來使用。

### <a name="return-value"></a>傳回值

如果方法成功，則為 S_OK;否則是錯誤碼。

### <a name="remarks"></a>備註

如果您的應用程式使用自動儲存檔的預設 MFC 實值，您應該使用的簡單版本 `RegisterWithRestartManager` 。 `RegisterWithRestartManager`如果您想要自訂應用程式的自動儲存行為，請使用的複雜版本。

如果您使用 *strRestartIdentifier*的空字串來呼叫這個方法，就會 `RegisterWithRestartManager` 為這個重新開機管理員的實例建立唯一的識別碼串。

當應用程式意外結束時，重新開機管理員會從命令列重新開機應用程式，並提供唯一的重新開機識別碼作為選擇性引數。 在此案例中，架構會呼叫 `RegisterWithRestartManager` 兩次。 第一個呼叫是來自 [CWinApp：： InitInstance](#initinstance) ，字串識別碼的空字串。 然後，方法 [CWinApp：:P rocessshellcommand](#processshellcommand) `RegisterWithRestartManager` 使用唯一的重新開機識別碼進行呼叫。

使用重新開機管理員註冊應用程式之後，重新開機管理員會監視應用程式。 如果應用程式意外結束，重新開機管理員會在關閉程式期間呼叫復原回呼函式。 重新開機管理員會等待 *dwPingInterval* 取得復原回呼函式的回應。 如果復原回呼函式在這段時間內沒有回應，應用程式就會結束，而不會執行復原回呼函數。

依預設，不支援 dwRestartFlags，但提供供日後使用。 *DwRestartFlags*可能的值如下所示：

- RESTART_NO_CRASH

- RESTART_NO_HANG

- RESTART_NO_PATCH

- RESTART_NO_REBOOT

## <a name="cwinappreopenpreviousfilesatrestart"></a><a name="reopenpreviousfilesatrestart"></a> CWinApp：： ReopenPreviousFilesAtRestart

決定當應用程式意外結束時，重新開機管理員是否重新開啟已開啟的檔案。

```
virtual BOOL ReopenPreviousFilesAtRestart() const;
```

### <a name="return-value"></a>傳回值

TRUE 表示重新開機管理員重新開啟先前開啟的檔案;FALSE 表示重新開機管理員不存在。

## <a name="cwinapprestartinstance"></a><a name="restartinstance"></a> CWinApp：： RestartInstance

處理重新開機管理員所起始的應用程式重新開機。

```
virtual BOOL CWinApp::RestartInstance();
```

### <a name="return-value"></a>傳回值

如果資料恢復處理常式開啟先前開啟的檔，則為 TRUE;如果資料復原處理常式發生錯誤，或沒有先前開啟的檔，則為 FALSE。

### <a name="remarks"></a>備註

當重新開機管理員重新開機應用程式時，架構會呼叫這個方法。 這個方法會抓取資料修復處理常式，並還原已自動儲存的檔案。 這個方法會呼叫 [CDataRecoveryHandler：： RestoreAutosavedDocuments](../../mfc/reference/cdatarecoveryhandler-class.md#restoreautosaveddocuments) ，以判斷使用者是否想要還原自動儲存的檔案。

如果 [CDataRecoveryHandler](../../mfc/reference/cdatarecoveryhandler-class.md) 判斷沒有任何開啟的檔，這個方法會傳回 FALSE。 如果沒有任何開啟的檔，則通常會啟動應用程式。

## <a name="cwinapprestoreautosavedfilesatrestart"></a><a name="restoreautosavedfilesatrestart"></a> CWinApp：： RestoreAutosavedFilesAtRestart

決定重新開機管理員在重新開機應用程式時是否還原自動儲存的檔案。

```
virtual BOOL RestoreAutosavedFilesAtRestart() const;
```

### <a name="return-value"></a>傳回值

TRUE 表示重新開機管理員還原自動儲存的檔案;FALSE 表示重新開機管理員不存在。

## <a name="cwinapprun"></a><a name="run"></a> CWinApp：： Run

提供預設訊息迴圈。

```
virtual int Run();
```

### <a name="return-value"></a>傳回值

**`int`** 所傳回的值 `WinMain` 。

### <a name="remarks"></a>備註

`Run` 取得和分派 Windows 訊息，直到應用程式收到 WM_QUIT 訊息為止。 如果應用程式的訊息佇列目前未包含任何訊息，則會 `Run` 呼叫 [OnIdle](#onidle) 來執行閒置時間處理。 傳入的訊息會移至 [PreTranslateMessage](#pretranslatemessage) 成員函式以進行特殊處理，然後移至 windows 函式以 `TranslateMessage` 進行標準鍵盤轉譯; 最後 `DispatchMessage` 會呼叫 windows 函式。

`Run` 很少被覆寫，但您可以覆寫它以提供特殊行為。

## <a name="cwinapprunautomated"></a><a name="runautomated"></a> CWinApp：： RunAutomated

呼叫此函式可判斷 " **/Automation**" 或 " **-Automation**" 選項是否存在，這表示用戶端應用程式是否已啟動伺服器應用程式。

```
BOOL RunAutomated();
```

### <a name="return-value"></a>傳回值

如果找到選項則為非零;否則為0。

### <a name="remarks"></a>備註

如果有，則會從命令列中移除此選項。 如需 OLE Automation 的詳細資訊，請參閱 [Automation server](../../mfc/automation-servers.md)文章。

## <a name="cwinapprunembedded"></a><a name="runembedded"></a> CWinApp：： RunEmbedded

呼叫此函式可判斷 " **/Embedding**" 或 " **-** 內嵌" 選項是否存在，這表示用戶端應用程式是否已啟動伺服器應用程式。

```
BOOL RunEmbedded();
```

### <a name="return-value"></a>傳回值

如果找到選項則為非零;否則為0。

### <a name="remarks"></a>備註

如果有，則會從命令列中移除此選項。 如需有關內嵌的詳細資訊，請參閱 [伺服器：執行伺服器一](../../mfc/servers-implementing-a-server.md)文。

## <a name="cwinappsaveallmodified"></a><a name="saveallmodified"></a> CWinApp：： SaveAllModified

由架構呼叫，以在應用程式的主框架視窗關閉或透過 WM_QUERYENDSESSION 訊息時儲存所有檔。

```
virtual BOOL SaveAllModified();
```

### <a name="return-value"></a>傳回值

如果安全地終止應用程式，則為非零;如果無法安全地終止應用程式，則為0。

### <a name="remarks"></a>備註

此成員函式的預設執行會依序呼叫 [CDocument：： SaveModified](../../mfc/reference/cdocument-class.md#savemodified) 成員函式，以取得應用程式內所有修改過的檔。

## <a name="cwinappselectprinter"></a><a name="selectprinter"></a> CWinApp：： SelectPrinter

呼叫此成員函式來選取特定的印表機，並釋放先前在 [列印] 對話方塊中選取的印表機。

```cpp
void SelectPrinter(
    HANDLE hDevNames,
    HANDLE hDevMode,
    BOOL bFreeOld = TRUE);
```

### <a name="parameters"></a>參數

*hDevNames*<br/>
[DEVNAMES](/windows/win32/api/commdlg/ns-commdlg-devnames)結構 t) 的控制碼，可識別特定印表機的驅動程式、裝置和輸出埠名稱。

*hDevMode*<br/>
[DEVMODE](/windows/win32/api/wingdi/ns-wingdi-devmodea)結構的控制碼，指定印表機裝置初始化和環境的相關資訊。

*bFreeOld*<br/>
釋出先前選取的印表機。

### <a name="remarks"></a>備註

如果 *hDevMode* 和 *HDEVNAMES* 都是 Null，就會 `SelectPrinter` 使用目前的預設印表機。

## <a name="cwinappsethelpmode"></a><a name="sethelpmode"></a> CWinApp：： SetHelpMode

設定應用程式的說明類型。

```cpp
void SetHelpMode(AFX_HELP_TYPE eHelpType);
```

### <a name="parameters"></a>參數

*eHelpType*<br/>
指定要使用的說明類型。 如需詳細資訊，請參閱 [CWinApp：： m_eHelpType](#m_ehelptype) 。

### <a name="remarks"></a>備註

設定應用程式的說明類型。

若要將您的應用程式說明類型設定為 HTMLHelp，您可以呼叫 [EnableHTMLHelp](#enablehtmlhelp)。 呼叫之後 `EnableHTMLHelp` ，您的應用程式必須使用 HTMLHelp 作為其說明應用程式。 如果您想要變更為使用 WinHelp，您可以呼叫， `SetHelpMode` 並將 *eHelpType* 設定為 `afxWinHelp` 。

## <a name="cwinappsetregistrykey"></a><a name="setregistrykey"></a> CWinApp：： SetRegistryKey

會導致應用程式設定儲存在登錄中，而不是 INI 檔案中。

```cpp
void SetRegistryKey(LPCTSTR lpszRegistryKey);
void SetRegistryKey(UINT nIDRegistryKey);
```

### <a name="parameters"></a>參數

*lpszRegistryKey*<br/>
包含索引鍵名稱之字串的指標。

*nIDRegistryKey*<br/>
包含登錄機碼名稱之字串資源的識別碼。

### <a name="remarks"></a>備註

此函數會設定 *m_pszRegistryKey*，然後由 `GetProfileInt` `GetProfileString` 的、、 `WriteProfileInt` 和 `WriteProfileString` 成員 `CWinApp` 函式使用。 如果已呼叫這個函數，最近使用過的 (MRU) 檔案清單也會儲存在登錄中。 登錄機碼通常是公司的名稱。 它會以下列格式的金鑰儲存： HKEY_CURRENT_USER \Software \\<公司名稱 \> \\<應用程式名稱 \> \\<區段名稱 \> \\<值名稱 \> 。

## <a name="cwinappsupportsapplicationrecovery"></a><a name="supportsapplicationrecovery"></a> CWinApp：： SupportsApplicationRecovery

判斷重新開機管理員是否復原意外結束的應用程式。

```
virtual BOOL SupportsApplicationRecovery() const;
```

### <a name="return-value"></a>傳回值

TRUE 表示重新開機管理員復原應用程式;FALSE 表示重新開機管理員不存在。

## <a name="cwinappsupportsautosaveatinterval"></a><a name="supportsautosaveatinterval"></a> CWinApp：： SupportsAutosaveAtInterval

判斷重新開機管理員是否 autosaves 定期開啟檔。

```
virtual BOOL SupportsAutosaveAtInterval() const;
```

### <a name="return-value"></a>傳回值

TRUE 表示重新開機管理員 autosaves 開啟的檔;FALSE 表示重新開機管理員不存在。

## <a name="cwinappsupportsautosaveatrestart"></a><a name="supportsautosaveatrestart"></a> CWinApp：： SupportsAutosaveAtRestart

決定當應用程式重新開機時，重新開機管理員是否 autosaves 任何開啟的檔。

```
virtual BOOL SupportsAutosaveAtRestart() const;
```

### <a name="return-value"></a>傳回值

TRUE 表示當應用程式重新開機時，重新開機管理員 autosaves 開啟的檔;FALSE 表示重新開機管理員不存在。

## <a name="cwinappsupportsrestartmanager"></a><a name="supportsrestartmanager"></a> CWinApp：： SupportsRestartManager

判斷應用程式是否支援重新開機管理員。

```
virtual BOOL SupportsRestartManager() const;
```

### <a name="return-value"></a>傳回值

TRUE 表示應用程式支援重新開機管理員;FALSE 表示應用程式不存在。

## <a name="cwinappunregister"></a><a name="unregister"></a> CWinApp：：取消註冊

取消註冊應用程式物件所註冊的所有檔案。

```
virtual BOOL Unregister();
```

### <a name="return-value"></a>傳回值

非零成功，否則為 0。

### <a name="remarks"></a>備註

函式會 `Unregister` 復原應用程式物件和 [Register](#register) 函數所執行的註冊。 一般來說，MFC 會隱含呼叫這兩個函式，因此不會出現在您的程式碼中。

覆寫此函式可執行自訂的取消註冊步驟。

## <a name="cwinappunregistershellfiletypes"></a><a name="unregistershellfiletypes"></a> CWinApp：： UnregisterShellFileTypes

呼叫此成員函式，以使用 Windows 檔案管理員取消註冊您所有應用程式的檔案類型。

```cpp
void UnregisterShellFileTypes();
```

## <a name="cwinappwinhelp"></a><a name="winhelp"></a> CWinApp：： WinHelp

呼叫這個成員函式來叫用 WinHelp 應用程式。

```
virtual void WinHelp(
    DWORD_PTR dwData,
    UINT nCmd = HELP_CONTEXT);
```

### <a name="parameters"></a>參數

*dwData*<br/>
指定其他資料。 使用的值取決於 *nCmd* 參數的值。

*nCmd*<br/>
指定要求的說明類型。 如需可能值的清單，以及它們如何影響 *dwData* 參數，請參閱 [WinHelp](/windows/win32/api/winuser/nf-winuser-winhelpw) Windows 函數。

### <a name="remarks"></a>備註

架構也會呼叫這個函式來叫用 WinHelp 應用程式。

當您的應用程式終止時，架構會自動關閉 WinHelp 應用程式。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#53](../../mfc/reference/codesnippet/cpp/cwinapp-class_28.cpp)]

## <a name="cwinappwriteprofilebinary"></a><a name="writeprofilebinary"></a> CWinApp：： WriteProfileBinary

呼叫此成員函式，將二進位資料寫入至應用程式登錄的指定區段或。INI 檔案。

```
BOOL WriteProfileBinary(
    LPCTSTR lpszSection,
    LPCTSTR lpszEntry,
    LPBYTE pData,
    UINT nBytes);
```

### <a name="parameters"></a>參數

*lpszSection*<br/>
指向以 null 終止的字串，這個字串指定包含項目的區段。 如果區段不存在，則會建立該區段。 區段的名稱與大小寫無關;字串可能是大寫和小寫字母的任何組合。

*lpszEntry*<br/>
指向以 null 終止的字串，其中包含要寫入值的專案。 如果專案不存在於指定的區段中，則會建立該專案。

*.Pdata*<br/>
指向要寫入的資料。

*n*<br/>
包含要寫入的位元組數目。

### <a name="return-value"></a>傳回值

如果成功則為非零；否則為 0。

### <a name="example"></a>範例

這則範例會使用 `CWinApp* pApp = AfxGetApp();` 來取得 CWinApp 類別，以說明如何 `WriteProfileBinary` `GetProfileBinary` 從 MFC 應用程式中的任何函式使用和該方法。

[!code-cpp[NVC_MFCWindowing#54](../../mfc/reference/codesnippet/cpp/cwinapp-class_29.cpp)]

如需其他範例，請參閱 [CWinApp：： GetProfileBinary](#getprofilebinary)的範例。

## <a name="cwinappwriteprofileint"></a><a name="writeprofileint"></a> CWinApp：： WriteProfileInt

呼叫此成員函式，將指定的值寫入至應用程式登錄的指定區段或。INI 檔案。

```
BOOL WriteProfileInt(
    LPCTSTR lpszSection,
    LPCTSTR lpszEntry,
    int nValue);
```

### <a name="parameters"></a>參數

*lpszSection*<br/>
指向以 null 終止的字串，這個字串指定包含項目的區段。 如果區段不存在，則會建立該區段。 區段的名稱與大小寫無關;字串可能是大寫和小寫字母的任何組合。

*lpszEntry*<br/>
指向以 null 終止的字串，其中包含要寫入值的專案。 如果專案不存在於指定的區段中，則會建立該專案。

*N 值*<br/>
包含要寫入的值。

### <a name="return-value"></a>傳回值

如果成功則為非零；否則為 0。

### <a name="example"></a>範例

這個範例 `CWinApp* pApp = AfxGetApp();` 會使用來取得 CWinApp 類別，以說明 `WriteProfileString` `WriteProfileInt` `GetProfileString` `GetProfileInt` 可從 MFC 應用程式中的任何函式使用、、和的方式。

[!code-cpp[NVC_MFCWindowing#43](../../mfc/reference/codesnippet/cpp/cwinapp-class_9.cpp)]

如需其他範例，請參閱 [CWinApp：： GetProfileInt](#getprofileint)的範例。

## <a name="cwinappwriteprofilestring"></a><a name="writeprofilestring"></a> CWinApp：： WriteProfileString

呼叫此成員函式，將指定的字串寫入至應用程式登錄的指定區段或。INI 檔案。

```
BOOL WriteProfileString(
    LPCTSTR lpszSection,
    LPCTSTR lpszEntry,
    LPCTSTR lpszValue);
```

### <a name="parameters"></a>參數

*lpszSection*<br/>
指向以 null 終止的字串，這個字串指定包含項目的區段。 如果區段不存在，則會建立該區段。 區段的名稱與大小寫無關;字串可能是大寫和小寫字母的任何組合。

*lpszEntry*<br/>
指向以 null 終止的字串，其中包含要寫入值的專案。 如果專案不存在於指定的區段中，則會建立該專案。 如果此參數為 Null，則會刪除 *lpszSection* 所指定的區段。

*lpszValue*<br/>
指向要寫入的字串。 如果此參數為 Null，則會刪除 *lpszEntry* 參數所指定的專案。

### <a name="return-value"></a>傳回值

如果成功則為非零；否則為 0。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#43](../../mfc/reference/codesnippet/cpp/cwinapp-class_9.cpp)]

如需其他範例，請參閱 [CWinApp：： GetProfileInt](#getprofileint)的範例。

## <a name="cwinappsetappid"></a><a name="setappid"></a> CWinApp：： SetAppID

明確地設定應用程式的應用程式使用者模型識別碼。 在向使用者呈現任何使用者介面之前，應該先呼叫這個方法 (最好的地方就是) 應用程式。

```cpp
void SetAppID(LPCTSTR lpcszAppID);
```

### <a name="parameters"></a>參數

*lpcszAppID*<br/>
指定應用程式使用者模型識別碼。

### <a name="remarks"></a>備註

## <a name="see-also"></a>另請參閱

[CWinThread 類別](../../mfc/reference/cwinthread-class.md)<br/>
[階層架構圖表](../../mfc/hierarchy-chart.md)<br/>
[如何：加入重新開機管理員支援](../../mfc/how-to-add-restart-manager-support.md)
