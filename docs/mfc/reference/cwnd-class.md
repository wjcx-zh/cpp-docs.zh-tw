---
title: CWnd 類別
ms.date: 11/19/2018
f1_keywords:
- CWnd
- AFXWIN/CWnd
- AFXWIN/CWnd::CWnd
- AFXWIN/CWnd::accDoDefaultAction
- AFXWIN/CWnd::accHitTest
- AFXWIN/CWnd::accLocation
- AFXWIN/CWnd::accNavigate
- AFXWIN/CWnd::accSelect
- AFXWIN/CWnd::AnimateWindow
- AFXWIN/CWnd::ArrangeIconicWindows
- AFXWIN/CWnd::Attach
- AFXWIN/CWnd::BeginModalState
- AFXWIN/CWnd::BeginPaint
- AFXWIN/CWnd::BindDefaultProperty
- AFXWIN/CWnd::BindProperty
- AFXWIN/CWnd::BringWindowToTop
- AFXWIN/CWnd::CalcWindowRect
- AFXWIN/CWnd::CancelToolTips
- AFXWIN/CWnd::CenterWindow
- AFXWIN/CWnd::ChangeClipboardChain
- AFXWIN/CWnd::CheckDlgButton
- AFXWIN/CWnd::CheckRadioButton
- AFXWIN/CWnd::ChildWindowFromPoint
- AFXWIN/CWnd::ClientToScreen
- AFXWIN/CWnd::CloseWindow
- AFXWIN/CWnd::ContinueModal
- AFXWIN/CWnd::Create
- AFXWIN/CWnd::CreateAccessibleProxy
- AFXWIN/CWnd::CreateCaret
- AFXWIN/CWnd::CreateControl
- AFXWIN/CWnd::CreateEx
- AFXWIN/CWnd::CreateGrayCaret
- AFXWIN/CWnd::CreateSolidCaret
- AFXWIN/CWnd::DeleteTempMap
- AFXWIN/CWnd::DestroyWindow
- AFXWIN/CWnd::Detach
- AFXWIN/CWnd::DlgDirList
- AFXWIN/CWnd::DlgDirListComboBox
- AFXWIN/CWnd::DlgDirSelect
- AFXWIN/CWnd::DlgDirSelectComboBox
- AFXWIN/CWnd::DragAcceptFiles
- AFXWIN/CWnd::DragDetect
- AFXWIN/CWnd::DrawAnimatedRects
- AFXWIN/CWnd::DrawCaption
- AFXWIN/CWnd::DrawMenuBar
- AFXWIN/CWnd::EnableActiveAccessibility
- AFXWIN/CWnd::EnableDynamicLayout
- AFXWIN/CWnd::EnableD2DSupport
- AFXWIN/CWnd::EnableScrollBar
- AFXWIN/CWnd::EnableScrollBarCtrl
- AFXWIN/CWnd::EnableToolTips
- AFXWIN/CWnd::EnableTrackingToolTips
- AFXWIN/CWnd::EnableWindow
- AFXWIN/CWnd::EndModalLoop
- AFXWIN/CWnd::EndModalState
- AFXWIN/CWnd::EndPaint
- AFXWIN/CWnd::ExecuteDlgInit
- AFXWIN/CWnd::FilterToolTipMessage
- AFXWIN/CWnd::FindWindow
- AFXWIN/CWnd::FindWindowEx
- AFXWIN/CWnd::FlashWindow
- AFXWIN/CWnd::FlashWindowEx
- AFXWIN/CWnd::FromHandle
- AFXWIN/CWnd::FromHandlePermanent
- AFXWIN/CWnd::get_accChild
- AFXWIN/CWnd::get_accChildCount
- AFXWIN/CWnd::get_accDefaultAction
- AFXWIN/CWnd::get_accDescription
- AFXWIN/CWnd::get_accFocus
- AFXWIN/CWnd::get_accHelp
- AFXWIN/CWnd::get_accHelpTopic
- AFXWIN/CWnd::get_accKeyboardShortcut
- AFXWIN/CWnd::get_accName
- AFXWIN/CWnd::get_accParent
- AFXWIN/CWnd::get_accRole
- AFXWIN/CWnd::get_accSelection
- AFXWIN/CWnd::get_accState
- AFXWIN/CWnd::get_accValue
- AFXWIN/CWnd::GetActiveWindow
- AFXWIN/CWnd::GetAncestor
- AFXWIN/CWnd::GetCapture
- AFXWIN/CWnd::GetCaretPos
- AFXWIN/CWnd::GetCheckedRadioButton
- AFXWIN/CWnd::GetClientRect
- AFXWIN/CWnd::GetClipboardOwner
- AFXWIN/CWnd::GetClipboardViewer
- AFXWIN/CWnd::GetControlUnknown
- AFXWIN/CWnd::GetDC
- AFXWIN/CWnd::GetDCEx
- AFXWIN/CWnd::GetDCRenderTarget
- AFXWIN/CWnd::GetDescendantWindow
- AFXWIN/CWnd::GetDesktopWindow
- AFXWIN/CWnd::GetDlgCtrlID
- AFXWIN/CWnd::GetDlgItem
- AFXWIN/CWnd::GetDlgItemInt
- AFXWIN/CWnd::GetDlgItemText
- AFXWIN/CWnd::GetDSCCursor
- AFXWIN/CWnd::GetDynamicLayout
- AFXWIN/CWnd::GetExStyle
- AFXWIN/CWnd::GetFocus
- AFXWIN/CWnd::GetFont
- AFXWIN/CWnd::GetForegroundWindow
- AFXWIN/CWnd::GetIcon
- AFXWIN/CWnd::GetLastActivePopup
- AFXWIN/CWnd::GetLayeredWindowAttributes
- AFXWIN/CWnd::GetMenu
- AFXWIN/CWnd::GetNextDlgGroupItem
- AFXWIN/CWnd::GetNextDlgTabItem
- AFXWIN/CWnd::GetNextWindow
- AFXWIN/CWnd::GetOleControlSite
- AFXWIN/CWnd::GetOpenClipboardWindow
- AFXWIN/CWnd::GetOwner
- AFXWIN/CWnd::GetParent
- AFXWIN/CWnd::GetParentFrame
- AFXWIN/CWnd::GetParentOwner
- AFXWIN/CWnd::GetProperty
- AFXWIN/CWnd::GetRenderTarget
- AFXWIN/CWnd::GetSafeHwnd
- AFXWIN/CWnd::GetSafeOwner
- AFXWIN/CWnd::GetScrollBarCtrl
- AFXWIN/CWnd::GetScrollBarInfo
- AFXWIN/CWnd::GetScrollInfo
- AFXWIN/CWnd::GetScrollLimit
- AFXWIN/CWnd::GetScrollPos
- AFXWIN/CWnd::GetScrollRange
- AFXWIN/CWnd::GetStyle
- AFXWIN/CWnd::GetSystemMenu
- AFXWIN/CWnd::GetTitleBarInfo
- AFXWIN/CWnd::GetTopLevelFrame
- AFXWIN/CWnd::GetTopLevelOwner
- AFXWIN/CWnd::GetTopLevelParent
- AFXWIN/CWnd::GetTopWindow
- AFXWIN/CWnd::GetUpdateRect
- AFXWIN/CWnd::GetUpdateRgn
- AFXWIN/CWnd::GetWindow
- AFXWIN/CWnd::GetWindowContextHelpId
- AFXWIN/CWnd::GetWindowDC
- AFXWIN/CWnd::GetWindowedChildCount
- AFXWIN/CWnd::GetWindowInfo
- AFXWIN/CWnd::GetWindowlessChildCount
- AFXWIN/CWnd::GetWindowPlacement
- AFXWIN/CWnd::GetWindowRect
- AFXWIN/CWnd::GetWindowRgn
- AFXWIN/CWnd::GetWindowText
- AFXWIN/CWnd::GetWindowTextLength
- AFXWIN/CWnd::HideCaret
- AFXWIN/CWnd::HiliteMenuItem
- AFXWIN/CWnd::HtmlHelp
- AFXWIN/CWnd::Invalidate
- AFXWIN/CWnd::InvalidateRect
- AFXWIN/CWnd::InvalidateRgn
- AFXWIN/CWnd::InvokeHelper
- AFXWIN/CWnd::IsChild
- AFXWIN/CWnd::IsD2DSupportEnabled
- AFXWIN/CWnd::IsDialogMessage
- AFXWIN/CWnd::IsDlgButtonChecked
- AFXWIN/CWnd::IsDynamicLayoutEnabled
- AFXWIN/CWnd::IsIconic
- AFXWIN/CWnd::IsTouchWindow
- AFXWIN/CWnd::IsWindowEnabled
- AFXWIN/CWnd::IsWindowVisible
- AFXWIN/CWnd::IsZoomed
- AFXWIN/CWnd::KillTimer
- AFXWIN/CWnd::LockWindowUpdate
- AFXWIN/CWnd::MapWindowPoints
- AFXWIN/CWnd::MessageBox
- AFXWIN/CWnd::ModifyStyle
- AFXWIN/CWnd::ModifyStyleEx
- AFXWIN/CWnd::MoveWindow
- AFXWIN/CWnd::NotifyWinEvent
- AFXWIN/CWnd::OnAmbientProperty
- AFXWIN/CWnd::OnDrawIconicThumbnailOrLivePreview
- AFXWIN/CWnd::OnHelp
- AFXWIN/CWnd::OnHelpFinder
- AFXWIN/CWnd::OnHelpIndex
- AFXWIN/CWnd::OnHelpUsing
- AFXWIN/CWnd::OnToolHitTest
- AFXWIN/CWnd::OpenClipboard
- AFXWIN/CWnd::PaintWindowlessControls
- AFXWIN/CWnd::PostMessage
- AFXWIN/CWnd::PreCreateWindow
- AFXWIN/CWnd::PreSubclassWindow
- AFXWIN/CWnd::PreTranslateMessage
- AFXWIN/CWnd::Print
- AFXWIN/CWnd::PrintClient
- AFXWIN/CWnd::PrintWindow
- AFXWIN/CWnd::RedrawWindow
- AFXWIN/CWnd::RegisterTouchWindow
- AFXWIN/CWnd::ReleaseDC
- AFXWIN/CWnd::RepositionBars
- AFXWIN/CWnd::RunModalLoop
- AFXWIN/CWnd::ScreenToClient
- AFXWIN/CWnd::ScrollWindow
- AFXWIN/CWnd::ScrollWindowEx
- AFXWIN/CWnd::SendChildNotifyLastMsg
- AFXWIN/CWnd::SendDlgItemMessage
- AFXWIN/CWnd::SendMessage
- AFXWIN/CWnd::SendMessageToDescendants
- AFXWIN/CWnd::SendNotifyMessage
- AFXWIN/CWnd::SetActiveWindow
- AFXWIN/CWnd::SetCapture
- AFXWIN/CWnd::SetCaretPos
- AFXWIN/CWnd::SetClipboardViewer
- AFXWIN/CWnd::SetDlgCtrlID
- AFXWIN/CWnd::SetDlgItemInt
- AFXWIN/CWnd::SetDlgItemText
- AFXWIN/CWnd::SetFocus
- AFXWIN/CWnd::SetFont
- AFXWIN/CWnd::SetForegroundWindow
- AFXWIN/CWnd::SetIcon
- AFXWIN/CWnd::SetLayeredWindowAttributes
- AFXWIN/CWnd::SetMenu
- AFXWIN/CWnd::SetOwner
- AFXWIN/CWnd::SetParent
- AFXWIN/CWnd::SetProperty
- AFXWIN/CWnd::SetRedraw
- AFXWIN/CWnd::SetScrollInfo
- AFXWIN/CWnd::SetScrollPos
- AFXWIN/CWnd::SetScrollRange
- AFXWIN/CWnd::SetTimer
- AFXWIN/CWnd::SetWindowContextHelpId
- AFXWIN/CWnd::SetWindowPlacement
- AFXWIN/CWnd::SetWindowPos
- AFXWIN/CWnd::SetWindowRgn
- AFXWIN/CWnd::SetWindowText
- AFXWIN/CWnd::ShowCaret
- AFXWIN/CWnd::ShowOwnedPopups
- AFXWIN/CWnd::ShowScrollBar
- AFXWIN/CWnd::ShowWindow
- AFXWIN/CWnd::SubclassDlgItem
- AFXWIN/CWnd::SubclassWindow
- AFXWIN/CWnd::UnlockWindowUpdate
- AFXWIN/CWnd::UnsubclassWindow
- AFXWIN/CWnd::UpdateData
- AFXWIN/CWnd::UpdateDialogControls
- AFXWIN/CWnd::UpdateLayeredWindow
- AFXWIN/CWnd::UpdateWindow
- AFXWIN/CWnd::ValidateRect
- AFXWIN/CWnd::ValidateRgn
- AFXWIN/CWnd::WindowFromPoint
- AFXWIN/CWnd::WinHelp
- AFXWIN/CWnd::Default
- AFXWIN/CWnd::DefWindowProc
- AFXWIN/CWnd::DoDataExchange
- AFXWIN/CWnd::GetCurrentMessage
- AFXWIN/CWnd::InitDynamicLayout
- AFXWIN/CWnd::LoadDynamicLayoutResource
- AFXWIN/CWnd::OnActivate
- AFXWIN/CWnd::OnActivateApp
- AFXWIN/CWnd::OnAppCommand
- AFXWIN/CWnd::OnAskCbFormatName
- AFXWIN/CWnd::OnCancelMode
- AFXWIN/CWnd::OnCaptureChanged
- AFXWIN/CWnd::OnChangeCbChain
- AFXWIN/CWnd::OnChangeUIState
- AFXWIN/CWnd::OnChar
- AFXWIN/CWnd::OnCharToItem
- AFXWIN/CWnd::OnChildActivate
- AFXWIN/CWnd::OnChildNotify
- AFXWIN/CWnd::OnClipboardUpdate
- AFXWIN/CWnd::OnClose
- AFXWIN/CWnd::OnColorizationColorChanged
- AFXWIN/CWnd::OnCommand
- AFXWIN/CWnd::OnCompacting
- AFXWIN/CWnd::OnCompareItem
- AFXWIN/CWnd::OnCompositionChanged
- AFXWIN/CWnd::OnContextMenu
- AFXWIN/CWnd::OnCopyData
- AFXWIN/CWnd::OnCreate
- AFXWIN/CWnd::OnCtlColor
- AFXWIN/CWnd::OnDeadChar
- AFXWIN/CWnd::OnDeleteItem
- AFXWIN/CWnd::OnDestroy
- AFXWIN/CWnd::OnDestroyClipboard
- AFXWIN/CWnd::OnDeviceChange
- AFXWIN/CWnd::OnDevModeChange
- AFXWIN/CWnd::OnDrawClipboard
- AFXWIN/CWnd::OnDrawItem
- AFXWIN/CWnd::OnDropFiles
- AFXWIN/CWnd::OnEnable
- AFXWIN/CWnd::OnEndSession
- AFXWIN/CWnd::OnEnterIdle
- AFXWIN/CWnd::OnEnterMenuLoop
- AFXWIN/CWnd::OnEnterSizeMove
- AFXWIN/CWnd::OnEraseBkgnd
- AFXWIN/CWnd::OnExitMenuLoop
- AFXWIN/CWnd::OnExitSizeMove
- AFXWIN/CWnd::OnFontChange
- AFXWIN/CWnd::OnGetDlgCode
- AFXWIN/CWnd::OnGetMinMaxInfo
- AFXWIN/CWnd::OnHelpInfo
- AFXWIN/CWnd::OnHotKey
- AFXWIN/CWnd::OnHScroll
- AFXWIN/CWnd::OnHScrollClipboard
- AFXWIN/CWnd::OnIconEraseBkgnd
- AFXWIN/CWnd::OnInitMenu
- AFXWIN/CWnd::OnInitMenuPopup
- AFXWIN/CWnd::OnInputDeviceChange
- AFXWIN/CWnd::OnInputLangChange
- AFXWIN/CWnd::OnInputLangChangeRequest
- AFXWIN/CWnd::OnKeyDown
- AFXWIN/CWnd::OnKeyUp
- AFXWIN/CWnd::OnKillFocus
- AFXWIN/CWnd::OnLButtonDblClk
- AFXWIN/CWnd::OnLButtonDown
- AFXWIN/CWnd::OnLButtonUp
- AFXWIN/CWnd::OnMButtonDblClk
- AFXWIN/CWnd::OnMButtonDown
- AFXWIN/CWnd::OnMButtonUp
- AFXWIN/CWnd::OnMDIActivate
- AFXWIN/CWnd::OnMeasureItem
- AFXWIN/CWnd::OnMenuChar
- AFXWIN/CWnd::OnMenuDrag
- AFXWIN/CWnd::OnMenuGetObject
- AFXWIN/CWnd::OnMenuRButtonUp
- AFXWIN/CWnd::OnMenuSelect
- AFXWIN/CWnd::OnMouseActivate
- AFXWIN/CWnd::OnMouseHover
- AFXWIN/CWnd::OnMouseHWheel
- AFXWIN/CWnd::OnMouseLeave
- AFXWIN/CWnd::OnMouseMove
- AFXWIN/CWnd::OnMouseWheel
- AFXWIN/CWnd::OnMove
- AFXWIN/CWnd::OnMoving
- AFXWIN/CWnd::OnNcActivate
- AFXWIN/CWnd::OnNcCalcSize
- AFXWIN/CWnd::OnNcCreate
- AFXWIN/CWnd::OnNcDestroy
- AFXWIN/CWnd::OnNcHitTest
- AFXWIN/CWnd::OnNcLButtonDblClk
- AFXWIN/CWnd::OnNcLButtonDown
- AFXWIN/CWnd::OnNcLButtonUp
- AFXWIN/CWnd::OnNcMButtonDblClk
- AFXWIN/CWnd::OnNcMButtonDown
- AFXWIN/CWnd::OnNcMButtonUp
- AFXWIN/CWnd::OnNcMouseHover
- AFXWIN/CWnd::OnNcMouseLeave
- AFXWIN/CWnd::OnNcMouseMove
- AFXWIN/CWnd::OnNcPaint
- AFXWIN/CWnd::OnNcRButtonDblClk
- AFXWIN/CWnd::OnNcRButtonDown
- AFXWIN/CWnd::OnNcRButtonUp
- AFXWIN/CWnd::OnNcRenderingChanged
- AFXWIN/CWnd::OnNcXButtonDblClk
- AFXWIN/CWnd::OnNcXButtonDown
- AFXWIN/CWnd::OnNcXButtonUp
- AFXWIN/CWnd::OnNextMenu
- AFXWIN/CWnd::OnNotify
- AFXWIN/CWnd::OnNotifyFormat
- AFXWIN/CWnd::OnPaint
- AFXWIN/CWnd::OnPaintClipboard
- AFXWIN/CWnd::OnPaletteChanged
- AFXWIN/CWnd::OnPaletteIsChanging
- AFXWIN/CWnd::OnParentNotify
- AFXWIN/CWnd::OnPowerBroadcast
- AFXWIN/CWnd::OnQueryDragIcon
- AFXWIN/CWnd::OnQueryEndSession
- AFXWIN/CWnd::OnQueryNewPalette
- AFXWIN/CWnd::OnQueryOpen
- AFXWIN/CWnd::OnQueryUIState
- AFXWIN/CWnd::OnRawInput
- AFXWIN/CWnd::OnRButtonDblClk
- AFXWIN/CWnd::OnRButtonDown
- AFXWIN/CWnd::OnRButtonUp
- AFXWIN/CWnd::OnRenderAllFormats
- AFXWIN/CWnd::OnRenderFormat
- AFXWIN/CWnd::OnSessionChange
- AFXWIN/CWnd::OnSetCursor
- AFXWIN/CWnd::OnSetFocus
- AFXWIN/CWnd::OnSettingChange
- AFXWIN/CWnd::OnShowWindow
- AFXWIN/CWnd::OnSize
- AFXWIN/CWnd::OnSizeClipboard
- AFXWIN/CWnd::OnSizing
- AFXWIN/CWnd::OnSpoolerStatus
- AFXWIN/CWnd::OnStyleChanged
- AFXWIN/CWnd::OnStyleChanging
- AFXWIN/CWnd::OnSysChar
- AFXWIN/CWnd::OnSysColorChange
- AFXWIN/CWnd::OnSysCommand
- AFXWIN/CWnd::OnSysDeadChar
- AFXWIN/CWnd::OnSysKeyDown
- AFXWIN/CWnd::OnSysKeyUp
- AFXWIN/CWnd::OnTCard
- AFXWIN/CWnd::OnTimeChange
- AFXWIN/CWnd::OnTimer
- AFXWIN/CWnd::OnTouchInput
- AFXWIN/CWnd::OnTouchInputs
- AFXWIN/CWnd::OnUniChar
- AFXWIN/CWnd::OnUnInitMenuPopup
- AFXWIN/CWnd::OnUpdateUIState
- AFXWIN/CWnd::OnUserChanged
- AFXWIN/CWnd::OnVKeyToItem
- AFXWIN/CWnd::OnVScroll
- AFXWIN/CWnd::OnVScrollClipboard
- AFXWIN/CWnd::OnWindowPosChanged
- AFXWIN/CWnd::OnWindowPosChanging
- AFXWIN/CWnd::OnWinIniChange
- AFXWIN/CWnd::OnWndMsg
- AFXWIN/CWnd::OnXButtonDblClk
- AFXWIN/CWnd::OnXButtonDown
- AFXWIN/CWnd::OnXButtonUp
- AFXWIN/CWnd::PostNcDestroy
- AFXWIN/CWnd::ReflectChildNotify
- AFXWIN/CWnd::ReflectLastMsg
- AFXWIN/CWnd::ResizeDynamicLayout
- AFXWIN/CWnd::WindowProc
- AFXWIN/CWnd::m_hWnd
helpviewer_keywords:
- CWnd [MFC], CWnd
- CWnd [MFC], accDoDefaultAction
- CWnd [MFC], accHitTest
- CWnd [MFC], accLocation
- CWnd [MFC], accNavigate
- CWnd [MFC], accSelect
- CWnd [MFC], AnimateWindow
- CWnd [MFC], ArrangeIconicWindows
- CWnd [MFC], Attach
- CWnd [MFC], BeginModalState
- CWnd [MFC], BeginPaint
- CWnd [MFC], BindDefaultProperty
- CWnd [MFC], BindProperty
- CWnd [MFC], BringWindowToTop
- CWnd [MFC], CalcWindowRect
- CWnd [MFC], CancelToolTips
- CWnd [MFC], CenterWindow
- CWnd [MFC], ChangeClipboardChain
- CWnd [MFC], CheckDlgButton
- CWnd [MFC], CheckRadioButton
- CWnd [MFC], ChildWindowFromPoint
- CWnd [MFC], ClientToScreen
- CWnd [MFC], CloseWindow
- CWnd [MFC], ContinueModal
- CWnd [MFC], Create
- CWnd [MFC], CreateAccessibleProxy
- CWnd [MFC], CreateCaret
- CWnd [MFC], CreateControl
- CWnd [MFC], CreateEx
- CWnd [MFC], CreateGrayCaret
- CWnd [MFC], CreateSolidCaret
- CWnd [MFC], DeleteTempMap
- CWnd [MFC], DestroyWindow
- CWnd [MFC], Detach
- CWnd [MFC], DlgDirList
- CWnd [MFC], DlgDirListComboBox
- CWnd [MFC], DlgDirSelect
- CWnd [MFC], DlgDirSelectComboBox
- CWnd [MFC], DragAcceptFiles
- CWnd [MFC], DragDetect
- CWnd [MFC], DrawAnimatedRects
- CWnd [MFC], DrawCaption
- CWnd [MFC], DrawMenuBar
- CWnd [MFC], EnableActiveAccessibility
- CWnd [MFC], EnableDynamicLayout
- CWnd [MFC], EnableD2DSupport
- CWnd [MFC], EnableScrollBar
- CWnd [MFC], EnableScrollBarCtrl
- CWnd [MFC], EnableToolTips
- CWnd [MFC], EnableTrackingToolTips
- CWnd [MFC], EnableWindow
- CWnd [MFC], EndModalLoop
- CWnd [MFC], EndModalState
- CWnd [MFC], EndPaint
- CWnd [MFC], ExecuteDlgInit
- CWnd [MFC], FilterToolTipMessage
- CWnd [MFC], FindWindow
- CWnd [MFC], FindWindowEx
- CWnd [MFC], FlashWindow
- CWnd [MFC], FlashWindowEx
- CWnd [MFC], FromHandle
- CWnd [MFC], FromHandlePermanent
- CWnd [MFC], get_accChild
- CWnd [MFC], get_accChildCount
- CWnd [MFC], get_accDefaultAction
- CWnd [MFC], get_accDescription
- CWnd [MFC], get_accFocus
- CWnd [MFC], get_accHelp
- CWnd [MFC], get_accHelpTopic
- CWnd [MFC], get_accKeyboardShortcut
- CWnd [MFC], get_accName
- CWnd [MFC], get_accParent
- CWnd [MFC], get_accRole
- CWnd [MFC], get_accSelection
- CWnd [MFC], get_accState
- CWnd [MFC], get_accValue
- CWnd [MFC], GetActiveWindow
- CWnd [MFC], GetAncestor
- CWnd [MFC], GetCapture
- CWnd [MFC], GetCaretPos
- CWnd [MFC], GetCheckedRadioButton
- CWnd [MFC], GetClientRect
- CWnd [MFC], GetClipboardOwner
- CWnd [MFC], GetClipboardViewer
- CWnd [MFC], GetControlUnknown
- CWnd [MFC], GetDC
- CWnd [MFC], GetDCEx
- CWnd [MFC], GetDCRenderTarget
- CWnd [MFC], GetDescendantWindow
- CWnd [MFC], GetDesktopWindow
- CWnd [MFC], GetDlgCtrlID
- CWnd [MFC], GetDlgItem
- CWnd [MFC], GetDlgItemInt
- CWnd [MFC], GetDlgItemText
- CWnd [MFC], GetDSCCursor
- CWnd [MFC], GetDynamicLayout
- CWnd [MFC], GetExStyle
- CWnd [MFC], GetFocus
- CWnd [MFC], GetFont
- CWnd [MFC], GetForegroundWindow
- CWnd [MFC], GetIcon
- CWnd [MFC], GetLastActivePopup
- CWnd [MFC], GetLayeredWindowAttributes
- CWnd [MFC], GetMenu
- CWnd [MFC], GetNextDlgGroupItem
- CWnd [MFC], GetNextDlgTabItem
- CWnd [MFC], GetNextWindow
- CWnd [MFC], GetOleControlSite
- CWnd [MFC], GetOpenClipboardWindow
- CWnd [MFC], GetOwner
- CWnd [MFC], GetParent
- CWnd [MFC], GetParentFrame
- CWnd [MFC], GetParentOwner
- CWnd [MFC], GetProperty
- CWnd [MFC], GetRenderTarget
- CWnd [MFC], GetSafeHwnd
- CWnd [MFC], GetSafeOwner
- CWnd [MFC], GetScrollBarCtrl
- CWnd [MFC], GetScrollBarInfo
- CWnd [MFC], GetScrollInfo
- CWnd [MFC], GetScrollLimit
- CWnd [MFC], GetScrollPos
- CWnd [MFC], GetScrollRange
- CWnd [MFC], GetStyle
- CWnd [MFC], GetSystemMenu
- CWnd [MFC], GetTitleBarInfo
- CWnd [MFC], GetTopLevelFrame
- CWnd [MFC], GetTopLevelOwner
- CWnd [MFC], GetTopLevelParent
- CWnd [MFC], GetTopWindow
- CWnd [MFC], GetUpdateRect
- CWnd [MFC], GetUpdateRgn
- CWnd [MFC], GetWindow
- CWnd [MFC], GetWindowContextHelpId
- CWnd [MFC], GetWindowDC
- CWnd [MFC], GetWindowedChildCount
- CWnd [MFC], GetWindowInfo
- CWnd [MFC], GetWindowlessChildCount
- CWnd [MFC], GetWindowPlacement
- CWnd [MFC], GetWindowRect
- CWnd [MFC], GetWindowRgn
- CWnd [MFC], GetWindowText
- CWnd [MFC], GetWindowTextLength
- CWnd [MFC], HideCaret
- CWnd [MFC], HiliteMenuItem
- CWnd [MFC], HtmlHelp
- CWnd [MFC], Invalidate
- CWnd [MFC], InvalidateRect
- CWnd [MFC], InvalidateRgn
- CWnd [MFC], InvokeHelper
- CWnd [MFC], IsChild
- CWnd [MFC], IsD2DSupportEnabled
- CWnd [MFC], IsDialogMessage
- CWnd [MFC], IsDlgButtonChecked
- CWnd [MFC], IsDynamicLayoutEnabled
- CWnd [MFC], IsIconic
- CWnd [MFC], IsTouchWindow
- CWnd [MFC], IsWindowEnabled
- CWnd [MFC], IsWindowVisible
- CWnd [MFC], IsZoomed
- CWnd [MFC], KillTimer
- CWnd [MFC], LockWindowUpdate
- CWnd [MFC], MapWindowPoints
- CWnd [MFC], MessageBox
- CWnd [MFC], ModifyStyle
- CWnd [MFC], ModifyStyleEx
- CWnd [MFC], MoveWindow
- CWnd [MFC], NotifyWinEvent
- CWnd [MFC], OnAmbientProperty
- CWnd [MFC], OnDrawIconicThumbnailOrLivePreview
- CWnd [MFC], OnHelp
- CWnd [MFC], OnHelpFinder
- CWnd [MFC], OnHelpIndex
- CWnd [MFC], OnHelpUsing
- CWnd [MFC], OnToolHitTest
- CWnd [MFC], OpenClipboard
- CWnd [MFC], PaintWindowlessControls
- CWnd [MFC], PostMessage
- CWnd [MFC], PreCreateWindow
- CWnd [MFC], PreSubclassWindow
- CWnd [MFC], PreTranslateMessage
- CWnd [MFC], Print
- CWnd [MFC], PrintClient
- CWnd [MFC], PrintWindow
- CWnd [MFC], RedrawWindow
- CWnd [MFC], RegisterTouchWindow
- CWnd [MFC], ReleaseDC
- CWnd [MFC], RepositionBars
- CWnd [MFC], RunModalLoop
- CWnd [MFC], ScreenToClient
- CWnd [MFC], ScrollWindow
- CWnd [MFC], ScrollWindowEx
- CWnd [MFC], SendChildNotifyLastMsg
- CWnd [MFC], SendDlgItemMessage
- CWnd [MFC], SendMessage
- CWnd [MFC], SendMessageToDescendants
- CWnd [MFC], SendNotifyMessage
- CWnd [MFC], SetActiveWindow
- CWnd [MFC], SetCapture
- CWnd [MFC], SetCaretPos
- CWnd [MFC], SetClipboardViewer
- CWnd [MFC], SetDlgCtrlID
- CWnd [MFC], SetDlgItemInt
- CWnd [MFC], SetDlgItemText
- CWnd [MFC], SetFocus
- CWnd [MFC], SetFont
- CWnd [MFC], SetForegroundWindow
- CWnd [MFC], SetIcon
- CWnd [MFC], SetLayeredWindowAttributes
- CWnd [MFC], SetMenu
- CWnd [MFC], SetOwner
- CWnd [MFC], SetParent
- CWnd [MFC], SetProperty
- CWnd [MFC], SetRedraw
- CWnd [MFC], SetScrollInfo
- CWnd [MFC], SetScrollPos
- CWnd [MFC], SetScrollRange
- CWnd [MFC], SetTimer
- CWnd [MFC], SetWindowContextHelpId
- CWnd [MFC], SetWindowPlacement
- CWnd [MFC], SetWindowPos
- CWnd [MFC], SetWindowRgn
- CWnd [MFC], SetWindowText
- CWnd [MFC], ShowCaret
- CWnd [MFC], ShowOwnedPopups
- CWnd [MFC], ShowScrollBar
- CWnd [MFC], ShowWindow
- CWnd [MFC], SubclassDlgItem
- CWnd [MFC], SubclassWindow
- CWnd [MFC], UnlockWindowUpdate
- CWnd [MFC], UnsubclassWindow
- CWnd [MFC], UpdateData
- CWnd [MFC], UpdateDialogControls
- CWnd [MFC], UpdateLayeredWindow
- CWnd [MFC], UpdateWindow
- CWnd [MFC], ValidateRect
- CWnd [MFC], ValidateRgn
- CWnd [MFC], WindowFromPoint
- CWnd [MFC], WinHelp
- CWnd [MFC], Default
- CWnd [MFC], DefWindowProc
- CWnd [MFC], DoDataExchange
- CWnd [MFC], GetCurrentMessage
- CWnd [MFC], InitDynamicLayout
- CWnd [MFC], LoadDynamicLayoutResource
- CWnd [MFC], OnActivate
- CWnd [MFC], OnActivateApp
- CWnd [MFC], OnAppCommand
- CWnd [MFC], OnAskCbFormatName
- CWnd [MFC], OnCancelMode
- CWnd [MFC], OnCaptureChanged
- CWnd [MFC], OnChangeCbChain
- CWnd [MFC], OnChangeUIState
- CWnd [MFC], OnChar
- CWnd [MFC], OnCharToItem
- CWnd [MFC], OnChildActivate
- CWnd [MFC], OnChildNotify
- CWnd [MFC], OnClipboardUpdate
- CWnd [MFC], OnClose
- CWnd [MFC], OnColorizationColorChanged
- CWnd [MFC], OnCommand
- CWnd [MFC], OnCompacting
- CWnd [MFC], OnCompareItem
- CWnd [MFC], OnCompositionChanged
- CWnd [MFC], OnContextMenu
- CWnd [MFC], OnCopyData
- CWnd [MFC], OnCreate
- CWnd [MFC], OnCtlColor
- CWnd [MFC], OnDeadChar
- CWnd [MFC], OnDeleteItem
- CWnd [MFC], OnDestroy
- CWnd [MFC], OnDestroyClipboard
- CWnd [MFC], OnDeviceChange
- CWnd [MFC], OnDevModeChange
- CWnd [MFC], OnDrawClipboard
- CWnd [MFC], OnDrawItem
- CWnd [MFC], OnDropFiles
- CWnd [MFC], OnEnable
- CWnd [MFC], OnEndSession
- CWnd [MFC], OnEnterIdle
- CWnd [MFC], OnEnterMenuLoop
- CWnd [MFC], OnEnterSizeMove
- CWnd [MFC], OnEraseBkgnd
- CWnd [MFC], OnExitMenuLoop
- CWnd [MFC], OnExitSizeMove
- CWnd [MFC], OnFontChange
- CWnd [MFC], OnGetDlgCode
- CWnd [MFC], OnGetMinMaxInfo
- CWnd [MFC], OnHelpInfo
- CWnd [MFC], OnHotKey
- CWnd [MFC], OnHScroll
- CWnd [MFC], OnHScrollClipboard
- CWnd [MFC], OnIconEraseBkgnd
- CWnd [MFC], OnInitMenu
- CWnd [MFC], OnInitMenuPopup
- CWnd [MFC], OnInputDeviceChange
- CWnd [MFC], OnInputLangChange
- CWnd [MFC], OnInputLangChangeRequest
- CWnd [MFC], OnKeyDown
- CWnd [MFC], OnKeyUp
- CWnd [MFC], OnKillFocus
- CWnd [MFC], OnLButtonDblClk
- CWnd [MFC], OnLButtonDown
- CWnd [MFC], OnLButtonUp
- CWnd [MFC], OnMButtonDblClk
- CWnd [MFC], OnMButtonDown
- CWnd [MFC], OnMButtonUp
- CWnd [MFC], OnMDIActivate
- CWnd [MFC], OnMeasureItem
- CWnd [MFC], OnMenuChar
- CWnd [MFC], OnMenuDrag
- CWnd [MFC], OnMenuGetObject
- CWnd [MFC], OnMenuRButtonUp
- CWnd [MFC], OnMenuSelect
- CWnd [MFC], OnMouseActivate
- CWnd [MFC], OnMouseHover
- CWnd [MFC], OnMouseHWheel
- CWnd [MFC], OnMouseLeave
- CWnd [MFC], OnMouseMove
- CWnd [MFC], OnMouseWheel
- CWnd [MFC], OnMove
- CWnd [MFC], OnMoving
- CWnd [MFC], OnNcActivate
- CWnd [MFC], OnNcCalcSize
- CWnd [MFC], OnNcCreate
- CWnd [MFC], OnNcDestroy
- CWnd [MFC], OnNcHitTest
- CWnd [MFC], OnNcLButtonDblClk
- CWnd [MFC], OnNcLButtonDown
- CWnd [MFC], OnNcLButtonUp
- CWnd [MFC], OnNcMButtonDblClk
- CWnd [MFC], OnNcMButtonDown
- CWnd [MFC], OnNcMButtonUp
- CWnd [MFC], OnNcMouseHover
- CWnd [MFC], OnNcMouseLeave
- CWnd [MFC], OnNcMouseMove
- CWnd [MFC], OnNcPaint
- CWnd [MFC], OnNcRButtonDblClk
- CWnd [MFC], OnNcRButtonDown
- CWnd [MFC], OnNcRButtonUp
- CWnd [MFC], OnNcRenderingChanged
- CWnd [MFC], OnNcXButtonDblClk
- CWnd [MFC], OnNcXButtonDown
- CWnd [MFC], OnNcXButtonUp
- CWnd [MFC], OnNextMenu
- CWnd [MFC], OnNotify
- CWnd [MFC], OnNotifyFormat
- CWnd [MFC], OnPaint
- CWnd [MFC], OnPaintClipboard
- CWnd [MFC], OnPaletteChanged
- CWnd [MFC], OnPaletteIsChanging
- CWnd [MFC], OnParentNotify
- CWnd [MFC], OnPowerBroadcast
- CWnd [MFC], OnQueryDragIcon
- CWnd [MFC], OnQueryEndSession
- CWnd [MFC], OnQueryNewPalette
- CWnd [MFC], OnQueryOpen
- CWnd [MFC], OnQueryUIState
- CWnd [MFC], OnRawInput
- CWnd [MFC], OnRButtonDblClk
- CWnd [MFC], OnRButtonDown
- CWnd [MFC], OnRButtonUp
- CWnd [MFC], OnRenderAllFormats
- CWnd [MFC], OnRenderFormat
- CWnd [MFC], OnSessionChange
- CWnd [MFC], OnSetCursor
- CWnd [MFC], OnSetFocus
- CWnd [MFC], OnSettingChange
- CWnd [MFC], OnShowWindow
- CWnd [MFC], OnSize
- CWnd [MFC], OnSizeClipboard
- CWnd [MFC], OnSizing
- CWnd [MFC], OnSpoolerStatus
- CWnd [MFC], OnStyleChanged
- CWnd [MFC], OnStyleChanging
- CWnd [MFC], OnSysChar
- CWnd [MFC], OnSysColorChange
- CWnd [MFC], OnSysCommand
- CWnd [MFC], OnSysDeadChar
- CWnd [MFC], OnSysKeyDown
- CWnd [MFC], OnSysKeyUp
- CWnd [MFC], OnTCard
- CWnd [MFC], OnTimeChange
- CWnd [MFC], OnTimer
- CWnd [MFC], OnTouchInput
- CWnd [MFC], OnTouchInputs
- CWnd [MFC], OnUniChar
- CWnd [MFC], OnUnInitMenuPopup
- CWnd [MFC], OnUpdateUIState
- CWnd [MFC], OnUserChanged
- CWnd [MFC], OnVKeyToItem
- CWnd [MFC], OnVScroll
- CWnd [MFC], OnVScrollClipboard
- CWnd [MFC], OnWindowPosChanged
- CWnd [MFC], OnWindowPosChanging
- CWnd [MFC], OnWinIniChange
- CWnd [MFC], OnWndMsg
- CWnd [MFC], OnXButtonDblClk
- CWnd [MFC], OnXButtonDown
- CWnd [MFC], OnXButtonUp
- CWnd [MFC], PostNcDestroy
- CWnd [MFC], ReflectChildNotify
- CWnd [MFC], ReflectLastMsg
- CWnd [MFC], ResizeDynamicLayout
- CWnd [MFC], WindowProc
- CWnd [MFC], m_hWnd
ms.assetid: 49a832ee-bc34-4126-88b3-bc1d9974f6c4
ms.openlocfilehash: 62298872def1a6e0e262c5339d323b83ad9bbc3d
ms.sourcegitcommit: ec6dd97ef3d10b44e0fedaa8e53f41696f49ac7b
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/25/2020
ms.locfileid: "88837641"
---
# <a name="cwnd-class"></a>CWnd 類別

提供 MFC 程式庫中所有視窗類別的基本功能。

## <a name="syntax"></a>語法

```
class CWnd : public CCmdTarget
```

## <a name="members"></a>成員

### <a name="public-constructors"></a>公用建構函式

|名稱|描述|
|----------|-----------------|
|[CWnd::CWnd](#cwnd)|建構 `CWnd` 物件。|

### <a name="public-methods"></a>公用方法

|名稱|描述|
|----------|-----------------|
|[CWnd::accDoDefaultAction](#accdodefaultaction)|由架構呼叫以執行物件的預設動作。|
|[CWnd::accHitTest](#acchittest)|由架構呼叫以擷取畫面中給定點的子項目或子物件。|
|[CWnd::accLocation](#acclocation)|由架構呼叫以擷取指定物件目前畫面的位置。|
|[CWnd::accNavigate](#accnavigate)|由架構呼叫以便於周遊容器內的另一使用者介面項目並擷取物件 (如果可能)。|
|[CWnd::accSelect](#accselect)|由架構呼叫以修改選取或移動指定物件的鍵盤焦點。|
|[CWnd::AnimateWindow](#animatewindow)|建立相關聯的視窗物件的動畫。|
|[CWnd::ArrangeIconicWindows](#arrangeiconicwindows)|排列所有最小化 (圖示) 子視窗。|
|[CWnd::Attach](#attach)|將 Windows 控制代碼附加至 `CWnd` 物件。|
|[CWnd::BeginModalState](#beginmodalstate)|呼叫此成員函式以製作框架視窗強制回應。|
|[CWnd::BeginPaint](#beginpaint)|準備 `CWnd` 進行繪製。|
|[CWnd::BindDefaultProperty](#binddefaultproperty)|將呼叫物件的預設簡單繫結屬性 (在類型程式庫中標示)，繫結至資料來源控制項相關聯的游標。|
|[CWnd::BindProperty](#bindproperty)|將資料繫結控制項上的游標繫結屬性繫結至資料來源控制項，並註冊該關聯性與 MFC 繫結管理員。|
|[CWnd::BringWindowToTop](#bringwindowtotop)|將 `CWnd` 帶到重疊視窗堆疊的最上層。|
|[CWnd::CalcWindowRect](#calcwindowrect)|呼叫可從用戶端矩形計算視窗矩形。|
|[CWnd::CancelToolTips](#canceltooltips)|停用工具提示控制項。|
|[CWnd::CenterWindow](#centerwindow)|將相對於其父系的視窗置中。|
|[CWnd::ChangeClipboardChain](#changeclipboardchain)|從剪貼簿檢視器的鏈結中移除 `CWnd`。|
|[CWnd::CheckDlgButton](#checkdlgbutton)|在按鈕控制項旁放置核取記號，或從中移除核取記號。|
|[CWnd::CheckRadioButton](#checkradiobutton)|檢查指定的選項按鈕，及移除指定的按鈕群組中所有其他選項按鈕的核取記號。|
|[CWnd::ChildWindowFromPoint](#childwindowfrompoint)|判斷 (如果有的話) 是否有子視窗包含指定的點。|
|[CWnd::ClientToScreen](#clienttoscreen)|將畫面上指定的點或矩形的用戶端座標，轉換為螢幕座標。|
|[CWnd::CloseWindow](#closewindow)|將視窗最小化。|
|[CWnd::ContinueModal](#continuemodal)|繼續視窗的強制回應狀態。|
|[CWnd::Create](#create)|建立並初始化 `CWnd` 物件相關聯的子視窗。|
|[CWnd::CreateAccessibleProxy](#createaccessibleproxy)|建立指定物件的 Active Accessibility Proxy。|
|[CWnd::CreateCaret](#createcaret)|建立系統游標的新形狀，並取得插入號的擁有權。|
|[CWnd::CreateControl](#createcontrol)|建立將由 `CWnd` 物件在 MFC 程式中表示的 ActiveX 控制項。|
|[CWnd::CreateEx](#createex)|建立 Windows 重疊、快顯視窗或子視窗，並將其附加至 `CWnd` 物件。|
|[CWnd::CreateGrayCaret](#creategraycaret)|建立系統游標的灰色區塊，並取得插入號的擁有權。|
|[CWnd::CreateSolidCaret](#createsolidcaret)|建立系統游標的實心區塊，並取得插入號的擁有權。|
|[CWnd::DeleteTempMap](#deletetempmap)|由 `CWinApp` 閒置時間處理常式自動呼叫，並刪除 `FromHandle` 建立的任何暫存 `CWnd` 物件。|
|[CWnd::DestroyWindow](#destroywindow)|終結附加的 Windowd 視窗。|
|[CWnd::Detach](#detach)|從 `CWnd` 物件卸離 Windows 控制代碼，並傳回控制代碼。|
|[CWnd::DlgDirList](#dlgdirlist)|使用檔案或目錄清單填入清單方塊。|
|[CWnd::DlgDirListComboBox](#dlgdirlistcombobox)|使用檔案或目錄清單來填入下拉式方塊的清單方塊。|
|[CWnd::DlgDirSelect](#dlgdirselect)|從清單方塊擷取目前的選取範圍。|
|[CWnd::DlgDirSelectComboBox](#dlgdirselectcombobox)|從下拉式方塊的清單方塊中擷取目前的選取範圍。|
|[CWnd::DragAcceptFiles](#dragacceptfiles)|指出視窗將接受拖曳的檔案。|
|[CWnd::DragDetect](#dragdetect)|擷取滑鼠並追蹤其移動，直到使用者放開左側按鈕、按下 ESC 鍵，或將滑鼠移到指定點周圍的拖曳矩形外。|
|[CWnd::DrawAnimatedRects](#drawanimatedrects)|繪製框線矩形，並以動畫效果呈現它來指出圖示的開頭，或最小化或最大化視窗。|
|[CWnd::DrawCaption](#drawcaption)|繪製標題。|
|[CWnd::DrawMenuBar](#drawmenubar)|重新繪製功能表列。|
|[CWnd::EnableActiveAccessibility](#enableactiveaccessibility)|啟用使用者定義的 `Active Accessibility` 函式。|
|[CWnd::EnableDynamicLayout](#enabledynamiclayout)|可在使用者調整視窗大小時，動態調整子視窗的位置與大小。|
|[CWnd::EnableD2DSupport](#enabled2dsupport)|啟用或停用視窗 `D2D` 支援。 初始化主視窗之前先呼叫這個方法。|
|[CWnd::EnableScrollBar](#enablescrollbar)|啟用或停用一個捲軸的一或兩個箭號。|
|[CWnd::EnableScrollBarCtrl](#enablescrollbarctrl)|啟用或停用同層級捲軸控制項。|
|[CWnd::EnableToolTips](#enabletooltips)|啟用工具提示控制項。|
|[CWnd::EnableTrackingToolTips](#enabletrackingtooltips)|啟用追蹤模式中的工具提示控制項。|
|[CWnd::EnableWindow](#enablewindow)|啟用或停用滑鼠和鍵盤輸入。|
|[CWnd::EndModalLoop](#endmodalloop)|結束視窗的強制回應狀態。|
|[CWnd::EndModalState](#endmodalstate)|呼叫此成員函式，將框架視窗從強制回應變更為非強制回應。|
|[CWnd::EndPaint](#endpaint)|標記繪製的結束。|
|[CWnd::ExecuteDlgInit](#executedlginit)|初始化對話方塊資源。|
|[CWnd::FilterToolTipMessage](#filtertooltipmessage)|擷取對話方塊中控制項相關聯的標題或文字。|
|[CWnd::FindWindow](#findwindow)|傳回由其視窗名稱和視窗類別識別的視窗控制代碼。|
|[CWnd::FindWindowEx](#findwindowex)|傳回由其視窗名稱和視窗類別識別的視窗控制代碼。|
|[CWnd::FlashWindow](#flashwindow)|閃爍視窗一次。|
|[CWnd::FlashWindowEx](#flashwindowex)|閃爍視窗與其他功能。|
|[CWnd::FromHandle](#fromhandle)|將控制代碼提供給視窗時，將指標傳回至 `CWnd` 物件。 如果 `CWnd` 物件沒有附加至控制代碼，會建立並附加暫存 `CWnd` 物件。|
|[CWnd::FromHandlePermanent](#fromhandlepermanent)|將控制代碼提供給視窗時，將指標傳回至 `CWnd` 物件。|
|[CWnd::get_accChild](#get_accchild)|由架構呼叫以擷取指定子系的 `IDispatch` 介面位址。|
|[CWnd::get_accChildCount](#get_accchildcount)|由架構呼叫以擷取屬於此物件的子物件數目。|
|[CWnd::get_accDefaultAction](#get_accdefaultaction)|由架構呼叫以擷取具有物件預設動作描述的字串。|
|[CWnd::get_accDescription](#get_accdescription)|由架構呼叫以擷取含有指定物件的視覺外觀描述的字串。|
|[CWnd::get_accFocus](#get_accfocus)|由架構呼叫以擷取具有鍵盤焦點的物件。|
|[CWnd::get_accHelp](#get_acchelp)|由架構呼叫以取得物件的 **Help** 屬性字串。|
|[CWnd::get_accHelpTopic](#get_acchelptopic)|由架構呼叫以擷取 `WinHelp` 檔 (與指定物件和該檔案中適切主題的識別項關聯) 的完整路徑。|
|[CWnd::get_accKeyboardShortcut](#get_acckeyboardshortcut)|由架構呼叫以擷取指定物件的快速鍵或便捷鍵。|
|[CWnd::get_accName](#get_accname)|由架構呼叫以擷取指定物件的名稱。|
|[CWnd::get_accParent](#get_accparent)|由架構呼叫以擷取物件之父代的 `IDispatch` 介面。|
|[CWnd::get_accRole](#get_accrole)|由架構呼叫以擷取含有指定物件的角色描述資訊。|
|[CWnd::get_accSelection](#get_accselection)|由架構呼叫以擷取此物件的選取子物件。|
|[CWnd::get_accState](#get_accstate)|由架構呼叫以擷取指定物件的目前狀態。|
|[CWnd::get_accValue](#get_accvalue)|由架構呼叫以擷取指定物件的值。|
|[CWnd::GetActiveWindow](#getactivewindow)|擷取使用中視窗。|
|[CWnd::GetAncestor](#getancestor)|擷取指定視窗的上階視窗物件。|
|[CWnd::GetCapture](#getcapture)|擷取具有滑鼠捕捉的 `CWnd`。|
|[CWnd::GetCaretPos](#getcaretpos)|擷取插入號之目前位置的用戶端座標。|
|[CWnd::GetCheckedRadioButton](#getcheckedradiobutton)|傳回按鈕群組中目前核取的選項按鈕的識別碼。|
|[CWnd::GetClientRect](#getclientrect)|取得 `CWnd` 工作區的維度。|
|[CWnd::GetClipboardOwner](#getclipboardowner)|擷取剪貼簿的目前擁有者的指標。|
|[CWnd::GetClipboardViewer](#getclipboardviewer)|擷取剪貼簿檢視器鏈結中的第一個視窗的指標。|
|[CWnd::GetControlUnknown](#getcontrolunknown)|擷取至未知 ActiveX 控制項的指標。|
|[CWnd::GetDC](#getdc)|擷取工作區的顯示內容。|
|[CWnd::GetDCEx](#getdcex)|擷取工作區的顯示內容，並在繪製時啟用裁剪。|
|[CWnd::GetDCRenderTarget](#getdcrendertarget)|擷取裝置內容 (DC) 會呈現 `CWnd` 視窗的目標。|
|[CWnd::GetDescendantWindow](#getdescendantwindow)|搜尋所有下階視窗，並傳回具有指定識別碼的視窗。|
|[CWnd::GetDesktopWindow](#getdesktopwindow)|擷取 Windows 桌面視窗。|
|[CWnd::GetDlgCtrlID](#getdlgctrlid)|如果 `CWnd` 是子視窗，呼叫這個函式會傳回它的識別碼值。|
|[CWnd::GetDlgItem](#getdlgitem)|從指定的對話方塊中擷取具有指定識別碼的控制項。|
|[CWnd::GetDlgItemInt](#getdlgitemint)|將指定對話方塊中的控制項文字轉譯成整數值。|
|[CWnd::GetDlgItemText](#getdlgitemtext)|擷取與控制項相關聯的標題或文字。|
|[CWnd::GetDSCCursor](#getdsccursor)|擷取料來源控制項的 DataSource、UserName、Password 和 SQL 屬性所定義之基礎游標的指標。|
|[CWnd::GetDynamicLayout](#getdynamiclayout)|擷取動態配置管理員物件的指標。|
|[CWnd::GetExStyle](#getexstyle)|傳回視窗的延伸樣式。|
|[CWnd::GetFocus](#getfocus)|擷取目前具有輸入焦點的 `CWnd`。|
|[CWnd::GetFont](#getfont)|擷取目前的字型。|
|[CWnd::GetForegroundWindow](#getforegroundwindow)|讓指標回到前景視窗 (使用者目前使用的最上層視窗)。|
|[CWnd::GetIcon](#geticon)|擷取圖示的控制代碼。|
|[CWnd::GetLastActivePopup](#getlastactivepopup)|判斷 `CWnd` 擁有的快顯視窗哪一個是最近啟用的。|
|[CWnd::GetLayeredWindowAttributes](#getlayeredwindowattributes)|擷取分層視窗的不透明和透明色鍵。|
|[CWnd::GetMenu](#getmenu)|擷取指定功能表的指標。|
|[CWnd::GetNextDlgGroupItem](#getnextdlggroupitem)|搜尋控制項群組內的下一個 (或上一個) 控制項。|
|[CWnd::GetNextDlgTabItem](#getnextdlgtabitem)|使用遵循 (或在指定控制項) 之前的 [WS_TABSTOP](styles-used-by-mfc.md#window-styles) 樣式抓取第一個控制項。|
|[CWnd::GetNextWindow](#getnextwindow)|傳回視窗管理員清單中的下一個 (或上一個) 視窗。|
|[CWnd::GetOleControlSite](#getolecontrolsite)|擷取指定的 ActiveX 控制項的自訂網站。|
|[CWnd::GetOpenClipboardWindow](#getopenclipboardwindow)|擷取目前已開啟剪貼簿的視窗指標。|
|[CWnd::GetOwner](#getowner)|擷取 `CWnd` 擁有者的指標。|
|[CWnd::GetParent](#getparent)|擷取 `CWnd` 的父視窗 (如果有的話)。|
|[CWnd::GetParentFrame](#getparentframe)|擷取 `CWnd` 物件的父框架視窗。|
|[CWnd::GetParentOwner](#getparentowner)|傳回子視窗的父視窗指標。|
|[CWnd：： GetProperty](#getproperty)|擷取 ActiveX 控制項屬性。|
|[CWnd::GetRenderTarget](#getrendertarget)|取得與此視窗相關聯的呈現目標。|
|[CWnd::GetSafeHwnd](#getsafehwnd)|`m_hWnd`如果指標為 null，則傳回，否則為 null **`this`** 。|
|[CWnd::GetSafeOwner](#getsafeowner)|擷取給定視窗的安全擁有者。|
|[CWnd::GetScrollBarCtrl](#getscrollbarctrl)|傳回一個同層級捲軸控制項。|
|[CWnd::GetScrollBarInfo](#getscrollbarinfo)|擷取所指定之捲軸的相關資訊。|
|[CWnd::GetScrollInfo](#getscrollinfo)|擷取 `SCROLLINFO` 結構維護的捲軸相關資訊。|
|[CWnd::GetScrollLimit](#getscrolllimit)|擷取捲軸的限制。|
|[CWnd::GetScrollPos](#getscrollpos)|擷取捲動方塊的目前位置。|
|[CWnd::GetScrollRange](#getscrollrange)|複製給定捲軸目前的最小和最大捲軸位置。|
|[CWnd::GetStyle](#getstyle)|傳回目前的視窗樣式。|
|[CWnd::GetSystemMenu](#getsystemmenu)|可讓應用程式存取控制功能表以進行複製和修改。|
|[CWnd::GetTitleBarInfo](#gettitlebarinfo)|擷取指定之標題列的相關資訊。|
|[CWnd::GetTopLevelFrame](#gettoplevelframe)|擷取視窗的最上層框架視窗。|
|[CWnd::GetTopLevelOwner](#gettoplevelowner)|擷取最上層視窗。|
|[CWnd::GetTopLevelParent](#gettoplevelparent)|擷取視窗的最上層父代。|
|[CWnd::GetTopWindow](#gettopwindow)|傳回屬於 `CWnd` 的第一個子視窗。|
|[CWnd::GetUpdateRect](#getupdaterect)|擷取完全圍住 `CWnd` 更新區域的最小矩形座標。|
|[CWnd::GetUpdateRgn](#getupdatergn)|擷取 `CWnd` 更新區域。|
|[CWnd::GetWindow](#getwindow)|傳回與此視窗具有指定關聯性的視窗。|
|[CWnd::GetWindowContextHelpId](#getwindowcontexthelpid)|擷取說明內容識別碼。|
|[CWnd::GetWindowDC](#getwindowdc)|擷取整個視窗的顯示內容，包括標題列、功能表和捲軸。|
|[CWnd::GetWindowedChildCount](#getwindowedchildcount)|傳回相關聯子視窗的數目。|
|[CWnd::GetWindowInfo](#getwindowinfo)|傳回視窗的相關資訊。|
|[CWnd：： GetWindowlessChildCount](#getwindowlesschildcount)|傳回相關聯的無視窗子視窗數目。|
|[CWnd::GetWindowPlacement](#getwindowplacement)|擷取視窗的顯示狀態和一般 (還原)、最小化和最大化位置。|
|[CWnd::GetWindowRect](#getwindowrect)|取得 `CWnd` 的螢幕座標。|
|[CWnd::GetWindowRgn](#getwindowrgn)|擷取視窗的視窗區域複本。|
|[CWnd::GetWindowText](#getwindowtext)|傳回視窗文字或標題 (如果有的話)。|
|[CWnd::GetWindowTextLength](#getwindowtextlength)|傳回視窗的文字或標題的長度。|
|[CWnd::HideCaret](#hidecaret)|藉由從顯示畫面移除插入號來隱藏該插入號。|
|[CWnd::HiliteMenuItem](#hilitemenuitem)|反白顯示或從最上層 (功能表列) 的功能表項目中移除反白顯示。|
|[CWnd::HtmlHelp](#htmlhelp)|呼叫以初始化 HTMLHelp 應用程式。|
|[CWnd::Invalidate](#invalidate)|使整個工作區失效。|
|[CWnd::InvalidateRect](#invalidaterect)|將矩形加入至目前的更新區域，使給定矩形內的工作區失效。|
|[CWnd::InvalidateRgn](#invalidatergn)|將區域加入至目前的更新區域，使給定區域內的工作區失效。|
|[CWnd::InvokeHelper](#invokehelper)|叫用 ActiveX 控制項方法或屬性。|
|[CWnd::IsChild](#ischild)|指出 `CWnd` 是子視窗，還是指定視窗的其他直屬下階。|
|[CWnd::IsD2DSupportEnabled](#isd2dsupportenabled)|判斷是否已啟用 D2D 支援。|
|[CWnd::IsDialogMessage](#isdialogmessage)|判斷指定的訊息是否適用於非強制回應對話方塊，若是則處理它。|
|[CWnd::IsDlgButtonChecked](#isdlgbuttonchecked)|決定是否核取按鈕控制項。|
|[CWnd::IsDynamicLayoutEnabled](#isdynamiclayoutenabled)|決定是否在這個視窗上啟用動態配置。 如果啟用動態配置時，則使用者可在調整父視窗大小時變更子視窗的位置與大小。|
|[CWnd::IsIconic](#isiconic)|決定是否將 `CWnd` 降到最低 (圖示)。|
|[CWnd::IsTouchWindow](#istouchwindow)|指定 `CWnd` 是否有觸控支援。|
|[CWnd::IsWindowEnabled](#iswindowenabled)|決定是否為滑鼠和鍵盤輸入啟用視窗。|
|[CWnd::IsWindowVisible](#iswindowvisible)|決定視窗是否可見。|
|[CWnd::IsZoomed](#iszoomed)|決定是否將 `CWnd` 最大化。|
|[CWnd::KillTimer](#killtimer)|刪除系統計時器。|
|[CWnd::LockWindowUpdate](#lockwindowupdate)|停用或重新啟用在給定視窗中繪製。|
|[CWnd::MapWindowPoints](#mapwindowpoints)|將一組點從 `CWnd` 的座標空間轉換 (對應) 至另一個視窗的座標空間。|
|[CWnd::MessageBox](#messagebox)|建立並顯示視窗，其中包含應用程式提供的訊息和標題。|
|[CWnd::ModifyStyle](#modifystyle)|修改目前的視窗樣式。|
|[CWnd::ModifyStyleEx](#modifystyleex)|修改視窗的延伸樣式。|
|[CWnd::MoveWindow](#movewindow)|變更 `CWnd` 的位置和維度。|
|[CWnd::NotifyWinEvent](#notifywinevent)|表示發生預先定義之事件的系統。|
|[CWnd::OnAmbientProperty](#onambientproperty)|實作環境屬性值。|
|[CWnd::OnDrawIconicThumbnailOrLivePreview](#ondrawiconicthumbnailorlivepreview)|需要取得點陣圖，在 Windows 7 索引標籤上顯示為縮圖時，或顯示在用戶端上以查看應用程式時，由架構呼叫。|
|[CWnd::OnHelp](#onhelp)|在應用程式 (使用目前的內容) 中處理 F1 說明。|
|[CWnd::OnHelpFinder](#onhelpfinder)|處理 ID_HELP_FINDER 和 ID_DEFAULT_HELP 命令。|
|[CWnd::OnHelpIndex](#onhelpindex)|處理 ID_HELP_INDEX 命令，並提供預設說明主題。|
|[CWnd::OnHelpUsing](#onhelpusing)|處理 ID_HELP_USING 命令。|
|[CWnd::OnToolHitTest](#ontoolhittest)|決定一個點是否位於指定工具的周框中並擷取工具的相關資訊。|
|[CWnd::OpenClipboard](#openclipboard)|開啟剪貼簿。 在呼叫 Windows [CloseClipboard](/windows/win32/api/winuser/nf-winuser-closeclipboard) 函數之前，其他應用程式將無法修改剪貼簿。|
|[CWnd::PaintWindowlessControls](#paintwindowlesscontrols)|在控制項容器上繪製無視窗控制項。|
|[CWnd::PostMessage](#postmessage)|在應用程式佇列中放置訊息，然後傳回，而不需等待視窗處理訊息。|
|[CWnd::PreCreateWindow](#precreatewindow)|在建立附加至此 `CWnd` 物件的 Windows 視窗前呼叫。|
|[CWnd::PreSubclassWindow](#presubclasswindow)|允許在呼叫 [SubclassWindow](#subclasswindow) 之前，進行其他必要的子類別化。|
|[CWnd::PreTranslateMessage](#pretranslatemessage)|由 `CWinApp` 使用，可先篩選視窗訊息，再將它們分派至 `TranslateMessage` 和 `DispatchMessage` Windows 函式。|
|[CWnd::Print](#print)|在指定的裝置內容中繪製目前的視窗。|
|[CWnd::PrintClient](#printclient)|在指定的裝置內容中繪製任何視窗 (通常是印表機裝置內容)。|
|[CWnd::PrintWindow](#printwindow)|將視覺視窗複製到指定的裝置內容，通常是印表機 DC。|
|[CWnd::RedrawWindow](#redrawwindow)|更新工作區中指定的矩形或區域。|
|[CWnd::RegisterTouchWindow](#registertouchwindow)|註冊/取消註冊視窗 Windows 觸控支援。|
|[CWnd::ReleaseDC](#releasedc)|釋放用戶端和視窗裝置內容，釋放這些內容供其他應用程式使用。|
|[CWnd::RepositionBars](#repositionbars)|工作區中的重新置放控制列。|
|[CWnd::RunModalLoop](#runmodalloop)|擷取、轉換或分派處於強制回應狀態之視窗的訊息。|
|[CWnd::ScreenToClient](#screentoclient)|將畫面上指定的點或矩形的螢幕座標，轉換為用戶端座標。|
|[CWnd::ScrollWindow](#scrollwindow)|捲動工作區的內容。|
|[CWnd::ScrollWindowEx](#scrollwindowex)|捲動工作區的內容。 類似於 `ScrollWindow`，但具有額外的功能。|
|[CWnd::SendChildNotifyLastMsg](#sendchildnotifylastmsg)|從父視窗中將通知訊息提供給子視窗，讓子視窗可以處理工作。|
|[CWnd::SendDlgItemMessage](#senddlgitemmessage)|將訊息傳送至指定的控制項。|
|[CWnd::SendMessage](#sendmessage)|傳送訊息給 `CWnd` 物件，在處理訊息後才會傳回。|
|[CWnd::SendMessageToDescendants](#sendmessagetodescendants)|傳送訊息給視窗的所有下階視窗。|
|[CWnd::SendNotifyMessage](#sendnotifymessage)|將指定的訊息傳送至視窗並儘速傳回，視呼叫執行緒是否建立視窗而定。|
|[CWnd::SetActiveWindow](#setactivewindow)|啟用視窗。|
|[CWnd::SetCapture](#setcapture)|導致所有後續滑鼠輸入傳送至 `CWnd`。|
|[CWnd::SetCaretPos](#setcaretpos)|將插入號移動到指定的位置。|
|[CWnd::SetClipboardViewer](#setclipboardviewer)|將 `CWnd` 新增到視窗的鏈結，每當剪貼簿的內容變更時就會通知這些視窗。|
|[CWnd::SetDlgCtrlID](#setdlgctrlid)|設定視窗或視窗的控制項識別碼 (這可以是任何子視窗，而不只是對話方塊中的控制項)。|
|[CWnd::SetDlgItemInt](#setdlgitemint)|將控制項的文字設為表示整數值的字串。|
|[CWnd::SetDlgItemText](#setdlgitemtext)|在指定的對話方塊中設定控制項的標題或文字。|
|[CWnd::SetFocus](#setfocus)|宣告輸入焦點。|
|[CWnd::SetFont](#setfont)|設定目前的字型。|
|[CWnd::SetForegroundWindow](#setforegroundwindow)|將建立視窗的執行緒放置到前景並啟動視窗。|
|[CWnd::SetIcon](#seticon)|將控制代碼設為特定的圖示。|
|[CWnd::SetLayeredWindowAttributes](#setlayeredwindowattributes)|設定分層視窗的不透明和透明色鍵。|
|[CWnd::SetMenu](#setmenu)|將功能表設定為指定的功能表。|
|[CWnd::SetOwner](#setowner)|變更 `CWnd` 的擁有者。|
|[CWnd::SetParent](#setparent)|變更父視窗。|
|[CWnd::SetProperty](#setproperty)|設定 ActiveX 控制項屬性。|
|[CWnd::SetRedraw](#setredraw)|允許重新繪製 `CWnd` 中的變更，或防止重新繪製進行變更。|
|[CWnd::SetScrollInfo](#setscrollinfo)|設定捲軸的相關資訊。|
|[CWnd::SetScrollPos](#setscrollpos)|設定捲動方塊的目前位置，而且如果指定，會重新繪製捲軸以反映新位置。|
|[CWnd::SetScrollRange](#setscrollrange)|設定給定捲軸的最小和最大位置值。|
|[CWnd::SetTimer](#settimer)|安裝會在觸發時傳送 [WM_TIMER](#ontimer) 訊息的系統計時器。|
|[CWnd::SetWindowContextHelpId](#setwindowcontexthelpid)|設定說明內容識別碼。|
|[CWnd::SetWindowPlacement](#setwindowplacement)|設定視窗的顯示狀態和一般 (還原)、最小化和最大化位置。|
|[CWnd::SetWindowPos](#setwindowpos)|變更大小、位置和子系順序、快顯視窗，和最上層視窗。|
|[CWnd::SetWindowRgn](#setwindowrgn)|設定視窗的區域。|
|[CWnd::SetWindowText](#setwindowtext)|將視窗文字或標題 (如果有的話) 設為指定的文字。|
|[CWnd::ShowCaret](#showcaret)|在畫面上插入號的目前位置上顯示插入號。 顯示後，插入號會開始自動閃爍。|
|[CWnd::ShowOwnedPopups](#showownedpopups)|顯示或隱藏視窗擁有的所有快顯視窗。|
|[CWnd::ShowScrollBar](#showscrollbar)|顯示或隱藏捲軸。|
|[CWnd::ShowWindow](#showwindow)|顯示或隱藏視窗。|
|[CWnd::SubclassDlgItem](#subclassdlgitem)|將 Windows 控制項附加至 `CWnd` 物件，並使其透過 `CWnd` 的訊息對應來路由訊息。|
|[CWnd::SubclassWindow](#subclasswindow)|將視窗附加至 `CWnd` 物件，並使其透過 `CWnd` 的訊息對應來路由訊息。|
|[CWnd::UnlockWindowUpdate](#unlockwindowupdate)|解除鎖定已使用 `CWnd::LockWindowUpdate` 鎖定的視窗。|
|[CWnd::UnsubclassWindow](#unsubclasswindow)|從物件卸離視窗 `CWnd`|
|[CWnd::UpdateData](#updatedata)|從對話方塊中初始化或擷取資料。|
|[CWnd::UpdateDialogControls](#updatedialogcontrols)|呼叫以更新對話方塊按鈕和其他控制項的狀態。|
|[CWnd::UpdateLayeredWindow](#updatelayeredwindow)|更新分層視窗的位置、大小、形狀、內容和透明度。|
|[CWnd::UpdateWindow](#updatewindow)|更新工作區。|
|[CWnd::ValidateRect](#validaterect)|從目前的更新區域中移除矩形，驗證給定矩形內的工作區。|
|[CWnd::ValidateRgn](#validatergn)|從目前的更新區域中移除區域，驗證給定區域內的工作區。|
|[CWnd::WindowFromPoint](#windowfrompoint)|識別包含指定點的視窗。|
|[CWnd::WinHelp](#winhelp)|呼叫以初始化 WinHelp 應用程式。|

### <a name="protected-methods"></a>保護方法

|名稱|描述|
|----------|-----------------|
|[CWnd::Default](#default)|呼叫預設視窗程序，提供應用程式不會處理的任何視窗訊息的預設處理程序。|
|[CWnd::DefWindowProc](#defwindowproc)|呼叫預設視窗程序，提供應用程式不會處理的任何視窗訊息的預設處理程序。|
|[CWnd::DoDataExchange](#dodataexchange)|適用於對話方塊資料交換和驗證。 由 `UpdateData` 呼叫。|
|[CWnd::GetCurrentMessage](#getcurrentmessage)|傳回此視窗目前正在處理的訊息指標。 只應在 `On` *訊息*訊息處理常式成員函式中呼叫。|
|[CWnd::InitDynamicLayout](#initdynamiclayout)|由架構呼叫以初始化視窗的動態配置。|
|[CWnd::LoadDynamicLayoutResource](#loaddynamiclayoutresource)|從資源檔載入動態配置資訊。|
|[CWnd：： OnActivate](#onactivate)|當 `CWnd` 啟動或停用時呼叫。|
|[CWnd::OnActivateApp](#onactivateapp)|當應用程式即將啟動或停用時呼叫。|
|[CWnd::OnAppCommand](#onappcommand)|當使用者產生應用程式命令事件時呼叫。|
|[CWnd::OnAskCbFormatName](#onaskcbformatname)|當剪貼簿擁有者將顯示剪貼簿內容時，由剪貼簿檢視器應用程式呼叫。|
|[CWnd::OnCancelMode](#oncancelmode)|呼叫以讓 `CWnd` 取消任何內部的模式，例如滑鼠捕捉。|
|[CWnd::OnCaptureChanged](#oncapturechanged)|將訊息傳送至正失去滑鼠捕捉的視窗。|
|[CWnd::OnChangeCbChain](#onchangecbchain)|通知正在從鏈結中移除指定的視窗。|
|[CWnd::OnChangeUIState](#onchangeuistate)|應變更使用者介面 (UI) 狀態時呼叫。|
|[CWnd::OnChar](#onchar)|按鍵轉譯為非系統字元時呼叫。|
|[CWnd::OnCharToItem](#onchartoitem)|由包含 [LBS_WANTKEYBOARDINPUT](../../mfc/reference/styles-used-by-mfc.md#list-box-styles) 樣式的子清單方塊呼叫，以回應 [WM_CHAR](#onchar) 訊息。|
|[CWnd::OnChildActivate](#onchildactivate)|每當 `CWnd` 的大小或位置變更，或 `CWnd` 已啟動時，針對多重文件介面 (MDI) 子視窗呼叫。|
|[CWnd::OnChildNotify](#onchildnotify)|由父視窗呼叫，讓通知控制項有機會回應控制項通知。|
|[CWnd::OnClipboardUpdate](#onclipboardupdate)|於剪貼簿內容已變更時呼叫。|
|[CWnd::OnClose](#onclose)|呼叫以表示 `CWnd` 應該關閉。|
|[CWnd::OnColorizationColorChanged](#oncolorizationcolorchanged)|當非工作區的轉譯原則已變更時呼叫。|
|[CWnd::OnCommand](#oncommand)|當使用者選取命令時呼叫。|
|[CWnd::OnCompacting](#oncompacting)|當 Windows 偵測到系統記憶體過低時呼叫。|
|[CWnd::OnCompareItem](#oncompareitem)|呼叫以判斷子排序之主控描繪的下拉式方塊或清單方塊中新項目的相對位置。|
|[CWnd::OnCompositionChanged](#oncompositionchanged)|當桌面視窗管理員 (DWM) 組合啟用或停用時，為所有最上層視窗呼叫。|
|[CWnd::OnContextMenu](#oncontextmenu)|當使用者在視窗中按一下滑鼠右鍵時呼叫。|
|[CWnd::OnCopyData](#oncopydata)|在應用程式之間複製資料。|
|[CWnd::OnCreate](#oncreate)|在視窗建立過程中呼叫。|
|[CWnd::OnCtlColor](#onctlcolor)|即將繪製控制項時，如果`CWnd` 是控制項的父代則呼叫。|
|[CWnd::OnDeadChar](#ondeadchar)|當按鍵轉譯為非系統無效字元 (例如強調符號) 時呼叫。|
|[CWnd::OnDeleteItem](#ondeleteitem)|當主控描繪子清單方塊或下拉式方塊損毀，或從控制項移除項目時呼叫。|
|[CWnd::OnDestroy](#ondestroy)|`CWnd` 正在損毀時呼叫。|
|[CWnd::OnDestroyClipboard](#ondestroyclipboard)|當透過呼叫 Windows [EmptyClipboard](/windows/win32/api/winuser/nf-winuser-emptyclipboard) 函式清空剪貼簿時呼叫。|
|[CWnd::OnDeviceChange](#ondevicechange)|將裝置或電腦的硬體組態變更通知應用程式或裝置驅動程式。|
|[CWnd::OnDevModeChange](#ondevmodechange)|當使用者變更裝置模式設定時，針對所有最上層視窗呼叫。|
|[CWnd::OnDrawClipboard](#ondrawclipboard)|於剪貼簿內容變更時呼叫。|
|[CWnd::OnDrawItem](#ondrawitem)|主控描繪子按鈕控制項、下拉式方塊控制項、清單方塊控制項或功能表的視覺外觀必須繪製時呼叫。|
|[CWnd::OnDropFiles](#ondropfiles)|當使用者在視窗 (已本身註冊為捨棄檔案的收件者) 上放開滑鼠按鈕時呼叫。|
|[CWnd::OnEnable](#onenable)|啟用或停用 `CWnd` 時呼叫。|
|[CWnd::OnEndSession](#onendsession)|當工作階段正在結束時呼叫。|
|[CWnd::OnEnterIdle](#onenteridle)|呼叫此函式，可將強制回應對話方塊或功能表正在進入閒置狀態的訊息，通知應用程式的主視窗程序。|
|[CWnd::OnEnterMenuLoop](#onentermenuloop)|已進入功能表強制回應迴圈時呼叫。|
|[CWnd::OnEnterSizeMove](#onentersizemove)|在受影響的視窗進入移動或調整大小的強制回應迴圈後呼叫。|
|[CWnd::OnEraseBkgnd](#onerasebkgnd)|視窗背景需要清除時呼叫。|
|[CWnd::OnExitMenuLoop](#onexitmenuloop)|已結束功能表強制回應迴圈時呼叫。|
|[CWnd::OnExitSizeMove](#onexitsizemove)|在受影響的視窗結束移動或調整大小的強制回應迴圈後呼叫。|
|[CWnd::OnFontChange](#onfontchange)|字型資源的集區變更時呼叫。|
|[CWnd::OnGetDlgCode](#ongetdlgcode)|呼叫控制項，讓控制項可以處理方向鍵和 TAB 鍵輸入本身。|
|[CWnd::OnGetMinMaxInfo](#ongetminmaxinfo)|每當 Windows 必須知道最大化的位置或維度，或最小或最大的追蹤大小時呼叫。|
|[CWnd::OnHelpInfo](#onhelpinfo)|當使用者按下 F1 鍵時，由架構呼叫。|
|[CWnd::OnHotKey](#onhotkey)|當使用者按下全系統的便捷鍵時呼叫。|
|[CWnd::OnHScroll](#onhscroll)|當使用者按一下 `CWnd` 的水平捲軸時呼叫。|
|[CWnd::OnHScrollClipboard](#onhscrollclipboard)|當剪貼簿擁有者應該捲動剪貼簿影像、使適當的區段失效，及更新捲軸值時呼叫。|
|[CWnd::OnIconEraseBkgnd](#oniconerasebkgnd)|當 `CWnd` 減到最小 (圖示)，且必須先填入圖示的背景再繪製圖示時呼叫。|
|[CWnd::OnInitMenu](#oninitmenu)|當功能表即將變成現用時呼叫。|
|[CWnd::OnInitMenuPopup](#oninitmenupopup)|當快顯功能表即將變成現用時呼叫。|
|[CWnd::OnInputDeviceChange](#oninputdevicechange)|從系統中新增或移除 I/O 裝置時呼叫。|
|[CWnd::OnInputLangChange](#oninputlangchange)|在應用程式的輸入語言變更後呼叫。|
|[CWnd::OnInputLangChangeRequest](#oninputlangchangerequest)|當使用者選擇新的輸入語言時呼叫。|
|[CWnd::OnKeyDown](#onkeydown)|按下非系統鍵時呼叫。|
|[CWnd::OnKeyUp](#onkeyup)|放開非系統鍵時呼叫。|
|[CWnd::OnKillFocus](#onkillfocus)|在 `CWnd` 遺失輸入焦點前立即呼叫。|
|[CWnd::OnLButtonDblClk](#onlbuttondblclk)|當使用者按兩下滑鼠左鍵時呼叫。|
|[CWnd::OnLButtonDown](#onlbuttondown)|當使用者按下滑鼠左鍵時呼叫。|
|[CWnd::OnLButtonUp](#onlbuttonup)|當使用者放開滑鼠左鍵時呼叫。|
|[CWnd::OnMButtonDblClk](#onmbuttondblclk)|當使用者按兩下滑鼠中鍵時呼叫。|
|[CWnd::OnMButtonDown](#onmbuttondown)|當使用者按下滑鼠中鍵時呼叫。|
|[CWnd::OnMButtonUp](#onmbuttonup)|當使用者放開滑鼠中鍵時呼叫。|
|[CWnd::OnMDIActivate](#onmdiactivate)|當 MDI 子視窗啟用或停用時呼叫。|
|[CWnd::OnMeasureItem](#onmeasureitem)|建立控制項時，針對主控描繪子下拉式方塊、清單方塊或功能表項目呼叫。 `CWnd` 會將控制項維度通知 Windows。|
|[CWnd::OnMenuChar](#onmenuchar)|當使用者按下功能表的助憶鍵字元，且該字元不符合目前功能表中任何預先定義的助憶鍵時呼叫。|
|[CWnd::OnMenuDrag](#onmenudrag)|當使用者開始拖曳功能表項目時呼叫。|
|[CWnd::OnMenuGetObject](#onmenugetobject)|當滑鼠游標進入功能表項目，或從項目中央移到項目上方或下方時呼叫。|
|[CWnd::OnMenuRButtonUp](#onmenurbuttonup)|當游標位於功能表項目上，而使用者放開滑鼠右鍵時呼叫。|
|[CWnd::OnMenuSelect](#onmenuselect)|當使用者選取功能表項目時呼叫。|
|[CWnd::OnMouseActivate](#onmouseactivate)|當游標處於非使用中視窗，且使用者按下滑鼠按鈕時呼叫。|
|[CWnd::OnMouseHover](#onmousehover)|當游標停留在先前呼叫 [TrackMouseEvent](/windows/win32/api/winuser/nf-winuser-trackmouseevent)所指定的時間期間，將滑鼠游標停留在視窗的工作區上時呼叫。|
|[CWnd::OnMouseHWheel](#onmousehwheel)|當目前的視窗由桌面視窗管理員 (DWM) 組成，且該視窗最大化時呼叫。|
|[CWnd::OnMouseLeave](#onmouseleave)|當游標離開先前呼叫 [TrackMouseEvent](/windows/win32/api/winuser/nf-winuser-trackmouseevent)所指定之視窗的工作區時呼叫。|
|[CWnd::OnMouseMove](#onmousemove)|當滑鼠游標移動時呼叫。|
|[CWnd::OnMouseWheel](#onmousewheel)|當使用者旋轉滑鼠滾輪時呼叫。 使用 Windows NT 4.0 訊息處理。|
|[CWnd::OnMove](#onmove)|在 `CWnd` 的位置變更後呼叫。|
|[CWnd::OnMoving](#onmoving)|指出使用者正在移動 `CWnd` 物件。|
|[CWnd::OnNcActivate](#onncactivate)|當非工作區需要變更以表示作用中或非作用中狀態時呼叫。|
|[CWnd::OnNcCalcSize](#onnccalcsize)|需要計算工作區的大小和位置時呼叫。|
|[CWnd::OnNcCreate](#onnccreate)|在建立非工作區時，于 [>oncreate](#oncreate) 之前呼叫。|
|[CWnd::OnNcDestroy](#onncdestroy)|當非工作區正在損毀時呼叫。|
|[CWnd::OnNcHitTest](#onnchittest)|每次移動滑鼠時，如果 `CWnd` 包含游標，或已使用 `SetCapture` 擷取滑鼠輸入時呼叫。|
|[CWnd::OnNcLButtonDblClk](#onnclbuttondblclk)|當使用者按兩下滑鼠左鍵，而游標位於 `CWnd` 的非工作區內時呼叫。|
|[CWnd::OnNcLButtonDown](#onnclbuttondown)|當使用者按下滑鼠左鍵，而游標位於 `CWnd` 的非工作區內時呼叫。|
|[CWnd::OnNcLButtonUp](#onnclbuttonup)|當使用者放開滑鼠左鍵，而游標位於 `CWnd` 的非工作區內時呼叫。|
|[CWnd::OnNcMButtonDblClk](#onncmbuttondblclk)|當使用者按兩下滑鼠中鍵，而游標位於 `CWnd` 的非工作區內時呼叫。|
|[CWnd::OnNcMButtonDown](#onncmbuttondown)|當使用者按下滑鼠中鍵，而游標位於 `CWnd` 的非工作區內時呼叫。|
|[CWnd::OnNcMButtonUp](#onncmbuttonup)|當使用者放開滑鼠中鍵，而游標位於 `CWnd` 的非工作區內時呼叫。|
|[CWnd::OnNcMouseHover](#onncmousehover)|當游標停留在先前呼叫 [TrackMouseEvent](/windows/win32/api/winuser/nf-winuser-trackmouseevent)所指定的時間期間，將滑鼠游標停留在視窗的非工作區上時呼叫。|
|[CWnd::OnNcMouseLeave](#onncmouseleave)|當資料指標離開先前呼叫 [TrackMouseEvent](/windows/win32/api/winuser/nf-winuser-trackmouseevent)所指定之視窗的非工作區時，架構會呼叫這個成員函式。|
|[CWnd::OnNcMouseMove](#onncmousemove)|當游標在 `CWnd` 的非工作區內移動時呼叫。|
|[CWnd::OnNcPaint](#onncpaint)|當非工作區需要繪製時呼叫。|
|[CWnd::OnNcRButtonDblClk](#onncrbuttondblclk)|當使用者按兩下滑鼠右鍵，而游標位於 `CWnd` 的非工作區內時呼叫。|
|[CWnd::OnNcRButtonDown](#onncrbuttondown)|當使用者按下滑鼠右鍵，而游標位於 `CWnd` 的非工作區內時呼叫。|
|[CWnd::OnNcRButtonUp](#onncrbuttonup)|當使用者放開滑鼠右鍵，而游標位於 `CWnd` 的非工作區內時呼叫。|
|[CWnd::OnNcRenderingChanged](#onncrenderingchanged)|當非工作區的轉譯原則已變更時呼叫。|
|[CWnd::OnNcXButtonDblClk](#onncxbuttondblclk)|當使用者按兩下 XBUTTON1 或 XBUTTON2，而游標位於視窗的非工作區時呼叫。|
|[CWnd::OnNcXButtonDown](#onncxbuttondown)|當使用者按下滑鼠的 XBUTTON1 或 XBUTTON2，而游標位於視窗的非工作區時呼叫。|
|[CWnd::OnNcXButtonUp](#onncxbuttonup)|當使用者放開滑鼠的 XBUTTON1 或 XBUTTON2，而游標位於視窗的非工作區時呼叫。|
|[CWnd::OnNextMenu](#onnextmenu)|當使用向右鍵或向左鍵切換功能表列和系統功能表時呼叫。|
|[CWnd::OnNotify](#onnotify)|由架構呼叫，將其中一個控制項已發生的事件，或控制項需要資訊等狀況通知父視窗。|
|[CWnd::OnNotifyFormat](#onnotifyformat)|呼叫以決定目前視窗的 WM_NOTIFY 通知訊息中是否接受 ANSI 或 Unicode 結構。|
|[CWnd::OnPaint](#onpaint)|呼叫以重新繪製視窗的一部份。|
|[CWnd::OnPaintClipboard](#onpaintclipboard)|當需要重新繪製剪貼簿檢視器的工作區時呼叫。|
|[CWnd::OnPaletteChanged](#onpalettechanged)|呼叫以允許使用調色盤的視窗調整其邏輯色板的大小，並更新其工作區。|
|[CWnd::OnPaletteIsChanging](#onpaletteischanging)|當應用程式即將實現其邏輯色板時通知其他應用程式。|
|[CWnd::OnParentNotify](#onparentnotify)|建立或終結子視窗時，或當使用者按一下滑鼠按鈕，而游標移至子視窗上方時，進行呼叫。|
|[CWnd::OnPowerBroadcast](#onpowerbroadcast)|電源管理事件發生時呼叫。|
|[CWnd::OnQueryDragIcon](#onquerydragicon)|最小化 (圖示化) `CWnd` 即將由使用者拖曳時呼叫。|
|[CWnd::OnQueryEndSession](#onqueryendsession)|當使用者選擇結束 Windows 工作階段時呼叫。|
|[CWnd::OnQueryNewPalette](#onquerynewpalette)|通知 `CWnd` 即將接收輸入焦點。|
|[CWnd::OnQueryOpen](#onqueryopen)|當 `CWnd` 是圖示，且使用者要求開啟圖示時呼叫。|
|[CWnd::OnQueryUIState](#onqueryuistate)|呼叫以擷取視窗的使用者介面 (UI) 狀態。|
|[CWnd::OnRawInput](#onrawinput)|當目前視窗取得原始輸入時呼叫。|
|[CWnd::OnRButtonDblClk](#onrbuttondblclk)|當使用者按兩下滑鼠右鍵時呼叫。|
|[CWnd::OnRButtonDown](#onrbuttondown)|當使用者按下滑鼠右鍵時呼叫。|
|[CWnd::OnRButtonUp](#onrbuttonup)|當使用者放開滑鼠右鍵時呼叫。|
|[CWnd::OnRenderAllFormats](#onrenderallformats)|當擁有者應用程式正在被破壞，而且需要呈現其所有格式時呼叫。|
|[CWnd::OnRenderFormat](#onrenderformat)|需要呈現具有延遲轉譯需求的特定格式時，針對剪貼簿擁有者呼叫。|
|[CWnd::OnSessionChange](#onsessionchange)|呼叫以將工作階段狀態的變更通知應用程式。|
|[CWnd::OnSetCursor](#onsetcursor)|如果不擷取滑鼠輸入，而且滑鼠導致游標在視窗內移動，則呼叫。|
|[CWnd::OnSetFocus](#onsetfocus)|在 `CWnd` 取得輸入焦點後呼叫。|
|[CWnd::OnSettingChange](#onsettingchange)|當 Win32 `SystemParametersInfo` 函式變更整個系統的設定時呼叫。|
|[CWnd::OnShowWindow](#onshowwindow)|當 `CWnd` 要隱藏或顯示時呼叫。|
|[CWnd::OnSize](#onsize)|在 `CWnd` 大小變更後呼叫。|
|[CWnd::OnSizeClipboard](#onsizeclipboard)|當剪貼簿檢視器視窗中的工作區大小變更後呼叫。|
|[CWnd::OnSizing](#onsizing)|表示使用者正在重新調整矩形的大小。|
|[CWnd::OnSpoolerStatus](#onspoolerstatus)|每當加入工作或從列印管理員佇列中移除工作時，從列印管理員呼叫。|
|[CWnd::OnStyleChanged](#onstylechanged)|表示 [SetWindowLong](/windows/win32/api/winuser/nf-winuser-setwindowlongw) Windows 函式已變更一個或多個視窗的樣式。|
|[CWnd::OnStyleChanging](#onstylechanging)|表示 [SetWindowLong](/windows/win32/api/winuser/nf-winuser-setwindowlongw) Windows 函式即將變更一個或多個視窗的樣式。|
|[CWnd::OnSysChar](#onsyschar)|按鍵轉譯為系統字元時呼叫。|
|[CWnd::OnSysColorChange](#onsyscolorchange)|當系統色彩設定中進行變更時，為所有最上層視窗呼叫。|
|[CWnd::OnSysCommand](#onsyscommand)|當使用者從 [控制] 功能表中選取命令時，或在使用者選取 [最大化] 或 [最小化] 按鈕時呼叫。|
|[CWnd::OnSysDeadChar](#onsysdeadchar)|當按鍵轉譯為系統無效字元 (例如強調符號) 時呼叫。|
|[CWnd::OnSysKeyDown](#onsyskeydown)|當使用者按住 ALT 鍵，然後按下另一個按鍵時呼叫。|
|[CWnd::OnSysKeyUp](#onsyskeyup)|當使用者在按住 ALT 鍵時放開按下的按鍵時呼叫。|
|[CWnd::OnTCard](#ontcard)|使用者按一下可設計的按鈕時呼叫。|
|[CWnd::OnTimeChange](#ontimechange)|在系統時間變更後，針對所有最上層視窗呼叫。|
|[CWnd::OnTimer](#ontimer)|在 [SetTimer](#settimer)中指定的每個間隔之後呼叫。|
|[CWnd::OnTouchInput](#ontouchinput)|處理來自 Windows 觸控的單一輸入。|
|[CWnd::OnTouchInputs](#ontouchinputs)|處理來自 Windows 觸控的輸入。|
|[CWnd::OnUniChar](#onunichar)|按下按鍵時呼叫。 亦即，目前視窗具有鍵盤焦點，且[TranslateMessage](/windows/win32/api/winuser/nf-winuser-translatemessage)函式會轉譯[WM_KEYDOWN](/windows/win32/inputdev/wm-keydown)的訊息。|
|[CWnd::OnUnInitMenuPopup](#onuninitmenupopup)|於下拉式功能表或子功能表被終結時呼叫。|
|[CWnd::OnUpdateUIState](#onupdateuistate)|呼叫以變更指定的視窗及其所有子視窗的使用者介面 (UI) 狀態。|
|[CWnd::OnUserChanged](#onuserchanged)|在使用者登入或登出後呼叫。|
|[CWnd::OnVKeyToItem](#onvkeytoitem)|由所擁有的清單方塊呼叫， `CWnd` 以回應 [WM_KEYDOWN](#onkeydown) 的訊息。|
|[CWnd::OnVScroll](#onvscroll)|當使用者按一下視窗的垂直捲軸時呼叫。|
|[CWnd::OnVScrollClipboard](#onvscrollclipboard)|當擁有者應該捲動剪貼簿影像、使適當的區段失效，及更新捲軸值時呼叫。|
|[CWnd::OnWindowPosChanged](#onwindowposchanged)|當大小、位置或迭置順序因呼叫 [SetWindowPos](#setwindowpos) 或另一個視窗管理函式而變更時呼叫。|
|[CWnd::OnWindowPosChanging](#onwindowposchanging)|當大小、位置或迭置順序即將因呼叫 [SetWindowPos](#setwindowpos) 或另一個視窗管理函式而變更時呼叫。|
|[CWnd::OnWinIniChange](#onwininichange)|在 Windows 初始化檔案 (WIN.INI) 變更後，針所有最上層視窗呼叫。|
|[CWnd::OnWndMsg](#onwndmsg)|指出是否已處理視窗訊息。|
|[CWnd::OnXButtonDblClk](#onxbuttondblclk)|當使用者按兩下 XBUTTON1 或 XBUTTON2，而游標位於視窗的工作區時呼叫。|
|[CWnd::OnXButtonDown](#onxbuttondown)|當使用者按下 XBUTTON1 或 XBUTTON2，而游標位於視窗的工作區時呼叫。|
|[CWnd::OnXButtonUp](#onxbuttonup)|當使用者放開 XBUTTON1 或 XBUTTON2，而游標位於視窗的工作區時呼叫。|
|[CWnd::PostNcDestroy](#postncdestroy)|此虛擬函式是在終結視窗之後，由預設 [OnNcDestroy](#onncdestroy) 函式所呼叫。|
|[CWnd::ReflectChildNotify](#reflectchildnotify)|將訊息反映至其來源的 Helper 函式。|
|[CWnd::ReflectLastMsg](#reflectlastmsg)|將最後一個訊息反映到子視窗。|
|[CWnd::ResizeDynamicLayout](#resizedynamiclayout)|如果已啟用視窗的動態配置，則會在視窗大小變更以調整子視窗的版面配置時由架構呼叫。|
|[CWnd::WindowProc](#windowproc)|提供 `CWnd` 的視窗程序。 透過訊息對應的預設分派訊息。|

### <a name="public-operators"></a>公用運算子

|名稱|描述|
|----------|-----------------|
|[HWND CWnd::operator](#operator_hwnd)|呼叫以取得視窗的控制代碼。|
|[CWnd::operator !=](#operator_neq)|判斷視窗是否與 [m_hWnd](#m_hwnd)控制碼的視窗不同。|
|[CWnd：： operator = =](#operator_eq_eq)|判斷視窗是否與 [m_hWnd](#m_hwnd)控制碼的視窗相同。|

### <a name="public-data-members"></a>公用資料成員

|名稱|描述|
|----------|-----------------|
|[CWnd::m_hWnd](#m_hwnd)|指出附加至此的 HWND `CWnd` 。|

## <a name="remarks"></a>備註

`CWnd` 物件不同於 Windows 視窗，但兩者緊密連結。 `CWnd` 物件是由 `CWnd` 建構函式和解構函式所建立或終結。 另一方面，Windows 視窗是由成員函式所建立 `Create` 並由虛擬函式終結的 windows 內部資料結構 `CWnd` 。 [DestroyWindow](#destroywindow)函式會終結 Windows 視窗而不會終結物件。

`CWnd`類別和訊息對應機制會隱藏 `WndProc` 函數。 傳入的 Windows 通知訊息會自動透過訊息對應路由傳送到<em>訊息</em>成員函式**上**的適當訊息 `CWnd` 。 您可以覆寫 **On**<em>訊息</em> 成員函式，以處理衍生類別中成員的特定訊息。

`CWnd` 類別也可讓您建立應用程式的 Windows 子視窗。 自 `CWnd` 衍生類別，然後將成員變數加入至衍生類別以儲存應用程式的特定資料。 實作訊息處理常式成員函式，和衍生類別中對應的訊息，以指定訊息被導向至視窗時會發生什麼事。

您在兩個步驟中建立子視窗。 首先，呼叫此函式 `CWnd` 以建立 `CWnd` 物件，然後呼叫 [create](#create) 成員函式來建立子視窗，並將其附加至 `CWnd` 物件。

當使用者終止子視窗時，摧毀 `CWnd` 物件，或呼叫 `DestroyWindow` 成員函式來移除視窗並摧毀其資料結構。

在 Microsoft Foundation 類別庫中，會自 `CWnd` 衍生進一步類別以提供特定的視窗類型。 其中許多類別（包括 [CFrameWnd](../../mfc/reference/cframewnd-class.md)、 [CMDIFrameWnd](../../mfc/reference/cmdiframewnd-class.md)、 [CMDIChildWnd](../../mfc/reference/cmdichildwnd-class.md)、 [CView](../../mfc/reference/cview-class.md)和 [CDialog](../../mfc/reference/cdialog-class.md)）都是設計來進一步衍生。 衍生自的控制項類別（ `CWnd` 例如 [CButton](../../mfc/reference/cbutton-class.md)）可以直接使用，也可以用來進一步衍生類別。

如需使用的詳細資訊 `CWnd` ，請參閱 [框架視窗](../../mfc/frame-windows.md) 和 [視窗物件](../../mfc/window-objects.md)。

## <a name="inheritance-hierarchy"></a>繼承階層架構

[CObject](../../mfc/reference/cobject-class.md)

[CCmdTarget](../../mfc/reference/ccmdtarget-class.md)

`CWnd`

## <a name="requirements"></a>規格需求

**標題:** afxwin.h

## <a name="cwndaccdodefaultaction"></a><a name="accdodefaultaction"></a> CWnd：： accDoDefaultAction

由架構呼叫以執行物件的預設動作。

```
virtual HRESULT accDoDefaultAction(VARIANT varChild);
```

### <a name="parameters"></a>參數

*varChild*<br/>
指定要叫用的預設動作是物件的或其中一個物件的子專案。 這個參數可以是 CHILDID_SELF (來執行物件的預設動作) 或子識別碼 (，以執行其中一個物件之子項目的預設動作) 。

### <a name="return-value"></a>傳回值

在成功時傳回 S_OK，失敗時傳回 COM 錯誤碼。 請參閱 Windows SDK 中的[IAccessible：： accDoDefaultAction](/windows/win32/api/oleacc/nf-oleacc-iaccessible-accdodefaultaction)傳回**值**。

### <a name="remarks"></a>備註

此函數是 MFC 的 [Active Accessibility](/windows/win32/WinAuto/microsoft-active-accessibility) 支援的一部分。

覆寫衍生類別中的這個函 `CWnd` 式，以執行物件的預設動作。 如需詳細資訊，請參閱 Windows SDK 中的 [IAccessible：： accDoDefaultAction](/windows/win32/api/oleacc/nf-oleacc-iaccessible-accdodefaultaction) 。

## <a name="cwndacchittest"></a><a name="acchittest"></a> CWnd：： accHitTest

由架構呼叫以擷取畫面中給定點的子項目或子物件。

```
virtual HRESULT accHitTest(
    long xLeft,
    long yTop,
    VARIANT* pvarChild);
```

### <a name="parameters"></a>參數

*xLeft*<br/>
要進行點擊測試之點的 X 座標（以螢幕單位)  (）。

*yTop*<br/>
要進行點擊測試之點的 Y 座標（以螢幕單位)  (）。

*pvarChild*<br/>
接收在 *xLeft* 和 *yTop*指定的點識別物件的資訊。 請參閱 Windows SDK 中[IAccessible：： accHitTest](/windows/win32/api/oleacc/nf-oleacc-iaccessible-acchittest)的*pvarID* 。

### <a name="return-value"></a>傳回值

在成功時傳回 S_OK，失敗時傳回 COM 錯誤碼。 請參閱 Windows SDK 中的傳回 **值** `IAccessible::accHitTest` 。

### <a name="remarks"></a>備註

此函數是 MFC 的 [Active Accessibility](/windows/win32/WinAuto/microsoft-active-accessibility) 支援的一部分。

`CWnd`如果您有 nonwindowed 使用者介面專案 (非視窗的 ActiveX 控制項（MFC 會處理) ）以外的專案，請在衍生類別中覆寫此函數。

如需詳細資訊，請參閱 Windows SDK 中的 [IAccessible：： accHitTest](/windows/win32/api/oleacc/nf-oleacc-iaccessible-acchittest) 。

## <a name="cwndacclocation"></a><a name="acclocation"></a> CWnd：： accLocation

由架構呼叫以擷取指定物件目前畫面的位置。

```
virtual HRESULT accLocation(
    long* pxLeft,
    long* pyTop,
    long* pcxWidth,
    long* pcyHeight,
    VARIANT varChild);
```

### <a name="parameters"></a>參數

*pxLeft*<br/>
接收物件左上角的 x 座標， (螢幕單位) 。

*pyTop*<br/>
接收物件左上角的 y 座標， (螢幕單位) 。

*pcxWidth*<br/>
在螢幕單位) 中接收物件 (的寬度。

*pcyHeight*<br/>
以螢幕單位) 接收物件 (的高度。

*varChild*<br/>
指定要抓取的位置是物件的物件或其中一個物件的子項目。 這個參數可以是 CHILDID_SELF (取得物件) 或子識別碼 (的相關資訊，以取得物件的子專案) 的相關資訊。

### <a name="return-value"></a>傳回值

在成功時傳回 S_OK，失敗時傳回 COM 錯誤碼。 請參閱 Windows SDK 中的傳回 **值** `IAccessible::accLocation` 。

### <a name="remarks"></a>備註

`CWnd`如果您有 nonwindowed 使用者介面專案 (非視窗的 ActiveX 控制項（MFC 會處理) ）以外的專案，請在衍生類別中覆寫此函數。

如需詳細資訊，請參閱 `IAccessible::accLocation` Windows SDK 中的。

## <a name="cwndaccnavigate"></a><a name="accnavigate"></a> CWnd：： accNavigate

由架構呼叫以便於周遊容器內的另一使用者介面項目並擷取物件 (如果可能)。

```
virtual HRESULT accNavigate(
    long navDir,
    VARIANT varStart,
    VARIANT* pvarEndUpAt);
```

### <a name="parameters"></a>參數

*navDir*<br/>
指定要導覽的方向。 請參閱 Windows SDK 中[IAccessible：： accNavigate](/windows/win32/api/oleacc/nf-oleacc-iaccessible-accnavigate)的*navDir* 。

*varStart*<br/>
指定起始物件。 請參閱 Windows SDK 中的 *varStart* `IAccessible::accNavigate` 。

*pvarEndUpAt*<br/>
接收目的地使用者介面物件的相關資訊。 請參閱 Windows SDK 中的 *pvarEnd* `IAccessible::accNavigate` 。

### <a name="return-value"></a>傳回值

在成功時傳回 S_OK，失敗時傳回 COM 錯誤碼。 請參閱 Windows SDK 中的傳回 **值** `IAccessible::accNavigate` 。

### <a name="remarks"></a>備註

此函數是 MFC 的 [Active Accessibility](/windows/win32/WinAuto/microsoft-active-accessibility) 支援的一部分。

`CWnd`如果您有 nonwindowed 使用者介面專案 (非視窗的 ActiveX 控制項（MFC 會處理) ）以外的專案，請在衍生類別中覆寫此函數。

如需詳細資訊，請參閱 Windows SDK 中的 [IAccessible：： accNavigate](/windows/win32/api/oleacc/nf-oleacc-iaccessible-accnavigate) 。

## <a name="cwndaccselect"></a><a name="accselect"></a> CWnd：： accSelect

由架構呼叫以修改選取或移動指定物件的鍵盤焦點。

```
virtual HRESULT accSelect(
    long flagsSelect,
    VARIANT varChild);
```

### <a name="parameters"></a>參數

*flagsSelect*<br/>
指定如何變更目前的選取範圍或焦點。 請參閱 Windows SDK 中[IAccessible：： accSelect](/windows/win32/api/oleacc/nf-oleacc-iaccessible-accselect)的*flagsSelect* 。

*varChild*<br/>
指定要選取的物件。 這個參數可以是 CHILDID_SELF (選取物件本身) 或子識別碼 (選取其中一個物件的子系) 。

### <a name="return-value"></a>傳回值

在成功時傳回 S_OK，失敗時傳回 COM 錯誤碼。 請參閱 Windows SDK 中的傳回 **值** `IAccessible::accSelect` 。

### <a name="remarks"></a>備註

此函數是 MFC 的 [Active Accessibility](/windows/win32/WinAuto/microsoft-active-accessibility) 支援的一部分。

`CWnd`如果您有 nonwindowed 使用者介面專案 (非視窗的 ActiveX 控制項（MFC 會處理) ）以外的專案，請在衍生類別中覆寫此函數。

如需詳細資訊，請參閱 Windows SDK 中的 [IAccessible：： accSelect](/windows/win32/api/oleacc/nf-oleacc-iaccessible-accselect) 。

## <a name="cwndanimatewindow"></a><a name="animatewindow"></a> CWnd：： AnimateWindow

顯示或隱藏視窗時產生特殊效果。

```
BOOL AnimateWindow(
    DWORD dwTime,
    DWORD dwFlags);
```

### <a name="parameters"></a>參數

*dwTime*<br/>
指定播放動畫所花的時間（以毫秒為單位）。 通常，動畫會花費200毫秒來播放。

*dwFlags*<br/>
指定動畫的類型。 如需可能值的完整清單，請參閱 [AnimateWindow](/windows/win32/api/winuser/nf-winuser-animatewindow)。

### <a name="return-value"></a>傳回值

如果函式成功則為非零值，否則為 0。

### <a name="remarks"></a>備註

此成員函式會模擬函數 [AnimateWindow](/windows/win32/api/winuser/nf-winuser-animatewindow)的功能，如 Windows SDK 所述。

## <a name="cwndarrangeiconicwindows"></a><a name="arrangeiconicwindows"></a> CWnd：： ArrangeIconicWindows

排列所有最小化 (圖示) 子視窗。

```
UINT ArrangeIconicWindows();
```

### <a name="return-value"></a>傳回值

如果函式成功，則為一列圖示的高度;否則為0。

### <a name="remarks"></a>備註

此成員函式也會在桌面視窗中排列圖示，這些圖示涵蓋整個畫面。 [GetDesktopWindow](#getdesktopwindow)成員函式會抓取桌面視窗物件的指標。

若要在 MDI 用戶端視窗中排列 iconic MDI 子視窗，請呼叫 [CMDIFrameWnd：： MDIIconArrange](../../mfc/reference/cmdiframewnd-class.md#mdiiconarrange)。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#66](../../mfc/reference/codesnippet/cpp/cwnd-class_1.cpp)]

## <a name="cwndattach"></a><a name="attach"></a> CWnd：： Attach

將 Windows 視窗附加至 `CWnd` 物件。

```
BOOL Attach(HWND hWndNew);
```

### <a name="parameters"></a>參數

*hWndNew*<br/>
指定 Windows 視窗的控制碼。

### <a name="return-value"></a>傳回值

如果成功則為非零；否則為 0。

### <a name="example"></a>範例

這個範例示範如何使用附加和卸離來對應至 MDI 用戶端視窗。

[!code-cpp[NVC_MFCWindowing#67](../../mfc/reference/codesnippet/cpp/cwnd-class_2.h)]

[!code-cpp[NVC_MFCWindowing#68](../../mfc/reference/codesnippet/cpp/cwnd-class_3.cpp)]

[!code-cpp[NVC_MFCWindowing#69](../../mfc/reference/codesnippet/cpp/cwnd-class_4.cpp)]

## <a name="cwndbeginmodalstate"></a><a name="beginmodalstate"></a> CWnd：： BeginModalState

呼叫此成員函式以製作框架視窗強制回應。

```
virtual void BeginModalState();
```

## <a name="cwndbeginpaint"></a><a name="beginpaint"></a> CWnd：： BeginPaint

準備 `CWnd` 使用繪製的相關資訊來繪製和填滿 `PAINTSTRUCT` 資料結構。

```
CDC* BeginPaint(LPPAINTSTRUCT lpPaint);
```

### <a name="parameters"></a>參數

*lpPaint*<br/>
指向要接收繪製資訊的 [PAINTSTRUCT](/windows/win32/api/winuser/ns-winuser-paintstruct) 結構。

### <a name="return-value"></a>傳回值

識別的裝置內容 `CWnd` 。 指標可能是暫時性的，不應儲存在 [EndPaint](#endpaint)範圍之外。

### <a name="remarks"></a>備註

繪圖結構所包含的 RECT 資料結構具有最小的矩形，可完全括住更新區域，以及指定是否已清除背景的旗標。

更新區域是由 [無效](#invalidate)、 [InvalidateRect](#invalidaterect)或 [InvalidateRgn](#invalidatergn) 成員函式及系統在其大小、移動、建立、滾動或執行任何其他會影響工作區的作業所設定。 如果更新區域標記為要清除，則會傳送 `BeginPaint` [WM_ONERASEBKGND](#onerasebkgnd) 訊息。

`BeginPaint`除非回應[WM_PAINT](#onpaint)訊息，否則請勿呼叫成員函式。 成員函式的每個呼叫都 `BeginPaint` 必須有相符的 [EndPaint](#endpaint) 成員函式呼叫。 如果插入點位於要繪製的區域中，則成員函式 `BeginPaint` 會自動隱藏插入號，以防止其被清除。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#70](../../mfc/reference/codesnippet/cpp/cwnd-class_5.cpp)]

## <a name="cwndbinddefaultproperty"></a><a name="binddefaultproperty"></a> CWnd：： BindDefaultProperty

將呼叫物件的預設簡單系結屬性 (例如，在類型程式庫中標示的編輯控制項) 系結至資料來源控制項之 DataSource、使用者名稱、密碼和 SQL 屬性所定義的基礎資料指標。

```cpp
void BindDefaultProperty(
    DISPID dwDispID,
    VARTYPE vtProp,
    LPCTSTR szFieldName,
    CWnd* pDSCWnd);
```

### <a name="parameters"></a>參數

*dwDispID*<br/>
在要系結至資料來源控制項的資料繫結控制項上，指定屬性的 DISPID。

*vtProp*<br/>
指定要系結的屬性類型，例如 VT_BSTR、VT_VARIANT 等等。

*szFieldName*<br/>
指定資料來源控制項所提供資料行的資料行名稱，此資料行是由屬性所系結。

*pDSCWnd*<br/>
指向裝載屬性將系結之資料來源控制項的視窗。 `GetDlgItem`使用 dc 主機視窗的資源識別碼來呼叫，以取得此指標。

### <a name="remarks"></a>備註

`CWnd`您呼叫此函式的物件必須是資料繫結控制項。

### <a name="example"></a>範例

`BindDefaultProperty` 可能用於下列內容：

[!code-cpp[NVC_MFC_AxDataBinding#2](../../mfc/reference/codesnippet/cpp/cwnd-class_7.cpp)]

## <a name="cwndbindproperty"></a><a name="bindproperty"></a> CWnd：： BindProperty

系結資料繫結控制項上的游標系結屬性 (例如，方格控制項) 至資料來源控制項，以及註冊與 MFC 系結管理員的關聯性。

```cpp
void BindProperty(
    DISPID dwDispId,
    CWnd* pWndDSC);
```

### <a name="parameters"></a>參數

*dwDispId*<br/>
在要系結至資料來源控制項的資料繫結控制項上，指定屬性的 DISPID。

*pWndDSC*<br/>
指向裝載屬性將系結之資料來源控制項的視窗。 `GetDlgItem`使用 dc 主機視窗的資源識別碼來呼叫，以取得此指標。

### <a name="remarks"></a>備註

`CWnd`您呼叫此函式的物件必須是資料繫結控制項。

### <a name="example"></a>範例

`BindProperty` 可能用於下列內容：

[!code-cpp[NVC_MFC_AxDataBinding#4](../../mfc/reference/codesnippet/cpp/cwnd-class_9.cpp)]

## <a name="cwndbringwindowtotop"></a><a name="bringwindowtotop"></a> CWnd：： BringWindowToTop

將 `CWnd` 帶到重疊視窗堆疊的最上層。

```cpp
void BringWindowToTop();
```

### <a name="remarks"></a>備註

此外，`BringWindowToTop` 會啟用快顯、最上層和 MDI 子視窗。 需使用 `BringWindowToTop` 成員函式，才能顯示出重疊視窗部分或完全遮住的視窗。

這個函式只會呼叫 Win32 [BringWindowToTop](/windows/win32/api/winuser/nf-winuser-bringwindowtotop) 函數。 呼叫 [SetWindowPos](#setwindowpos) 函式，以依迭置順序變更視窗的位置。 `BringWindowToTop` 函式不會將視窗樣式變更為最上層視窗。 如需詳細資訊，請參閱 [HWND_TOP 和 HWND_TOPMOST 之間的差異](https://devblogs.microsoft.com/oldnewthing/?p=33263)

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#71](../../mfc/reference/codesnippet/cpp/cwnd-class_10.cpp)]

## <a name="cwndcalcwindowrect"></a><a name="calcwindowrect"></a> CWnd：： CalcWindowRect

計算可以包含指定用戶端矩形的視窗矩形。

```
virtual void CalcWindowRect(
    LPRECT lpClientRect,
    UINT nAdjustType = adjustBorder);
```

### <a name="parameters"></a>參數

*lpClientRect*<br/>
[in，out]矩形結構的指標。 在輸入時，此結構包含用戶端矩形。 在方法完成之後，這個結構會包含可包含指定之用戶端矩形的視窗矩形。

*nAdjustType*<br/>
在用 `CWnd::adjustBorder` 來計算沒有 WS_EX_CLIENTEDGE 樣式的視窗座標; 否則，請使用 `CWnd::adjustOutside` 。

### <a name="remarks"></a>備註

計算視窗矩形的大小不包含功能表列的空間。

如需更多使用限制，請參閱 [AdjustWindowRectEx](/windows/win32/api/winuser/nf-winuser-adjustwindowrectex)。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#72](../../mfc/reference/codesnippet/cpp/cwnd-class_11.cpp)]

## <a name="cwndcanceltooltips"></a><a name="canceltooltips"></a> CWnd：： CancelToolTips

如果目前顯示工具提示，請呼叫此成員函式，以從螢幕中移除工具提示。

```
static void PASCAL CancelToolTips(BOOL bKeys = FALSE);
```

### <a name="parameters"></a>參數

*bKeys*<br/>
TRUE 表示在按下按鍵時取消工具提示，並將狀態列文字設定為預設值;否則為 FALSE。

### <a name="remarks"></a>備註

> [!NOTE]
> 使用這個成員函式不會影響您的程式碼所管理的工具提示。 它只會影響 [CWnd：： EnableToolTips](#enabletooltips)所管理的工具提示控制項。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#73](../../mfc/reference/codesnippet/cpp/cwnd-class_12.cpp)]

## <a name="cwndcenterwindow"></a><a name="centerwindow"></a> CWnd：： CenterWindow

將相對於其父系的視窗置中。

```cpp
void CenterWindow(CWnd* pAlternateOwner = NULL);
```

### <a name="parameters"></a>參數

*pAlternateOwner*<br/>
相對於父視窗) 之相對於其中央 (的替代視窗的指標。

### <a name="remarks"></a>備註

通常會從 [CDialog：： OnInitDialog](../../mfc/reference/cdialog-class.md#oninitdialog) 呼叫至相對於應用程式主視窗的中央對話方塊。 根據預設，函式會將相對於其父視窗的子視窗與其擁有者相對的快顯視窗置中。 如果未擁有快顯視窗，它會相對於螢幕的中央。 若要將相對於不是擁有者或父系之特定視窗的視窗置中， *pAlternateOwner* 參數可以設定為有效的視窗。 若要強制將相對於畫面的置中，請傳遞 [CWnd：： GetDesktopWindow](#getdesktopwindow) 傳回的值做為 *pAlternateOwner*。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#74](../../mfc/reference/codesnippet/cpp/cwnd-class_13.cpp)]

## <a name="cwndchangeclipboardchain"></a><a name="changeclipboardchain"></a> CWnd：： ChangeClipboardChain

從剪貼簿檢視器的鏈中移除 `CWnd` ，並藉由 *hWndNext* 鏈中上階的子系，讓指定的視窗 `CWnd` 。

```
BOOL ChangeClipboardChain(HWND hWndNext);
```

### <a name="parameters"></a>參數

*hWndNext*<br/>
識別 `CWnd` 剪貼簿-檢視器鏈中接下來的視窗。

### <a name="return-value"></a>傳回值

如果成功則為非零；否則為 0。

## <a name="cwndcheckdlgbutton"></a><a name="checkdlgbutton"></a> CWnd：： CheckDlgButton

選取 (在) 旁放置核取記號，或清除 (會從按鈕) 移除核取記號，或是變更三個狀態按鈕的狀態。

```cpp
void CheckDlgButton(
    int nIDButton,
    UINT nCheck);
```

### <a name="parameters"></a>參數

*nIDButton*<br/>
指定要修改的按鈕。

*n*<br/>
指定要採取的動作。 如果 *n* 為非零值，則成員函式會在 `CheckDlgButton` 按鈕旁放置核取記號; 如果為0，則會移除核取記號。 針對三狀態按鈕，如果 *n* 為2，則按鈕狀態為 [不定]。

### <a name="remarks"></a>備註

`CheckDlgButton`函數會將[BM_SETCHECK](/windows/win32/Controls/bm-setcheck)訊息傳送至指定的按鈕。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#75](../../mfc/reference/codesnippet/cpp/cwnd-class_14.cpp)]

## <a name="cwndcheckradiobutton"></a><a name="checkradiobutton"></a> CWnd：： CheckRadioButton

選取 (加入核取記號，) 群組中的指定選項按鈕，並清除 () 從群組中的所有其他選項按鈕移除核取記號。

```cpp
void CheckRadioButton(
    int nIDFirstButton,
    int nIDLastButton,
    int nIDCheckButton);
```

### <a name="parameters"></a>參數

*nIDFirstButton*<br/>
指定群組中第一個選項按鈕的整數識別碼。

*nIDLastButton*<br/>
指定群組中最後一個選項按鈕的整數識別碼。

*nIDCheckButton*<br/>
指定要檢查之選項按鈕的整數識別碼。

### <a name="remarks"></a>備註

`CheckRadioButton`函數會將[BM_SETCHECK](/windows/win32/Controls/bm-setcheck)訊息傳送至指定的選項按鈕。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#76](../../mfc/reference/codesnippet/cpp/cwnd-class_15.cpp)]

## <a name="cwndchildwindowfrompoint"></a><a name="childwindowfrompoint"></a> CWnd：： ChildWindowFromPoint

判斷屬於的子視窗（如果有的話） `CWnd` 包含指定的點（如果有的話）。

```
CWnd* ChildWindowFromPoint(POINT point) const;

CWnd* ChildWindowFromPoint(
    POINT point,
    UINT nFlags) const;
```

### <a name="parameters"></a>參數

*點*<br/>
指定要測試之點的用戶端座標。

*nflags*<br/>
指定要略過的子視窗。 這個參數可以是下列值的組合：

|值|意義|
|-----------|-------------|
|CWP_ALL|不要略過任何子視窗|
|CWP_SKIPINVISIBLE|略過隱藏的子視窗|
|CWP_SKIPDISABLED|略過停用的子視窗|
|CWP_SKIPTRANSPARENT|略過透明子視窗|

### <a name="return-value"></a>傳回值

識別包含點的子視窗。 如果指定的點位於工作區之外，則為 Null。 如果此點位於用戶端區域內，但未包含在任何子視窗內， `CWnd` 則會傳回。

這個成員函式會傳回隱藏或停用的子視窗，其中包含指定的點。

一個以上的視窗可能包含指定的點。 不過，此函式只 `CWnd` 會傳回包含點之第一個視窗的 *。

`CWnd`傳回的 * 可能是暫時性的，不應儲存供稍後使用。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#77](../../mfc/reference/codesnippet/cpp/cwnd-class_16.cpp)]

## <a name="cwndclienttoscreen"></a><a name="clienttoscreen"></a> CWnd：： ClientToScreen

將畫面上指定的點或矩形的用戶端座標，轉換為螢幕座標。

```cpp
void ClientToScreen(LPPOINT lpPoint) const;  void ClientToScreen(LPRECT lpRect) const;
```

### <a name="parameters"></a>參數

*lpPoint*<br/>
指向[POINT structure](/windows/win32/api/windef/ns-windef-point) `CPoint` 包含要轉換之用戶端座標的點結構或物件。

*lpRect*<br/>
指向[RECT structure](/windows/win32/api/windef/ns-windef-rect) `CRect` 包含要轉換之用戶端座標的 RECT 結構或物件。

### <a name="remarks"></a>備註

成員函式 `ClientToScreen` 會使用或結構中的用戶端座標 `POINT` `RECT` 或 `CPoint` `CRect` *lpPoint* 或 *lpRect* 所指向的或物件來計算新的螢幕座標，然後將結構中的座標取代為新的座標。 新的螢幕座標相對於系統顯示的左上角。

成員函式 `ClientToScreen` 會假設指定的點或矩形是在用戶端座標中。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#78](../../mfc/reference/codesnippet/cpp/cwnd-class_17.cpp)]

## <a name="cwndclosewindow"></a><a name="closewindow"></a> CWnd：： Closewindowsg

將視窗最小化。

```cpp
void CloseWindow();
```

### <a name="remarks"></a>備註

此成員函式會模擬函數 [closewindowsg](/windows/win32/api/winuser/nf-winuser-closewindow)的功能，如 Windows SDK 所述。

## <a name="cwndcontinuemodal"></a><a name="continuemodal"></a> CWnd：： ContinueModal

[RunModalLoop](#runmodalloop)會呼叫這個成員函式，以判斷何時應結束強制回應狀態。

```
virtual BOOL ContinueModal();
```

### <a name="return-value"></a>傳回值

如果強制回應迴圈繼續，則為非零;當呼叫 [EndModalLoop](#endmodalloop) 時，則為0。

### <a name="remarks"></a>備註

依預設，它會在呼叫之前傳回非零 `EndModalLoop` 。

## <a name="cwndcreate"></a><a name="create"></a> CWnd：： Create

建立指定的子視窗，並將它附加至 [CWnd](../../mfc/reference/cwnd-class.md) 物件。

```
virtual BOOL Create(
    LPCTSTR lpszClassName,
    LPCTSTR lpszWindowName,
    DWORD dwStyle,
    Const RECT& rect,
    CWnd* pParentWnd,
    UINT nID,
    CCreateContext* pContext = NULL);
```

### <a name="parameters"></a>參數

*lpszClassName*<br/>
在以 null 結束的字串指標，其中包含已註冊系統視窗類別的名稱;或預先定義之系統視窗類別的名稱。

*lpszWindowName*<br/>
在以 null 結束的字串指標，其中包含視窗顯示名稱;否則為 Null，表示沒有視窗顯示名稱。

*dwStyle*<br/>
在位組合 (或 [視窗樣式](styles-used-by-mfc.md#window-styles)) 。 WS_POPUP 選項不是有效的樣式。

*矩形*<br/>
在視窗的大小和位置，相對於父視窗的左上角。

*pParentWnd*<br/>
在父視窗的指標。

*nID*<br/>
在視窗的識別碼。

*pContext*<br/>
在 [CCreateCoNtext](../../mfc/reference/ccreatecontext-structure.md) 結構的指標，用於自訂應用程式的檔視圖架構。

### <a name="return-value"></a>傳回值

如果方法成功，則為 TRUE;否則為 FALSE。

### <a name="remarks"></a>備註

> [!WARNING]
> `CWnd::PreCreateWindow``CREATESTRUCT` **`this`** 如果功能表是 Null，且樣式包含 WS_CHILD，現在會將其參數的 hMenu 成員指派給指標。 如需適當的功能，請確定您的對話方塊控制項具有非 Null 的識別碼。
>
> 這項變更會修正 managed/原生 interop 案例中的損毀。 中的追蹤語句會 `CWnd::Create` 警示開發人員有問題。

使用 [AfxRegisterWndClass](../../mfc/reference/application-information-and-management.md#afxregisterwndclass) 函式來註冊視窗類別。 使用者定義視窗類別可在已註冊的模組中使用。

在方法傳回之前，以及在視窗變成可見之前，會呼叫 [CWnd：： >oncreate](#oncreate) 方法 `Create` 。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#79](../../mfc/reference/codesnippet/cpp/cwnd-class_18.cpp)]

## <a name="cwndcreateaccessibleproxy"></a><a name="createaccessibleproxy"></a> CWnd：： CreateAccessibleProxy

建立指定物件的 Active Accessibility Proxy。

```
virtual HRESULT CreateAccessibleProxy(
    WPARAM wParam,
    LPARAM lParam,
    LRESULT* pResult);
```

### <a name="parameters"></a>參數

*wParam*<br/>
識別 Active Accessibility proxy 所存取的物件。 可以是下列其中一個值

|值|意義|
|-----------|-------------|
|OBJID_CLIENT|參考視窗的工作區。|

*lParam*<br/>
提供其他訊息相關資訊。

*pResult*<br/>
儲存結果碼之 LRESULT 的指標。

### <a name="remarks"></a>備註

建立指定物件的 Active Accessibility Proxy。

## <a name="cwndcreatecaret"></a><a name="createcaret"></a> CWnd：： CreateCaret

為系統插入號建立新的圖形，並宣告插入號的擁有權。

```cpp
void CreateCaret(CBitmap* pBitmap);
```

### <a name="parameters"></a>參數

*pBitmap*<br/>
識別定義插入號圖形的點陣圖。

### <a name="remarks"></a>備註

點陣圖必須先前是由 [CBitmap：： CreateBitmap](../../mfc/reference/cbitmap-class.md#createbitmap) 成員函式、 [CreateDIBitmap](/windows/win32/api/wingdi/nf-wingdi-createdibitmap) Windows 函數或 [CBitmap：： LoadBitmap](../../mfc/reference/cbitmap-class.md#loadbitmap) 成員函式所建立。

`CreateCaret` 自動終結先前的插入號圖形（如果有的話），而不論哪個視窗擁有插入號。 一旦建立之後，插入號一開始就會隱藏。 若要顯示插入號，必須呼叫 [ShowCaret](#showcaret) 成員函式。

系統插入號是共用的資源。 `CWnd` 只有在具有輸入焦點或作用中時，才應該建立插入號。 它應該會在遺失輸入焦點或變成非使用中時，終結插入號。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#80](../../mfc/reference/codesnippet/cpp/cwnd-class_19.cpp)]

## <a name="cwndcreatecontrol"></a><a name="createcontrol"></a> CWnd：： CreateControl

您可以使用這個成員函式，建立將由物件在 MFC 程式中表示的 ActiveX 控制項 `CWnd` 。

```
BOOL CreateControl(
    LPCTSTR pszClass,
    LPCTSTR pszWindowName,
    DWORD dwStyle,
    const RECT& rect,
    CWnd* pParentWnd,
    UINT nID,
    CFile* pPersist = NULL,
    BOOL bStorage = FALSE,
    BSTR bstrLicKey = NULL);

BOOL CreateControl(
    REFCLSID clsid,
    LPCTSTR pszWindowName,
    DWORD dwStyle,
    const RECT& rect,
    CWnd* pParentWnd,
    UINT nID,
    CFile* pPersist = NULL,
    BOOL bStorage = FALSE,
    BSTR bstrLicKey = NULL);

BOOL CreateControl(
    REFCLSID clsid,
    LPCTSTR pszWindowName,
    DWORD dwStyle,
    const POINT* ppt,
    const SIZE* psize,
    CWnd* pParentWnd,
    UINT nID,
    CFile* pPersist = NULL,
    BOOL bStorage = FALSE,
    BSTR bstrLicKey = NULL);
```

### <a name="parameters"></a>參數

*pszClass*<br/>
此字串可能包含類別的 OLE "short name" (ProgID) ，例如 "CIRC3"。Circ3Ctrl。 1 "。 名稱必須符合控制項所註冊的相同名稱。 或者，字串可能會包含包含在大括弧中之 CLSID 的字串格式，例如 "{9DBAFCCF-592F-101B-85CE-00608CEC297B}"。 在任一種情況下，都會 `CreateControl` 將字串轉換為對應的類別識別碼。

*pszWindowName*<br/>
要在控制項中顯示的文字指標。 如果有任何) ，則設定控制項標題或文字屬性的值 (。 如果是 Null，則不會變更控制項的標題或文字屬性。

*dwStyle*<br/>
視窗樣式。 可用的樣式會列在 [備註] 之下。

*矩形*<br/>
指定控制項的大小和位置。 它可以是 [CRect](../../atl-mfc-shared/reference/crect-class.md) 物件或 [RECT 結構](/windows/win32/api/windef/ns-windef-rect)。

*Ppt*<br/>
指向包含控制項左上角的 [點結構](/windows/win32/api/windef/ns-windef-point) 或 `CPoint` 物件。

*pSize*<br/>
指向包含控制項大小的 [大小](/windows/win32/api/windef/ns-windef-size) 結構或 `CSize` 物件

*pParentWnd*<br/>
指定控制項的父視窗。 它不得為 NULL。

*nID*<br/>
指定控制項的識別碼。

*pPersist*<br/>
[CFile](../../mfc/reference/cfile-class.md)的指標，其中包含控制項的持續性狀態。 預設值為 Null，表示控制項會自行初始化，而不會從任何持續性儲存體還原其狀態。 如果不是 Null，它應該是衍生物件的指標， `CFile` 其中包含控制項的持續性資料（以資料流程或儲存體的形式）。 這項資料可能已儲存在先前的用戶端啟用中。 `CFile`可以包含其他資料，但是在呼叫時，其讀寫指標必須設定為持續性資料的第一個位元組 `CreateControl` 。

*bStorage*<br/>
指出 *pPersist* 中的資料是否應解讀為 IStorage 或 IStream 資料。 如果 *pPersist* 中的資料是儲存體， *BSTORAGE* 應該是 TRUE。 如果 *pPersist* 中的資料是資料流程， *BSTORAGE* 應為 FALSE。 預設值為 FALSE。

*bstrLicKey*<br/>
選用的授權金鑰資料。 只有在建立需要執行時間授權金鑰的控制項時，才需要此資料。 如果控制項支援授權，您就必須提供授權金鑰，才能成功建立控制項。 預設值是 NULL。

*Clsid*<br/>
控制項的唯一類別 ID。

### <a name="return-value"></a>傳回值

如果成功則為非零；否則為 0。

### <a name="remarks"></a>備註

`CreateControl` 是 [CWnd：： Create](#create) 函數的直接類比，它會建立的視窗 `CWnd` 。 `CreateControl` 建立 ActiveX 控制項，而不是一般視窗。

僅支援 Windows *dwStyle* 旗標的子集 `CreateControl` ：

- WS_VISIBLE 建立一開始可見的視窗。 如果您想要立即顯示控制項（例如一般視窗），則為必要。

- WS_DISABLED 會建立一開始停用的視窗。 停用的視窗無法接收來自使用者的輸入。 如果控制項有啟用的屬性，則可設定。

- WS_BORDER 建立包含細線條框線的視窗。 如果控制項有 BorderStyle 屬性，可以設定。

- WS_GROUP 指定控制項群組的第一個控制項。 使用者可以使用方向索引鍵，將鍵盤焦點從群組中的某個控制項變更為下一個控制項。 在第一個控制項屬於相同群組之後，以 WS_GROUP 樣式定義的所有控制項。 具有 WS_GROUP 樣式的下一個控制項會結束群組，並啟動下一個群組。

- WS_TABSTOP 指定當使用者按下 TAB 鍵時，可接收鍵盤焦點的控制項。 按下 TAB 鍵會將鍵盤焦點變更為 WS_TABSTOP 樣式的下一個控制項。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#81](../../mfc/reference/codesnippet/cpp/cwnd-class_20.h)]

## <a name="cwndcreateex"></a><a name="createex"></a> CWnd：： CreateEx

建立指定的視窗，並將其附加至 `CWnd` 物件。

```
virtual BOOL CreateEx(
    DWORD dwExStyle,
    LPCTSTR lpszClassName,
    LPCTSTR lpszWindowName,
    DWORD dwStyle,
    int x,
    int y,
    int nWidth,
    int nHeight,
    HWND hWndParent,
    HMENU nIDorHMenu,
    LPVOID lpParam = NULL);

virtual BOOL CreateEx(
    DWORD dwExStyle,
    LPCTSTR lpszClassName,
    LPCTSTR lpszWindowName,
    DWORD dwStyle,
    const RECT& rect,
    CWnd* pParentWnd,
    UINT nID,
    LPVOID lpParam = NULL);
```

### <a name="parameters"></a>參數

*dwExStyle*<br/>
[擴充視窗樣式](../../mfc/reference/styles-used-by-mfc.md#extended-window-styles)的位元組合 (或) ;否則為預設擴充視窗樣式的 Null。

*lpszClassName*<br/>
以 null 結束的字串指標，其中包含已註冊系統視窗類別的名稱;或預先定義之系統視窗類別的名稱。

*lpszWindowName*<br/>
以 null 結束的字串指標，其中包含視窗顯示名稱;否則為 Null，表示沒有視窗顯示名稱。

*dwStyle*<br/>
位組合 (或 [視窗樣式](styles-used-by-mfc.md#window-styles)的) ;否則為預設視窗樣式的 Null。

*x*<br/>
視窗左邊的初始水準距離，或父視窗。

*y*<br/>
視窗頂端或父視窗的初始垂直距離。

*nWidth*<br/>
視窗的寬度（以圖元為單位）。

*nHeight*<br/>
視窗的高度（以圖元為單位）。

*hwndParent*<br/>
如果是子視窗，則為父視窗的控制碼;否則，如果視窗有擁有者，則為擁有者視窗的控制碼。

*nIDorHMenu*<br/>
子視窗的視窗識別碼;否則為視窗的功能表識別碼。

*lpParam*<br/>
傳遞給*lpCreateParams*欄位中[CWnd：： >oncreate](#oncreate)方法之使用者資料的指標。

*矩形*<br/>
相對於螢幕或父視窗的視窗大小和位置。

*pParentWnd*<br/>
如果是子視窗，則為父視窗的指標;否則，如果視窗有擁有者，則為擁有者視窗的指標。

*nID*<br/>
子視窗的視窗識別碼;否則為視窗的功能表識別碼。

### <a name="return-value"></a>傳回值

如果方法成功，則為 TRUE;否則為 FALSE。

### <a name="remarks"></a>備註

> [!WARNING]
> `CWnd::PreCreateWindow``CREATESTRUCT` **`this`** 如果功能表是 Null，且樣式包含 WS_CHILD，現在會將其參數的 hMenu 成員指派給指標。 如需適當的功能，請確定您的對話方塊控制項具有非 Null 的識別碼。
>
> 這項變更會修正 managed/原生 interop 案例中的損毀。 `TRACE`中的語句會 `CWnd::Create` 提醒開發人員有問題。

預設的擴充視窗樣式是 WS_EX_LEFT。 預設視窗樣式是 WS_OVERLAPPED。

使用 [AfxRegisterWndClass](../../mfc/reference/application-information-and-management.md#afxregisterwndclass) 函式來註冊視窗類別。 使用者定義視窗類別可在已註冊的模組中使用。

子視窗的維度相對於父視窗的工作區左上角。 最上層視窗的維度相對於螢幕左上角。

在方法傳回之前，以及在視窗變成可見之前，會呼叫 [CWnd：： >oncreate](#oncreate) 方法 `CreateEx` 。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#82](../../mfc/reference/codesnippet/cpp/cwnd-class_21.cpp)]

## <a name="cwndcreategraycaret"></a><a name="creategraycaret"></a> CWnd：： CreateGrayCaret

為系統插入號和插入號的宣告擁有權建立灰色矩形。

```cpp
void CreateGrayCaret(
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>參數

*nWidth*<br/>
以邏輯單元) 指定插入號 (的寬度。 如果此參數為0，則寬度會設定為系統定義的視窗框線寬度。

*nHeight*<br/>
以邏輯單元) 指定插入號 (的高度。 如果此參數為0，則高度會設定為系統定義的視窗框線高度。

### <a name="remarks"></a>備註

插入號圖形可以是線條或區塊。

參數 *nWidth* 和 *nHeight* 會以邏輯單元指定插入號的寬度和高度 () ;確切的寬度和高度 (（以圖元為單位）) 取決於對應模式。

[GetSystemMetrics](/windows/win32/api/winuser/nf-winuser-getsystemmetrics) Windows 函式可以取出系統的視窗框線寬度或高度，SM_CXBORDER 和 SM_CYBORDER 索引。 使用視窗框線寬度或高度，可確保在高解析度顯示畫面上會顯示插入號。

成員函式 `CreateGrayCaret` 會自動終結先前的插入號圖形（如果有的話），而不論哪個視窗擁有插入號。 一旦建立之後，插入號一開始就會隱藏。 若要顯示插入號，必須呼叫 [ShowCaret](#showcaret) 成員函式。

系統插入號是共用的資源。 `CWnd` 只有在具有輸入焦點或作用中時，才應該建立插入號。 它應該會在遺失輸入焦點或變成非使用中時，終結插入號。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#83](../../mfc/reference/codesnippet/cpp/cwnd-class_22.cpp)]

## <a name="cwndcreatesolidcaret"></a><a name="createsolidcaret"></a> CWnd：： CreateSolidCaret

針對系統插入號和插入號的宣告擁有權建立實心矩形。

```cpp
void CreateSolidCaret(
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>參數

*nWidth*<br/>
以邏輯單元) 指定插入號 (的寬度。 如果此參數為0，則寬度會設定為系統定義的視窗框線寬度。

*nHeight*<br/>
以邏輯單元) 指定插入號 (的高度。 如果此參數為0，則高度會設定為系統定義的視窗框線高度。

### <a name="remarks"></a>備註

插入號圖形可以是線條或區塊。

參數 *nWidth* 和 *nHeight* 會以邏輯單元指定插入號的寬度和高度 () ;確切的寬度和高度 (（以圖元為單位）) 取決於對應模式。

[GetSystemMetrics](/windows/win32/api/winuser/nf-winuser-getsystemmetrics) Windows 函式可以取出系統的視窗框線寬度或高度，SM_CXBORDER 和 SM_CYBORDER 索引。 使用視窗框線寬度或高度，可確保在高解析度顯示畫面上會顯示插入號。

成員函式 `CreateSolidCaret` 會自動終結先前的插入號圖形（如果有的話），而不論哪個視窗擁有插入號。 一旦建立之後，插入號一開始就會隱藏。 若要顯示插入號，必須呼叫 [ShowCaret](#showcaret) 成員函式。

系統插入號是共用的資源。 `CWnd` 只有在具有輸入焦點或作用中時，才應該建立插入號。 它應該會在遺失輸入焦點或變成非使用中時，終結插入號。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#84](../../mfc/reference/codesnippet/cpp/cwnd-class_23.cpp)]

## <a name="cwndcwnd"></a><a name="cwnd"></a> CWnd：： CWnd

建構 `CWnd` 物件。

```
CWnd();
```

### <a name="remarks"></a>備註

在呼叫 [CreateEx](#createex) 或 [Create](#create) 成員函式之前，不會建立和附加 Windows 視窗。

## <a name="cwnddefault"></a><a name="default"></a> CWnd：:D efault

呼叫預設視窗程式。

```
LRESULT Default();
```

### <a name="return-value"></a>傳回值

視傳送的訊息而定。

### <a name="remarks"></a>備註

預設視窗程式會為應用程式未處理的任何視窗訊息提供預設處理。 這個成員函式可確保處理每個訊息。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#85](../../mfc/reference/codesnippet/cpp/cwnd-class_24.cpp)]

## <a name="cwnddefwindowproc"></a><a name="defwindowproc"></a> CWnd：:D efWindowProc

呼叫預設視窗程式，此程式會為應用程式未處理的任何視窗訊息提供預設處理。

```
virtual LRESULT DefWindowProc(
    UINT message,
    WPARAM wParam,
    LPARAM lParam);
```

### <a name="parameters"></a>參數

*message*<br/>
指定要處理的 Windows 訊息。

*wParam*<br/>
指定其他訊息相關資訊。

*lParam*<br/>
指定其他訊息相關資訊。

### <a name="return-value"></a>傳回值

視傳送的訊息而定。

### <a name="remarks"></a>備註

這個成員函式可確保處理每個訊息。 它應該使用與視窗程式所收到的參數相同的參數來呼叫。

## <a name="cwnddeletetempmap"></a><a name="deletetempmap"></a> CWnd：:D eleteTempMap

由物件的閒置時間處理常式自動呼叫 `CWinApp` 。

```
static void PASCAL DeleteTempMap();
```

### <a name="remarks"></a>備註

刪除成員函式所建立的任何暫存 `CWnd` 物件 `FromHandle` 。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#86](../../mfc/reference/codesnippet/cpp/cwnd-class_25.cpp)]

## <a name="cwnddestroywindow"></a><a name="destroywindow"></a> CWnd：:D estroyWindow

終結附加至物件的 Windows 視窗 `CWnd` 。

```
virtual BOOL DestroyWindow();
```

### <a name="return-value"></a>傳回值

如果視窗已損毀，則為非零;否則為0。

### <a name="remarks"></a>備註

成員函式 `DestroyWindow` 會將適當的訊息傳送至視窗，以將它停用並移除輸入焦點。 它也會終結視窗的功能表、清除應用程式佇列、終結未處理的計時器、移除剪貼簿擁有權，以及在 `CWnd` 檢視器鏈頂端時中斷剪貼簿檢視器鏈。 它會將 [WM_DESTROY](#ondestroy) 和 [WM_NCDESTROY](#onncdestroy) 訊息傳送至視窗。 它不會摧毀 `CWnd` 物件。

`DestroyWindow` 是執行清除的預留位置。 因為 `DestroyWindow` 是虛擬函式，所以它會顯示在 `CWnd` 類別檢視的任何衍生類別中。 但是，即使您在衍生的類別中覆寫這個函 `CWnd` 式，也 `DestroyWindow` 不一定會呼叫。 如果 `DestroyWindow` 未在 MFC 程式碼中呼叫，則當您想要呼叫它時，您必須在自己的程式碼中明確呼叫它。

例如，假設您已 `DestroyWindow` 在衍生類別中覆寫 `CView` 。 因為 MFC 原始程式碼不會 `DestroyWindow` 在其衍生的任何類別中呼叫 `CFrameWnd` ， `DestroyWindow` 除非您明確地呼叫，否則不會呼叫您的覆寫。

如果視窗是任何視窗的父系，則會在父視窗損毀時自動終結這些子視窗。 成員函式會 `DestroyWindow` 先終結子視窗，然後再終結視窗本身。

成員函式也會終結 `DestroyWindow` [CDialog：： Create](../../mfc/reference/cdialog-class.md#create)所建立的非強制回應對話方塊。

如果終結的 `CWnd` 是子視窗，而且沒有設定 [WS_EX_NOPARENTNOTIFY](../../mfc/reference/styles-used-by-mfc.md#extended-window-styles) 樣式，則會將 [WM_PARENTNOTIFY](/windows/win32/inputmsg/wm-parentnotify) 訊息傳送至父代。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#87](../../mfc/reference/codesnippet/cpp/cwnd-class_26.cpp)]

## <a name="cwnddetach"></a><a name="detach"></a> CWnd：:D etach

從 `CWnd` 物件卸離 Windows 控制代碼，並傳回控制代碼。

```
HWND Detach();
```

### <a name="return-value"></a>傳回值

Windows 物件的 HWND。

### <a name="example"></a>範例

  請參閱 [CWnd：： Attach](#attach)的範例。

## <a name="cwnddlgdirlist"></a><a name="dlgdirlist"></a> CWnd：:D lgDirList

使用檔案或目錄清單填入清單方塊。

```
int DlgDirList(
    LPTSTR lpPathSpec,
    int nIDListBox,
    int nIDStaticPath,
    UINT nFileType);
```

### <a name="parameters"></a>參數

*lpPathSpec*<br/>
指向以 null 終止的字串，其中包含路徑或檔案名。 `DlgDirList` 修改這個字串，其長度應該足以包含修改。 如需詳細資訊，請參閱下列「備註」一節。

*nIDListBox*<br/>
指定清單方塊的識別碼。 如果 *nIDListBox* 為0，則 `DlgDirList` 假設沒有任何清單方塊存在，而且不會嘗試填滿一個方塊。

*nIDStaticPath*<br/>
指定用來顯示目前磁片磁碟機和目錄之靜態文字控制項的識別碼。 如果 *nIDStaticPath* 為0，則 `DlgDirList` 會假設沒有這類文字控制項存在。

*nFileType*<br/>
指定要顯示之檔案的屬性。 它可以是下列值的任意組合：

- DDL_READWRITE 不含其他屬性的讀寫資料檔案。

- DDL_READONLY 唯讀檔案。

- DDL_HIDDEN 隱藏的檔案。

- DDL_SYSTEM 系統檔案。

- DDL_DIRECTORY 目錄。

- DDL_ARCHIVE 封存。

- DDL_POSTMSGS LB_DIR 旗標。 如果設定了 LB_DIR 旗標，Windows 會將所產生的訊息放 `DlgDirList` 在應用程式的佇列中; 否則，它們會直接傳送至對話方塊程式。

- DDL_DRIVES 磁片磁碟機。 如果設定了 DDL_DRIVES 旗標，則會自動設定 DDL_EXCLUSIVE 旗標。 因此，若要建立包含磁片磁碟機和檔案的目錄清單，您必須呼叫 `DlgDirList` 兩次：一次設定 DDL_DRIVES 旗標，並使用清單其餘部分的旗標。

- DDL_EXCLUSIVE 專有位。 如果設定了獨佔位，則只會列出指定之類型的檔案;否則會列出指定類型的一般檔案和檔案。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

`DlgDirList` 將 [LB_RESETCONTENT](/windows/win32/Controls/lb-resetcontent) 和 [LB_DIR](/windows/win32/Controls/lb-dir) 訊息傳送至清單方塊。 它會將 *nIDListBox* 所指定的清單方塊填入與 *lpPathSpec*所指定路徑相符的所有檔案名。

*LpPathSpec*參數的格式如下：

`[drive:] [ [\u]directory[\idirectory]...\u] [filename]`

在此範例中， *磁片磁碟機* 是磁碟機號、 *目錄* 是有效的目錄名稱，而 *filename* 是至少必須包含一個萬用字元的有效檔案名。 萬用字元是問號 (**？**) ，表示符合任何字元，而星號 (<strong>\*</strong>) ，表示符合任意數目的字元。

如果您為 *lpPathSpec*指定0長度的字串，或只指定目錄名稱，但未包含任何檔案規格，則字串會變更為 " \* . \* "。

如果 *lpPathSpec* 包含磁片磁碟機及/或目錄名稱，則在填入清單方塊之前，目前的磁片磁碟機和目錄會變更為指定的磁片磁碟機和目錄。 *NIDStaticPath*所識別的文字控制項也會以新的磁片磁碟機及/或目錄名稱進行更新。

填入清單方塊之後，請移除路徑的磁片磁碟機和/或目錄部分，以更新 *lpPathSpec* 。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#88](../../mfc/reference/codesnippet/cpp/cwnd-class_27.cpp)]

## <a name="cwnddlgdirlistcombobox"></a><a name="dlgdirlistcombobox"></a> CWnd：:D lgDirListComboBox

使用檔案或目錄清單來填入下拉式方塊的清單方塊。

```
int DlgDirListComboBox(
    LPTSTR lpPathSpec,
    int nIDComboBox,
    int nIDStaticPath,
    UINT nFileType);
```

### <a name="parameters"></a>參數

*lpPathSpec*<br/>
指向以 null 終止的字串，其中包含路徑或檔案名。 `DlgDirListComboBox` 修改這個字串，因此此資料不能是字串常值的形式。 請參閱下列「備註」一節。

*nIDComboBox*<br/>
在對話方塊中指定下拉式方塊的識別碼。 如果 *nIDComboBox* 為0，則 `DlgDirListComboBox` 會假設沒有下拉式方塊存在，而且不會嘗試填滿一個。

*nIDStaticPath*<br/>
指定用來顯示目前磁片磁碟機和目錄之靜態文字控制項的識別碼。 如果 *nIDStaticPath* 為0，則 `DlgDirListComboBox` 會假設沒有這類文字控制項存在。

*nFileType*<br/>
指定要顯示之檔案的 DOS 檔案屬性。 它可以是下列值的任意組合：

- DDL_READWRITE 不含其他屬性的讀寫資料檔案。

- DDL_READONLY 唯讀檔案。

- DDL_HIDDEN 隱藏的檔案。

- DDL_SYSTEM 系統檔案。

- DDL_DIRECTORY 目錄。

- DDL_ARCHIVE 封存。

- DDL_POSTMSGS CB_DIR 旗標。 如果設定了 CB_DIR 旗標，Windows 會將所產生的訊息放 `DlgDirListComboBox` 在應用程式的佇列中; 否則，它們會直接傳送至對話方塊程式。

- DDL_DRIVES 磁片磁碟機。 如果設定了 DDL_DRIVES 旗標，則會自動設定 DDL_EXCLUSIVE 旗標。 因此，若要建立包含磁片磁碟機和檔案的目錄清單，您必須呼叫 `DlgDirListComboBox` 兩次：一次設定 DDL_DRIVES 旗標，並使用清單其餘部分的旗標。

- DDL_EXCLUSIVE 專有位。 如果設定了獨佔位，則只會列出指定之類型的檔案;否則會列出指定類型的一般檔案和檔案。

### <a name="return-value"></a>傳回值

指定函數的結果。 如果已建立清單則為非零值，甚至是空的清單。 0傳回值表示輸入字串不包含有效的搜尋路徑。

### <a name="remarks"></a>備註

`DlgDirListComboBox` 將 [CB_RESETCONTENT](/windows/win32/Controls/cb-resetcontent) 和 [CB_DIR](/windows/win32/Controls/cb-dir) 訊息傳送至下拉式方塊。 它會在 *nIDComboBox* 所指定之下拉式方塊的清單方塊中，填入符合 *lpPathSpec*所提供路徑的所有檔案的名稱。

*LpPathSpec*參數的格式如下：

`[drive:] [ [\u]directory[\idirectory]...\u] [filename]`

在此範例中， *磁片磁碟機* 是磁碟機號、 *目錄* 是有效的目錄名稱，而 *filename* 是至少必須包含一個萬用字元的有效檔案名。 萬用字元是問號 (**？**) ，表示比對任何字元，以及星號 (<strong>\*</strong>) ，表示符合任意數量的字元。

如果您為 *lpPathSpec*指定長度為零的字串，將會使用目前的目錄，而不會修改 *lpPathSpec* 。 如果您只指定目錄名稱，但不包含任何檔案規格，則字串會變更為 " \* "。

如果 *lpPathSpec* 包含磁片磁碟機及/或目錄名稱，則在填入清單方塊之前，目前的磁片磁碟機和目錄會變更為指定的磁片磁碟機和目錄。 *NIDStaticPath*所識別的文字控制項也會以新的磁片磁碟機及/或目錄名稱進行更新。

填入下拉式方塊清單方塊之後， *lpPathSpec* 會藉由移除路徑的磁片磁碟機和/或目錄部分來更新。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#89](../../mfc/reference/codesnippet/cpp/cwnd-class_28.cpp)]

## <a name="cwnddlgdirselect"></a><a name="dlgdirselect"></a> CWnd：:D lgDirSelect

從清單方塊擷取目前的選取範圍。

```
BOOL DlgDirSelect(
    LPTSTR lpString,
    int nIDListBox);
```

### <a name="parameters"></a>參數

*lpString*<br/>
指向要接收清單方塊中目前選取範圍的緩衝區。

*nIDListBox*<br/>
在對話方塊中指定清單方塊的整數識別碼。

### <a name="return-value"></a>傳回值

如果成功則為非零；否則為 0。

### <a name="remarks"></a>備註

它會假設清單方塊已由 [DlgDirList](#dlgdirlist) 成員函式填滿，且選取範圍是磁碟機號、檔案或目錄名稱。

成員函式會 `DlgDirSelect` 將選取範圍複製到 *lpString*所指定的緩衝區。 如果沒有選取專案， *lpString* 就不會變更。

`DlgDirSelect` 將 [LB_GETCURSEL](/windows/win32/Controls/lb-getcursel) 和 [LB_GETTEXT](/windows/win32/Controls/lb-gettext) 訊息傳送至清單方塊。

它不允許從清單方塊傳回一個以上的檔案名。 清單方塊不得為多重選取清單方塊。

## <a name="cwnddlgdirselectcombobox"></a><a name="dlgdirselectcombobox"></a> CWnd：:D lgDirSelectComboBox

從下拉式方塊的清單方塊中擷取目前的選取範圍。

```
BOOL DlgDirSelectComboBox(
    LPTSTR lpString,
    int nIDComboBox);
```

### <a name="parameters"></a>參數

*lpString*<br/>
指向接收所選路徑的緩衝區。

*nIDComboBox*<br/>
在對話方塊中指定下拉式方塊的整數識別碼。

### <a name="return-value"></a>傳回值

如果成功則為非零；否則為 0。

### <a name="remarks"></a>備註

它會假設清單方塊已由 [DlgDirListComboBox](#dlgdirlistcombobox) 成員函式填滿，且選取範圍是磁碟機號、檔案或目錄名稱。

成員函式會 `DlgDirSelectComboBox` 將選取專案複製到指定的緩衝區。 如果沒有選取專案，則不會變更緩衝區的內容。

`DlgDirSelectComboBox` 將 [CB_GETCURSEL](/windows/win32/Controls/cb-getcursel) 和 [CB_GETLBTEXT](/windows/win32/Controls/cb-getlbtext) 訊息傳送至下拉式方塊。

不允許從下拉式方塊傳回一個以上的檔案名。

## <a name="cwnddodataexchange"></a><a name="dodataexchange"></a> CWnd：:D oDataExchange

由架構呼叫以交換和驗證對話資料。

```
virtual void DoDataExchange(CDataExchange* pDX);
```

### <a name="parameters"></a>參數

*pDX*<br/>
`CDataExchange` 物件的指標。

### <a name="remarks"></a>備註

請勿直接呼叫此函數。 它是由 [UpdateData](#updatedata) 成員函式所呼叫。 呼叫 `UpdateData` 以初始化對話方塊的控制項，或從對話方塊中取出資料。

當您從 [CDialog](../../mfc/reference/cdialog-class.md)衍生應用程式特定的對話類別時，如果您想要利用架構的自動資料交換和驗證，則需要覆寫此成員函式。 [新增變數] 嚮導會為您撰寫這個成員函式的覆寫版本，讓您包含對話方塊資料交換的所需「資料對應」 (DDX) 和驗證 (DDV) 全域函式呼叫。

若要自動產生這個成員函式的覆寫版本，請先使用對話方塊編輯器建立對話方塊資源，然後再衍生應用程式特定的對話方塊類別。 然後使用 [新增變數] 嚮導，將變數、資料和驗證範圍與新對話方塊中的各種控制項產生關聯。 然後，嚮導會寫入已覆寫的 `DoDataExchange` ，其中包含資料對應。 以下是 Add Variable wizard 產生的範例 DDX/DDV 程式碼區塊：

[!code-cpp[NVC_MFCWindowing#90](../../mfc/reference/codesnippet/cpp/cwnd-class_29.cpp)]

覆 `DoDataExchange` 寫的成員函式必須在原始程式檔中的巨集式之前。

如需對話方塊資料交換和驗證的詳細資訊，請參閱 [在表單中顯示和運算元據](../../data/odbc/displaying-and-manipulating-data-in-a-form.md) 和 [對話方塊資料交換和驗證](../../mfc/dialog-data-exchange-and-validation.md)。 如需 [Add Variable wizard] 所產生之 DDX_ 和 DDV_ 宏的描述，請參閱 [技術提示 26](../../mfc/tn026-ddx-and-ddv-routines.md)。

## <a name="cwnddragacceptfiles"></a><a name="dragacceptfiles"></a> CWnd：:D ragAcceptFiles

`CWnd`在應用程式的[CWinApp：： InitInstance](../../mfc/reference/cwinapp-class.md#initinstance)函式中使用指標從視窗內呼叫這個成員函式，以指出視窗接受從 Windows 檔案管理員或檔案總管卸載的檔案。

```cpp
void DragAcceptFiles(BOOL bAccept = TRUE);
```

### <a name="parameters"></a>參數

*BAccept*<br/>
指出是否接受拖曳檔案的旗標。

### <a name="remarks"></a>備註

只有呼叫 `DragAcceptFiles` *bAccept* 參數設為 TRUE 的視窗，已識別其本身可以處理 Windows 訊息 WM_DROPFILES。 例如，在 MDI 應用程式中，如果在 `CMDIFrameWnd` 函式呼叫中使用視窗指標 `DragAcceptFiles` ，則只有視窗會 `CMDIFrameWnd` 取得 WM_DROPFILES 訊息。 此訊息不會傳送至所有開啟的 `CMDIChildWnd` 視窗。 `CMDIChildWnd`若要接收此訊息的視窗，您必須 `DragAcceptFiles` 使用 `CMDIChildWnd` 視窗指標呼叫。

若要停止接收拖曳的檔案，請呼叫 *bAccept* 設定為 FALSE 的成員函式。

## <a name="cwnddragdetect"></a><a name="dragdetect"></a> CWnd：:D ragDetect

擷取滑鼠並追蹤其移動，直到使用者放開左側按鈕、按下 ESC 鍵，或將滑鼠移到指定點周圍的拖曳矩形外。

```
BOOL DragDetect(POINT pt) const;
```

### <a name="parameters"></a>參數

*pt*<br/>
滑鼠的初始位置，以螢幕座標為單位。 函數會使用這個點來決定拖曳矩形的座標。

### <a name="return-value"></a>傳回值

如果使用者在按住左按鈕時將滑鼠移至拖曳矩形之外，則傳回值為非零值。

如果使用者未在按住左按鈕時將滑鼠移至拖曳矩形之外，則傳回值為零。

### <a name="remarks"></a>備註

此成員函式會模擬函數 [DragDetect](/windows/win32/api/winuser/nf-winuser-dragdetect)的功能，如 Windows SDK 所述。

## <a name="cwnddrawanimatedrects"></a><a name="drawanimatedrects"></a> CWnd：:D rawAnimatedRects

繪製框線矩形，並以動畫效果呈現它來指出圖示的開頭，或最小化或最大化視窗。

```
BOOL DrawAnimatedRects(
    int idAni,
    CONST RECT* lprcFrom,
    CONST RECT* lprcTo);
```

### <a name="parameters"></a>參數

*idAni*<br/>
指定動畫的類型。 如果您指定 IDANI_CAPTION，視窗標題將會從 *lprcFrom* 所指定的位置建立動畫至 *lprcTo*所指定的位置。 效果類似于最小化或最大化視窗。

*lprcFrom*<br/>
[矩形](/windows/win32/api/windef/ns-windef-rect)結構的指標，指定圖示或最小化視窗的位置和大小。

*lprcTo*<br/>
[矩形](/windows/win32/api/windef/ns-windef-rect)結構的指標，指定還原視窗的位置和大小

### <a name="return-value"></a>傳回值

如果函式成功則為非零值，否則為 0。

### <a name="remarks"></a>備註

此成員函式會模擬函數 [DrawAnimatedRects](/windows/win32/api/winuser/nf-winuser-drawanimatedrects)的功能，如 Windows SDK 所述。

## <a name="cwnddrawcaption"></a><a name="drawcaption"></a> CWnd：:D rawCaption

繪製視窗標題。

```
BOOL DrawCaption(
    CDC* pDC,
    LPCRECT lprc,
    UINT uFlags);
```

### <a name="parameters"></a>參數

*Pdc*<br/>
裝置內容的指標。 此函式會在此裝置內容中繪製視窗標題。

*lprc*<br/>
矩形結構的指標，指定視窗標題的周框。

*uFlags*<br/>
指定繪製選項。 如需完整的值清單，請參閱 [DrawCaption](/windows/win32/api/winuser/nf-winuser-drawcaption)。

### <a name="return-value"></a>傳回值

如果函式成功則為非零值，否則為 0。

### <a name="remarks"></a>備註

此成員函式會模擬函數 [DrawCaption](/windows/win32/api/winuser/nf-winuser-drawcaption)的功能，如 Windows SDK 所述。

## <a name="cwnddrawmenubar"></a><a name="drawmenubar"></a> CWnd：:D rawMenuBar

重新繪製功能表列。

```cpp
void DrawMenuBar();
```

### <a name="remarks"></a>備註

如果在 Windows 建立視窗之後變更了功能表列，請呼叫此函式來繪製已變更的功能表列。

### <a name="example"></a>範例

  請參閱 [CWnd：： GetMenu](#getmenu)的範例。

## <a name="cwndenableactiveaccessibility"></a><a name="enableactiveaccessibility"></a> CWnd：： EnableActiveAccessibility

啟用使用者定義的 Active Accessibility 函數。

```cpp
void EnableActiveAccessibility();
```

### <a name="remarks"></a>備註

MFC 的預設 Active Accessibility 支援對標準視窗和控制項（包括 ActiveX 控制項）已足夠：但是，如果您 `CWnd` 的衍生類別包含 nonwindowed 的使用者介面元素，MFC 就無法得知它們。 在這種情況下，您必須在類別中覆寫適當的 [Active Accessibility 成員](/windows/win32/winauto/sdk-components) 函式，而且您必須 `EnableActiveAccessibility` 在類別的函式中呼叫。

## <a name="cwndenabledynamiclayout"></a><a name="enabledynamiclayout"></a> CWnd：： EnableDynamicLayout

啟用或停用動態配置管理員。 啟用動態配置時，會在使用者調整視窗大小時動態調整子視窗的位置與大小。

```cpp
void EnableDynamicLayout(BOOL bEnable = TRUE);
```

### <a name="parameters"></a>參數

*bEnable*<br/>
TRUE 表示啟用動態配置；FALSE 則停用動態配置。

### <a name="remarks"></a>備註

如果您想要啟用動態配置，除了呼叫這個方法之外，還必須執行其他作業。 您還必須提供動態配置資訊，該資訊指定視窗中的控制項如何回應大小變更。 您可以在資源編輯器中或以程式設計方式，為每個控制項指定這項資訊。 請參閱 [動態版面](../../mfc/dynamic-layout.md)配置。

## <a name="cwndenabled2dsupport"></a><a name="enabled2dsupport"></a> CWnd：： EnableD2DSupport

啟用或停用視窗 D2D 支援。 初始化主視窗之前先呼叫這個方法。

```cpp
void EnableD2DSupport(
    BOOL bEnable = TRUE,
    BOOL bUseDCRenderTarget = FALSE);
```

### <a name="parameters"></a>參數

*bEnable*<br/>
指定是否開啟或關閉 D2D 支援。

*bUseDCRenderTarget*<br/>
指定是否要使用裝置內容 (DC) 呈現目標 CDCRenderTarget。 如果為 FALSE，則會使用 CHwndRenderTarget。

## <a name="cwndenablescrollbar"></a><a name="enablescrollbar"></a> CWnd：： EnableScrollBar

啟用或停用一個捲軸的一或兩個箭號。

```
BOOL EnableScrollBar(
    int nSBFlags,
    UINT nArrowFlags = ESB_ENABLE_BOTH);
```

### <a name="parameters"></a>參數

*nSBFlags*<br/>
指定捲軸類型。 可以具有下列其中一個值：

- SB_BOTH 啟用或停用與視窗相關聯之水準和垂直捲動條的箭號。

- SB_HORZ 啟用或停用與視窗相關聯的水準捲軸箭號。

- SB_VERT 啟用或停用與視窗相關聯之垂直捲動條的箭號。

*nArrowFlags*<br/>
指定捲軸箭號是否為啟用或停用，以及啟用或停用的箭號。 可以具有下列其中一個值：

- ESB_ENABLE_BOTH 啟用捲軸的兩箭號 (預設) 。

- ESB_DISABLE_LTUP 停用水準捲軸的向左鍵或垂直捲動條的向上箭號。

- ESB_DISABLE_RTDN 停用水準捲軸的向右箭號或垂直捲動條的向下箭號。

- ESB_DISABLE_BOTH 停用捲軸的兩個箭號。

### <a name="return-value"></a>傳回值

如果箭號依指定啟用或停用，則為非零。 否則，它是0，表示箭號已在要求的狀態中，或發生錯誤。

## <a name="cwndenablescrollbarctrl"></a><a name="enablescrollbarctrl"></a> CWnd：： EnableScrollBarCtrl

啟用或停用此視窗的捲軸。

```cpp
void EnableScrollBarCtrl(
    int nBar,
    BOOL bEnable = TRUE);
```

### <a name="parameters"></a>參數

*nBar*<br/>
捲軸識別碼。

*bEnable*<br/>
指定是否要啟用或停用捲軸。

### <a name="remarks"></a>備註

如果視窗具有同級捲軸控制項，則會使用該捲軸;否則會使用視窗自己的捲軸。

## <a name="cwndenabletooltips"></a><a name="enabletooltips"></a> CWnd：： EnableToolTips

啟用指定視窗的工具提示。

```
BOOL EnableToolTips(BOOL bEnable = TRUE);
```

### <a name="parameters"></a>參數

*bEnable*<br/>
指定是否啟用或停用工具提示控制項。 TRUE 會啟用控制項;FALSE 會停用控制項。

### <a name="return-value"></a>傳回值

如果已啟用工具提示，則為 TRUE;否則為 FALSE。

### <a name="remarks"></a>備註

覆寫 [OnToolHitTest](#ontoolhittest) 以提供視窗的 [TOOLINFO](/windows/win32/api/commctrl/ns-commctrl-tttoolinfoa) 結構或結構。

> [!NOTE]
> 某些視窗（例如 [CToolBar](../../mfc/reference/ctoolbar-class.md)）提供內建的 [OnToolHitTest](#ontoolhittest)執行。

如需此結構的詳細資訊，請參閱 Windows SDK 中的 [TOOLINFO](/windows/win32/api/commctrl/ns-commctrl-tttoolinfoa) 。

`EnableToolTips`除非您的父視窗衍生自，否則呼叫的只是為了顯示子控制項的工具提示 `CFrameWnd` 。 這是因為 `CFrameWnd` 提供 TTN_NEEDTEXT 通知的預設處理常式。 如果您的父視窗不是衍生自 `CFrameWnd` ，也就是如果它是對話方塊或表單檢視，除非您提供 TTN_NEEDTEXT 工具提示通知的處理常式，否則子控制項的工具提示將不會正確顯示。 請參閱 [工具提示](../../mfc/tool-tips-in-windows-not-derived-from-cframewnd.md)。

針對您的 windows 所提供的預設工具提示 `EnableToolTips` 沒有與其相關聯的文字。 為了取得要顯示之工具提示的文字，TTN_NEEDTEXT 通知會在顯示工具提示視窗之前，傳送至工具提示控制項的父視窗。 如果沒有此訊息的處理常式可將某個值指派給結構的 *pszText* 成員 `TOOLTIPTEXT` ，則工具提示不會顯示任何文字。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#91](../../mfc/reference/codesnippet/cpp/cwnd-class_30.cpp)]

[!code-cpp[NVC_MFCWindowing#92](../../mfc/reference/codesnippet/cpp/cwnd-class_31.cpp)]

## <a name="cwndenabletrackingtooltips"></a><a name="enabletrackingtooltips"></a> CWnd：： EnableTrackingToolTips

啟用或停用追蹤工具提示。

```
BOOL EnableTrackingToolTips(BOOL bEnable = TRUE);
```

### <a name="parameters"></a>參數

*bEnable*<br/>
指定是否啟用或停用追蹤工具提示。 如果此參數為 TRUE，將會啟用追蹤工具提示。 如果此參數為 FALSE，則會停用追蹤工具提示。

### <a name="return-value"></a>傳回值

指出呼叫成員函式之前的狀態 `EnableWindow` 。 如果之前已停用視窗，則傳回值為非零。 如果之前已啟用視窗或發生錯誤，則傳回值為0。

### <a name="remarks"></a>備註

追蹤工具提示是工具提示視窗，您可以在螢幕上動態定位。 藉由快速更新位置，工具提示視窗看似可順暢地移動或「追蹤」。 如果您需要工具提示文字，以在指標移動時遵循指標的位置，這項功能會很有用。

## <a name="cwndenablewindow"></a><a name="enablewindow"></a> CWnd：： EnableWindow

啟用或停用滑鼠和鍵盤輸入。

```
BOOL EnableWindow(BOOL bEnable = TRUE);
```

### <a name="parameters"></a>參數

*bEnable*<br/>
指定是否要啟用或停用指定的視窗。 如果此參數為 TRUE，將會啟用視窗。 如果此參數為 FALSE，則會停用視窗。

### <a name="return-value"></a>傳回值

指出呼叫成員函式之前的狀態 `EnableWindow` 。 如果之前已停用視窗，則傳回值為非零。 如果之前已啟用視窗或發生錯誤，則傳回值為0。

### <a name="remarks"></a>備註

當輸入停用時，會忽略按下滑鼠按鍵和按鍵的輸入。 當輸入啟用時，視窗會處理所有輸入。

如果已啟用狀態變更，則會在此函式傳回之前傳送 [WM_ENABLE](#onenable) 訊息。

如果停用，則會隱含停用所有的子視窗，但不會 WM_ENABLE 訊息傳送。

必須先啟用視窗，才能啟用視窗。 例如，如果應用程式顯示非強制回應對話方塊，並停用其主視窗，則必須先啟用主視窗，然後才能終結對話方塊。 否則，另一個視窗會取得輸入焦點並啟用。 如果停用子視窗，當 Windows 嘗試判斷哪個視窗應該取得滑鼠訊息時，就會忽略此視窗。

根據預設，視窗會在建立時啟用。 應用程式可以在 [create](#create) 或 [CreateEx](#createex) 成員函式中指定 WS_DISABLED 樣式，以建立一開始停用的視窗。 建立視窗之後，應用程式也可以使用成員函式 `EnableWindow` 來啟用或停用視窗。

應用程式可以使用此函式來啟用或停用對話方塊中的控制項。 停用的控制項無法接收輸入焦點，也不能存取使用者。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#93](../../mfc/reference/codesnippet/cpp/cwnd-class_32.cpp)]

## <a name="cwndendmodalloop"></a><a name="endmodalloop"></a> CWnd：： EndModalLoop

終止對的呼叫 `RunModalLoop` 。

```
virtual void EndModalLoop(int nResult);
```

### <a name="parameters"></a>參數

*N 結果*<br/>
包含要傳回給 [RunModalLoop](#runmodalloop)呼叫端的值。

### <a name="remarks"></a>備註

*N 結果*參數會傳播至的傳回值 `RunModalLoop` 。

## <a name="cwndendmodalstate"></a><a name="endmodalstate"></a> CWnd：： EndModalState

呼叫此成員函式，將框架視窗從強制回應變更為非強制回應。

```
virtual void EndModalState();
```

## <a name="cwndendpaint"></a><a name="endpaint"></a> CWnd：： EndPaint

在給定的視窗中標示繪製的結尾。

```cpp
void EndPaint(LPPAINTSTRUCT lpPaint);
```

### <a name="parameters"></a>參數

*lpPaint*<br/>
指向 [PAINTSTRUCT](/windows/win32/api/winuser/ns-winuser-paintstruct) 結構，其中包含 [BeginPaint](#beginpaint) 成員函式所取出的繪製資訊。

### <a name="remarks"></a>備註

成員函式對成員函式的 `EndPaint` 每個呼叫都是必要的 `BeginPaint` ，但只有在繪製完成後才需要。

如果成員函式隱藏了插入號，則會將 `BeginPaint` `EndPaint` 插入號還原至畫面。

### <a name="example"></a>範例

  請參閱 [CWnd：： BeginPaint](#beginpaint)的範例。

## <a name="cwndexecutedlginit"></a><a name="executedlginit"></a> CWnd：： ExecuteDlgInit

初始化對話方塊資源。

```
BOOL ExecuteDlgInit(LPCTSTR lpszResourceName);
BOOL ExecuteDlgInit(LPVOID lpResource);
```

### <a name="parameters"></a>參數

*lpszResourceName*<br/>
以 null 結束的字串指標，指定資源的名稱。

*lpResource*<br/>
資源的指標。

### <a name="return-value"></a>傳回值

如果執行對話方塊資源則為 TRUE;否則為 FALSE。

### <a name="remarks"></a>備註

`ExecuteDlgInit` 將會使用系結至執行中模組的資源，或其他來源的資源。 若要完成這項工作，請 `ExecuteDlgInit` 呼叫來尋找資源控制碼 `AfxFindResourceHandle` 。 如果您的 MFC 應用程式未使用共用 DLL (MFCx0 [U] [D]。DLL) 會 `AfxFindResourceHandle` 呼叫 [AfxGetResourceHandle](application-information-and-management.md#afxgetresourcehandle)，它會傳回可執行檔的目前資源控制碼。 如果您的 MFC 應用程式使用 MFCx0 [U] [D]。DLL，會 `AfxFindResourceHandle` 在 `CDynLinkLibrary` 尋找正確資源控制碼的共用和 MFC 擴充 dll 物件清單中進行。

## <a name="cwndfiltertooltipmessage"></a><a name="filtertooltipmessage"></a> CWnd：： FilterToolTipMessage

由架構呼叫以顯示工具提示訊息。

```cpp
void FilterToolTipMessage(MSG* pMsg);
```

### <a name="parameters"></a>參數

*pMsg*<br/>
工具提示訊息的指標。

### <a name="remarks"></a>備註

在大部分的 MFC 應用程式中，此方法是由 [PreTranslateMessage](#pretranslatemessage) 和 [EnableToolTips](#enabletooltips)的架構所呼叫，而您不需要自行呼叫。

不過，在某些應用程式中（例如，某些 ActiveX 控制項），這些方法可能不會由架構叫用，而您必須自行呼叫 FilterToolTipMessage。 如需詳細資訊，請參閱 [建立工具提示的方法](../../mfc/methods-of-creating-tool-tips.md)。

## <a name="cwndfindwindow"></a><a name="findwindow"></a> CWnd：： FindWindow

`CWnd`傳回由*lpszClassName*指定其視窗類別的最上層，而其視窗名稱或標題則由*lpszWindowName*提供。

```
static CWnd* PASCAL FindWindow(
    LPCTSTR lpszClassName,
    LPCTSTR lpszWindowName);
```

### <a name="parameters"></a>參數

*lpszClassName*<br/>
指向以 null 終止的字串，這個字串會指定 (結構) 的視窗類別名稱 `WNDCLASS` 。 如果 *lpClassName* 為 Null，則所有類別名稱都會相符。

*lpszWindowName*<br/>
指向以 null 終止的字串，這個字串會指定視窗標題)  (視窗名稱。 如果 *lpWindowName* 為 Null，則所有視窗名稱都會相符。

### <a name="return-value"></a>傳回值

識別具有指定類別名稱和視窗名稱的視窗。 如果找不到這類視窗，則為 Null。

`CWnd`* 可能是暫時性的，不應儲存供稍後使用。

### <a name="remarks"></a>備註

此函數不會搜尋子視窗。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#94](../../mfc/reference/codesnippet/cpp/cwnd-class_33.cpp)]

## <a name="cwndfindwindowex"></a><a name="findwindowex"></a> CWnd：： FindWindowEx

抓取其類別名稱和視窗名稱符合指定字串的視窗物件。

```
static CWnd* FindWindowEx(
    HWND hwndParent,
    HWND hwndChildAfter,
    LPCTSTR lpszClass,
    LPCTSTR lpszWindow);
```

### <a name="parameters"></a>參數

*hwndParent*<br/>
要搜尋其子視窗的父視窗控制碼。

*hwndChildAfter*<br/>
子視窗的控制碼。 搜尋會以 Z 順序的下一個子視窗開始。 子視窗必須是 *hwndParent*的直接子視窗，而不只是子系視窗。

*lpszClass*<br/>
以 null 結束的字串指標，指定類別名稱，或先前對 [RegisterClass](/windows/win32/api/winuser/nf-winuser-registerclassw) 或 [RegisterClassEx](/windows/win32/api/winuser/nf-winuser-registerclassexw)的呼叫所建立的類別 atom。

*lpszWindow*<br/>
以 null 結束的字串指標，指定視窗標題)  (視窗名稱。 如果此參數為 Null，則所有視窗名稱都會相符。

### <a name="return-value"></a>傳回值

如果函式成功，則傳回值是具有指定類別和視窗名稱之 window 物件的指標。 如果函式失敗，則傳回值為 Null。

### <a name="remarks"></a>備註

此成員函式會模擬函數 [FindWindowEx](/windows/win32/api/winuser/nf-winuser-findwindowexw)的功能，如 Windows SDK 所述。

## <a name="cwndflashwindow"></a><a name="flashwindow"></a> CWnd：： FlashWindow

將指定的視窗閃爍一次。

```
BOOL FlashWindow(BOOL bInvert);
```

### <a name="parameters"></a>參數

*bInvert*<br/>
指定是否 `CWnd` 要閃爍或回到其原始狀態。 `CWnd`如果*BINVERT*為 TRUE，則會從一個狀態閃爍至另一個狀態。 如果 *bInvert* 為 FALSE，則會將視窗傳回至其原始狀態 (作用中或非使用中的) 。

### <a name="return-value"></a>傳回值

如果視窗在呼叫成員函式之前為作用中，則為非零， `FlashWindow` 否則為0。

### <a name="remarks"></a>備註

若要連續閃爍，請建立系統計時器並重複呼叫 `FlashWindow` 。 閃爍 `CWnd` 表示變更標題列的外觀，就像 `CWnd` 是從非作用中變更為作用中狀態一樣，反之亦然。  (非作用中標題列會變更為作用中標題列;現用標題列會變更為非使用中的標題列。 ) 

通常會閃爍視窗，以通知使用者需要注意，但目前沒有輸入焦點。

只有當視窗取得輸入焦點且不會再閃爍時， *bInvert* 參數才應為 FALSE：在等候取得輸入焦點時，後續呼叫上應該是 TRUE。

針對最小化的視窗，此函式一律會傳回非零值。 如果視窗最小化，則 `FlashWindow` 只會閃爍視窗的圖示;最小化視窗會忽略 *bInvert* 。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#95](../../mfc/reference/codesnippet/cpp/cwnd-class_34.cpp)]

## <a name="cwndflashwindowex"></a><a name="flashwindowex"></a> CWnd：： FlashWindowEx

閃爍指定的視窗。

```
BOOL FlashWindowEx(
    DWORD dwFlags,
    UINT uCount,
    DWORD dwTimeout);
```

### <a name="parameters"></a>參數

*dwFlags*<br/>
指定閃爍狀態。 如需完整的值清單，請參閱 [FLASHWINFO](/windows/win32/api/winuser/ns-winuser-flashwinfo) 結構。

*uCount*<br/>
指定快閃視窗的次數。

*dwTimeout*<br/>
指定要閃爍視窗的速率（以毫秒為單位）。 如果 *dwTimeout* 為零，則函數會使用預設的資料指標閃爍頻率。

### <a name="return-value"></a>傳回值

傳回值會在呼叫函式之前，指定視窗的狀態 `FlashWindowEx` 。 如果視窗標題在呼叫之前繪製為使用中，則傳回值為非零值。 否則，傳回值為零。

### <a name="remarks"></a>備註

這個方法會模擬函數 [FlashWindowEx](/windows/win32/api/winuser/nf-winuser-flashwindowex)的功能，如 Windows SDK 所述。

## <a name="cwndfromhandle"></a><a name="fromhandle"></a> CWnd：： FromHandle

將控制代碼提供給視窗時，將指標傳回至 `CWnd` 物件。 如果 `CWnd` 物件沒有附加至控制代碼，會建立並附加暫存 `CWnd` 物件。

```
static CWnd* PASCAL FromHandle(HWND hWnd);
```

### <a name="parameters"></a>參數

*hWnd*<br/>
Windows 視窗的 HWND。

### <a name="return-value"></a>傳回值

將控制代碼提供給視窗時，將指標傳回至 `CWnd` 物件。 如果 `CWnd` 物件沒有附加至控制代碼，會建立並附加暫存 `CWnd` 物件。

該指標可能是暫時性的，因此不應該儲存供日後使用。

## <a name="cwndfromhandlepermanent"></a><a name="fromhandlepermanent"></a> CWnd：： FromHandlePermanent

將控制代碼提供給視窗時，將指標傳回至 `CWnd` 物件。

```
static CWnd* PASCAL FromHandlePermanent(HWND hWnd);
```

### <a name="parameters"></a>參數

*hWnd*<br/>
Windows 視窗的 HWND。

### <a name="return-value"></a>傳回值

`CWnd` 物件的指標。

### <a name="remarks"></a>備註

如果 `CWnd` 物件未附加至控制碼，則會傳回 Null。

與 [FromHandle](#fromhandle)不同的是，此函式不會建立暫存物件。

## <a name="cwndget_accchild"></a><a name="get_accchild"></a> CWnd：： get_accChild

由架構呼叫以擷取指定子系的 `IDispatch` 介面位址。

```
virtual HRESULT get_accChild(
    VARIANT varChild,
    IDispatch** ppdispChild);
```

### <a name="parameters"></a>參數

*varChild*<br/>
識別要取出其介面的子系 `IDispatch` 。

*ppdispChild*<br/>
接收子物件之介面的位址 `IDispatch` 。

### <a name="return-value"></a>傳回值

在成功時傳回 S_OK，失敗時傳回 COM 錯誤碼。 請參閱 Windows SDK 中[IAccessible：： get_accChild](/windows/win32/api/oleacc/nf-oleacc-iaccessible-get_accchild)的傳回**值**。

### <a name="remarks"></a>備註

此函數是 MFC 的 [Active Accessibility](/windows/win32/WinAuto/microsoft-active-accessibility) 支援的一部分。

`CWnd`如果您有 nonwindowed 使用者介面專案 (非視窗的 ActiveX 控制項（MFC 會處理) ）以外的專案，請在衍生類別中覆寫此函數。

如需詳細資訊，請參閱 Windows SDK 中的 [IAccessible：： get_accChild](/windows/win32/api/oleacc/nf-oleacc-iaccessible-get_accchild) 。

## <a name="cwndget_accchildcount"></a><a name="get_accchildcount"></a> CWnd：： get_accChildCount

由架構呼叫以擷取屬於此物件的子物件數目。

```
virtual HRESULT get_accChildCount(long* pcountChildren);
```

### <a name="parameters"></a>參數

*pcountChildren*<br/>
接收子係數目。

### <a name="return-value"></a>傳回值

在成功時傳回 S_OK，失敗時傳回 COM 錯誤碼。 請參閱 Windows SDK 中[IAccessible：： get_accChildCount](/windows/win32/api/oleacc/nf-oleacc-iaccessible-get_accchildcount)的傳回**值**。

### <a name="remarks"></a>備註

此函數是 MFC 的 [Active Accessibility](/windows/win32/WinAuto/microsoft-active-accessibility) 支援的一部分。

`CWnd`如果您有 nonwindowed 使用者介面專案 (非視窗的 ActiveX 控制項（MFC 會處理) ）以外的專案，請在衍生類別中覆寫此函數。 呼叫基類版本，然後加入 nonwindowed 子項目。

如需詳細資訊，請參閱 Windows SDK 中的 [IAccessible：： get_accChildCount](/windows/win32/api/oleacc/nf-oleacc-iaccessible-get_accchildcount) 。

## <a name="cwndget_accdefaultaction"></a><a name="get_accdefaultaction"></a> CWnd：： get_accDefaultAction

由架構呼叫以擷取具有物件預設動作描述的字串。

```
virtual HRESULT get_accDefaultAction(
    VARIANT varChild,
    BSTR* pszDefaultAction);
```

### <a name="parameters"></a>參數

*varChild*<br/>
指定要抓取的預設動作是物件的或其中一個物件的子項目。 這個參數可以是 CHILDID_SELF (取得物件) 或子識別碼 (的相關資訊，以取得物件的子專案) 的相關資訊。

*pszDefaultAction*<br/>
接收當地語系化字串的 BSTR 位址，此字串描述指定之物件的預設動作; 如果這個物件沒有預設動作，則為 Null。

### <a name="return-value"></a>傳回值

在成功時傳回 S_OK，失敗時傳回 COM 錯誤碼。 請參閱 Windows SDK 中[IAccessible：： get_accDefaultAction](/windows/win32/api/oleacc/nf-oleacc-iaccessible-get_accdefaultaction)的傳回**值**。

### <a name="remarks"></a>備註

此函數是 MFC 的 [Active Accessibility](/windows/win32/WinAuto/microsoft-active-accessibility) 支援的一部分。

覆寫衍生類別中的這個函 `CWnd` 式，以描述您物件的預設動作。

如需詳細資訊，請參閱 Windows SDK 中的 [IAccessible：： get_accDefaultAction](/windows/win32/api/oleacc/nf-oleacc-iaccessible-get_accdefaultaction) 。

## <a name="cwndget_accdescription"></a><a name="get_accdescription"></a> CWnd：： get_accDescription

由架構呼叫以擷取含有指定物件的視覺外觀描述的字串。

```
virtual HRESULT get_accDescription(
    VARIANT varChild,
    BSTR* pszDescription);
```

### <a name="parameters"></a>參數

*varChild*<br/>
指定要抓取的描述是物件的或其中一個物件的子專案。 這個參數可以是 CHILDID_SELF (取得物件) 或子識別碼 (的相關資訊，以取得物件的子專案) 的相關資訊。

*pszDescription*<br/>
接收當地語系化字串的 BSTR 位址，此字串會描述指定的物件，如果此物件沒有可用的描述，則為 Null。

### <a name="return-value"></a>傳回值

在成功時傳回 S_OK，失敗時傳回 COM 錯誤碼。 請參閱 Windows SDK 中[IAccessible：： get_accDescription](/windows/win32/api/oleacc/nf-oleacc-iaccessible-get_accdescription)的傳回**值**。

### <a name="remarks"></a>備註

此函數是 MFC 的 [Active Accessibility](/windows/win32/WinAuto/microsoft-active-accessibility) 支援的一部分。

覆寫衍生類別中的這個函 `CWnd` 式，以描述您的物件。 呼叫基類版本並加入您的描述。

如需詳細資訊，請參閱 Windows SDK 中的 [IAccessible：： get_accDescription](/windows/win32/api/oleacc/nf-oleacc-iaccessible-get_accdescription) 。

## <a name="cwndget_accfocus"></a><a name="get_accfocus"></a> CWnd：： get_accFocus

由架構呼叫以擷取具有鍵盤焦點的物件。

```
virtual HRESULT get_accFocus(VARIANT* pvarChild);
```

### <a name="parameters"></a>參數

*pvarChild*<br/>
接收具有焦點之物件的相關資訊。 請參閱 Windows SDK 中的[IAccessible：： Get_accFocus](/windows/win32/api/oleacc/nf-oleacc-iaccessible-get_accfocus) *pvarID* 。

### <a name="return-value"></a>傳回值

在成功時傳回 S_OK，失敗時傳回 COM 錯誤碼。 請參閱 Windows SDK 中的傳回 **值** `IAccessible::get_accFocus` 。

### <a name="remarks"></a>備註

此函數是 MFC 的 [Active Accessibility](/windows/win32/WinAuto/microsoft-active-accessibility) 支援的一部分。

`CWnd`如果您有 nonwindowed 使用者介面專案 (非視窗的 ActiveX 控制項（MFC 會處理) ）以外的專案，請在衍生類別中覆寫此函數。

如需詳細資訊，請參閱 Windows SDK 中的 [IAccessible：： get_accFocus](/windows/win32/api/oleacc/nf-oleacc-iaccessible-get_accfocus) 。

## <a name="cwndget_acchelp"></a><a name="get_acchelp"></a> CWnd：： get_accHelp

由架構呼叫以取得物件的 **Help** 屬性字串。

```
virtual HRESULT get_accHelp(
    VARIANT varChild,
    BSTR* pszHelp);
```

### <a name="parameters"></a>參數

*varChild*<br/>
指定要抓取的說明資訊是物件的或其中一個物件的子項目。 這個參數可以是 CHILDID_SELF (取得物件) 或子識別碼 (的相關資訊，以取得物件的子專案) 的相關資訊。

*pszHelp*<br/>
接收包含指定物件之說明資訊之當地語系化字串的 BSTR 位址; 如果沒有可用的說明資訊，則為 Null。

### <a name="return-value"></a>傳回值

在成功時傳回 S_OK，失敗時傳回 COM 錯誤碼。 請參閱 Windows SDK 中[IAccessible：： get_accHelp](/windows/win32/api/oleacc/nf-oleacc-iaccessible-get_acchelp)的傳回**值**。

### <a name="remarks"></a>備註

此函數是 MFC 的 [Active Accessibility](/windows/win32/WinAuto/microsoft-active-accessibility) 支援的一部分。

覆寫衍生類別中的這個函 `CWnd` 式，以提供物件的解說文字。

如需詳細資訊，請參閱 Windows SDK 中的 [IAccessible：： get_accHelp](/windows/win32/api/oleacc/nf-oleacc-iaccessible-get_acchelp) 。

## <a name="cwndget_acchelptopic"></a><a name="get_acchelptopic"></a> CWnd：： get_accHelpTopic

由架構呼叫，以取得與指定物件相關聯之 **WinHelp** 檔案的完整路徑，以及該檔案內適當主題的識別碼。

```
virtual HRESULT get_accHelpTopic(
    BSTR* pszHelpFile,
    VARIANT varChild,
    long* pidTopic);
```

### <a name="parameters"></a>參數

*pszHelpFile*<br/>
接收 `WinHelp` 與指定物件相關聯之檔案完整路徑的 BSTR 位址（如果有的話）。

*varChild*<br/>
指定要抓取的說明主題是物件的或其中一個物件的子項目。 這個參數可以是 CHILDID_SELF (取得物件) 的說明主題或 (的子系識別碼，以取得其中一個物件之子項目的說明主題) 。

*pidTopic*<br/>
識別與指定物件相關聯的說明檔主題。 請參閱 Windows SDK 中的[IAccessible：： Get_accHelpTopic](/windows/win32/api/oleacc/nf-oleacc-iaccessible-get_acchelptopic) *pidTopic* 。

### <a name="return-value"></a>傳回值

在成功時傳回 S_OK，失敗時傳回 COM 錯誤碼。 請參閱 Windows SDK 中的傳回 **值** `IAccessible::get_accHelpTopic` 。

### <a name="remarks"></a>備註

此函數是 MFC 的 [Active Accessibility](/windows/win32/WinAuto/microsoft-active-accessibility) 支援的一部分。

覆寫衍生類別中的這個函 `CWnd` 式，以提供有關物件的說明資訊。

如需詳細資訊，請參閱 Windows SDK 中的 [IAccessible：： get_accHelpTopic](/windows/win32/api/oleacc/nf-oleacc-iaccessible-get_acchelptopic) 。

## <a name="cwndget_acckeyboardshortcut"></a><a name="get_acckeyboardshortcut"></a> CWnd：： get_accKeyboardShortcut

由架構呼叫以擷取指定物件的快速鍵或便捷鍵。

```
virtual HRESULT get_accKeyboardShortcut(
    VARIANT varChild,
    BSTR* pszKeyboardShortcut);
```

### <a name="parameters"></a>參數

*varChild*<br/>
指定要抓取的鍵盤快速鍵是物件的物件或其中一個物件的子項目。 這個參數可以是 CHILDID_SELF (取得物件) 或子識別碼 (的相關資訊，以取得物件的子專案) 的相關資訊。

*pszKeyboardShortcut*<br/>
接收當地語系化字串以識別鍵盤快速鍵的 BSTR 位址，如果沒有任何鍵盤快速鍵與指定的物件相關聯，則為 Null。

### <a name="return-value"></a>傳回值

在成功時傳回 S_OK，失敗時傳回 COM 錯誤碼。 請參閱 Windows SDK 中[IAccessible：： get_accKeyboardShortcut](/windows/win32/api/oleacc/nf-oleacc-iaccessible-get_acckeyboardshortcut)的傳回**值**。

### <a name="remarks"></a>備註

此函數是 MFC 的 [Active Accessibility](/windows/win32/WinAuto/microsoft-active-accessibility) 支援的一部分。

覆寫 `CWnd` 衍生類別中的這個函式，以識別物件的鍵盤快速鍵。

如需詳細資訊，請參閱 Windows SDK 中的 [IAccessible：： get_accKeyboardShortcut](/windows/win32/api/oleacc/nf-oleacc-iaccessible-get_acckeyboardshortcut) 。

## <a name="cwndget_accname"></a><a name="get_accname"></a> CWnd：： get_accName

由架構呼叫以擷取指定物件的名稱。

```
virtual HRESULT get_accName(
    VARIANT varChild,
    BSTR* pszName);
```

### <a name="parameters"></a>參數

*varChild*<br/>
指定要抓取的名稱是物件的名稱或物件的其中一個子項目。 這個參數可以是 CHILDID_SELF (取得物件) 或子識別碼 (的相關資訊，以取得物件的子專案) 的相關資訊。

*pszName*<br/>
接收字串的 BSTR 位址，該字串包含指定之物件的名稱。

### <a name="return-value"></a>傳回值

在成功時傳回 S_OK，失敗時傳回 COM 錯誤碼。 請參閱 Windows SDK 中[IAccessible：： get_accName](/windows/win32/api/oleacc/nf-oleacc-iaccessible-get_accname)的傳回**值**。

### <a name="remarks"></a>備註

此函數是 MFC 的 [Active Accessibility](/windows/win32/WinAuto/microsoft-active-accessibility) 支援的一部分。

覆寫衍生類別中的這個函 `CWnd` 式，以傳回物件的名稱。

如需詳細資訊，請參閱 Windows SDK 中的 [IAccessible：： get_accName](/windows/win32/api/oleacc/nf-oleacc-iaccessible-get_accname) 。

## <a name="cwndget_accparent"></a><a name="get_accparent"></a> CWnd：： get_accParent

由架構呼叫以擷取物件之父代的 `IDispatch` 介面。

```
virtual HRESULT get_accParent(IDispatch** ppdispParent);
```

### <a name="parameters"></a>參數

*ppdispParent*<br/>
接收父物件之介面的位址 `IDispatch` 。 如果沒有父系存在，或子系無法存取其父系，則變數會設為 Null。

### <a name="return-value"></a>傳回值

在成功時傳回 S_OK，失敗時傳回 COM 錯誤碼。 請參閱 Windows SDK 中[IAccessible：： get_accParent](/windows/win32/api/oleacc/nf-oleacc-iaccessible-get_accparent)的傳回**值**。

### <a name="remarks"></a>備註

此函數是 MFC 的 [Active Accessibility](/windows/win32/WinAuto/microsoft-active-accessibility) 支援的一部分。

在大部分情況下，您不需要覆寫此函數。

如需詳細資訊，請參閱 Windows SDK 中的 [IAccessible：： get_accParent](/windows/win32/api/oleacc/nf-oleacc-iaccessible-get_accparent) 。

## <a name="cwndget_accrole"></a><a name="get_accrole"></a> CWnd：： get_accRole

由架構呼叫以擷取含有指定物件的角色描述資訊。

```
virtual HRESULT get_accRole(
    VARIANT varChild,
    VARIANT* pvarRole);
```

### <a name="parameters"></a>參數

*varChild*<br/>
指定要抓取的角色資訊是物件的物件或其中一個物件的子項目。 這個參數可以是 CHILDID_SELF (取得物件) 或子識別碼 (的相關資訊，以取得物件的子專案) 的相關資訊。

*pvarRole*<br/>
接收角色資訊。 請參閱 Windows SDK 中的[IAccessible：： Get_accRole](/windows/win32/api/oleacc/nf-oleacc-iaccessible-get_accrole) *pvarRole* 。

### <a name="return-value"></a>傳回值

在成功時傳回 S_OK，失敗時傳回 COM 錯誤碼。 請參閱 Windows SDK 中的傳回 **值** `IAccessible::get_accRole` 。

### <a name="remarks"></a>備註

此函數是 MFC 的 [Active Accessibility](/windows/win32/WinAuto/microsoft-active-accessibility) 支援的一部分。

`CWnd`如果您有 nonwindowed 使用者介面專案 (非視窗的 ActiveX 控制項（MFC 會處理) ）以外的專案，請在衍生類別中覆寫此函數。

如需詳細資訊，請參閱 Windows SDK 中的 [IAccessible：： get_accRole](/windows/win32/api/oleacc/nf-oleacc-iaccessible-get_accrole) 。

## <a name="cwndget_accselection"></a><a name="get_accselection"></a> CWnd：： get_accSelection

由架構呼叫以擷取此物件的選取子物件。

```
virtual HRESULT get_accSelection(VARIANT* pvarChildren);
```

### <a name="parameters"></a>參數

*pvarChildren*<br/>
接收選取的子系的相關資訊。 請參閱 Windows SDK 中的[IAccessible：： Get_accSelection](/windows/win32/api/oleacc/nf-oleacc-iaccessible-get_accselection) *pvarChildren* 。

### <a name="return-value"></a>傳回值

在成功時傳回 S_OK，失敗時傳回 COM 錯誤碼。 請參閱 Windows SDK 中的傳回 **值** `IAccessible::get_accSelection` 。

### <a name="remarks"></a>備註

此函數是 MFC 的 [Active Accessibility](/windows/win32/WinAuto/microsoft-active-accessibility) 支援的一部分。

`CWnd`如果您有 nonwindowed 使用者介面專案 (非視窗的 ActiveX 控制項（MFC 會處理) ）以外的專案，請在衍生類別中覆寫此函數。

如需詳細資訊，請參閱 Windows SDK 中的 [IAccessible：： get_accSelection](/windows/win32/api/oleacc/nf-oleacc-iaccessible-get_accselection) 。

## <a name="cwndget_accstate"></a><a name="get_accstate"></a> CWnd：： get_accState

由架構呼叫以擷取指定物件的目前狀態。

```
virtual HRESULT get_accState(
    VARIANT varChild,
    VARIANT* pvarState);
```

### <a name="parameters"></a>參數

*varChild*<br/>
指定要抓取的狀態資訊是物件的或其中一個物件的子項目。 這個參數可以是 CHILDID_SELF (取得物件) 或子識別碼 (的相關資訊，以取得物件的子專案) 的相關資訊。

*pvarState*<br/>
接收物件狀態的相關資訊。 請參閱 Windows SDK 中的[IAccessible：： Get_accState](/windows/win32/api/oleacc/nf-oleacc-iaccessible-get_accstate) *pvarState* 。

### <a name="return-value"></a>傳回值

在成功時傳回 S_OK，失敗時傳回 COM 錯誤碼。 請參閱 Windows SDK 中的傳回 **值** `IAccessible::get_accState` 。

### <a name="remarks"></a>備註

此函數是 MFC 的 [Active Accessibility](/windows/win32/WinAuto/microsoft-active-accessibility) 支援的一部分。

`CWnd`如果您有 nonwindowed 使用者介面專案 (非視窗的 ActiveX 控制項（MFC 會處理) ）以外的專案，請在衍生類別中覆寫此函數。

如需詳細資訊，請參閱 Windows SDK 中的 [IAccessible：： get_accState](/windows/win32/api/oleacc/nf-oleacc-iaccessible-get_accstate) 。

## <a name="cwndget_accvalue"></a><a name="get_accvalue"></a> CWnd：： get_accValue

由架構呼叫以擷取指定物件的值。

```
virtual HRESULT get_accValue(
    VARIANT varChild,
    BSTR* pszValue);
```

### <a name="parameters"></a>參數

*varChild*<br/>
指定要抓取的值資訊是物件的值，還是物件的其中一個子項目。 這個參數可以是 CHILDID_SELF (取得物件) 或子識別碼 (的相關資訊，以取得物件的子專案) 的相關資訊。

*pszValue*<br/>
接收包含物件目前值之當地語系化字串的 BSTR 位址。

### <a name="return-value"></a>傳回值

在成功時傳回 S_OK，失敗時傳回 COM 錯誤碼。 請參閱 Windows SDK 中[IAccessible：： get_accValue](/windows/win32/api/oleacc/nf-oleacc-iaccessible-get_accvalue)的傳回**值**。

### <a name="remarks"></a>備註

此函數是 MFC 的 [Active Accessibility](/windows/win32/WinAuto/microsoft-active-accessibility) 支援的一部分。

`CWnd`如果您有 nonwindowed 使用者介面專案 (非視窗的 ActiveX 控制項（MFC 會處理) ）以外的專案，請在衍生類別中覆寫此函數。

如需詳細資訊，請參閱 Windows SDK 中的 [IAccessible：： get_accValue](/windows/win32/api/oleacc/nf-oleacc-iaccessible-get_accvalue) 。

## <a name="cwndgetactivewindow"></a><a name="getactivewindow"></a> CWnd：： GetActiveWindow

捕獲使用中視窗的指標。

```
static CWnd* PASCAL GetActiveWindow();
```

### <a name="return-value"></a>傳回值

使用中視窗，如果在呼叫時沒有視窗處於使用中狀態，則為 Null。 該指標可能是暫時性的，因此不應該儲存供日後使用。

### <a name="remarks"></a>備註

使用中視窗是具有目前輸入焦點的視窗，或是 [SetActiveWindow](#setactivewindow) 成員函式明確設為作用中的視窗。

## <a name="cwndgetancestor"></a><a name="getancestor"></a> CWnd：： GetAncestor

擷取指定視窗的上階視窗物件。

```
CWnd* GetAncestor(UINT gaFlags) const;
```

### <a name="parameters"></a>參數

*gaFlags*<br/>
指定要取出的上階。 如需可能值的完整清單，請參閱 [GetAncestor](/windows/win32/api/winuser/nf-winuser-getancestor)。

### <a name="return-value"></a>傳回值

如果函式成功，則傳回值是上階視窗物件的指標。 如果函式失敗，則傳回值為 Null。

### <a name="remarks"></a>備註

此成員函式會模擬函數 [GetAncestor](/windows/win32/api/winuser/nf-winuser-getancestor)的功能，如 Windows SDK 所述。

## <a name="cwndgetcapture"></a><a name="getcapture"></a> CWnd：： GetCapture

抓取具有滑鼠捕捉的視窗。

```
static CWnd* PASCAL GetCapture();
```

### <a name="return-value"></a>傳回值

識別具有滑鼠捕捉的視窗。 如果沒有視窗具有滑鼠捕捉，則為 Null。

傳回值可能是暫時性的，不應儲存供稍後使用。

### <a name="remarks"></a>備註

在任何指定的時間，只有一個視窗具有滑鼠捕捉。 呼叫 [SetCapture](#setcapture) 成員函式時，視窗會收到滑鼠捕捉。 無論游標是否在其框線內，此視窗都會收到滑鼠輸入。

## <a name="cwndgetcaretpos"></a><a name="getcaretpos"></a> CWnd：： GetCaretPos

抓取插入號的目前位置的用戶端座標，並將其傳回做為 `CPoint` 。

```
static CPoint PASCAL GetCaretPos();
```

### <a name="return-value"></a>傳回值

[CPoint](../../atl-mfc-shared/reference/cpoint-class.md) 物件，其中包含插入號位置的座標。

### <a name="remarks"></a>備註

在視窗的用戶端座標中會提供插入號位置 `CWnd` 。

## <a name="cwndgetcheckedradiobutton"></a><a name="getcheckedradiobutton"></a> CWnd：： GetCheckedRadioButton

抓取指定群組中目前已選取之選項按鈕的識別碼。

```
int GetCheckedRadioButton(
    int nIDFirstButton,
    int nIDLastButton);
```

### <a name="parameters"></a>參數

*nIDFirstButton*<br/>
指定群組中第一個選項按鈕的整數識別碼。

*nIDLastButton*<br/>
指定群組中最後一個選項按鈕的整數識別碼。

### <a name="return-value"></a>傳回值

核取之選項按鈕的識別碼，如果未選取任何識別碼，則為0。

## <a name="cwndgetclientrect"></a><a name="getclientrect"></a> CWnd：： GetClientRect

將用戶端區域的用戶端座標複製 `CWnd` 到 *lpRect*所指向的結構中。

```cpp
void GetClientRect(LPRECT lpRect) const;
```

### <a name="parameters"></a>參數

*lpRect*<br/>
指向 [RECT 結構](/windows/win32/api/windef/ns-windef-rect) 或 `CRect` 物件以接收用戶端座標。 `left`和 `top` 成員將會是0。 `right`和 `bottom` 成員會包含視窗的寬度和高度。

### <a name="remarks"></a>備註

用戶端座標指定工作區的左上角和右下角。 由於用戶端座標是相對於工作區的左上角 `CWnd` ，因此左上角的座標是 (0、0) 。

### <a name="example"></a>範例

  請參閱 [CWnd：： IsIconic](#isiconic)的範例。

## <a name="cwndgetclipboardowner"></a><a name="getclipboardowner"></a> CWnd：： GetClipboardOwner

抓取剪貼簿的目前擁有者。

```
static CWnd* PASCAL GetClipboardOwner();
```

### <a name="return-value"></a>傳回值

如果函式成功，則識別擁有剪貼簿的視窗。 否則，它會是 Null。

傳回的指標可能是暫時性的，不應儲存供稍後使用。

### <a name="remarks"></a>備註

剪貼簿仍可包含資料（即使目前未擁有）。

## <a name="cwndgetclipboardviewer"></a><a name="getclipboardviewer"></a> CWnd：： GetClipboardViewer

抓取剪貼簿-檢視器鏈中的第一個視窗。

```
static CWnd* PASCAL GetClipboardViewer();
```

### <a name="return-value"></a>傳回值

識別目前負責顯示剪貼簿的視窗（如果成功）;否則為 Null (例如，如果沒有檢視器) 。

傳回的指標可能是暫時性的，不應儲存供稍後使用。

## <a name="cwndgetcontrolunknown"></a><a name="getcontrolunknown"></a> CWnd：： GetControlUnknown

呼叫這個成員函式，以取得未知 OLE 控制項的指標。

```
LPUNKNOWN GetControlUnknown();
```

### <a name="return-value"></a>傳回值

這個物件所表示之 OLE 控制項的 [IUnknown](/windows/win32/api/unknwn/nn-unknwn-iunknown) 介面指標 `CWnd` 。 如果這個物件不代表 OLE 控制項，則傳回值為 Null。

### <a name="remarks"></a>備註

您不應該釋放這個 `IUnknown` 指標。 一般而言，您會使用來取得控制項的特定介面。

傳回的介面指標 `GetControlUnknown` 不是參考計數。 請勿在指標上呼叫 [iunknown：： Release](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) ，除非您先前已對其呼叫 [Iunknown：： AddRef](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) 。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#96](../../mfc/reference/codesnippet/cpp/cwnd-class_35.cpp)]

## <a name="cwndgetcurrentmessage"></a><a name="getcurrentmessage"></a> CWnd：： GetCurrentMessage

傳回此視窗目前正在處理的訊息指標。 只有當在<em>message</em> **message 訊息**處理常式成員函式中時，才應該呼叫。

```
static const MSG* PASCAL GetCurrentMessage();
```

### <a name="return-value"></a>傳回值

傳回 [訊息結構的指標，其中](/windows/win32/api/winuser/ns-winuser-msg) 包含視窗目前正在處理的訊息。 只有當在<em>訊息</em>處理常式**上**時，才應該呼叫。

### <a name="example"></a>範例

  請參閱 [CMDIFrameWnd：： MDICascade](../../mfc/reference/cmdiframewnd-class.md#mdicascade)的範例。

## <a name="cwndgetdc"></a><a name="getdc"></a> CWnd：： GetDC

根據針對指定的類別樣式，取得用戶端區域之一般、類別或私用裝置內容的指標 `CWnd` 。

```
CDC* GetDC();
```

### <a name="return-value"></a>傳回值

`CWnd`如果成功，則識別工作區的裝置內容，否則傳回值為 Null。 該指標可能是暫時性的，因此不應該儲存供日後使用。

### <a name="remarks"></a>備註

針對常見的裝置 `GetDC` 內容，會在每次抓取內容時，將預設屬性指派給內容。 針對類別和私用內容， `GetDC` 保留先前指派的屬性不變。 裝置內容可以用於後續的圖形裝置介面 (GDI) 函式在工作區中繪製。

除非裝置內容屬於視窗類別，否則必須呼叫 [ReleaseDC](#releasedc) 成員函式，以在繪製之後釋放內容。

成員函式會傳回屬於類別的裝置內容（ `CWnd` `GetDC` 如果 CS_CLASSDC、CS_OWNDC 或 CS_PARENTDC 在 `WNDCLASS` 註冊類別時，指定為結構中的樣式）。

## <a name="cwndgetdcex"></a><a name="getdcex"></a> CWnd：： GetDCEx

捕獲視窗的裝置內容控制碼 `CWnd` 。

```
CDC* GetDCEx(
    CRgn* prgnClip,
    DWORD flags);
```

### <a name="parameters"></a>參數

*prgnClip*<br/>
識別可能與用戶端視窗的可見區域結合的裁剪區域。

*flags*<br/>
可以具有下列其中一個預設值：

- DCX_CACHE 會從快取傳回裝置內容，而不是 OWNDC 或 CLASSDC 視窗。 覆寫 CS_OWNDC 和 CS_CLASSDC。

- DCX_CLIPCHILDREN 排除視窗下所有子視窗的可見區域 `CWnd` 。

- DCX_CLIPSIBLINGS 排除視窗上方所有同級視窗的可見區域 `CWnd` 。

- DCX_EXCLUDERGN 從傳回的裝置內容的可見區域排除 *prgnClip* 所識別的裁剪區域。

- DCX_INTERSECTRGN 會在所傳回裝置內容的可見區域內，與 *prgnClip* 所識別的裁剪區域交集。

- DCX_LOCKWINDOWUPDATE 即使有 `LockWindowUpdate` 作用中的呼叫也會排除此視窗，也會允許繪圖。 此值可用於追蹤期間的繪圖。

- DCX_PARENTCLIP 使用父視窗的可見區域，並忽略父視窗的 WS_CLIPCHILDREN 和 WS_PARENTDC 樣式位。 此值會將裝置內容的原點設定為視窗的左上角 `CWnd` 。

- DCX_WINDOW 會傳回對應至視窗矩形的裝置內容，而不是用戶端矩形。

### <a name="return-value"></a>傳回值

如果函式成功，則為指定之視窗的裝置內容;否則為 Null。

### <a name="remarks"></a>備註

裝置內容可以在後續的 GDI 函式中用來在工作區中繪製。

此函式是 [GetDC](/windows/win32/api/winuser/nf-winuser-getdc) 函式的擴充功能，可讓應用程式更能控制是否要裁剪視窗的裝置內容。

除非裝置內容屬於視窗類別，否則必須呼叫 [ReleaseDC](/windows/win32/api/winuser/nf-winuser-releasedc) 函式，以在繪製之後釋放內容。 由於在任何指定時間只有五個常見的裝置內容可供使用，因此無法釋出裝置內容可以防止其他應用程式取得裝置內容的存取權。

若要取得快取的裝置內容，應用程式必須指定 [DCX_CACHE](/windows/win32/api/winuser/nf-winuser-getdcex)。 如果未指定 DCX_CACHE，且視窗不是 CS_OWNDC 或 [CS_CLASSDC](/windows/win32/api/winuser/ns-winuser-wndclassw)，則此函數會傳回 Null。

[GetDCEx](/windows/win32/api/winuser/nf-winuser-getdcex)函式會傳回具有特殊特性的裝置內容（如果在註冊類別時， [WNDCLASS](/windows/win32/api/winuser/ns-winuser-wndclassw)結構中指定了 CS_CLASSDC、 [CS_OWNDC](/windows/win32/api/winuser/ns-winuser-wndclassw)或[CS_PARENTDC](/windows/win32/api/winuser/ns-winuser-wndclassw)樣式）。

如需這些特性的詳細資訊，請參閱 `WNDCLASS` Windows SDK 中結構的描述。

## <a name="cwndgetdcrendertarget"></a><a name="getdcrendertarget"></a> CWnd：： GetDCRenderTarget

擷取裝置內容 (DC) 會呈現 `CWnd` 視窗的目標。

```
CDCRenderTarget* GetDCRenderTarget();
```

### <a name="return-value"></a>傳回值

如果函式成功，裝置內容會呈現指定視窗的目標，否則為 NULL。

### <a name="remarks"></a>備註

## <a name="cwndgetdescendantwindow"></a><a name="getdescendantwindow"></a> CWnd：： GetDescendantWindow

呼叫這個成員函式，以找出指定之識別碼所指定的子系視窗。

```
CWnd* GetDescendantWindow(
    int nID,
    BOOL bOnlyPerm = FALSE) const;
```

### <a name="parameters"></a>參數

*nID*<br/>
指定要取出的控制項或子視窗的識別碼。

*bOnlyPerm*<br/>
指定要傳回的視窗是否可以是暫時性的。 若為 TRUE，則只會傳回永久視窗;如果為 FALSE，則函式會傳回暫存視窗。 如需有關暫存視窗的詳細資訊，請參閱 [技術提示 3](../../mfc/tn003-mapping-of-windows-handles-to-objects.md)。

### <a name="return-value"></a>傳回值

物件的指標 `CWnd` ，如果找不到子視窗，則為 Null。

### <a name="remarks"></a>備註

此成員函式會搜尋子視窗的整個樹狀結構，而不只是直接子系的視窗。

## <a name="cwndgetdesktopwindow"></a><a name="getdesktopwindow"></a> CWnd：： GetDesktopWindow

傳回 Windows 桌面視窗。

```
static CWnd* PASCAL GetDesktopWindow();
```

### <a name="return-value"></a>傳回值

識別 Windows 桌面視窗。 此指標可能是暫時性的，不應儲存供稍後使用。

### <a name="remarks"></a>備註

桌面視窗涵蓋整個畫面，而是所有圖示和其他視窗都是在其上方繪製的區域。

## <a name="cwndgetdlgctrlid"></a><a name="getdlgctrlid"></a> CWnd：： GetDlgCtrlID

傳回任何子視窗的視窗或控制項識別碼值，而不只是對話方塊中控制項的值。

```
int GetDlgCtrlID() const;
```

### <a name="return-value"></a>傳回值

如果函式成功，則為子視窗的數值識別碼， `CWnd` 否則為0。

### <a name="remarks"></a>備註

因為最上層視窗沒有識別碼值，所以如果 `CWnd` 是最上層視窗，則此函式的傳回值無效。

### <a name="example"></a>範例

  請參閱 [CWnd：： OnCtlColor](#onctlcolor)的範例。

## <a name="cwndgetdlgitem"></a><a name="getdlgitem"></a> CWnd：： GetDlgItem

抓取對話方塊或其他視窗中所指定控制項或子視窗的指標。

```
CWnd* GetDlgItem(int nID) const;

void GetDlgItem(
    int nID,
    HWND* phWnd) const;
```

### <a name="parameters"></a>參數

*nID*<br/>
指定要取出的控制項或子視窗的識別碼。

*phWnd*<br/>
子視窗的指標。

### <a name="return-value"></a>傳回值

給定控制項或子視窗的指標。 如果沒有 *nID* 參數所指定之整數識別碼的控制項存在，則此值為 Null。

傳回的指標可能是暫時性的，不應儲存供稍後使用。

### <a name="remarks"></a>備註

傳回的指標通常會轉換為 *nID*所識別的控制項類型。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#97](../../mfc/reference/codesnippet/cpp/cwnd-class_36.cpp)]

## <a name="cwndgetdlgitemint"></a><a name="getdlgitemint"></a> CWnd：： GetDlgItemInt

抓取 *nID*所識別之控制項的文字。

```
UINT GetDlgItemInt(
    int nID,
    BOOL* lpTrans = NULL,
    BOOL bSigned = TRUE) const;
```

### <a name="parameters"></a>參數

*nID*<br/>
指定要轉譯之對話方塊控制項的整數識別碼。

*lpTrans*<br/>
指向要接收翻譯旗標的布林值變數。

*bSigned*<br/>
指定要取出的值是否經過簽署。

### <a name="return-value"></a>傳回值

指定對話方塊專案文字的翻譯值。 因為0是有效的傳回值，所以必須使用 *lpTrans* 來偵測錯誤。 如果需要帶正負號的傳回值，請將它轉換為 **`int`** 類型。

如果轉譯的數位大於 INT_MAX 的帶正負號的 () 或 UINT_MAX (未簽署的) ，此函數會傳回0。

發生錯誤時（例如，遇到非數位字元並超過上述最大值），會 `GetDlgItemInt` 將0複製到 *lpTrans*所指向的位置。 如果沒有任何錯誤， *lpTrans* 會收到非零值。 如果 *lpTrans* 為 Null，則 `GetDlgItemInt` 不會對錯誤發出警告。

### <a name="remarks"></a>備註

它會將指定對話方塊中指定之控制項的文字轉譯成整數值，方法是在文字的開頭處移除任何額外的空格並轉換小數位數。 它會在到達文字結尾或遇到任何非數位字元時，停止轉譯。

如果 *bSigned* 為 TRUE，會 `GetDlgItemInt` 檢查文字開頭的減號 (-) ，並將文字轉譯為帶正負號的數位。 否則，它會建立不帶正負號的值。

它會將 [WM_GETTEXT](/windows/win32/winmsg/wm-gettext) 訊息傳送至控制項。

## <a name="cwndgetdlgitemtext"></a><a name="getdlgitemtext"></a> CWnd：： GetDlgItemText

呼叫這個成員函式，以取得與對話方塊中控制項相關聯的標題或文字。

```
int GetDlgItemText(
    int nID,
    LPTSTR lpStr,
    int nMaxCount) const;

int GetDlgItemText(
    int nID,
    CString& rString) const;
```

### <a name="parameters"></a>參數

*nID*<br/>
指定要取出其標題之控制項的整數識別碼。

*lpStr*<br/>
指向緩衝區以接收控制項的標題或文字。

*nMaxCount*<br/>
指定要複製到 *lpStr*之字串的最大長度 (（以字元為單位）) 。 如果字串的長度超過 *nMaxCount*，則會被截斷。

*rString*<br/>
[CString](../../atl-mfc-shared/reference/cstringt-class.md)的參考。

### <a name="return-value"></a>傳回值

指定複製到緩衝區的實際字元數，而不包含終止的 null 字元。 如果未複製任何文字，則此值為0。

### <a name="remarks"></a>備註

成員函式 `GetDlgItemText` 會將文字複製到 *lpStr* 所指向的位置，並傳回其複製的位元組數目計數。

## <a name="cwndgetdsccursor"></a><a name="getdsccursor"></a> CWnd：： GetDSCCursor

呼叫這個成員函式，以取得資料來源控制項的 DataSource、使用者名稱、密碼和 SQL 屬性所定義之基礎資料指標的指標。

```
IUnknown* GetDSCCursor();
```

### <a name="return-value"></a>傳回值

資料來源控制項所定義之資料指標的指標。 MFC 會負責呼叫 `AddRef` 指標。

### <a name="remarks"></a>備註

使用傳回的指標來設定複雜資料繫結控制項的 ICursor 屬性，例如資料系結方格控制項。 資料來源控制項在第一個繫結控制項要求其資料指標之前，將不會變成作用中狀態。 這可能會由 MFC 系結管理員的呼叫 `GetDSCCursor` 或隱含方式發生。 無論是哪一種情況，您都可以藉由呼叫 `GetDSCCursor` ，然後 `Release` 在傳回的指標上呼叫，來強制讓資料來源控制項成為使用中狀態 `IUnknown` 。 啟用將會導致資料來源控制項嘗試連接到基礎資料來源。 傳回的指標可能會在下列內容中使用：

### <a name="example"></a>範例

[!code-cpp[NVC_MFC_AxDataBinding#5](../../mfc/reference/codesnippet/cpp/cwnd-class_37.cpp)]

## <a name="cwndgetdynamiclayout"></a><a name="getdynamiclayout"></a> CWnd：： GetDynamicLayout

擷取動態配置管理員物件的指標。

```
CMFCDynamicLayout* GetDynamicLayout();
```

### <a name="return-value"></a>傳回值

動態配置管理員物件的指標，或是如果未啟用動態配置，則為 NULL。

### <a name="remarks"></a>備註

視窗物件擁有及管理傳回的指標存留期，因此它只應該用來存取物件；請勿永久刪除指標或儲存指標。

## <a name="cwndgetexstyle"></a><a name="getexstyle"></a> CWnd：： GetExStyle

傳回視窗的延伸樣式。

```
DWORD GetExStyle() const;
```

### <a name="return-value"></a>傳回值

視窗的延伸樣式。 如需 MFC 中使用之擴充視窗樣式的詳細資訊，請參閱 [擴充的視窗樣式](../../mfc/reference/styles-used-by-mfc.md#extended-window-styles)。

## <a name="cwndgetfocus"></a><a name="getfocus"></a> CWnd：： GetFocus

抓取 `CWnd` 目前具有輸入焦點之的指標。

```
static CWnd* PASCAL GetFocus();
```

### <a name="return-value"></a>傳回值

具有目前焦點之視窗的指標; 如果沒有焦點視窗，則為 Null。

該指標可能是暫時性的，因此不應該儲存供日後使用。

## <a name="cwndgetfont"></a><a name="getfont"></a> CWnd：： GetFont

將 WM_GETFONT 訊息傳送至視窗，以取得目前的字型。

```
CFont* GetFont() const;
```

### <a name="return-value"></a>傳回值

[CFont](../../mfc/reference/cfont-class.md)物件的指標，該物件附加至視窗的目前字型。

### <a name="remarks"></a>備註

除非視窗處理 WM_GETFONT 訊息，否則此方法不會有任何作用。 衍生自的許多 MFC 類別 `CWnd` 會處理此訊息，因為它們附加到預先定義的視窗類別，其中包含 WM_GETFONT 訊息的訊息處理常式。 若要使用這個方法，您衍生自的類別 `CWnd` 必須定義 WM_GETFONT 訊息的方法處理常式。

## <a name="cwndgetforegroundwindow"></a><a name="getforegroundwindow"></a> CWnd：： GetForegroundWindow

傳回前景視窗的指標， (使用者目前) 的工作視窗。

```
static CWnd* PASCAL GetForegroundWindow();
```

### <a name="return-value"></a>傳回值

前景視窗的指標。 這可能是暫存 `CWnd` 物件。

### <a name="remarks"></a>備註

前景視窗只適用于最上層 windows (框架視窗或對話方塊) 。

## <a name="cwndgeticon"></a><a name="geticon"></a> CWnd：： GetIcon

呼叫這個成員函式，以取得大型 (32x32) 的控制碼，或小 (16x16) 圖示的控制碼，如 *bBigIcon*所示。

```
HICON GetIcon(BOOL bBigIcon) const;
```

### <a name="parameters"></a>參數

*bBigIcon*<br/>
若為 TRUE，則指定32圖元乘以32圖元圖示;如果為 FALSE，則指定16圖元 x 16 圖元圖示。

### <a name="return-value"></a>傳回值

圖示的控制代碼。 如果不成功，則傳回 Null。

## <a name="cwndgetlastactivepopup"></a><a name="getlastactivepopup"></a> CWnd：： GetLastActivePopup

判斷 `CWnd` 擁有的快顯視窗哪一個是最近啟用的。

```
CWnd* GetLastActivePopup() const;
```

### <a name="return-value"></a>傳回值

識別最近活動的快顯視窗。 如果符合下列任一條件，則傳回值會是視窗本身：

- 視窗本身是最近使用中的狀態。

- 視窗並未擁有任何快顯視窗。

- 視窗不是最上層視窗，也不是由另一個視窗所擁有。

該指標可能是暫時性的，因此不應該儲存供日後使用。

### <a name="example"></a>範例

  請參閱 [CWnd：： FindWindow](#findwindow)的範例。

## <a name="cwndgetlayeredwindowattributes"></a><a name="getlayeredwindowattributes"></a> CWnd：： GetLayeredWindowAttributes

擷取分層視窗的不透明和透明色鍵。

```
BOOL GetLayeredWindowAttributes(
    COLORREF* pcrKey,
    BYTE* pbAlpha,
    DWORD* pdwFlags) const;
```

### <a name="parameters"></a>參數

*pcrKey*<br/>
COLORRE光圈值的指標，此值會接收在撰寫分層視窗時所要使用的透明色彩索引鍵。 視窗在此色彩中繪製的所有圖元都是透明的。 如果不需要引數，這可以是 Null。

*pbAlpha*<br/>
接收 Alpha 值的位元組指標，用來描述分層視窗的不透明度。 當 *pbAlpha* 所參考的變數是0時，此視窗是完全透明的。 當 *pbAlpha* 所參考的變數為255時，此視窗是不透明的。 如果不需要引數，這可以是 Null。

*pdwFlags*<br/>
接收分層旗標的 DWORD 指標。 如果不需要引數，這可以是 Null。 如需可能值的完整清單，請參閱 [GetLayeredWindowAttributes](/windows/win32/api/winuser/nf-winuser-getlayeredwindowattributes)。

### <a name="return-value"></a>傳回值

如果函式成功則為非零值，否則為 0。

### <a name="remarks"></a>備註

此成員函式會模擬函數 [GetLayeredWindowAttributes](/windows/win32/api/winuser/nf-winuser-getlayeredwindowattributes)的功能，如 Windows SDK 所述。

## <a name="cwndgetmenu"></a><a name="getmenu"></a> CWnd：： GetMenu

抓取此視窗功能表的指標。

```
CMenu* GetMenu() const;
```

### <a name="return-value"></a>傳回值

識別功能表。 如果沒有功能表，則值為 Null `CWnd` 。 如果是子視窗，傳回值會是未定義的 `CWnd` 。

傳回的指標可能是暫時性的，不應儲存供稍後使用。

### <a name="remarks"></a>備註

這個函式不能用於子視窗，因為它們沒有功能表。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#98](../../mfc/reference/codesnippet/cpp/cwnd-class_38.cpp)]

## <a name="cwndgetmenubarinfo"></a><a name="getmenubarinfo"></a> CWnd：： GetMenuBarInfo

抓取指定功能表列的相關資訊。

```
BOOL GetMenuBarInfo(
    LONG idObject,
    LONG idItem,
    PMENUBARINFO pmbi) const;
```

### <a name="parameters"></a>參數

*idObject*<br/>
指定功能表物件。 如需可能值的清單，請參閱 [GetMenuBarInfo](/windows/win32/api/winuser/nf-winuser-getmenubarinfo)。

*idItem*<br/>
指定要取得其資訊的專案。 如果此參數為零，則函式會抓取功能表本身的相關資訊。 如果這個參數是1，則函式會抓取功能表上第一個專案的相關資訊，依此類推。

*pmbi*<br/>
接收資訊之 [MENUBARINFO](/windows/win32/api/winuser/ns-winuser-menubarinfo) 結構的指標。

### <a name="return-value"></a>傳回值

如果函式成功則為非零值，否則為 0。

### <a name="remarks"></a>備註

此成員函式會模擬函數 [GetMenuBarInfo](/windows/win32/api/winuser/nf-winuser-getmenubarinfo)的功能，如 Windows SDK 所述。

## <a name="cwndgetnextdlggroupitem"></a><a name="getnextdlggroupitem"></a> CWnd：： GetNextDlgGroupItem

在對話方塊中，搜尋控制項群組內的上一個或下一個控制項。

```
CWnd* GetNextDlgGroupItem(
    CWnd* pWndCtl,
    BOOL bPrevious = FALSE) const;

COleControlSiteOrWnd* GetNextDlgGroupItem(
    COleControlSiteOrWnd* pCurSiteOrWnd = NULL) const;
```

### <a name="parameters"></a>參數

*pWndCtl*<br/>
識別要當做搜尋起點使用的控制項。

*bPrevious*<br/>
指定函數如何在對話方塊中搜尋控制項群組。 若為 TRUE，則函式會在群組中搜尋先前的控制項;如果為 FALSE，則會搜尋群組中的下一個控制項。

*pCurSiteOrWnd*<br/>
識別 `COleControlSiteOrWnd` 控制項。 如需的詳細資訊 `COleControlSiteOrWnd` ，請參閱 **備註**。

### <a name="return-value"></a>傳回值

如果成員函式成功，則為群組中上一個或下一個控制項的指標。

傳回的指標可能是暫時性的，不應儲存供稍後使用。

### <a name="remarks"></a>備註

控制項群組的開頭是使用 [WS_GROUP](styles-used-by-mfc.md#window-styles) 樣式所建立的控制項，並以 WS_GROUP 樣式所建立的最後一個控制項做為結尾。

依預設，成員函式會將 `GetNextDlgGroupItem` 指標傳回至群組中的下一個控制項。 如果 *pWndCtl* 識別群組中的第一個控制項，而 *bPrevious* 為 TRUE，則會將 `GetNextDlgGroupItem` 指標傳回至群組中的最後一個控制項。

> [!NOTE]
> 由於 MFC 支援無視窗的 ActiveX 控制項、標準 ActiveX 控制項和 windows，因此只會在 HWND 不再尾碼的情況下參考控制項。 此 `COleControlSiteOrWnd` 物件包含將物件識別為視窗型 activex 控制項、無視窗 activex 控制項或視窗的資訊，如下所示：

|控制項或視窗類型|識別資訊|
|----------------------------|-----------------------------|
|視窗型 ActiveX 控制項|包含 HWND，並將 [COleControlSite](../../mfc/reference/colecontrolsite-class.md) 物件與其相關聯。 的 `m_hWnd` 成員 `COleControlSiteOrWnd` 會設定為控制項的 HWND，而 `m_pSite` 成員會指向控制項的 `COleControlSite` 。|
|無視窗的 ActiveX 控制項|不包含 HWND。 的 `m_pSite` 成員 `COleControlSiteOrWnd` 會指向控制項的 `COleControlSite` ，而 `m_hWnd` 成員為 Null。|
|標準視窗|只包含 HWND。 的 `m_hWnd` 成員 `COleControlSiteOrWnd` 設定為視窗的 HWND，而 `m_pSite` 成員為 Null。|

## <a name="cwndgetnextdlgtabitem"></a><a name="getnextdlgtabitem"></a> CWnd：： GetNextDlgTabItem

抓取第一個控制項的指標，該控制項是使用 [WS_TABSTOP](styles-used-by-mfc.md#window-styles) 樣式所建立，並在指定的控制項之前或之後。

```
CWnd* GetNextDlgTabItem(
    CWnd* pWndCtl,
    BOOL bPrevious = FALSE) const;

COleControlSiteOrWnd* GetNextDlgTabItem(
    COleControlSiteOrWnd* pCurSiteOrWnd,
    BOOL bPrevious) const;
```

### <a name="parameters"></a>參數

*pWndCtl*<br/>
識別要當做搜尋起點使用的控制項。

*pCurSiteOrWnd*<br/>
識別 `COleControlSiteOrWnd` 控制項。 如需的詳細資訊 `COleControlSiteOrWnd` ，請參閱 [CWnd：： GetNextDlgGroupItem](#getnextdlggroupitem)。

*bPrevious*<br/>
指定函數如何搜尋對話方塊。 若為 TRUE，則函式會在對話方塊中搜尋先前的控制項;如果為 FALSE，則會搜尋下一個控制項。

### <a name="return-value"></a>傳回值

如果成員函式成功，則為具有 WS_TABSTOP 樣式之上一個或下一個控制項的指標。

傳回的指標可能是暫時性的，不應儲存供稍後使用。

如需的詳細資訊 `COleControlSiteOrWnd` ，請參閱 [CWnd：： GetNextDlgGroupItem](#getnextdlggroupitem)。

## <a name="cwndgetnextwindow"></a><a name="getnextwindow"></a> CWnd：： GetNextWindow

在 [視窗管理員] 清單中搜尋下一個 (或先前的) 視窗。

```
CWnd* GetNextWindow(UINT nFlag = GW_HWNDNEXT) const;
```

### <a name="parameters"></a>參數

*nFlag*<br/>
指定函式是否傳回下一個視窗或上一個視窗的指標。 它可以是 GW_HWNDNEXT，其會傳回視窗管理員清單上的物件後面的視窗 `CWnd` ，或 GW_HWNDPREV，它會傳回視窗管理員清單上的上一個視窗。

### <a name="return-value"></a>傳回值

如果成員函式成功，則識別 [視窗管理員] 清單中的下一個 (或先前的) 視窗。

傳回的指標可能是暫時性的，不應儲存供稍後使用。

### <a name="remarks"></a>備註

視窗管理員的清單包含所有最上層視窗的專案、其相關聯的子視窗，以及任何子視窗的子視窗。

如果 `CWnd` 是最上層視窗，此函式會搜尋下一個 (或先前) 最上層視窗; 如果 `CWnd` 是子視窗，此函式會搜尋下一個 (或先前的) 子視窗。

## <a name="cwndgetolecontrolsite"></a><a name="getolecontrolsite"></a> CWnd：： GetOleControlSite

擷取指定的 ActiveX 控制項的自訂網站。

```
COleControlSite* GetOleControlSite(UINT idControl) const;
```

### <a name="parameters"></a>參數

*idControl*<br/>
ActiveX 控制項的識別碼。

## <a name="cwndgetopenclipboardwindow"></a><a name="getopenclipboardwindow"></a> CWnd：： GetOpenClipboardWindow

抓取目前開啟剪貼簿的視窗控制碼。

```
static CWnd* PASCAL GetOpenClipboardWindow();
```

### <a name="return-value"></a>傳回值

如果函式成功，則為目前開啟剪貼簿的視窗控制碼;否則為 Null。

## <a name="cwndgetowner"></a><a name="getowner"></a> CWnd：： GetOwner

抓取視窗擁有者的指標。

```
CWnd* GetOwner() const;
```

### <a name="return-value"></a>傳回值

`CWnd` 物件的指標。

### <a name="remarks"></a>備註

如果視窗沒有擁有者，則預設會傳回父視窗物件的指標。 請注意，擁有者與擁有者之間的關聯性，與在數個重要方面不同于父子式層面。 例如，具有父系的視窗會限制為其父視窗的工作區。 擁有的視窗可以在桌面上的任何位置繪製。

此函數的擁有權概念與 [GetWindow](/windows/win32/api/winuser/nf-winuser-getwindow)的擁有權概念不同。

## <a name="cwndgetparent"></a><a name="getparent"></a> CWnd：： GetParent

呼叫此函式可取得子視窗的父視窗 (（如果有任何) ）的指標。

```
CWnd* GetParent() const;
```

### <a name="return-value"></a>傳回值

請參閱 Windows SDK 中 [GetParent](/windows/win32/api/winuser/nf-winuser-getparent) 的傳回值一節。

### <a name="remarks"></a>備註

函式 `GetParent` 會傳回直屬父 (的指標（如果存在）) 。 相反地， [GetParentOwner](#getparentowner) 函式會傳回不是子視窗的最直屬父代或主控視窗的指標， (沒有 WS_CHILD 樣式) 。 如果子視窗內有子視窗 `GetParent` ，並傳回 `GetParentOwner` 不同的結果。

## <a name="cwndgetparentframe"></a><a name="getparentframe"></a> CWnd：： GetParentFrame

呼叫這個成員函式，以取得父框架視窗。

```
CFrameWnd* GetParentFrame() const;
```

### <a name="return-value"></a>傳回值

如果成功，則為框架視窗的指標;否則為 Null。

### <a name="remarks"></a>備註

成員函式會搜尋父鏈，直到找到 [CFrameWnd](../../mfc/reference/cframewnd-class.md) (或衍生類別) 物件為止。

## <a name="cwndgetparentowner"></a><a name="getparentowner"></a> CWnd：： GetParentOwner

呼叫這個成員函式，以取得子視窗的父視窗或擁有者視窗的指標。

```
CWnd* GetParentOwner() const;
```

### <a name="return-value"></a>傳回值

`CWnd` 物件的指標。 如果 `CWnd` 物件沒有附加至控制代碼，會建立並附加暫存 `CWnd` 物件。 該指標可能是暫時性的，因此不應該儲存供日後使用。

### <a name="remarks"></a>備註

`GetParentOwner` 傳回不是子視窗的最直屬父代或主控視窗的指標， (沒有 WS_CHILD 樣式) 。 您可以使用 [SetOwner](#setowner)來設定目前的擁有者視窗。 根據預設，視窗的父系是其擁有者。

相反地， [GetParent](#getparent) 函式會傳回直屬父系的指標，不論它是否為子視窗。 如果子視窗內有子視窗 `GetParent` ，並傳回 `GetParentOwner` 不同的結果。

## <a name="cwndgetproperty"></a><a name="getproperty"></a> CWnd：： GetProperty

呼叫這個成員函式，以取得 *dwDispID*所指定的 ActiveX 控制項屬性。

```cpp
void GetProperty(
    DISPID dwDispID,
    VARTYPE vtProp,
    void* pvProp)const;
```

### <a name="parameters"></a>參數

*dwDispID*<br/>
識別要取出的屬性。

*vtProp*<br/>
指定要抓取的屬性型別。 如需可能的值，請參閱 [COleDispatchDriver::InvokeHelper](../../mfc/reference/coledispatchdriver-class.md#invokehelper)的＜備註＞一節。

*pvProp*<br/>
將接收屬性值之變數的位址。 它必須符合 *vtProp*所指定的類型。

### <a name="remarks"></a>備註

`GetProperty` 透過 *pvProp*傳回值。

> [!NOTE]
> 這個函式應該只在 `CWnd` 代表 ActiveX 控制項的物件上呼叫。

如需有關搭配 ActiveX 控制項容器使用這個成員函式的詳細資訊，請參閱 Activex 控制項容器文章 [： Activex 控制項容器中的 activex 控制項程式設計](../../mfc/programming-activex-controls-in-a-activex-control-container.md)。

## <a name="cwndgetrendertarget"></a><a name="getrendertarget"></a> CWnd：： GetRenderTarget

取得與此視窗相關聯的呈現目標。

```
CHwndRenderTarget* GetRenderTarget();
```

### <a name="return-value"></a>傳回值

呈現目標的指標或 Null。

## <a name="cwndgetsafehwnd"></a><a name="getsafehwnd"></a> CWnd：： GetSafeHwnd

`m_hWnd`如果指標為 null，則傳回，否則為 null **`this`** 。

```
HWND GetSafeHwnd() const;
```

### <a name="return-value"></a>傳回值

傳回視窗的視窗控制碼。 如果未 `CWnd` 附加至視窗，或搭配 null 指標使用，則會傳回 null `CWnd` 。

### <a name="example"></a>範例

  請參閱 [CWnd：： SubclassWindow](#subclasswindow)的範例。

## <a name="cwndgetsafeowner"></a><a name="getsafeowner"></a> CWnd：： GetSafeOwner

呼叫這個成員函式，以抓取應該用於對話方塊或其他強制回應視窗的擁有者視窗。

```
static CWnd* GetSafeOwner(
    CWnd* pParent = NULL,
    HWND* pWndTop = NULL);
```

### <a name="parameters"></a>參數

*pParent*<br/>
父視窗的指標 `CWnd` 。 可能是 NULL。

*pWndTop*<br/>
目前位於頂端之視窗的指標。 可能是 NULL。

### <a name="return-value"></a>傳回值

給定視窗之安全擁有者的指標。

### <a name="remarks"></a>備註

Safe owner 是 *pParent*的第一個非子系父視窗。 如果 *pParent* 為 Null，則會使用) 透過 [AfxGetMainWnd](../../mfc/reference/application-information-and-management.md#afxgetmainwnd) 取得的執行緒主視窗 (來尋找擁有者。

> [!NOTE]
> 架構本身會使用這個函式來判斷對話方塊的正確擁有者視窗，以及未指定擁有者的屬性工作表。

## <a name="cwndgetscrollbarctrl"></a><a name="getscrollbarctrl"></a> CWnd：： GetScrollBarCtrl

呼叫這個成員函式，以取得指定之同級捲軸或分隔視窗的指標。

```
virtual CScrollBar* GetScrollBarCtrl(int nBar) const;
```

### <a name="parameters"></a>參數

*nBar*<br/>
指定捲軸的類型。 參數可以採用下列其中一個值：

- SB_HORZ 抓取水準捲軸的位置。

- SB_VERT 抓取垂直捲動條的位置。

### <a name="return-value"></a>傳回值

同級捲軸控制項，如果沒有則為 Null。

### <a name="remarks"></a>備註

當在建立視窗期間設定 WS_HSCROLL 或 WS_VSCROLL 位時，此成員函式不會在所建立的捲軸上運作。 此函式的實作為只會傳回 `CWnd` Null。 衍生類別（例如 `CView` ）會執行所述的功能。

## <a name="cwndgetscrollbarinfo"></a><a name="getscrollbarinfo"></a> CWnd：： GetScrollBarInfo

擷取所指定之捲軸的相關資訊。

```
BOOL GetScrollBarInfo(
    LONG idObject,
    PSCROLLBARINFO psbi) const;
```

### <a name="parameters"></a>參數

*idObject*<br/>
指定功能表物件。 如需可能值的清單，請參閱 [GetScrollBarInfo](/windows/win32/api/winuser/nf-winuser-getscrollbarinfo)。

*psbi*<br/>
接收資訊之 [SCROLLBARINFO](/windows/win32/api/winuser/ns-winuser-scrollbarinfo) 結構的指標。

### <a name="return-value"></a>傳回值

如果函式成功則為非零值，否則為 0。

### <a name="remarks"></a>備註

此成員函式會模擬函數 [GetScrollBarInfo](/windows/win32/api/winuser/nf-winuser-getscrollbarinfo)的功能，如 Windows SDK 所述。

## <a name="cwndgetscrollinfo"></a><a name="getscrollinfo"></a> CWnd：： GetScrollInfo

呼叫這個成員函式，以抓取 `SCROLLINFO` 結構針對捲軸所維護的資訊。

```
BOOL GetScrollInfo(
    int nBar,
    LPSCROLLINFO lpScrollInfo,
    UINT nMask = SIF_ALL);
```

### <a name="parameters"></a>參數

*nBar*<br/>
指定捲軸是否為控制項或視窗非工作區的一部分。 如果它是非工作區的一部分， *nBar* 也會指出捲軸是水準、垂直或兩者的位置。 它必須是下列其中一項：

- SB_CTL 抓取捲軸控制項的參數。 `m_hWnd`資料成員必須是捲軸控制項的控制碼。

- SB_HORZ 抓取視窗標準水準捲軸的參數。

- SB_VERT 抓取視窗標準垂直捲動條的參數。

*lpScrollInfo*<br/>
[SCROLLINFO](/windows/win32/api/winuser/ns-winuser-scrollinfo)結構的指標。 如需此結構的詳細資訊，請參閱 Windows SDK。

*nMask*<br/>
指定要取出的捲軸參數。 預設值會指定 SIF_PAGE、SIF_POS、SIF_TRACKPOS 和 SIF_RANGE 的組合。 `SCROLLINFO`如需*nMask*值的詳細資訊，請參閱。

### <a name="return-value"></a>傳回值

如果訊息抓取任何值，則傳回值為 TRUE。 否則為 FALSE。

### <a name="remarks"></a>備註

`GetScrollInfo` 可讓應用程式使用32位的捲軸位置。

[SCROLLINFO](/windows/win32/api/winuser/ns-winuser-scrollinfo)結構包含捲軸的相關資訊，包括捲軸位置的最小和最大值、頁面大小，以及捲動方塊 (捲動方塊的位置) 。 如需 `SCROLLINFO` 變更結構預設值的詳細資訊，請參閱 Windows SDK 中的結構主題。

表示捲軸位置的 MFC Windows 訊息處理常式， [CWnd：： OnHScroll](#onhscroll) 和 [CWnd：： OnVScroll](#onvscroll)，只提供16個位的位置資料。 `GetScrollInfo` 並 `SetScrollInfo` 提供32位的捲軸位置資料。 因此，應用程式可以 `GetScrollInfo` 在處理 `CWnd::OnHScroll` 或 `CWnd::OnVScroll` 取得32位捲軸位置資料時呼叫。

## <a name="cwndgetscrolllimit"></a><a name="getscrolllimit"></a> CWnd：： GetScrollLimit

呼叫這個成員函式，以抓取捲軸的最大滾動位置。

```
int GetScrollLimit(int nBar);
```

### <a name="parameters"></a>參數

*nBar*<br/>
指定捲軸的類型。 參數可以採用下列其中一個值：

- SB_HORZ 抓取水準捲軸的捲軸限制。

- SB_VERT 抓取垂直捲動條的捲軸限制。

### <a name="return-value"></a>傳回值

指定捲軸成功時的最大位置;否則為0。

## <a name="cwndgetscrollpos"></a><a name="getscrollpos"></a> CWnd：： GetScrollPos

抓取捲軸之捲動方塊的目前位置。

```
int GetScrollPos(int nBar) const;
```

### <a name="parameters"></a>參數

*nBar*<br/>
指定要檢查的捲軸。 參數可以採用下列其中一個值：

- SB_HORZ 抓取水準捲軸的位置。

- SB_VERT 抓取垂直捲動條的位置。

### <a name="return-value"></a>傳回值

指定捲軸中捲動方塊的目前位置（如果成功）;否則為0。

### <a name="remarks"></a>備註

目前的位置是相依于目前滾動範圍的相對值。 例如，如果滾動範圍是50到100，而捲動方塊位於橫條的中間，則目前的位置為75。

## <a name="cwndgetscrollrange"></a><a name="getscrollrange"></a> CWnd：： GetScrollRange

將給定捲軸的目前最小和最大捲軸位置複製到 *lpMinPos* 和 *lpMaxPos*所指定的位置。

```cpp
void GetScrollRange(
    int nBar,
    LPINT lpMinPos,
    LPINT lpMaxPos) const;
```

### <a name="parameters"></a>參數

*nBar*<br/>
指定要檢查的捲軸。 參數可以採用下列其中一個值：

- SB_HORZ 抓取水準捲軸的位置。

- SB_VERT 抓取垂直捲動條的位置。

*lpMinPos*<br/>
指向要接收最小位置的整數變數。

*lpMaxPos*<br/>
指向要接收最大位置的整數變數。

### <a name="remarks"></a>備註

如果沒有 `CWnd` 捲軸，則成員函式會 `GetScrollRange` 將0複製到 *lpMinPos* 和 *lpMaxPos*。

標準捲軸的預設範圍是0到100。 捲軸控制項的預設範圍是空的 (兩個值都是 0) 。

## <a name="cwndgetstyle"></a><a name="getstyle"></a> CWnd：： GetStyle

傳回目前的視窗樣式。

```
DWORD GetStyle() const;
```

### <a name="return-value"></a>傳回值

視窗的樣式。 如需 MFC 中使用之視窗樣式的詳細資訊，請參閱 [視窗樣式](styles-used-by-mfc.md#window-styles)。

## <a name="cwndgetsystemmenu"></a><a name="getsystemmenu"></a> CWnd：： GetSystemMenu

可讓應用程式存取控制功能表以進行複製和修改。

```
CMenu* GetSystemMenu(BOOL bRevert) const;
```

### <a name="parameters"></a>參數

*bRevert*<br/>
指定要採取的動作。 如果 *bRevert* 為 FALSE，則會將 `GetSystemMenu` 控制碼傳回給目前使用中的 [控制] 功能表。 這個複本一開始等同于 [控制台]，但可以修改。 如果 *bRevert* 為 TRUE，則 `GetSystemMenu` 將 [控制] 功能表重設回預設狀態。 先前可能已修改的控制項功能表（如果有的話）會終結。 在此情況下，傳回值是未定義的。

### <a name="return-value"></a>傳回值

如果 *bRevert* 為 FALSE，則識別控制項功能表的複本。 如果 *bRevert* 為 TRUE，則傳回值為未定義。

傳回的指標可能是暫時性的，不應儲存供稍後使用。

### <a name="remarks"></a>備註

任何不是用 `GetSystemMenu` 來建立自己的 [控制] 功能表複本的視窗，都會收到標準的 [控制] 功能表。

成員函式所傳回的指標 `GetSystemMenu` 可以搭配 [CMenu：： AppendMenu](../../mfc/reference/cmenu-class.md#appendmenu)、 [CMenu：： InsertMenu](../../mfc/reference/cmenu-class.md#insertmenu)或 [CMenu：： ModifyMenu](../../mfc/reference/cmenu-class.md#modifymenu) 函式使用，以變更控制項功能表。

[控制] 功能表一開始會包含以各種識別碼值（例如 SC_CLOSE、SC_MOVE 和 SC_SIZE）所識別的專案。 [控制] 功能表上的專案會產生 [WM_SYSCOMMAND](#onsyscommand) 的訊息。 所有預先定義的控制功能表項目都具有大於0xF000 的識別碼號碼。 如果應用程式將專案新增至 [控制] 功能表，則應該使用小於 F000 的識別碼。

Windows 可能會自動讓專案無法在標準的 [控制] 功能表上使用。 `CWnd` 可以透過回應 [WM_INITMENU](#oninitmenu) 的訊息（在顯示任何功能表之前傳送）來執行自己的選取或無法使用。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#99](../../mfc/reference/codesnippet/cpp/cwnd-class_39.cpp)]

## <a name="cwndgettitlebarinfo"></a><a name="gettitlebarinfo"></a> CWnd：： GetTitleBarInfo

擷取指定之標題列的相關資訊。

```
BOOL GetTitleBarInfo(PTITLEBARINFO pti) const;
```

### <a name="parameters"></a>參數

*Pti*<br/>
接收資訊之 [TITLEBARINFO](/windows/win32/api/winuser/ns-winuser-titlebarinfo) 結構的指標。

### <a name="remarks"></a>備註

此成員函式會模擬函數 [GetTitleBarInfo](/windows/win32/api/winuser/nf-winuser-gettitlebarinfo)的功能，如 Windows SDK 所述。

## <a name="cwndgettoplevelframe"></a><a name="gettoplevelframe"></a> CWnd：： GetTopLevelFrame

呼叫此成員函式，以抓取視窗的最上層框架視窗（如果有的話）。

```
CFrameWnd* GetTopLevelFrame() const;
```

### <a name="return-value"></a>傳回值

識別視窗的最上層框架視窗。

傳回的指標可能是暫時性的，不應儲存供稍後使用。

### <a name="remarks"></a>備註

如果沒有 `CWnd` 附加的視窗，或其最上層父系不是 [CFrameWnd](../../mfc/reference/cframewnd-class.md)衍生的物件，則此函數會傳回 Null。

## <a name="cwndgettoplevelowner"></a><a name="gettoplevelowner"></a> CWnd：： GetTopLevelOwner

呼叫此成員函式以取出最上層視窗。

```
CWnd* GetTopLevelOwner() const;
```

### <a name="return-value"></a>傳回值

識別最上層視窗。 傳回的指標可能是暫時性的，不應儲存供稍後使用。

### <a name="remarks"></a>備註

最上層視窗是桌面的子視窗。 如果沒有 `CWnd` 附加的視窗，此函數會傳回 Null。

## <a name="cwndgettoplevelparent"></a><a name="gettoplevelparent"></a> CWnd：： GetTopLevelParent

呼叫這個成員函式，以抓取視窗的最上層父代。

```
CWnd* GetTopLevelParent() const;
```

### <a name="return-value"></a>傳回值

識別視窗的最上層父視窗。

傳回的指標可能是暫時性的，不應儲存供稍後使用。

### <a name="remarks"></a>備註

`GetTopLevelParent` 類似于 [GetTopLevelFrame](#gettoplevelframe) 和 [GetTopLevelOwner](#gettoplevelowner);但是，它會忽略設定為目前擁有者視窗的值。

## <a name="cwndgettopwindow"></a><a name="gettopwindow"></a> CWnd：： GetTopWindow

搜尋屬於的最上層子視窗 `CWnd` 。

```
CWnd* GetTopWindow() const;
```

### <a name="return-value"></a>傳回值

識別子視窗連結清單中的最上層子視窗 `CWnd` 。 如果沒有任何子視窗存在，則此值為 Null。

傳回的指標可能是暫時性的，不應儲存供稍後使用。

### <a name="remarks"></a>備註

如果沒有 `CWnd` 子系，此函數會傳回 Null。

## <a name="cwndgetupdaterect"></a><a name="getupdaterect"></a> CWnd：： GetUpdateRect

抓取完全封閉更新區域之最小矩形的座標。

```
BOOL GetUpdateRect(
    LPRECT lpRect,
    BOOL bErase = FALSE);
```

### <a name="parameters"></a>參數

*lpRect*<br/>
指向 `CRect` 物件或 [RECT 結構](/windows/win32/api/windef/ns-windef-rect) ，此結構會接收包含更新區域之更新的用戶端座標。

將此參數設定為 Null，以判斷更新區域是否存在於中 `CWnd` 。 如果 *lpRect* 為 Null，則 `GetUpdateRect` 成員函式會傳回非零（如果有更新區域），如果沒有的話，則傳回0。 這會提供一種方式來判斷 WM_PAINT 訊息是否由不正確區域所產生。 請勿在 Windows 3.0 版和更舊版本中，將此參數設定為 Null。

*bErase*<br/>
指定是否要清除更新區域中的背景。

### <a name="return-value"></a>傳回值

指定更新區域的狀態。 如果更新區域不是空的，則此值為非零。否則為0。

如果 *lpRect* 參數設定為 Null，則傳回值為非零（如果有更新區域）;否則為0。

### <a name="remarks"></a>備註

如果 `CWnd` 是使用 CS_OWNDC 樣式所建立，且未 MM_TEXT 對應模式，則成員函式會 `GetUpdateRect` 以邏輯座標為單位提供矩形。 否則，會 `GetUpdateRect` 提供用戶端座標中的矩形。 如果沒有更新區域，則將 `GetUpdateRect` 矩形設定為空白 (將所有座標設定為 0) 。

*BErase*參數會指定是否 `GetUpdateRect` 應該清除更新區域的背景。 如果 *bErase* 為 TRUE，且更新區域不是空的，則會清除背景。 若要清除背景，請傳送 `GetUpdateRect` [WM_ERASEBKGND](#onerasebkgnd) 訊息。

[BeginPaint](#beginpaint)成員函式所取出的更新矩形，與成員函式所抓取的更新矩形相同 `GetUpdateRect` 。

成員函式 `BeginPaint` 會自動驗證更新區域，因此任何在 `GetUpdateRect` 呼叫後立即發出的呼叫都會抓取 `BeginPaint` 空的更新區域。

## <a name="cwndgetupdatergn"></a><a name="getupdatergn"></a> CWnd：： GetUpdateRgn

將更新區域抓取至 *pRgn*識別的區域。

```
int GetUpdateRgn(
    CRgn* pRgn,
    BOOL bErase = FALSE);
```

### <a name="parameters"></a>參數

*pRgn*<br/>
識別更新區域。

*bErase*<br/>
指定是否要清除背景，而且子視窗的非工作區也將會繪製。 如果值為 FALSE，則不會進行任何繪製。

### <a name="return-value"></a>傳回值

指定表示產生之區欄位型別的短整數旗標。 值可以採用下列任一項：

- SIMPLEREGION 區域沒有重迭的框線。

- COMPLEXREGION 區域有重迭的框線。

- NullREGION 區域是空的。

- 錯誤：未建立任何區域。

### <a name="remarks"></a>備註

此區域的座標相對於左上角， (用戶端座標) 。

[BeginPaint](#beginpaint)成員函式會自動驗證更新區域，因此在呼叫後立即發出的任何呼叫都會抓取 `GetUpdateRgn` `BeginPaint` 空的更新區域。

## <a name="cwndgetwindow"></a><a name="getwindow"></a> CWnd：： GetWindow

傳回所要求視窗的指標，如果沒有則傳回 Null。

```
CWnd* GetWindow(UINT nCmd) const;
```

### <a name="parameters"></a>參數

*nCmd*<br/>
指定 `CWnd` 和傳回的視窗之間的關聯性。 它可以採用下列其中一個值：

- GW_CHILD 識別 `CWnd` 第一個子視窗。

- GW_HWNDFIRST 如果 `CWnd` 是子視窗，會傳回第一個同級視窗。 否則，它會傳回清單中的第一個最上層視窗。

- GW_HWNDLAST 如果 `CWnd` 是子視窗，則會傳回最後一個同級視窗。 否則，它會傳回清單中的最後一個最上層視窗。

- GW_HWNDNEXT 會傳回視窗管理員清單中的下一個視窗。

- GW_HWNDPREV 會傳回視窗管理員清單上的上一個視窗。

- GW_OWNER 識別 `CWnd` 擁有者。

### <a name="return-value"></a>傳回值

傳回的指標可能是暫時性的，不應儲存供稍後使用。

## <a name="cwndgetwindowcontexthelpid"></a><a name="getwindowcontexthelpid"></a> CWnd：： GetWindowCoNtextHelpId

呼叫此成員函式，以取得與視窗相關聯的說明內容識別碼（如果有的話）。

```
DWORD GetWindowContextHelpId() const;
```

### <a name="return-value"></a>傳回值

說明內容識別碼。 如果視窗沒有任何，則傳回0。

## <a name="cwndgetwindowedchildcount"></a><a name="getwindowedchildcount"></a> CWnd：： GetWindowedChildCount

呼叫這個成員函式，以抓取相關聯的子視窗數目。

```
long GetWindowedChildCount();
```

### <a name="return-value"></a>傳回值

與物件相關聯的子視窗數目 `CWnd` 。

## <a name="cwndgetwindowdc"></a><a name="getwindowdc"></a> CWnd：： GetWindowDC

抓取整個視窗的顯示內容，包括標題列、功能表和捲軸。

```
CDC* GetWindowDC();
```

### <a name="return-value"></a>傳回值

如果函式成功，則識別給定視窗的顯示內容;否則為 Null。

傳回的指標可能是暫時性的，不應儲存供稍後使用。 每次成功呼叫時，都應該呼叫[ReleaseDC](#releasedc)一次 `GetWindowDC` 。

### <a name="remarks"></a>備註

視窗顯示內容允許在中的任何位置繪製 `CWnd` ，因為內容的原點是左上角， `CWnd` 而不是工作區的左邊。

預設屬性會在每次抓取內容時指派給顯示內容。 先前的屬性會遺失。

`GetWindowDC` 的目的是要用於非工作區中的特殊繪製效果 `CWnd` 。 不建議在任何視窗的非工作區中繪製。

[GetSystemMetrics](/windows/win32/api/winuser/nf-winuser-getsystemmetrics) Windows 函式可用來取出非工作區的各個部分的維度，例如標題列、功能表和捲軸。

繪製完成之後，必須呼叫 [ReleaseDC](#releasedc) 成員函式來釋放顯示內容。 無法釋出顯示內容將會嚴重影響應用程式所要求的繪製，因為可以同時開啟的裝置內容數目有所限制。

## <a name="cwndgetwindowinfo"></a><a name="getwindowinfo"></a> CWnd：： GetWindowInfo

捕獲有關視窗的資訊。

```
BOOL GetWindowInfo(PWINDOWINFO pwi) const;
```

### <a name="parameters"></a>參數

*pwi*<br/>
[WINDOWINFO](/windows/win32/api/winuser/ns-winuser-windowinfo)結構的指標。

### <a name="remarks"></a>備註

此成員函式會模擬函數 [GetWindowInfo](/windows/win32/api/winuser/nf-winuser-getwindowinfo)的功能，如 Windows SDK 所述。

## <a name="cwndgetwindowlesschildcount"></a><a name="getwindowlesschildcount"></a> CWnd：： GetWindowlessChildCount

抓取相關聯的無視窗子視窗數目。

```
long GetWindowlessChildCount();
```

### <a name="return-value"></a>傳回值

與物件相關聯的無視窗子視窗數目 `CWnd` 。

## <a name="cwndgetwindowplacement"></a><a name="getwindowplacement"></a> CWnd：： GetWindowPlacement

擷取視窗的顯示狀態和一般 (還原)、最小化和最大化位置。

```
BOOL GetWindowPlacement(WINDOWPLACEMENT* lpwndpl) const;
```

### <a name="parameters"></a>參數

*lpwndpl*<br/>
指向 `WINDOWPLACEMENT` 接收顯示狀態和位置資訊的結構。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

`flags`此函數所抓取之[WINDOWPLACEMENT](/windows/win32/api/winuser/ns-winuser-windowplacement)結構的成員一律為0。 如果 `CWnd` 已最大化， `showCmd` SW_SHOWMAXIMIZED 的成員 `WINDOWPLACEMENT` 。 如果視窗最小化，就會 SW_SHOWMINIMIZED。 否則 SW_SHOWNORMAL。

## <a name="cwndgetwindowrect"></a><a name="getwindowrect"></a> CWnd：： GetWindowRect

將物件的周框的維度複製 `CWnd` 到 *lpRect*所指向的結構中。

```cpp
void GetWindowRect(LPRECT lpRect) const;
```

### <a name="parameters"></a>參數

*lpRect*<br/>
指向 `CRect` 物件或 [RECT 結構](/windows/win32/api/windef/ns-windef-rect) ，此結構會接收左上角和右下角的螢幕座標。

### <a name="remarks"></a>備註

這些尺寸是以螢幕座標提供，相對於顯示畫面的左上角。 包含標題、框線和捲軸的維度（如果有的話）。

## <a name="cwndgetwindowrgn"></a><a name="getwindowrgn"></a> CWnd：： GetWindowRgn

呼叫此成員函式以取得視窗的視窗區域。

```
int GetWindowRgn(HRGN hRgn)const;
```

### <a name="parameters"></a>參數

*hRgn*<br/>
視窗區域的控制碼。

### <a name="return-value"></a>傳回值

傳回值會指定函數取得的區欄位型別。 它可能是下列其中一個值：

- NullREGION 區域是空的。

- SIMPLEREGION 區域是單一矩形。

- COMPLEXREGION 區域是一個以上的矩形。

- 錯誤發生錯誤;區域不會受到影響。

### <a name="remarks"></a>備註

視窗區域會決定視窗內作業系統允許繪製的區域。 作業系統不會顯示視窗區域以外的視窗的任何部分。

視窗視窗區域的座標是相對於視窗的左上角，而不是視窗的工作區。

若要設定視窗的視窗區域，請呼叫 [CWnd：： SetWindowRgn](#setwindowrgn)。

## <a name="cwndgetwindowtext"></a><a name="getwindowtext"></a> CWnd：： GetWindowText

複製 `CWnd` 標題標題 (如果它有一個) 指向 *lpszStringBuf* 所指向的緩衝區或指向目的地字串 *rString*。

```
int GetWindowText(
    LPTSTR lpszStringBuf,
    int nMaxCount) const;

void GetWindowText(
    CString& rString) const;
```

### <a name="parameters"></a>參數

*lpszStringBuf*<br/>
指向接收所複製之視窗標題字串的緩衝區。

*nMaxCount*<br/>
指定要複製到緩衝區的字元數上限，包括結束的 null 字元。 如果字串的長度超過 *nMaxCount*中指定的字元數，則會被截斷。

*rString*<br/>
[CString](../../atl-mfc-shared/reference/cstringt-class.md)物件，這個物件會接收所複製的視窗標題字串。

### <a name="return-value"></a>傳回值

指定複製字串的長度（以字元為單位），不包括終止的 null 字元。 如果沒有標題， `CWnd` 或標題是空的，則為0。

### <a name="remarks"></a>備註

如果 `CWnd` 物件是控制項，則成員函式會 `GetWindowText` 複製控制項內的文字，而不是複製標題。

此成員函式會將 [WM_GETTEXT](/windows/win32/winmsg/wm-gettext) 訊息傳送至 `CWnd` 物件。

### <a name="example"></a>範例

  請參閱 [CWnd：： SetWindowText](#setwindowtext)的範例。

## <a name="cwndgetwindowtextlength"></a><a name="getwindowtextlength"></a> CWnd：： GetWindowTextLength

傳回 `CWnd` 物件標題標題的長度。

```
int GetWindowTextLength() const;
```

### <a name="return-value"></a>傳回值

指定文字長度（以字元為單位），不包含任何 null 終止字元。 如果沒有這類文字，則值為0。

### <a name="remarks"></a>備註

如果 `CWnd` 是控制項，則成員函式會傳回 `GetWindowTextLength` 控制項內文字的長度，而不是標題。

此成員函式會將 [WM_GETTEXTLENGTH](/windows/win32/winmsg/wm-gettextlength) 訊息傳送至 `CWnd` 物件。

### <a name="example"></a>範例

  請參閱 [CWnd：： SetWindowText](#setwindowtext)的範例。

## <a name="cwndhidecaret"></a><a name="hidecaret"></a> CWnd：： HideCaret

藉由從顯示畫面移除插入號來隱藏該插入號。

```cpp
void HideCaret();
```

### <a name="remarks"></a>備註

雖然不會再顯示插入號，但可使用 [ShowCaret](#showcaret) 成員函式再次顯示。 隱藏插入號並不會摧毀其目前的形狀。

隱藏是累計的。 如果 `HideCaret` 在資料列中呼叫了五次，則 `ShowCaret` 必須先呼叫成員函式五次，才會顯示插入號。

## <a name="cwndhilitemenuitem"></a><a name="hilitemenuitem"></a> CWnd：： HiliteMenuItem

反白顯示或移除頂層 (功能表列) 功能表項目中的醒目提示。

```
BOOL HiliteMenuItem(
    CMenu* pMenu,
    UINT nIDHiliteItem,
    UINT nHilite);
```

### <a name="parameters"></a>參數

*pMenu*<br/>
識別包含要反白顯示之專案的最上層功能表。

*nIDHiliteItem*<br/>
根據 *nHilite* 參數的值，指定要反白顯示的功能表項目。

*nHilite*<br/>
指定是否要反白顯示功能表項目或移除反白顯示。 它可以是 MF_HILITE 或 MF_UNHILITE 與 MF_BYCOMMAND 或 MF_BYPOSITION 的組合。 您可以使用位 OR 運算子來結合這些值。 這些值具有以下意義：

- MF_BYCOMMAND 會將 *NIDHiliteItem* 解讀為 (預設轉譯) 的功能表項目識別碼。

- MF_BYPOSITION 會將 *NIDHiliteItem* 解讀為功能表項目以零為基底的位移。

- MF_HILITE 醒目顯示專案。 如果未指定此值，則會從專案中移除反白顯示。

- MF_UNHILITE 移除專案中的醒目提示。

### <a name="return-value"></a>傳回值

指定是否反白顯示功能表項目。 如果專案已反白顯示，則為非零;否則為0。

### <a name="remarks"></a>備註

MF_HILITE 和 MF_UNHILITE 旗標只能搭配這個成員函式使用;它們無法搭配 [CMenu：： ModifyMenu](../../mfc/reference/cmenu-class.md#modifymenu) 成員函式使用。

## <a name="cwndhtmlhelp"></a><a name="htmlhelp"></a> CWnd：： HtmlHelp

呼叫此成員函式來叫用 HTMLHelp 應用程式。

```
virtual void HtmlHelp(
    DWORD_PTR dwData,
    UINT nCmd = 0x000F);
```

### <a name="parameters"></a>參數

*dwData*<br/>
指定其他資料。 使用的值取決於 *nCmd* 參數的值。

*nCmd*<br/>
指定要求的說明類型。 如需可能值的清單，以及它們如何影響 *dwData* 參數的詳細資訊，請參閱 Windows SDK 中的 HTML 說明 API 參考中所述的 *uCommand* 參數。

### <a name="remarks"></a>備註

如需詳細資訊，請參閱 [CWinApp：： HtmlHelp](../../mfc/reference/cwinapp-class.md#htmlhelp) 。

## <a name="cwndinitdynamiclayout"></a><a name="initdynamiclayout"></a> CWnd：： InitDynamicLayout

由架構呼叫以初始化視窗的動態配置。

```cpp
void InitDynamicLayout();
```

### <a name="remarks"></a>備註

請勿直接呼叫這個方法。

## <a name="cwndinvalidate"></a><a name="invalidate"></a> CWnd：：無效

使的整個工作區失效 `CWnd` 。

```cpp
void Invalidate(BOOL bErase = TRUE);
```

### <a name="parameters"></a>參數

*bErase*<br/>
指定是否要清除更新區域內的背景。

### <a name="remarks"></a>備註

下次出現 [WM_PAINT](#onpaint) 訊息時，就會將工作區標示為進行繪製。 在 [ValidateRect](#validaterect) 或 [ValidateRgn](#validatergn) 成員函式發生 WM_PAINT 訊息之前，也可以驗證該區域。

*BErase*參數會指定在處理更新區域時，是否要清除更新區域內的背景。 如果 *bErase* 為 TRUE，則會在呼叫 [BeginPaint](#beginpaint) 成員函式時清除背景;如果 *bErase* 為 FALSE，則背景會維持不變。 如果更新區域的任何部分的 *bErase* 為 TRUE，則會清除整個區域中的背景（而不只是指定的部分）。

每當[WM_PAINT](#onpaint) `CWnd` 更新區域不是空的，且該視窗的應用程式佇列中沒有其他訊息時，Windows 就會傳送 WM_PAINT 訊息。

### <a name="example"></a>範例

  請參閱 [CWnd：： UpdateWindow](#updatewindow)的範例。

## <a name="cwndinvalidaterect"></a><a name="invalidaterect"></a> CWnd：： InvalidateRect

將矩形加入至更新區域，使給定矩形內的工作區失效 `CWnd` 。

```cpp
void InvalidateRect(
    LPCRECT lpRect,
    BOOL bErase = TRUE);
```

### <a name="parameters"></a>參數

*lpRect*<br/>
指向 `CRect` 物件或 [RECT 結構](/windows/win32/api/windef/ns-windef-rect) ，其中包含在用戶端座標中要新增至更新區域)  (的矩形。 如果 *lpRect* 為 Null，則會將整個工作區加入至區域。

*bErase*<br/>
指定是否要清除更新區域內的背景。

### <a name="remarks"></a>備註

當傳送下一個 [WM_PAINT](#onpaint) 訊息時，不正確矩形（以及更新區域中的所有其他區域）會標示為進行繪製。 不正確區域會累積在更新區域中，直到下次進行 WM_PAINT 呼叫，或直到 [ValidateRect](#validaterect) 或 [ValidateRgn](#validatergn) 成員函式驗證區域為止。

*BErase*參數會指定在處理更新區域時，是否要清除更新區域內的背景。 如果 *bErase* 為 TRUE，則會在呼叫 [BeginPaint](#beginpaint) 成員函式時清除背景;如果 *bErase* 為 FALSE，則背景會維持不變。 如果更新區域的任何部分的 *bErase* 為 TRUE，則會清除整個區域中的背景，而不只是在指定的部分。

每當[WM_PAINT](#onpaint) `CWnd` 更新區域不是空的，且該視窗的應用程式佇列中沒有其他訊息時，Windows 就會傳送 WM_PAINT 訊息。

## <a name="cwndinvalidatergn"></a><a name="invalidatergn"></a> CWnd：： InvalidateRgn

將給定區域內的工作區加入至目前的更新區域，使其失效 `CWnd` 。

```cpp
void InvalidateRgn(
    CRgn* pRgn,
    BOOL bErase = TRUE);
```

### <a name="parameters"></a>參數

*pRgn*<br/>
[CRgn](../../mfc/reference/crgn-class.md)物件的指標，該物件會識別要新增至更新區域的區域。 區域假設有用戶端座標。 如果此參數為 Null，則會將整個工作區加入至更新區域。

*bErase*<br/>
指定是否要清除更新區域內的背景。

### <a name="remarks"></a>備註

下次傳送 [WM_PAINT](#onpaint) 訊息時，會將不正確區域和更新區域中的所有其他區域標記為進行繪製。 不正確區域會累積在更新區域中，直到下次傳送 WM_PAINT 訊息時，或直到 [ValidateRect](#validaterect) 或 [ValidateRgn](#validatergn) 成員函式驗證區域為止。

*BErase*參數會指定在處理更新區域時，是否要清除更新區域內的背景。 如果 *bErase* 為 TRUE，則會在呼叫 [BeginPaint](#beginpaint) 成員函式時清除背景;如果 *bErase* 為 FALSE，則背景會維持不變。 如果更新區域的任何部分的 *bErase* 為 TRUE，則會清除整個區域中的背景（而不只是指定的部分）。

每當[WM_PAINT](#onpaint) `CWnd` 更新區域不是空的，且該視窗的應用程式佇列中沒有其他訊息時，Windows 就會傳送 WM_PAINT 訊息。

指定的區域必須先前已由其中一個區域函數所建立。

## <a name="cwndinvokehelper"></a><a name="invokehelper"></a> CWnd：： InvokeHelper

呼叫這個成員函式，在*wFlags*指定的內容中叫用*dwDispID*所指定的 ActiveX 控制項方法或屬性。

```cpp
void AFX_CDECL InvokeHelper(
    DISPID dwDispID,
    WORD wFlags,
    VARTYPE vtRet,
    void* pvRet,
    const BYTE* pbParamInfo,
    ... );
```

### <a name="parameters"></a>參數

*dwDispID*<br/>
指定所要叫用的屬性或方法。

*wFlags*<br/>
描述呼叫之內容的旗標 `IDispatch::Invoke` 。

*vtRet*<br/>
指定傳回值的類型。 如需可能的值，請參閱 [COleDispatchDriver::InvokeHelper](../../mfc/reference/coledispatchdriver-class.md#invokehelper)的＜備註＞一節。

*pvRet*<br/>
將接收屬性值或傳回值之變數的位址。 它必須符合 *vtRet*所指定的類型。

*pbParamInfo*<br/>
以 null 結束的位元組字串指標，指定 *pbParamInfo*之後的參數類型。 如需可能的值，請參閱的「備註」一節 `COleDispatchDriver::InvokeHelper` 。

*...*<br/>
參數的變數清單， *pbParamInfo*中指定的類型。

### <a name="remarks"></a>備註

*PbParamInfo*參數會指定傳遞給方法或屬性的參數類型。 引數的變數清單會以 *...* 語法宣告代表。

此函式會將參數轉換為 VARIANTARG 值，然後 `IDispatch::Invoke` 在 ActiveX 控制項上叫用方法。 若呼叫 `IDispatch::Invoke` 失敗，此函式會擲回例外狀況。 如果 DISP_E_EXCEPTION 所傳回的 SCODE (狀態碼) ，此函式會擲回 `IDispatch::Invoke` [COleException](../../mfc/reference/coleexception-class.md) 物件，否則會擲回 [COleDispatchException](../../mfc/reference/coledispatchexception-class.md)。

> [!NOTE]
> 這個函式應該只在 `CWnd` 代表 ActiveX 控制項的物件上呼叫。

如需有關搭配 ActiveX 控制項容器使用這個成員函式的詳細資訊，請參閱 Activex 控制項容器文章 [： Activex 控制項容器中的 activex 控制項程式設計](../../mfc/programming-activex-controls-in-a-activex-control-container.md)。

## <a name="cwndischild"></a><a name="ischild"></a> CWnd：： IsChild

指出 *pWnd* 所指定的視窗是否為子視窗或其他的直接下階 `CWnd` 。

```
BOOL IsChild(const CWnd* pWnd) const;
```

### <a name="parameters"></a>參數

*pWnd*<br/>
識別要測試的視窗。

### <a name="return-value"></a>傳回值

指定函數的結果。 如果 *pWnd* 所識別的視窗是的子視窗，則此值為非零， `CWnd` 否則為0。

### <a name="remarks"></a>備註

`CWnd`如果 `CWnd` 物件位於從原始快顯視窗導向至子視窗的父視窗鏈中，子視窗就是的直接下階。

## <a name="cwndisd2dsupportenabled"></a><a name="isd2dsupportenabled"></a> CWnd：： IsD2DSupportEnabled

判斷是否已啟用 D2D 支援。

```
BOOL IsD2DSupportEnabled();
```

### <a name="return-value"></a>傳回值

如果已啟用功能，則為 TRUE;否則為 FALSE。

## <a name="cwndisdialogmessage"></a><a name="isdialogmessage"></a> CWnd：： IsDialogMessage

呼叫這個成員函式來判斷指定的訊息是否適用于非強制回應對話方塊;如果是，則此函式會處理訊息。

```
BOOL IsDialogMessage(LPMSG lpMsg);
```

### <a name="parameters"></a>參數

*lpMsg*<br/>
指向包含要檢查之訊息的 [MSG](/windows/win32/api/winuser/ns-winuser-msg) 結構。

### <a name="return-value"></a>傳回值

指定成員函數是否已處理給定的訊息。 如果已處理訊息，則為非零。否則為0。 如果傳回的是0，請呼叫基類的 [CWnd：:P retranslatemessage](#pretranslatemessage) 成員函式來處理訊息。 在成員函式的覆寫中 `CWnd::PreTranslateMessage` ，程式碼看起來像這樣：

[!code-cpp[NVC_MFCWindowing#100](../../mfc/reference/codesnippet/cpp/cwnd-class_40.cpp)]

### <a name="remarks"></a>備註

當函式 `IsDialogMessage` 處理訊息時，它會檢查鍵盤訊息，並將它們轉換成對應對話方塊的選取專案命令。 例如，TAB 鍵會選取下一個控制項或控制項群組，而向下鍵則會選取群組中的下一個控制項。

您不得將處理的訊息傳遞 `IsDialogMessage` 至 [TranslateMessage](/windows/win32/api/winuser/nf-winuser-translatemessage) 或 [DispatchMessage](/windows/win32/api/winuser/nf-winuser-dispatchmessage) Windows 函式，因為它已經過處理。

## <a name="cwndisdlgbuttonchecked"></a><a name="isdlgbuttonchecked"></a> CWnd：： IsDlgButtonChecked

判斷按鈕控制項旁邊是否有核取記號。

```
UINT IsDlgButtonChecked(int nIDButton) const;
```

### <a name="parameters"></a>參數

*nIDButton*<br/>
指定按鈕控制項的整數識別碼。

### <a name="return-value"></a>傳回值

如果已核取指定的控制項，則為非零，如果未核取，則為0。 只有選項按鈕和核取方塊可以勾選。 若是三個狀態的按鈕，如果按鈕是不定的，則傳回值可以是2。 此成員函式會傳回0作為按鍵。

### <a name="remarks"></a>備註

如果按鈕是三個狀態的控制項，則成員函式會判斷其是否為暗灰色、已檢查，或兩者皆非。

## <a name="cwndisdynamiclayoutenabled"></a><a name="isdynamiclayoutenabled"></a> CWnd：： IsDynamicLayoutEnabled

決定是否在這個視窗上啟用動態配置。 如果啟用動態配置時，則使用者可在調整父視窗大小時變更子視窗的位置與大小。

```
BOOL IsDynamicLayoutEnabled() const;
```

### <a name="return-value"></a>傳回值

如果啟用動態配置則為 TRUE，否則為 FALSE。

### <a name="remarks"></a>備註

## <a name="cwndisiconic"></a><a name="isiconic"></a> CWnd：： IsIconic

指定 `CWnd` (iconic) 是否最小化。

```
BOOL IsIconic() const;
```

### <a name="return-value"></a>傳回值

如果最小化，則為非零， `CWnd` 否則為0。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#101](../../mfc/reference/codesnippet/cpp/cwnd-class_41.cpp)]

## <a name="cwndistouchwindow"></a><a name="istouchwindow"></a> CWnd：： IsTouchWindow

指定 `CWnd` 是否有觸控支援。

```
BOOL IsTouchWindow() const;
```

### <a name="return-value"></a>傳回值

如果 `CWnd` 有觸控支援，則為 TRUE，否則為 FALSE。

### <a name="remarks"></a>備註

## <a name="cwndiswindowenabled"></a><a name="iswindowenabled"></a> CWnd：： IsWindowEnabled

指定是否 `CWnd` 啟用滑鼠和鍵盤輸入。

```
BOOL IsWindowEnabled() const;
```

### <a name="return-value"></a>傳回值

如果已啟用，則為非零， `CWnd` 否則為0。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#102](../../mfc/reference/codesnippet/cpp/cwnd-class_42.cpp)]

## <a name="cwndiswindowvisible"></a><a name="iswindowvisible"></a> CWnd：： IsWindowVisible

判斷指定視窗的可見度狀態。

```
BOOL IsWindowVisible() const;
```

### <a name="return-value"></a>傳回值

如果 `CWnd` 為可見，則為非零， (已設定 [WS_VISIBLE](styles-used-by-mfc.md#window-styles) 樣式位，且父視窗) 可見。 因為傳回值會反映 WS_VISIBLE 樣式位的狀態，所以傳回值可能是非零，即使 `CWnd` 是其他視窗完全遮蔽也一樣。

### <a name="remarks"></a>備註

視窗擁有 WS_VISIBLE 樣式位所指出的可見度狀態。 當使用 [ShowWindow](#showwindow) 成員函式的呼叫來設定這個樣式位時，只要視窗已設定樣式位，就會顯示視窗，而且會顯示後續的視窗繪製。

如果視窗由其他視窗所涵蓋，或是由其父視窗裁剪，則不會顯示任何具有 WS_VISIBLE 樣式之視窗的繪圖。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#103](../../mfc/reference/codesnippet/cpp/cwnd-class_43.cpp)]

## <a name="cwndiszoomed"></a><a name="iszoomed"></a> CWnd：： IsZoomed

判斷是否已 `CWnd` 最大化。

```
BOOL IsZoomed() const;
```

### <a name="return-value"></a>傳回值

如果已最大化，則為非零， `CWnd` 否則為0。

## <a name="cwndkilltimer"></a><a name="killtimer"></a> CWnd：： KillTimer

終止 *nIDEvent* 從先前的呼叫所識別的計時器事件 `SetTimer` 。

```
BOOL KillTimer(UINT_PTR nIDEvent);
```

### <a name="parameters"></a>參數

*nIDEvent*<br/>
傳遞至 [SetTimer](#settimer)的計時器事件值。

### <a name="return-value"></a>傳回值

指定函數的結果。 如果已終止事件，此值為非零值。 如果成員函式找 `KillTimer` 不到指定的計時器事件，則為0。

### <a name="remarks"></a>備註

與計時器相關聯的暫止 [WM_TIMER](#ontimer) 訊息不會從訊息佇列中移除。

### <a name="example"></a>範例

  請參閱 [CWnd：： SetTimer](#settimer)的範例。

## <a name="cwndloaddynamiclayoutresource"></a><a name="loaddynamiclayoutresource"></a> CWnd：： LoadDynamicLayoutResource

由架構呼叫以從資源檔載入動態配置資訊。

```
BOOL LoadDynamicLayoutResource(LPCTSTR lpszResourceName);
```

### <a name="parameters"></a>參數

*lpszResourceName*<br/>
包含此視窗所需之動態配置資訊的資源名稱。

### <a name="return-value"></a>傳回值

如果函式成功，則為非零。 如果發生失敗，則為 0。

### <a name="remarks"></a>備註

請勿直接呼叫這個方法。

## <a name="cwndlockwindowupdate"></a><a name="lockwindowupdate"></a> CWnd：： LockWindowUpdate

停用指定視窗中的繪圖。

```
BOOL LockWindowUpdate();
```

### <a name="return-value"></a>傳回值

如果函式成功，則為非零。 如果發生失敗或函式已 `LockWindowUpdate` 被用來鎖定另一個視窗，則為0。

### <a name="remarks"></a>備註

無法移動鎖定的視窗。 一次只能鎖定一個視窗。 若要解除鎖定已鎖定的視窗 `LockWindowUpdate` ，請呼叫 [UnlockWindowUpdate](#unlockwindowupdate)。

如果有鎖定視窗的應用程式 (或任何鎖定的子視窗) 呼叫 [GetDC、](/windows/win32/api/winuser/nf-winuser-getdc) [GetDCEx](/windows/win32/api/winuser/nf-winuser-getdcex) 或 [BeginPaint](/windows/win32/api/winuser/nf-winuser-beginpaint) windows 函式，則呼叫的函式會傳回其可見區域空白的裝置內容。 這會發生在應用程式透過呼叫成員函式解除鎖定視窗之前 `UnlockWindowUpdate` 。

當視窗更新被鎖定時，系統會將任何繪圖作業的周框，記錄到與鎖定視窗相關聯的裝置內容。 重新啟用繪圖時，此周框會在鎖定的視窗和其子視窗中失效，以強制最終 [WM_PAINT](/windows/win32/gdi/wm-paint) 的訊息更新畫面。 如果視窗更新鎖定時未發生任何繪圖，則沒有任何區域會失效。

成員函式不 `LockWindowUpdate` 會讓指定的視窗不可見，也不會清除 [WS_VISIBLE](styles-used-by-mfc.md#window-styles) 的樣式位。

## <a name="cwndm_hwnd"></a><a name="m_hwnd"></a> CWnd：： m_hWnd

附加至此的 Windows 視窗控制碼 `CWnd` 。

```
HWND m_hWnd;
```

### <a name="remarks"></a>備註

`m_hWnd`資料成員是 HWND 類型的公用變數。

## <a name="cwndmapwindowpoints"></a><a name="mapwindowpoints"></a> CWnd：： MapWindowPoints

將一組點從 `CWnd` 的座標空間轉換 (對應) 至另一個視窗的座標空間。

```cpp
void MapWindowPoints(
    CWnd* pwndTo,
    LPRECT lpRect) const;

void MapWindowPoints(
    CWnd* pwndTo,
    LPPOINT lpPoint,
    UINT nCount) const;
```

### <a name="parameters"></a>參數

*pwndTo*<br/>
識別要轉換點的視窗。 如果此參數為 Null，則會將點轉換成螢幕座標。

*lpRect*<br/>
指定要轉換其點的矩形。 此函數的第一個版本僅適用于 Windows 3.1 和更新版本。

*lpPoint*<br/>
[點結構](/windows/win32/api/windef/ns-windef-point)陣列的指標，其中包含要轉換的點集合。

*nCount*<br/>
指定 `POINT` *lpPoint*所指向之陣列中的結構數目。

## <a name="cwndmessagebox"></a><a name="messagebox"></a> CWnd：： MessageBox

建立並顯示包含應用程式提供之訊息和標題的視窗，以及 [ [訊息-方塊樣式](../../mfc/reference/styles-used-by-mfc.md#message-box-styles) ] 清單中所描述之預先定義圖示和按鈕的組合。

```
int MessageBox(
    LPCTSTR lpszText,
    LPCTSTR lpszCaption = NULL,
    UINT nType = MB_OK);
```

### <a name="parameters"></a>參數

*lpszText*<br/>
指向 `CString` 物件或以 null 終止的字串，其中包含要顯示的訊息。

*lpszCaption*<br/>
指向要 `CString` 用於訊息方塊標題的物件或以 null 終止的字串。 如果 *lpszCaption* 為 Null，則會使用預設標題 "Error"。

*nType*<br/>
指定訊息方塊的內容和行為。

### <a name="return-value"></a>傳回值

這個方法會利用 Windows SDK 中定義的 [MessageBox](/windows/win32/api/winuser/nf-winuser-messagebox) 函數。 這個方法會傳回呼叫這個函數的結果。

### <a name="remarks"></a>備註

使用全域函式 [AfxMessageBox](../../mfc/reference/cstring-formatting-and-message-box-display.md#afxmessagebox) 而不是這個成員函式，在您的應用程式中執行訊息方塊。

以下顯示可以在訊息方塊中使用的各種系統圖示：

|圖示|巨集|
|-|-|
|![停止 &#40;x&#41; 圖示](../../mfc/reference/media/vc364f1.gif "停止 &#40;x&#41; 圖示")|MB_ICONHAND、MB_ICONSTOP 和 MB_ICONERROR|
|![Help &#40;？ &#41; 圖示](../../mfc/reference/media/vc364f2.gif "Help &#40;？ &#41; 圖示")|MB_ICONQUESTION|
|![重要 &#40;&#33;&#41; 圖示](../../mfc/reference/media/vc364f3.gif "重要 &#40;&#33;&#41; 圖示")|MB_ICONEXCLAMATION 和 MB_ICONWARNING|
|![我&#41; 的資訊 &#40;圖示](../../mfc/reference/media/vc364f4.gif "我&#41; 的資訊 &#40;圖示")|MB_ICONASTERISK 和 MB_ICONINFORMATION|

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#104](../../mfc/reference/codesnippet/cpp/cwnd-class_44.cpp)]

## <a name="cwndmodifystyle"></a><a name="modifystyle"></a> CWnd：： ModifyStyle

呼叫此成員函式以修改視窗的樣式。

```
BOOL ModifyStyle(
    DWORD dwRemove,
    DWORD dwAdd,
    UINT nFlags = 0);
```

### <a name="parameters"></a>參數

*dwRemove*<br/>
指定樣式修改期間要移除的視窗樣式。

*dwAdd*<br/>
指定樣式修改期間要加入的視窗樣式。

*nFlags*<br/>
要傳遞至 [SetWindowPos](#setwindowpos)的旗標，如果 `SetWindowPos` 不應該呼叫，則為零。 預設值是零。 如需預設旗標的清單，請參閱「備註」一節。

### <a name="return-value"></a>傳回值

如果樣式已成功修改，則為非零;否則為0。

### <a name="remarks"></a>備註

您可以使用位 OR ( # A0) 運算子來結合要加入或移除的樣式。 如需可用視窗樣式的詳細資訊，請參閱 Windows SDK 中的主題 [視窗樣式](/windows/win32/winmsg/window-styles) 和 [CreateWindow](/windows/win32/api/winuser/nf-winuser-createwindoww) 。

如果*nFlags*為非零值，則會藉 `ModifyStyle` 由結合*nFlags*與下列四個預設旗標，來呼叫 Windows API 函數[SetWindowPos](/windows/win32/api/winuser/nf-winuser-setwindowpos)並重新繪製視窗：

- SWP_NOSIZE 會保留目前的大小。

- SWP_NOMOVE 會保留目前的位置。

- SWP_NOZORDER 會保留目前的 Z 順序。

- SWP_NOACTI加值稅E 不會啟動視窗。

若要修改視窗的擴充樣式，請參閱 [ModifyStyleEx](#modifystyleex)。

> [!NOTE]
> 某些控制項中的某些樣式 (編輯控制項中的 ES_READONLY 樣式（例如) ） `ModifyStyle` 可能無法正確地變更樣式，因為控制項可能需要執行特殊的內部處理。 在這些情況下， ( EM_SETREADONLY 所) 述的範例中，會提供變更樣式的對應訊息。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#105](../../mfc/reference/codesnippet/cpp/cwnd-class_45.cpp)]

## <a name="cwndmodifystyleex"></a><a name="modifystyleex"></a> CWnd：： ModifyStyleEx

呼叫這個成員函式，以修改視窗的延伸樣式。

```
BOOL ModifyStyleEx(
    DWORD dwRemove,
    DWORD dwAdd,
    UINT nFlags = 0);
```

### <a name="parameters"></a>參數

*dwRemove*<br/>
指定樣式修改期間要移除的延伸樣式。

*dwAdd*<br/>
指定樣式修改期間要加入的延伸樣式。

*nFlags*<br/>
要傳遞至 [SetWindowPos](#setwindowpos)的旗標，如果 `SetWindowPos` 不應該呼叫，則為零。 預設值是零。 如需預設旗標的清單，請參閱「備註」一節。

### <a name="return-value"></a>傳回值

如果樣式已成功修改，則為非零;否則為0。

### <a name="remarks"></a>備註

您可以使用位 OR ( # A0) 運算子來結合要加入或移除的樣式。 如需可用擴充樣式的詳細資訊，請參閱本書中的主題 [延伸視窗樣式](../../mfc/reference/styles-used-by-mfc.md#extended-window-styles) 和 [CreateWindowEx](/windows/win32/api/winuser/nf-winuser-createwindowexw) Windows SDK

如果*nFlags*為非零值，則會藉 `ModifyStyleEx` 由結合*nFlags*與下列四個預設旗標，來呼叫 Windows API 函數[SetWindowPos](/windows/win32/api/winuser/nf-winuser-setwindowpos)並重新繪製視窗：

- SWP_NOSIZE 會保留目前的大小。

- SWP_NOMOVE 會保留目前的位置。

- SWP_NOZORDER 會保留目前的 Z 順序。

- SWP_NOACTI加值稅E 不會啟動視窗。

若要使用一般視窗樣式修改 windows，請參閱 [ModifyStyle](#modifystyle)。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#106](../../mfc/reference/codesnippet/cpp/cwnd-class_46.cpp)]

## <a name="cwndmovewindow"></a><a name="movewindow"></a> CWnd：： MoveWindow

變更位置和維度。

```cpp
void MoveWindow(
    int x,
    int y,
    int nWidth,
    int nHeight,
    BOOL bRepaint = TRUE);

void MoveWindow(
    LPCRECT lpRect,
    BOOL bRepaint = TRUE);
```

### <a name="parameters"></a>參數

*x*<br/>
指定左邊的新位置 `CWnd` 。

*y*<br/>
指定頂端的新位置 `CWnd` 。

*nWidth*<br/>
指定的新寬度 `CWnd` 。

*nHeight*<br/>
指定的新高度 `CWnd` 。

*bRepaint*<br/>
指定是否 `CWnd` 要重新繪製。 若為 TRUE，則會 `CWnd` 如往常般在其[OnPaint](#onpaint)訊息處理常式中接收[WM_PAINT](/windows/win32/gdi/wm-paint)訊息。 如果此參數為 FALSE，則不會重新繪製任何種類。 這適用于工作區、非工作區的 (包括標題和捲軸) ，以及移至被視為移動結果之父視窗的任何部分 `CWnd` 。 當此參數為 FALSE 時，應用程式必須明確地使或重繪任何必須重新繪製的部分 `CWnd` 和父視窗。

*lpRect*<br/>
指定新大小和位置的 [CRect](../../atl-mfc-shared/reference/crect-class.md) 物件或 [RECT 結構](/windows/win32/api/windef/ns-windef-rect) 。

### <a name="remarks"></a>備註

針對最上層 `CWnd` 物件， *x* 和 *y* 參數是相對於畫面的左上角。 針對子 `CWnd` 物件，它們是相對於父視窗工作區的左上角。

函數會傳送 `MoveWindow` [WM_GETMINMAXINFO](#ongetminmaxinfo) 訊息。 處理此訊息可讓您 `CWnd` 有機會修改最大和最小可能視窗的預設值。 如果成員函式的參數 `MoveWindow` 超過這些值，則可以使用 WM_GETMINMAXINFO 處理常式中的最小值或最大值來取代這些值。

### <a name="example"></a>範例

  請參閱 [CWnd：： ClientToScreen](#clienttoscreen)的範例。

## <a name="cwndnotifywinevent"></a><a name="notifywinevent"></a> CWnd：： NotifyWinEvent

表示發生預先定義之事件的系統。 如果有任何用戶端應用程式已為事件註冊攔截函式，系統會呼叫用戶端的攔截函式。

```cpp
void NotifyWinEvent(
    DWORD event,
    LONG idObjectType,
    LONG idObject);
```

### <a name="parameters"></a>參數

*event*<br/>
指定發生的事件。 這個值必須是其中一個 [事件常數](/windows/win32/WinAuto/event-constants)。

*idObjectType*<br/>
識別產生事件的物件類型。 此值是其中一個預先定義的 [物件識別碼](/windows/win32/WinAuto/object-identifiers) 或自訂物件識別碼值。

*idObject*<br/>
識別事件是否由物件或物件的子專案所產生。 如果此值為 CHILDID_SELF，則事件是由物件本身產生。 如果不是，這個值就是產生事件之元素的子識別碼。

### <a name="remarks"></a>備註

此成員函式會模擬函數 [NotifyWinEvent](/windows/win32/api/winuser/nf-winuser-notifywinevent)的功能，如 Windows SDK 所述。

## <a name="cwndonactivate"></a><a name="onactivate"></a> CWnd：： OnActivate

當 `CWnd` 物件正在啟用或停用時，架構會呼叫這個成員函式。

```
afx_msg void OnActivate(
    UINT nState,
    CWnd* pWndOther,
    BOOL bMinimized);
```

### <a name="parameters"></a>參數

*nState*<br/>
指定 `CWnd` 要啟用或停用。 它可能是下列其中一個值：

- WA_INACTIVE 視窗正在停用。

- WA_ACTIVE 透過滑鼠點以外的方法啟動視窗 (例如，藉由使用鍵盤介面選取視窗) 。

- WA_CLICKACTIVE 視窗在按一下滑鼠時就會啟用。

*pWndOther*<br/>
要 `CWnd` 啟用或停用之的指標。 指標可以是 Null，而且可能是暫時性的。

*bMinimized*<br/>
指定 `CWnd` 要啟用或停用的最小化狀態。 TRUE 值表示視窗會最小化。

若為 TRUE，則 `CWnd` 會啟用，否則會停用。

### <a name="remarks"></a>備註

如果 `CWnd` 使用滑鼠按一下來啟始物件，它也會收到 [OnMouseActivate](#onmouseactivate) 成員函式呼叫。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonactivateapp"></a><a name="onactivateapp"></a> CWnd：： OnActivateApp

架構會呼叫此成員函式，以取得正在啟動之工作的所有最上層視窗，以及即將停用之工作的所有最上層視窗。

```
afx_msg void OnActivateApp(
    BOOL bActive,
    DWORD dwThreadID);
```

### <a name="parameters"></a>參數

*bActive*<br/>
指定 `CWnd` 要啟用或停用。 TRUE 表示正在 `CWnd` 啟用。 FALSE 表示將 `CWnd` 停用。

*dwThreadID*<br/>
指定執行緒識別碼的值。 如果 *bActive* 為 TRUE，則 *dwThreadID* 會識別擁有 `CWnd` 即將停用的執行緒。 如果 *bActive* 為 FALSE，則 *dwThreadID* 會識別擁有 `CWnd` 正在啟用的執行緒。

### <a name="remarks"></a>備註

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonambientproperty"></a><a name="onambientproperty"></a> CWnd：： OnAmbientProperty

架構會呼叫這個成員函式，從包含 OLE 控制項的視窗中取得環境屬性值。

```
virtual BOOL OnAmbientProperty(
    COleControlSite* pSite,
    DISPID dispid,
    VARIANT* pvar);
```

### <a name="parameters"></a>參數

*pSite*<br/>
要求環境屬性之控制項的網站指標。

*dispid*<br/>
要求的環境屬性的分派識別碼。

*pvar*<br/>
呼叫端配置 `VARIANT` 之結構的指標，將會傳回環境屬性的值。

### <a name="return-value"></a>傳回值

如果支援環境屬性，則為 TRUE;如果沒有，則為 FALSE。

### <a name="remarks"></a>備註

覆寫這個函式，以將 OLE 控制項容器傳回的預設環境屬性值變更為其控制項。 不是由覆寫函式處理的任何環境屬性要求都應該轉送至基類的執行。

## <a name="cwndonappcommand"></a><a name="onappcommand"></a> CWnd：： OnAppCommand

當使用者產生應用程式命令事件時，架構會呼叫這個成員函式。 當使用者按一下應用程式命令按鈕或輸入應用程式命令索引鍵時，就會發生這類事件。

```
afx_msg void OnAppCommand(
    CWnd* pWnd,
    UINT nCmd,
    UINT nDevice,
    UINT nKey);
```

### <a name="parameters"></a>參數

*pWnd*\
在 `CWnd` 物件的指標，該物件代表使用者按一下命令按鈕或按下命令鍵的視窗。 此視窗可以是接收訊息之視窗的子視窗。

*nCmd*\
在表示應用程式命令。 如需可能值的清單，請參閱[WM_APPCOMMAND](/windows/win32/inputdev/wm-appcommand)之*lParam*參數的*cmd*區段底下的命令。

*N 裝置*\
在產生輸入事件的輸入裝置。 如需可能值的清單，請參閱[WM_APPCOMMAND](/windows/win32/inputdev/wm-appcommand)之*LParam*參數的*uDevice*一節中的裝置。

*nKey*\
在指出任何關閉的虛擬機器碼，例如 CTRL 鍵或滑鼠左鍵。 如需可能值的清單，請參閱[WM_APPCOMMAND](/windows/win32/inputdev/wm-appcommand)之*LParam*參數的*dwKeys*一節中的索引鍵。 如需詳細資訊，請參閱 [關於滑鼠輸入](/windows/win32/inputdev/about-mouse-input)的「訊息參數」副標題。

### <a name="remarks"></a>備註

這個方法會接收 [WM_APPCOMMAND](/windows/win32/inputdev/wm-appcommand) 通知，如 Windows SDK 所述。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonaskcbformatname"></a><a name="onaskcbformatname"></a> CWnd：： OnAskCbFormatName

當剪貼簿包含 CF_OWNERDISPLAY 格式的資料控制碼時，架構會呼叫這個成員函式 (亦即，當剪貼簿擁有者將顯示剪貼簿內容) 時。

```
afx_msg void OnAskCbFormatName(
    UINT nMaxCount,
    LPTSTR lpszString);
```

### <a name="parameters"></a>參數

*nMaxCount*<br/>
指定要複製的最大位元組數目。

*lpszString*<br/>
指向要儲存格式名稱複本的緩衝區。

### <a name="remarks"></a>備註

剪貼簿擁有者應提供其格式的名稱。

覆寫這個成員函式，並將 CF_OWNERDISPLAY 格式的名稱複製到指定的緩衝區，而不超過指定的最大位元組數目。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndoncancelmode"></a><a name="oncancelmode"></a> CWnd：： OnCancelMode

架構會呼叫這個成員函式來通知 `CWnd` 取消任何內部模式。

```
afx_msg void OnCancelMode();
```

### <a name="remarks"></a>備註

如果 `CWnd` 物件具有焦點，則 `OnCancelMode` 會在對話方塊或訊息方塊顯示時呼叫其成員函式。 這讓您有 `CWnd` 機會取消像是滑鼠捕捉的模式。

預設的執行會透過呼叫 [ReleaseCapture](/windows/win32/api/winuser/nf-winuser-releasecapture) Windows 函式來回應。 覆寫衍生類別中的這個成員函式，以處理其他模式。

## <a name="cwndoncapturechanged"></a><a name="oncapturechanged"></a> CWnd：： OnCaptureChanged

架構會呼叫這個成員函式，以通知視窗遺失滑鼠捕捉。

```
afx_msg void OnCaptureChanged(CWnd* pWnd);
```

### <a name="parameters"></a>參數

*pWnd*<br/>
用來獲得滑鼠捕捉的視窗指標

### <a name="remarks"></a>備註

即使視窗呼叫 [ReleaseCapture](/windows/win32/api/winuser/nf-winuser-releasecapture) 本身，也會收到此訊息。 應用程式不應該嘗試設定滑鼠捕捉以回應此訊息。 當它收到這則訊息時，視窗應該視需要重繪自己，以反映新的滑鼠捕捉狀態。

如需 Windows 功能的詳細資訊，請參閱 Windows SDK `ReleaseCapture` 。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonchangecbchain"></a><a name="onchangecbchain"></a> CWnd：： OnChangeCbChain

架構會針對剪貼簿檢視器鏈中的每個視窗呼叫此成員函式，以通知視窗正在從鏈中移除。

```
afx_msg void OnChangeCbChain(
    HWND hWndRemove,
    HWND hWndAfter);
```

### <a name="parameters"></a>參數

*hWndRemove*<br/>
指定要從剪貼簿-檢視器鏈中移除的視窗控制碼。

*hWndAfter*<br/>
指定在從剪貼簿移除的視窗控制碼之後，從剪貼簿移除的視窗控制碼。

### <a name="remarks"></a>備註

每個 `CWnd` 接收呼叫的物件 `OnChangeCbChain` 都應該使用 [SendMessage](/windows/win32/api/winuser/nf-winuser-sendmessage) Windows 函式，將 [WM_CHANGECBCHAIN](/windows/win32/dataxchg/wm-changecbchain) 訊息傳送至剪貼簿-檢視器鏈中的下一個視窗， () 所傳回的控制碼 `SetClipboardViewer` 。 如果 *hWndRemove* 是鏈中的下一個視窗， *hWndAfter* 所指定的視窗就會變成下一個視窗，然後將剪貼簿訊息傳遞給它。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonchangeuistate"></a><a name="onchangeuistate"></a> CWnd：： OnChangeUIState

應變更使用者介面 (UI) 狀態時呼叫。

```
afx_msg void OnChangeUIState(
    UINT nAction,
    UINT nUIElement);
```

### <a name="parameters"></a>參數

*nAction*<br/>
指定要採取的動作。 可以是下列值之一：

- UIS_CLEAR 應隱藏 *nUIElement*) 所指定的 UI 狀態元素 (。

- UIS_INITIALIZE 您應該根據最後一個輸入事件來變更 *nUIElement*) 所指定的 UI 狀態元素 (。 如需詳細資訊，請參閱[WM_CHANGEUISTATE](/windows/win32/menurc/wm-changeuistate)的「**備註**」一節。

- UIS_SET *nUIElement*) 指定的 UI 狀態元素 (應該是可見的。

*nUIElement*<br/>
指定受影響的 UI 狀態元素或控制項的樣式。 可以是下列值之一：

- UISF_HIDEACCEL 鍵盤快速鍵盤。

- UISF_HIDEFOCUS 焦點指標。

- UISF_ACTIVE Windows XP：控制項應以用於作用中控制項的樣式來繪製。

### <a name="remarks"></a>備註

此成員函式會模擬 [WM_CHANGEUISTATE](/windows/win32/menurc/wm-changeuistate) 訊息的功能，如 Windows SDK 中所述。

## <a name="cwndonchar"></a><a name="onchar"></a> CWnd：： OnChar

當按鍵轉譯為非系統的字元時，架構會呼叫這個成員函式。

```
afx_msg void OnChar(
    UINT nChar,
    UINT nRepCnt,
    UINT nFlags);
```

### <a name="parameters"></a>參數

*nChar*<br/>
包含索引鍵的字元碼值。

*nRepCnt*<br/>
包含重複計數，這是使用者按住按鍵時重複按鍵的次數。

*nFlags*<br/>
包含掃描碼、按鍵轉換程式碼、先前的主要狀態和內容程式碼，如下列清單所示：

|值|意義|
|-----------|-------------|
|0-15|指定重複計數。 值是當使用者按住按鍵時，按鍵重複出現的次數。|
|16-23|指定掃描程式碼。 此值取決於原始設備製造商 (OEM) |
|24|指定機碼是否為擴充的索引鍵，例如出現在增強型101或102按鍵鍵盤上的右手 ALT 和 CTRL 鍵。 如果它是擴充索引鍵，則此值為 1;否則，它是0。|
|25-28|由 Windows 在內部使用。|
|29|指定內容程式碼。 如果按下按鍵時按住 ALT 鍵，則此值為 1;否則，此值為0。|
|30|指定先前的金鑰狀態。 如果在傳送訊息之前，金鑰已關閉，則此值為 1; 如果金鑰已啟動，則為0。|
|31|指定轉換狀態。 如果正在釋放金鑰，則值為1，如果正在按下索引鍵，則為0。|

### <a name="remarks"></a>備註

這個函式會在 [OnKeyUp](#onkeyup) 成員函式之前，以及在呼叫 [OnKeyDown](#onkeydown) 成員函式之前呼叫。 `OnChar` 包含按下或放開鍵盤按鍵的值。

因為所按下的按鍵與所產生的呼叫之間不一定要有一對一的對應關係 `OnChar` ，所以 *nFlags* 中的資訊通常對應用程式而言並不有用。 *NFlags*中的資訊僅適用于成員函式的最新呼叫， `OnKeyUp` 或 `OnKeyDown` 呼叫前面的成員函式 `OnChar` 。

針對 IBM 增強的101和102鍵鍵盤，增強型按鍵是鍵盤主要區段上的右 ALT 和右 CTRL 鍵;位於數位鍵台左邊的叢集中的 INS、DEL、HOME、END、PAGE UP、PAGE DOWN 和方向鍵;以及斜線 (/) 並在數位鍵台中輸入按鍵。 有些其他鍵盤可能會支援 *nFlags*中的擴充金鑰位。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonchartoitem"></a><a name="onchartoitem"></a> CWnd：： OnCharToItem

當具有 [LBS_WANTKEYBOARDINPUT](../../mfc/reference/styles-used-by-mfc.md#list-box-styles) 樣式的清單方塊傳送其擁有者 [WM_CHARTOITEM](/windows/win32/Controls/wm-chartoitem) 訊息以回應 [WM_CHAR](#onchar) 訊息時呼叫。

```
afx_msg int OnCharToItem(
    UINT nChar,
    CListBox* pListBox,
    UINT nIndex);
```

### <a name="parameters"></a>參數

*nChar*<br/>
指定使用者按下的索引鍵值。

*pListBox*<br/>
指定清單方塊的指標。 這可能是暫時性的。

*nIndex*<br/>
指定目前的插入號位置。

### <a name="return-value"></a>傳回值

架構會呼叫這個成員函式，以指定應用程式在回應呼叫時所執行的動作。 傳回值-2 表示應用程式已處理選取專案的所有層面，而不想讓清單方塊採取進一步的動作。 傳回值-1 表示清單方塊應該執行預設動作來回應擊鍵。 傳回值0或以上會指定清單方塊中專案的以零為基底的索引，並指出清單方塊應該針對指定的專案執行擊鍵的預設動作。

### <a name="remarks"></a>備註

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonchildactivate"></a><a name="onchildactivate"></a> CWnd：： OnChildActivate

如果 `CWnd` 物件是多個檔介面 (MDI) 子視窗，則 `OnChildActivate` 當使用者按一下視窗的標題列，或視窗啟用、移動或調整大小時，架構會呼叫這個架構。

```
afx_msg void OnChildActivate();
```

## <a name="cwndonchildnotify"></a><a name="onchildnotify"></a> CWnd：： OnChildNotify

這個成員函式會在收到適用于此視窗的通知訊息時，由這個視窗的父視窗呼叫。

```
virtual BOOL OnChildNotify(
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    LRESULT* pResult);
```

### <a name="parameters"></a>參數

*message*<br/>
傳送至父視窗的 Windows 訊息編號。

*wParam*<br/>
與訊息相關聯的 *wparam* 。

*lParam*<br/>
與訊息相關聯的 *lparam* 。

*pLResult*<br/>
要從父視窗程式傳回之值的指標。 如果預期不會傳回值，則此指標會是 Null。

### <a name="return-value"></a>傳回值

如果此視窗負責處理傳送至其父系的訊息，則為非零。否則為0。

### <a name="remarks"></a>備註

請勿直接呼叫此成員函式。

此成員函式的預設實值會傳回0，這表示父代應該處理訊息。

覆寫這個成員函式，以擴充控制項回應通知訊息的方式。

## <a name="cwndonclipboardupdate"></a><a name="onclipboardupdate"></a> CWnd：： OnClipboardUpdate

當剪貼簿的內容變更時，架構會呼叫這個成員函式。

```
afx_msg void OnClipboardUpdate();
```

## <a name="cwndonclose"></a><a name="onclose"></a> CWnd：： OnClose

架構會呼叫這個成員函式，作為 `CWnd` 或應用程式將終止的信號。

```
afx_msg void OnClose();
```

### <a name="remarks"></a>備註

預設的執行呼叫 `DestroyWindow` 。

## <a name="cwndoncolorizationcolorchanged"></a><a name="oncolorizationcolorchanged"></a> CWnd：： OnColorizationColorChanged

當非工作區的轉譯原則變更時，架構會呼叫這個成員。

```
afx_msg void OnColorizationColorChanged(
    DWORD dwColorizationColor,
    BOOL bOpacity);
```

### <a name="parameters"></a>參數

*dwColorizationColor*\
在指定新的顏色標示色彩。 色彩格式是0xAARRGGBB 格式的十六進位數位，其中四個元件的範圍從0x00 到0xFF。 AA 元件是 Alpha 值、RR 是紅色、GG 為綠色，而 BB 為藍色。

*bOpacity*\
在如果新的色彩與不透明度混合，則為 TRUE;如果不是，則為 FALSE。

### <a name="remarks"></a>備註

這個方法會接收 [WM_DWMNCRENDERINGCHANGED](/windows/win32/dwm/wm-dwmcolorizationcolorchanged) 的通知訊息，如 Windows SDK 中所述。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndoncommand"></a><a name="oncommand"></a> CWnd：： OnCommand

當使用者從功能表中選取專案時、子控制項傳送通知訊息，或翻譯快速鍵按鍵時，架構會呼叫這個成員函式。

```
virtual BOOL OnCommand(
    WPARAM wParam,
    LPARAM lParam);
```

### <a name="parameters"></a>參數

*wParam*<br/>
*WParam*的低序位字識別功能表項目、控制項或快速鍵的命令識別碼。 如果訊息是來自控制項，則 *wParam* 的高序位字指定通知訊息。 如果訊息是來自快速鍵，則高序位字是1。 如果訊息是來自功能表，高序位字是0。

*lParam*<br/>
識別當訊息來自控制項時傳送訊息的控制項。 否則， *lParam* 是0。

### <a name="return-value"></a>傳回值

如果應用程式處理此訊息，則會傳回非零。否則為0。

### <a name="remarks"></a>備註

`OnCommand` 處理用於控制通知和 ON_COMMAND 專案的訊息對應，並呼叫適當的成員函式。

在您的衍生類別中覆寫這個成員函式，以處理 [WM_COMMAND](/windows/win32/menurc/wm-command) 的訊息。 除非呼叫基類，否則覆寫不會處理訊息對應 `OnCommand` 。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndoncompacting"></a><a name="oncompacting"></a> CWnd：： OnCompacting

當 Windows 偵測到超過30到60秒間隔的系統時間超過12.5% 的時間，此架構會在壓縮記憶體時，為所有最上層視窗呼叫此成員函式。

```
afx_msg void OnCompacting(UINT nCpuTime);
```

### <a name="parameters"></a>參數

*nCpuTime*<br/>
指定 Windows 壓縮記憶體到花費在執行其他作業的 CPU 時間，目前花費的 CPU 時間比例。 例如，8000h 代表花費在壓縮記憶體的 CPU 時間50%。

### <a name="remarks"></a>備註

這表示系統記憶體不足。

當 `CWnd` 物件收到此呼叫時，應該盡可能釋放最多的記憶體，將應用程式目前的活動層級以及在 Windows 中執行的應用程式總數納入考慮。 應用程式可以呼叫 Windows 函式來判斷正在執行的應用程式數目。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndoncompareitem"></a><a name="oncompareitem"></a> CWnd：： OnCompareItem

架構會呼叫這個成員函式，以在子排序的擁有者繪製組合或清單方塊中指定新專案的相對位置。

```
afx_msg int OnCompareItem(
    int nIDCtl,
    LPCOMPAREITEMSTRUCT lpCompareItemStruct);
```

### <a name="parameters"></a>參數

*nIDCtl*<br/>
傳送 WM_COMPAREITEM 訊息之控制項的識別碼。

*lpCompareItemStruct*<br/>
包含 [COMPAREITEMSTRUCT](/windows/win32/api/winuser/ns-winuser-compareitemstruct) 資料結構的長指標，其中包含組合或清單方塊中兩個專案的識別碼和應用程式提供的資料。

### <a name="return-value"></a>傳回值

表示兩個專案的相對位置。 它可以是下列其中一個值：

|值|意義|
|-----------|-------------|
|-1|專案1會在專案2之前排序。|
|0|專案1和專案2的排序方式相同。|
|1|專案1會在專案2之後排序。|

### <a name="remarks"></a>備註

如果使用 [CBS_SORT](../../mfc/reference/styles-used-by-mfc.md#combo-box-styles) 或 [LBS_SORT](../../mfc/reference/styles-used-by-mfc.md#list-box-styles) 樣式建立組合或清單方塊，則每當應用程式加入新的專案時，Windows 會傳送 WM_COMPAREITEM 訊息給下拉式方塊或清單方塊擁有者。

下拉式方塊或清單方塊中的兩個專案是 reformed 在 `COMPAREITEMSTRUCT` *lpCompareItemStruct*所指向的結構中。 `OnCompareItem` 應傳回值，指出哪些專案應該出現在另一個專案之前。 一般而言，Windows 會進行此呼叫數次，直到它決定新專案的確切位置。

如果 `hwndItem` 結構的成員 `COMPAREITEMSTRUCT` 屬於 [CListBox](../../mfc/reference/clistbox-class.md) 或 [CComboBox](../../mfc/reference/ccombobox-class.md) 物件，則 `CompareItem` 會呼叫適當類別的虛擬函式。 覆寫 `CComboBox::CompareItem` 或 `CListBox::CompareItem` 在您 `CListBox` 的衍生或 `CComboBox` 類別中，以進行專案比較。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndoncompositionchanged"></a><a name="oncompositionchanged"></a> CWnd：： OnCompositionChanged

當啟用或停用桌面視窗管理員 (DWM) 組合時，架構會為所有最上層視窗呼叫這個成員函式。

```
afx_msg void OnCompositionChanged();
```

### <a name="remarks"></a>備註

這個方法會接收 [WM_DWMCOMPOSITIONCHANGED](/windows/win32/dwm/wm-dwmcompositionchanged) 通知，如 Windows SDK 所述。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndoncontextmenu"></a><a name="oncontextmenu"></a> CWnd：： OnCoNtextMenu

當使用者按一下滑鼠右鍵時，由架構呼叫 (以滑鼠右鍵按一下視窗中的) 。

```
afx_msg void OnContextMenu(
    CWnd* pWnd,
    CPoint pos);
```

### <a name="parameters"></a>參數

*pWnd*<br/>
使用者以滑鼠右鍵按一下滑鼠的視窗控制碼。 這可以是接收訊息之視窗的子視窗。 如需有關處理此訊息的詳細資訊，請參閱「備註」一節。

*Pos*<br/>
滑鼠點擊時，游標在螢幕座標中的位置。

### <a name="remarks"></a>備註

您可以使用 [trackpopupmenu 讓](../../mfc/reference/cmenu-class.md#trackpopupmenu)顯示內容功能表來處理此訊息。

如果您未顯示內容功能表，您應該將此訊息傳遞至 [DefWindowProc](#defwindowproc) 函式。 如果您的視窗是子視窗，則會 `DefWindowProc` 將訊息傳送至父視窗。 否則， `DefWindowProc` 如果指定的位置是在視窗的標題中，則會顯示預設的內容功能表。

## <a name="cwndoncopydata"></a><a name="oncopydata"></a> CWnd：： OnCopyData

架構會呼叫這個成員函式，將資料從一個應用程式複製到另一個應用程式。

```
afx_msg BOOL OnCopyData(
    CWnd* pWnd,
    COPYDATASTRUCT* pCopyDataStruct);
```

### <a name="parameters"></a>參數

*pWnd*<br/>
傳送資料之物件的指標 `CWnd` 。

*pCopyDataStruct*<br/>
[COPYDATASTRUCT](/windows/win32/api/winuser/ns-winuser-copydatastruct)結構的指標，其中包含要傳送的資料。

### <a name="return-value"></a>傳回值

如果接收應用程式成功接受資料，則傳回 TRUE。 否則，會傳回 FALSE。

### <a name="remarks"></a>備註

傳遞的資料不能包含指標或其他物件參考，無法存取接收資料的應用程式。

複製資料時，不能由傳送進程的另一個執行緒變更。

接收應用程式應該將資料視為唯讀。 參數 *pCopyDataStruct* 所指向的結構只在資料傳輸期間有效;但是，接收的應用程式不應該釋放與結構相關聯的記憶體。

如果接收的應用程式在此函數傳回之後需要存取資料，它必須將接收到的資料複製到本機緩衝區。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndoncreate"></a><a name="oncreate"></a> CWnd：： >oncreate

當應用程式要求藉由呼叫 [Create](#create) 或 [CreateEx](#createex) 成員函式來建立 Windows 視窗時，架構會呼叫這個成員函式。

```
afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
```

### <a name="parameters"></a>參數

*lpCreateStruct*<br/>
指向 [CREATESTRUCT](/windows/win32/api/winuser/ns-winuser-createstructw) 結構，其中包含要建立之物件的相關資訊 `CWnd` 。

### <a name="return-value"></a>傳回值

`OnCreate` 必須傳回0才能繼續建立 `CWnd` 物件。 如果應用程式傳回-1，則會終結視窗。

### <a name="remarks"></a>備註

`CWnd`物件會在建立視窗之後，但在可見之前收到此呼叫。 `OnCreate` 在或成員函式傳回之前呼叫 `Create` `CreateEx` 。

覆寫這個成員函式，以執行任何必要的衍生類別初始化。

`CREATESTRUCT`結構包含用來建立視窗之參數的複本。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonctlcolor"></a><a name="onctlcolor"></a> CWnd：： OnCtlColor

當子控制項即將繪製時，架構會呼叫這個成員函式。

```
afx_msg HBRUSH OnCtlColor(
    CDC* pDC,
    CWnd* pWnd,
    UINT nCtlColor);
```

### <a name="parameters"></a>參數

*Pdc*<br/>
包含子視窗顯示內容的指標。 可能是暫時性的。

*pWnd*<br/>
包含要求色彩之控制項的指標。 可能是暫時性的。

*nCtlColor*<br/>
包含下列其中一個值，指定控制項的類型：

- CTLCOLOR_BTN 按鈕控制項

- CTLCOLOR_DLG 對話方塊

- CTLCOLOR_EDIT 編輯控制項

- CTLCOLOR_LISTBOX 清單方塊控制項

- CTLCOLOR_MSGBOX 訊息方塊

- CTLCOLOR_SCROLLBAR 捲軸控制項

- CTLCOLOR_STATIC 靜態控制項

### <a name="return-value"></a>傳回值

`OnCtlColor` 必須將控制碼傳回給要用來繪製控制項背景的筆刷。

### <a name="remarks"></a>備註

大部分的控制項都會將此訊息傳送至其父 (通常會有一個對話方塊，) 使用正確的色彩準備 *pDC* 來繪製控制項。

若要變更文字色彩，請 `SetTextColor` 使用所需的紅色、綠色和藍色 (RGB) 值來呼叫成員函式。

若要變更單行編輯控制項的背景色彩，請在 CTLCOLOR_EDIT 和 CTLCOLOR_MSGBOX 訊息程式碼中設定筆刷控點，並呼叫 [CDC：： SetBkColor](../../mfc/reference/cdc-class.md#setbkcolor) 函式來回應 CTLCOLOR_EDIT 程式碼。

`OnCtlColor` 將不會針對下拉式方塊的清單方塊呼叫，因為下拉式清單方塊實際上是下拉式方塊的子系，而不是視窗的子系。 若要變更下拉式清單方塊的色彩，請使用的覆寫來建立，以 `CComboBox` `OnCtlColor` 檢查參數中的 CTLCOLOR_LISTBOX `nCtlColor` 。 在這個處理常式中，成員函式 `SetBkColor` 必須用來設定文字的背景色彩。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。 若要將下列方法加入至對話方塊類別，請使用 [Visual Studio 屬性] 窗格來加入 WM_CTLCOLOR 的訊息處理常式。 或者，您可以手動將 ON_WM_CTLCOLOR ( # A1 專案加入至訊息對應。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#107](../../mfc/reference/codesnippet/cpp/cwnd-class_47.cpp)]

## <a name="cwndondeadchar"></a><a name="ondeadchar"></a> CWnd：： OnDeadChar

當呼叫 [OnKeyUp](#onkeyup) 成員函式和 [OnKeyDown](#onkeydown) 成員函式時，架構會呼叫這個成員函式。

```
afx_msg void OnDeadChar(
    UINT nChar,
    UINT nRepCnt,
    UINT nFlags);
```

### <a name="parameters"></a>參數

*nChar*<br/>
指定不正確索引鍵字元值。

*nRepCnt*<br/>
指定重複計數。

*nFlags*<br/>
指定掃描碼、按鍵轉換程式碼、先前的主要狀態和內容程式碼，如下列清單所示：

|值|描述|
|-----------|-----------------|
|0-7|)  (OEM 相依值掃描程式碼。 高序位單字的低位元組。|
|8|擴充金鑰（例如，函式金鑰或數位鍵臺上的機碼） (1 （如果它是擴充金鑰）。否則為 0) 。|
|9-10|未使用。|
|11-12|由 Windows 在內部使用。|
|13|內容程式碼 (1 如果按下按鍵時按住 ALT 鍵，則為 < a0/1;否則為 0) 。|
|14|先前的金鑰狀態 (1 如果機碼在呼叫之前關閉，則為0（如果機碼) ）。|
|15|轉換狀態 (1 如果正在釋放機碼，則為0（如果按下按鍵) ）。|

### <a name="remarks"></a>備註

這個成員函式可以用來指定死索引鍵的字元值。 死索引鍵是一種索引鍵，例如與其他字元結合以形成複合字元的母音 (雙點) 字元。 例如，母音字元-O 字元包含死索引鍵、變音符號和 O 鍵。

應用程式通常會使用 `OnDeadChar` ，為使用者提供每個按鍵的相關意見反應。 例如，應用程式可以在目前的字元位置顯示輔色，而不移動插入號。

因為按下的按鍵與呼叫之間不一定要有一對一的對應關係 `OnDeadChar` ，所以 *nFlags* 中的資訊通常對應用程式而言並不有用。 *NFlags*中的資訊只適用于對[OnKeyUp](#onkeyup)成員函式的最新呼叫，或在呼叫之前的[OnKeyDown](#onkeydown)成員函式 `OnDeadChar` 。

針對 IBM 增強的101和102鍵鍵盤，增強型按鍵是鍵盤主要區段上的右 ALT 和右 CTRL 鍵;位於數位鍵台左邊的叢集中的 INS、DEL、HOME、END、PAGE UP、PAGE DOWN 和方向鍵;以及斜線 (/) 並在數位鍵台中輸入按鍵。 有些其他鍵盤可能會支援 *nFlags*中的擴充金鑰位。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndondeleteitem"></a><a name="ondeleteitem"></a> CWnd：： OnDeleteItem

架構會呼叫這個成員函式，以通知主控描繪清單方塊或下拉式方塊的擁有者，指出清單方塊或下拉式方塊已終結，或是 CComboBox 已移除專案 [：:D eletestring](../../mfc/reference/ccombobox-class.md#deletestring)、 [CListBox：:D eletestring](../../mfc/reference/clistbox-class.md#deletestring)、 [CComboBox：： ResetContent](../../mfc/reference/ccombobox-class.md#resetcontent)或 [CListBox：： ResetContent](../../mfc/reference/clistbox-class.md#resetcontent)。

```
afx_msg void OnDeleteItem(
    int nIDCtl,
    LPDELETEITEMSTRUCT lpDeleteItemStruct);
```

### <a name="parameters"></a>參數

*nIDCtl*<br/>
傳送 WM_DELETEITEM 訊息之控制項的識別碼。

*lpDeleteItemStruct*<br/>
指定 [DELETEITEMSTRUCT](/windows/win32/api/winuser/ns-winuser-deleteitemstruct) 資料結構的長指標，其中包含已刪除清單方塊專案的相關資訊。

### <a name="remarks"></a>備註

如果 `hwndItem` 結構的成員 `DELETEITEMSTRUCT` 屬於下拉式方塊或清單方塊，則 `DeleteItem` 會呼叫適當類別的虛擬函式。 覆寫 `DeleteItem` 適當控制項類別的成員函式，以刪除專案特定資料。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndondestroy"></a><a name="ondestroy"></a> CWnd：： OnDestroy

架構會呼叫這個成員函式，以通知 `CWnd` 物件其已被終結。

```
afx_msg void OnDestroy();
```

### <a name="remarks"></a>備註

`OnDestroy` 從畫面移除物件之後，就會呼叫 `CWnd` 。

`OnDestroy` 會先呼叫以進行終結 `CWnd` ，然後針對的子視窗終結 `CWnd` 它們。 您可以假設所有的子視窗在執行時仍然存在 `OnDestroy` 。

如果要終結的 `CWnd` 物件是剪貼簿-檢視器鏈的一部分 (藉由呼叫 [SetClipboardViewer](#setclipboardviewer) 成員函式來設定) ，則 `CWnd` 必須先從剪貼簿檢視器鏈中移除本身，方法是在從函式傳回之前呼叫 [ChangeClipboardChain](#changeclipboardchain) 成員函式 `OnDestroy` 。

## <a name="cwndondestroyclipboard"></a><a name="ondestroyclipboard"></a> CWnd：： OnDestroyClipboard

當剪貼簿透過呼叫 [EmptyClipboard](/windows/win32/api/winuser/nf-winuser-emptyclipboard) Windows 函式清空時，架構會呼叫剪貼簿擁有者的這個成員函式。

```
afx_msg void OnDestroyClipboard();
```

## <a name="cwndondevicechange"></a><a name="ondevicechange"></a> CWnd：： OnDeviceChange

架構會呼叫此成員函式，以通知應用程式或設備磁碟機變更裝置或電腦的硬體設定。

```
afx_msg BOOL OnDeviceChange(
    UINT nEventType,
    DWORD_PTR dwData);
```

### <a name="parameters"></a>參數

*nEventType*<br/>
事件種類。 如需可用值的描述，請參閱備註一節。

*dwData*<br/>
包含事件特定資料的結構位址。 其意義取決於指定的事件。

### <a name="remarks"></a>備註

對於提供軟體可控制功能的裝置，例如彈出和鎖定，作業系統通常會傳送 DBT_DEVICEREMOVEPENDING 訊息，讓應用程式和設備磁碟機正常地結束其裝置的使用。

如果作業系統強制移除裝置，則在這麼做之前，它可能不會傳送 DBT_DEVICEQUERYREMOVE 訊息。

*NEvent*參數可以是下列其中一個值：

- [DBT_DEVICEARRIVAL](/windows/win32/DevIO/dbt-devicearrival) 已插入裝置，而且現在已可供使用。

- [DBT_DEVICEQUERYREMOVE](/windows/win32/DevIO/dbt-devicequeryremove) 要求移除裝置的許可權。 任何應用程式都可以拒絕此要求，並取消移除。

- [DBT_DEVICEQUERYREMOVEFAILED](/windows/win32/DevIO/dbt-devicequeryremovefailed) 移除裝置的要求已取消。

- [DBT_DEVICEREMOVEPENDING](/windows/win32/DevIO/dbt-deviceremovepending) 即將移除裝置。 無法拒絕。

- [DBT_DEVICEREMOVECOMPLETE](/windows/win32/DevIO/dbt-deviceremovecomplete) 裝置已移除。

- [DBT_DEVICETYPESPECIFIC](/windows/win32/DevIO/dbt-devicetypespecific) 裝置特定的事件。

- [DBT_CONFIGCHANGED](/windows/win32/DevIO/dbt-configchanged) 目前的設定已變更。

- DBT_DEVNODES_CHANGED 裝置節點已變更。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndondevmodechange"></a><a name="ondevmodechange"></a> CWnd：： OnDevModeChange

`CWnd`當使用者變更裝置模式設定時，架構會為所有最上層物件呼叫此成員函式。

```
afx_msg void OnDevModeChange(LPTSTR lpDeviceName);
```

### <a name="parameters"></a>參數

*lpDeviceName*<br/>
指向 Windows 初始化檔中指定的裝置名稱，WIN.INI。

### <a name="remarks"></a>備註

處理 WM_DEVMODECHANGE 訊息的應用程式可能會重新初始化其裝置模式設定。 使用 Windows `ExtDeviceMode` 功能儲存和還原裝置設定的應用程式通常不會處理此函式。

當使用者從主控台變更預設印表機時，不會呼叫此函數。 在此情況下， `OnWinIniChange` 會呼叫函數。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndondrawclipboard"></a><a name="ondrawclipboard"></a> CWnd：： OnDrawClipboard

當剪貼簿的內容變更時，架構會針對剪貼簿檢視器鏈中的每個視窗呼叫這個成員函式。

```
afx_msg void OnDrawClipboard();
```

### <a name="remarks"></a>備註

只有透過呼叫 [SetClipboardViewer](#setclipboardviewer) 成員函式來聯結剪貼簿-檢視器鏈的應用程式，才需要回應此呼叫。

每個接收 `OnDrawClipboard` 呼叫的視窗都應該呼叫 [SendMessage](/windows/win32/api/winuser/nf-winuser-sendmessage) Windows 函式，將 [WM_DRAWCLIPBOARD](/windows/win32/dataxchg/wm-drawclipboard) 訊息傳遞至剪貼簿-檢視器鏈中的下一個視窗。 [SetClipboardViewer](#setclipboardviewer)成員函式會傳回下一個視窗的控制碼;它可能會修改以回應[OnChangeCbChain](#onchangecbchain)成員函式呼叫。

## <a name="cwndondrawiconicthumbnailorlivepreview"></a><a name="ondrawiconicthumbnailorlivepreview"></a> CWnd：： OnDrawIconicThumbnailOrLivePreview

需要取得點陣圖，在 Windows 7 索引標籤上顯示為縮圖時，或顯示在用戶端上以查看應用程式時，由架構呼叫。

```
virtual void OnDrawIconicThumbnailOrLivePreview(
    CDC& dc,
    CRect rect,
    CSize szRequiredThumbnailSize,
    BOOL bIsThumbnail,
    BOOL& bAlphaChannelSet);
```

### <a name="parameters"></a>參數

*直流*<br/>
指定裝置內容。

*矩形*<br/>
指定要呈現之區域的周框。

*szRequiredThumbnailSize*<br/>
指定目標縮圖的大小。 如果 *bIsThumbnail* 為 FALSE，則應該予以忽略。

*bIsThumbnail*<br/>
指定是否要針對 iconic 縮圖或即時預覽呼叫這個方法， (查看) 。

*bAlphaChannelSet*<br/>
擴展如果您的實值會初始化 *dc*中所選取點陣圖的 Alpha 色板，請將它設定為 TRUE。

### <a name="remarks"></a>備註

在衍生類別中覆寫此方法，並在指定的裝置內容上進行繪製，以便自訂縮圖和查看。 如果 *bThumbnail* 為 TRUE，則可以忽略 *szRequiredThumbnailSize* 。 在此情況下，您應該注意到您繪製的是完整大小的點陣圖 (也就是涵蓋整個工作區) 的點陣圖。 裝置內容 ( *dc*) 隨附于所選32位點陣圖。 預設的執行會使用 PRF_CLIENT、PRF_CHILDREN 和 PRF_NONCLIENT 旗標，將 WM_PRINT 傳送至此視窗。

## <a name="cwndondrawitem"></a><a name="ondrawitem"></a> CWnd：： OnDrawItem

當控制項或功能表的視覺外觀變更時，架構會針對主控描繪按鈕控制項、下拉式方塊控制項、清單方塊控制項或功能表的擁有者呼叫這個成員函式。

```
afx_msg void OnDrawItem(
    int nIDCtl,
    LPDRAWITEMSTRUCT lpDrawItemStruct);
```

### <a name="parameters"></a>參數

*nIDCtl*<br/>
包含傳送 WM_DRAWITEM 訊息之控制項的識別碼。 如果功能表傳送了訊息， *nIDCtl* 就會包含0。

*lpDrawItemStruct*<br/>
指定資料結構的長指標 `DRAWITEMSTRUCT` ，其中包含要繪製之專案的相關資訊，以及所需的繪圖類型。

### <a name="remarks"></a>備註

`itemAction` [DRAWITEMSTRUCT](/windows/win32/api/winuser/ns-winuser-drawitemstruct)結構的成員會定義要執行的繪圖作業。 此成員中的資料可讓控制項的擁有者判斷需要什麼繪製動作。

從處理此訊息傳回之前，應用程式應該確保結構的 *hDC* 成員所識別的裝置內容 `DRAWITEMSTRUCT` 會還原為預設狀態。

如果 `hwndItem` 成員屬於 [CButton](../../mfc/reference/cbutton-class.md)、 [CMenu](../../mfc/reference/cmenu-class.md)、 [CListBox](../../mfc/reference/clistbox-class.md)或 [CComboBox](../../mfc/reference/ccombobox-class.md) 物件，則 `DrawItem` 會呼叫適當類別的虛擬函式。 覆寫 `DrawItem` 適當控制項類別的成員函式，以繪製專案。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndondropfiles"></a><a name="ondropfiles"></a> CWnd：： OnDropFiles

當使用者放開滑鼠左鍵時，架構會呼叫這個成員函式，而該視窗已經註冊自己做為已卸載檔案的收件者。

```
afx_msg void OnDropFiles(HDROP hDropInfo);
```

### <a name="parameters"></a>參數

*hDropInfo*<br/>
描述已卸載之檔案的內部資料結構指標。 、和 Windows 函式會使用此控制碼來取得已卸載檔案 `DragFinish` `DragQueryFile` `DragQueryPoint` 的相關資訊。

### <a name="remarks"></a>備註

一般情況下，衍生類別的設計是支援卸載的檔案，而且會在視窗結構中自行註冊。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonenable"></a><a name="onenable"></a> CWnd：： OnEnable

當應用程式變更物件的啟用狀態時，架構會呼叫這個成員函式 `CWnd` 。

```
afx_msg void OnEnable(BOOL bEnable);
```

### <a name="parameters"></a>參數

*bEnable*<br/>
指定物件是否已 `CWnd` 啟用或停用。 如果已啟用，此參數為 TRUE `CWnd` ; 如果已停用，則為 FALSE `CWnd` 。

### <a name="remarks"></a>備註

`OnEnable` 會在 [EnableWindow](#enablewindow) 成員函式傳回之前呼叫，但在視窗啟用狀態 ( [WS_DISABLED](styles-used-by-mfc.md#window-styles) 樣式位) 已變更。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonendsession"></a><a name="onendsession"></a> CWnd：： OnEndSession

當 `CWnd` 物件從 [OnQueryEndSession](#onqueryendsession) 成員函式呼叫傳回非零值之後，架構會呼叫這個成員函式。

```
afx_msg void OnEndSession(BOOL bEnding);
```

### <a name="parameters"></a>參數

*彎曲*<br/>
指定是否結束會話。 如果會話已結束，則為 TRUE;否則為 FALSE。

### <a name="remarks"></a>備註

`OnEndSession`呼叫 `CWnd` 會通知物件該會話是否正在結束。

若 *為 TRUE，則 Windows* 可以在所有應用程式從處理此呼叫傳回之後隨時終止。 因此，讓應用程式執行中終止所需的所有工作 `OnEndSession` 。

當會話結束時，您不需要呼叫 [DestroyWindow](#destroywindow) 成員函數或 [PostQuitMessage](/windows/win32/api/winuser/nf-winuser-postquitmessage) Windows 函數。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonenteridle"></a><a name="onenteridle"></a> CWnd：： OnEnterIdle

架構會呼叫這個成員函式，以通知應用程式的主視窗程式，指出強制回應對話方塊或功能表正在進入閒置狀態。

```
afx_msg void OnEnterIdle(
    UINT nWhy,
    CWnd* pWho);
```

### <a name="parameters"></a>參數

*nWhy*<br/>
指定訊息是對話方塊或顯示功能表的結果。 這個參數可以是下列其中一個值：

- MSGF_DIALOGBOX 系統閒置，因為正在顯示對話方塊。

- MSGF_MENU 系統閒置，因為正在顯示功能表。

*pWho*<br/>
指定對話方塊的指標 (如果 *nWhy* 是 MSGF_DIALOGBOX) ，或包含所顯示功能表的視窗 (如果 *nWhy* 是 MSGF_MENU) 。 此指標可能是暫時性的，不應儲存供稍後使用。

### <a name="remarks"></a>備註

強制回應對話方塊或功能表在處理一或多個先前的訊息之後，就會進入閒置狀態，當佇列中沒有任何訊息在佇列中等候時。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonentermenuloop"></a><a name="onentermenuloop"></a> CWnd：： OnEnterMenuLoop

當輸入功能表強制回應迴圈時，架構會呼叫這個成員函式。

```
afx_msg void OnEnterMenuLoop(BOOL bIsTrackPopupMenu);
```

### <a name="parameters"></a>參數

*bIsTrackPopupMenu*<br/>
指定相關功能表是否為快顯功能表。 如果函式成功，則為非零值;否則為0。

### <a name="remarks"></a>備註

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonentersizemove"></a><a name="onentersizemove"></a> CWnd：： OnEnterSizeMove

架構會在受影響的視窗進入移動或調整大小的強制回應迴圈之後，一次呼叫此成員函式。

```
afx_msg void OnEnterSizeMove();
```

### <a name="remarks"></a>備註

這個方法會接收 [WM_ENTERSIZEMOVE](/windows/win32/winmsg/wm-entersizemove) 通知，如 Windows SDK 所述。

當使用者按一下視窗的標題列或調整框線，或是當視窗將 [WM_SYSCOMMAND](/windows/win32/menurc/wm-syscommand) 訊息傳遞給 [CWnd：:D efwindowproc](#defwindowproc) 函式，而該訊息的 *wParam* 參數指定 SC_MOVE 或 SC_SIZE 時，視窗會進入移動或調整大小的強制回應迴圈。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonerasebkgnd"></a><a name="onerasebkgnd"></a> CWnd：： OnEraseBkgnd

當物件背景需要清除時，架構會呼叫這個成員函式 `CWnd` (例如，當調整大小) 時。

```
afx_msg BOOL OnEraseBkgnd(CDC* pDC);
```

### <a name="parameters"></a>參數

*Pdc*<br/>
指定裝置內容物件。

### <a name="return-value"></a>傳回值

如果清除背景則為非零;否則為0。

### <a name="remarks"></a>備註

它會呼叫以準備不正確繪圖區域。

預設的執行會使用由視窗類別結構的成員所指定的視窗類別背景筆刷，來清除背景 `hbrBackground` 。

如果 `hbrBackground` 成員為 Null，則覆寫的版本 `OnEraseBkgnd` 應該會清除背景色彩。 您的版本也應該 `CWnd` 先針對筆刷呼叫 [UnrealizeObject](/windows/win32/api/wingdi/nf-wingdi-unrealizeobject) ，然後選取筆刷，以便將預期筆刷的原點與座標組齊。

覆寫 `OnEraseBkgnd` 應該會傳回非零值，以回應 WM_ERASEBKGND 如果處理訊息並清除背景，這表示不需要進一步清除。 如果它傳回0，則視窗仍會標示為需要清除。  (一般而言，這表示結構的 `fErase` 成員將會 `PAINTSTRUCT` 是 TRUE。 ) 

Windows 假設背景是使用 MM_TEXT 對應模式來計算。 如果裝置內容使用任何其他對應模式，則清除的區域可能不在工作區可見的部分內。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonexitmenuloop"></a><a name="onexitmenuloop"></a> CWnd：： OnExitMenuLoop

當已結束功能表強制回應迴圈時，架構會呼叫這個成員函式。

```
afx_msg void OnExitMenuLoop(BOOL bIsTrackPopupMenu);
```

### <a name="parameters"></a>參數

*bIsTrackPopupMenu*<br/>
指定相關功能表是否為快顯功能表。 如果函式成功，則為非零值;否則為0。

### <a name="remarks"></a>備註

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonexitsizemove"></a><a name="onexitsizemove"></a> CWnd：： OnExitSizeMove

架構會在受影響的視窗離開移動或調整大小強制回應迴圈之後，一次呼叫此成員函式。

```
afx_msg void OnExitSizeMove();
```

### <a name="remarks"></a>備註

這個方法會接收 [WM_EXITSIZEMOVE](/windows/win32/winmsg/wm-exitsizemove) 通知，如 Windows SDK 所述。

當使用者按一下視窗的標題列或調整框線，或是當視窗將 [WM_SYSCOMMAND](/windows/win32/menurc/wm-syscommand) 訊息傳遞給 [CWnd：:D efwindowproc](#defwindowproc) 函式，而該訊息的 *wParam* 參數指定 SC_MOVE 或 SC_SIZE 時，視窗會進入移動或調整大小的強制回應迴圈。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonfontchange"></a><a name="onfontchange"></a> CWnd：： OnFontChange

`OnFontChange`當應用程式變更字型資源的集區之後，系統中的所有最上層視窗都會收到來自架構的呼叫。

```
afx_msg void OnFontChange();
```

### <a name="remarks"></a>備註

從系統新增或移除字型 (例如透過 [AddFontResource](/windows/win32/api/wingdi/nf-wingdi-addfontresourcew) 或 [RemoveFontResource](/windows/win32/api/wingdi/nf-wingdi-removefontresourcew) Windows 函式的應用程式，) 應該將 [WM_FONTCHANGE](/windows/win32/gdi/wm-fontchange) 訊息傳送至所有最上層視窗。

若要傳送此訊息，請使用 [SendMessage](/windows/win32/api/winuser/nf-winuser-sendmessage) Windows 函數，並將 *hWnd* 參數設定為 HWND_BROADCAST。

## <a name="cwndongetdlgcode"></a><a name="ongetdlgcode"></a> CWnd：： OnGetDlgCode

呼叫控制項，讓控制項可以處理方向鍵和 TAB 鍵輸入本身。

```
afx_msg UINT OnGetDlgCode();
```

### <a name="return-value"></a>傳回值

下列一或多個值，指出應用程式處理的輸入類型：

- DLGC_BUTTON 按鈕 (一般) 。

- DLGC_DEFPUSHBUTTON 預設按鈕。

- DLGC_HASSETSEL EM_SETSEL 訊息。

- DLGC_UNDEFPUSHBUTTON 沒有預設的按鈕處理。  (應用程式可搭配使用此旗標與 DLGC_BUTTON，表示它會處理按鈕輸入，但會依賴系統來處理預設的按鍵處理。 ) 

- DLGC_RADIOBUTTON 選項按鈕。

- DLGC_STATIC 靜態控制項。

- DLGC_WANTALLKEYS 所有鍵盤輸入。

- DLGC_WANTARROWS 箭號鍵。

- DLGC_WANTCHARS WM_CHAR 訊息。

- DLGC_WANTMESSAGE 所有鍵盤輸入。 應用程式會將此訊息傳遞給控制項。

- DLGC_WANTTAB TAB 鍵。

### <a name="remarks"></a>備註

一般來說，Windows 會處理控制項的所有方向鍵和 TAB 鍵輸入 `CWnd` 。 藉由覆寫 `OnGetDlgCode` ， `CWnd` 控制項可以選擇特定類型的輸入來處理本身。

預先定義之控制項類別的預設函式會傳回 `OnGetDlgCode` 適用于每個類別的程式碼。

## <a name="cwndongetminmaxinfo"></a><a name="ongetminmaxinfo"></a> CWnd：： OnGetMinMaxInfo

每當 Windows 需要知道最大化的位置或維度或最小或最大的追蹤大小時，架構就會呼叫這個成員函式。

```
afx_msg void OnGetMinMaxInfo(MINMAXINFO* lpMMI);
```

### <a name="parameters"></a>參數

*lpMMI*<br/>
指向 `MINMAXINFO` 包含視窗最大化大小和位置的資訊，以及最小和最大追蹤大小的結構。 如需此結構的詳細資訊，請參閱 [MINMAXINFO](/windows/win32/api/winuser/ns-winuser-minmaxinfo) 結構。

### <a name="remarks"></a>備註

最大化的大小是當其框線完全延伸時的視窗大小。 視窗的最大追蹤大小是可利用框線來調整視窗大小的最大視窗大小。 視窗的最小追蹤大小是可使用框線來調整視窗大小的最小視窗大小。

Windows 會填入點陣列，以指定不同位置和維度的預設值。 應用程式可能會在中變更這些值 `OnGetMinMaxInfo` 。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonhelp"></a><a name="onhelp"></a> CWnd：： OnHelp

在應用程式 (使用目前的內容) 中處理 F1 說明。

```
afx_msg void OnHelp();
```

### <a name="remarks"></a>備註

如需詳細資訊，請參閱 [CWinApp：： OnHelp](../../mfc/reference/cwinapp-class.md#onhelp) 。

## <a name="cwndonhelpfinder"></a><a name="onhelpfinder"></a> CWnd：： OnHelpFinder

處理 ID_HELP_FINDER 和 ID_DEFAULT_HELP 命令。

```
afx_msg void OnHelpFinder();
```

### <a name="remarks"></a>備註

如需詳細資訊，請參閱 [CWinApp：： OnHelpFinder](../../mfc/reference/cwinapp-class.md#onhelpfinder) 。

## <a name="cwndonhelpindex"></a><a name="onhelpindex"></a> CWnd：： OnHelpIndex

處理 ID_HELP_INDEX 命令，並提供預設說明主題。

```
afx_msg void OnHelpIndex();
```

### <a name="remarks"></a>備註

如需詳細資訊，請參閱 [CWinApp：： OnHelpIndex](../../mfc/reference/cwinapp-class.md#onhelpindex) 。

## <a name="cwndonhelpinfo"></a><a name="onhelpinfo"></a> CWnd：： OnHelpInfo

當使用者按下 F1 鍵時，由架構呼叫。

```
afx_msg BOOL OnHelpInfo(HELPINFO* lpHelpInfo);
```

### <a name="parameters"></a>參數

*lpHelpInfo*<br/>
[HELPINFO](/windows/win32/api/winuser/ns-winuser-helpinfo)結構的指標，其中包含有關要求說明之功能表項目、控制項、對話方塊或視窗的資訊。

### <a name="return-value"></a>傳回值

如果視窗具有鍵盤焦點，或視窗內的功能表是作用中，則傳回 TRUE。 如果沒有任何視窗具有鍵盤焦點，則會傳回 FALSE。

### <a name="remarks"></a>備註

如果按下 F1 時，功能表為使用中狀態，則會將 WM_HELP 傳送至與功能表相關聯的視窗;否則，會將 WM_HELP 傳送至具有鍵盤焦點的視窗。 如果沒有視窗具有鍵盤焦點，WM_HELP 會傳送至目前的使用中視窗。

## <a name="cwndonhelpusing"></a><a name="onhelpusing"></a> CWnd：： OnHelpUsing

處理 ID_HELP_USING 命令。

```
afx_msg void OnHelpUsing();
```

### <a name="remarks"></a>備註

如需詳細資訊，請參閱 [CWinApp：： OnHelpUsing](../../mfc/reference/cwinapp-class.md#onhelpusing) 。

## <a name="cwndonhotkey"></a><a name="onhotkey"></a> CWnd：： OnHotKey

當使用者按下整個系統的快速鍵時，架構會呼叫這個成員函式。

```
afx_msg void OnHotKey(
    UINT nHotKeyId,
    UINT nKey1,
    UINT nKey2);
```

### <a name="parameters"></a>參數

*nHotKeyId*\
在產生訊息之快速鍵的識別碼。 如果訊息是由系統定義的熱鍵產生，此參數將會是下列其中一個值：

- `IDHOT_SNAPDESKTOP` -已按下的貼齊桌面快速鍵。
- `IDHOT_SNAPWINDOW` -已按下嵌入式管理視窗的快速鍵。

*nKey1*\
在 () 或旗標的位元組合，表示結合了 *nKey2* 參數所指定之索引鍵的按鍵。 可能的值包括：

- `MOD_ALT` -已將任一個 ALT 鍵保留下來。
- `MOD_CONTROL` -按住 CTRL 鍵。
- `MOD_SHIFT` -已保留 SHIFT 鍵。
- `MOD_WIN` -WINDOWS 機碼已關閉。 這些金鑰是以 Microsoft Windows 標誌標記。

*nKey2*\
在快速鍵的虛擬按鍵碼。

### <a name="remarks"></a>備註

這個方法會接收 [WM_HOTKEY](/windows/win32/inputdev/wm-hotkey) 通知，如 Windows SDK 所述。 此訊息會放在與註冊快速鍵之執行緒相關聯的訊息佇列頂端。 使用 [RegisterHotKey](/windows/win32/api/winuser/nf-winuser-registerhotkey) 函式來註冊整個系統的快速鍵。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonhscroll"></a><a name="onhscroll"></a> CWnd：： OnHScroll

當使用者按一下視窗的水準捲軸時，架構會呼叫這個成員函式。

```
afx_msg void OnHScroll(
    UINT nSBCode,
    UINT nPos,
    CScrollBar* pScrollBar);
```

### <a name="parameters"></a>參數

*nSBCode*<br/>
指定捲軸程式碼，指出使用者的滾動要求。 此參數可以是下列其中一項：

- SB_LEFT 滾動至最左邊。

- SB_ENDSCROLL 結束捲軸。

- SB_LINELEFT 向左移動。

- SB_LINERIGHT 向右滾動。

- SB_PAGELEFT 向左滾動一個頁面。

- SB_PAGERIGHT 向右滾動一頁。

- SB_RIGHT 滾動至最右邊。

- SB_THUMBPOSITION 滾動至絕對位置。 目前的位置是由 *nPos* 參數指定。

- SB_THUMBTRACK 將捲動方塊拖曳至指定的位置。 目前的位置是由 *nPos* 參數指定。

*nPos*<br/>
指定捲軸程式碼 SB_THUMBPOSITION 或 SB_THUMBTRACK 時的捲動方塊位置;否則，不使用。 視初始捲軸範圍而定， *nPos* 可能是負數，且應該在 **`int`** 必要時轉換為。

*pScrollBar*<br/>
如果捲軸訊息來自捲軸控制項，則包含控制項的指標。 如果使用者按一下視窗的捲軸，則此參數為 Null。 該指標可能是暫時性的，因此不應該儲存供日後使用。

### <a name="remarks"></a>備註

SB_THUMBTRACK 捲軸程式碼通常是由應用程式使用，而這些應用程式會在拖曳捲動方塊時提供一些意見反應。

如果應用程式會滾動捲軸所控制的內容，則也必須使用 [SetScrollPos](#setscrollpos) 成員函式重設捲動方塊的位置。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#108](../../mfc/reference/codesnippet/cpp/cwnd-class_48.cpp)]

## <a name="cwndonhscrollclipboard"></a><a name="onhscrollclipboard"></a> CWnd：： OnHScrollClipboard

`OnHScrollClipboard`當剪貼簿資料的 `CF_OWNERDISPLAY` 格式，且剪貼簿檢視器的水準捲軸中有事件時，剪貼簿檢視器就會呼叫剪貼簿擁有者的成員函式。

```
afx_msg void OnHScrollClipboard(
    CWnd* pClipAppWnd,
    UINT nSBCode,
    UINT nPos);
```

### <a name="parameters"></a>參數

*pClipAppWnd*<br/>
指定 [剪貼簿-檢視器] 視窗的指標。 該指標可能是暫時性的，因此不應該儲存供日後使用。

*nSBCode*<br/>
以低序位字組指定下列其中一個捲軸程式碼：

- SB_BOTTOM 向右下方。

- SB_ENDSCROLL 結束捲軸。

- SB_LINEDOWN 向下移動一行。

- SB_LINEUP 向上移動一行。

- SB_PAGEDOWN 向下移動一頁。

- SB_PAGEUP 向上滾動一頁。

- SB_THUMBPOSITION 滾動至絕對位置。 目前的位置是在 *nPos*中提供。

- SB_TOP 滾動至左上方。

*nPos*<br/>
如果捲軸程式碼 SB_THUMBPOSITION，則包含捲動方塊位置;否則不使用。

### <a name="remarks"></a>備註

擁有者應該會滾動剪貼簿影像、使適當的區段失效，並更新捲軸值。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndoniconerasebkgnd"></a><a name="oniconerasebkgnd"></a> CWnd：： OnIconEraseBkgnd

當您在 `CWnd` 繪製圖示之前必須先填滿圖示的背景時，架構會呼叫這個成員函式，以取得最小化的 (iconic) 物件。

```
afx_msg void OnIconEraseBkgnd(CDC* pDC);
```

### <a name="parameters"></a>參數

*Pdc*<br/>
指定圖示的裝置內容物件。 可能是暫時性的，不應儲存供日後使用。

### <a name="remarks"></a>備註

`CWnd` 只有在為視窗預設實定義類別圖示時，才會收到此呼叫;否則會呼叫 [OnEraseBkgnd](#onerasebkgnd) 。

[DefWindowProc](#defwindowproc)成員函式會使用父視窗的背景筆刷來填滿圖示背景。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndoninitmenu"></a><a name="oninitmenu"></a> CWnd：： OnInitMenu

當功能表即將變成作用中時，架構會呼叫這個成員函式。

```
afx_msg void OnInitMenu(CMenu* pMenu);
```

### <a name="parameters"></a>參數

*pMenu*<br/>
指定要初始化的功能表。 可能是暫時性的，不應儲存供日後使用。

### <a name="remarks"></a>備註

`OnInitMenu` 當使用者按一下功能表列上的專案，或按下功能表鍵時，就會呼叫。 覆寫此成員函式，以在功能表顯示前加以修改。

`OnInitMenu` 只有在第一次存取功能表 (例如，當使用者按一下功能表) 欄上的專案時，才會呼叫一次。 這個方法不會提供功能表項目的相關資訊。 當使用者移至功能表中的專案 (例如，將滑鼠移到數個功能表項目上時，) 不會再呼叫函式。 當使用者從功能表結束時 (例如，按一下應用程式工作區) ，然後按一下功能表列上的專案，就會再次呼叫該函式。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndoninitmenupopup"></a><a name="oninitmenupopup"></a> CWnd：： OnInitMenuPopup

當快顯功能表即將變成作用中時，架構會呼叫這個成員函式。

```
afx_msg void OnInitMenuPopup(
    CMenu* pPopupMenu,
    UINT nIndex,
    BOOL bSysMenu);
```

### <a name="parameters"></a>參數

*pPopupMenu*<br/>
指定快顯功能表的功能表物件。 可能是暫時性的，不應儲存供日後使用。

*nIndex*<br/>
指定主功能表中快顯功能表的索引。

*bSysMenu*<br/>
如果快顯功能表是 [控制台]，則為 TRUE。否則為 FALSE。

### <a name="remarks"></a>備註

這可讓應用程式在未變更整個功能表的情況下，修改快顯功能表，然後才顯示。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndoninputdevicechange"></a><a name="oninputdevicechange"></a> CWnd：： OnInputDeviceChange

在系統中新增或移除 i/o 裝置時，架構會呼叫這個成員函式。

```
afx_msg void OnInputDeviceChange(unsigned short uFlag);
```

### <a name="parameters"></a>參數

*uFlag*\
在此旗標可以包含下列值：

- `GIDC_ARRIVAL` -已將新的裝置新增至系統。
- `GIDC_REMOVAL` -已從系統中移除裝置。

### <a name="remarks"></a>備註

這個方法會接收 [WM_INPUT_DEVICE_CHANGE](/windows/win32/inputdev/wm-input-device-change) 通知，如 Windows SDK 所述。 是一般輸入裝置訊息。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndoninputlangchange"></a><a name="oninputlangchange"></a> CWnd：： OnInputLangChange

架構會在應用程式的輸入語言變更之後，為最上層受影響的視窗呼叫這個成員。

```
afx_msg void OnInputLangChange(
    UINT nCharSet,
    UINT nLocaleId);
```

### <a name="parameters"></a>參數

*nCharSet*\
在新地區設定的字元集。 如需詳細資訊，請參閱[LOGFONT](/windows/win32/api/wingdi/ns-wingdi-logfontw)結構的*lfCharSet*參數。

*nLocaleId*\
在輸入地區設定識別碼。 如需詳細資訊，請參閱 [語言識別項常數和字串](/windows/win32/Intl/language-identifier-constants-and-strings)。

### <a name="remarks"></a>備註

這個方法會接收 [WM_INPUTLANGCHANGE](/windows/win32/winmsg/wm-inputlangchange) 的通知訊息，如 Windows SDK 中所述。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndoninputlangchangerequest"></a><a name="oninputlangchangerequest"></a> CWnd：： OnInputLangChangeRequest

當使用者選擇新的輸入語言時，架構會針對具有焦點的視窗呼叫這個成員。

```
afx_msg void OnInputLangChangeRequest(
    UINT nFlags,
    UINT nLocaleId);
```

### <a name="parameters"></a>參數

*nFlags*\
在旗標的位 (或) 組合，表示已從安裝的地區設定清單中的上一個或下一個地區設定中選取新的地區設定，或新的輸入地區設定鍵盤配置可以搭配系統字元集使用。 可能的值為 INPUTLANGCHANGE_BACKWARD、INPUTLANGCHANGE_FORWARD 和 INPUTLANGCHANGE_SYSCHARSET。

*nLocaleId*\
在輸入地區設定識別碼。 如需詳細資訊，請參閱 [語言識別項常數和字串](/windows/win32/Intl/language-identifier-constants-and-strings)。

### <a name="remarks"></a>備註

這個方法會接收 [WM_INPUTLANGCHANGEREQUEST](/windows/win32/winmsg/wm-inputlangchangerequest) 的通知訊息，如 Windows SDK 中所述。 當使用者使用鍵盤控制台應用程式中指定的熱鍵，或從系統工作列上的指標，選擇新的輸入語言時，就會公佈此訊息。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonkeydown"></a><a name="onkeydown"></a> CWnd：： OnKeyDown

當按下非系統鍵時，架構會呼叫這個成員函式。

```
afx_msg void OnKeyDown(
    UINT nChar,
    UINT nRepCnt,
    UINT nFlags);
```

### <a name="parameters"></a>參數

*nChar*<br/>
指定指定之索引鍵的虛擬按鍵碼。 如需標準虛擬金鑰程式碼的清單，請參閱 Winuser。h

*nRepCnt*<br/>
[重複計數] (當使用者按住) 按鍵時，按鍵重複的次數。

*nFlags*<br/>
指定掃描碼、按鍵轉換程式碼、先前的主要狀態和內容程式碼，如下列清單所示：

|值|描述|
|-----------|-----------------|
|0-7|)  (OEM 相依值掃描程式碼。|
|8|擴充金鑰（例如，函式金鑰或數位鍵臺上的機碼） (1 （如果它是擴充金鑰) ）。|
|9-10|未使用。|
|11-12|由 Windows 在內部使用。|
|13|內容程式碼 (1 如果按下按鍵時按住 ALT 鍵，則為 < a0/1;否則為 0) 。|
|14|先前的金鑰狀態 (1 如果機碼在呼叫之前關閉，則為0（如果機碼) ）。|
|15|轉換狀態 (1 如果正在釋放機碼，則為0（如果按下按鍵) ）。|

針對 WM_KEYDOWN 訊息，金鑰轉換位 (位 15) 為0，而內容程式碼位 (位 13) 為0。

### <a name="remarks"></a>備註

非系統機碼是按下 ALT 鍵時所按下的鍵盤按鍵，或是在具有輸入焦點時按下的鍵盤按鍵 `CWnd` 。

因為會自動重複，所以 `OnKeyDown` 在進行 [OnKeyUp](#onkeyup) 成員函式呼叫之前，可能會發生一個以上的呼叫。 指出先前索引鍵狀態的位可以用來判斷 `OnKeyDown` 呼叫是第一個向下轉換，還是重複的轉換。

針對 IBM 增強的101和102鍵鍵盤，增強型按鍵是鍵盤主要區段上的右 ALT 和右 CTRL 鍵;位於數位鍵台左邊的叢集中的 INS、DEL、HOME、END、PAGE UP、PAGE DOWN 和方向鍵;以及斜線 (/) 並在數位鍵台中輸入按鍵。 有些其他鍵盤可能會支援 *nFlags*中的擴充金鑰位。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonkeyup"></a><a name="onkeyup"></a> CWnd：： OnKeyUp

當系統釋放非系統金鑰時，架構會呼叫這個成員函式。

```
afx_msg void OnKeyUp(
    UINT nChar,
    UINT nRepCnt,
    UINT nFlags);
```

### <a name="parameters"></a>參數

*nChar*<br/>
指定指定之索引鍵的虛擬按鍵碼。 如需標準虛擬金鑰程式碼的清單，請參閱 Winuser。h

*nRepCnt*<br/>
[重複計數] (當使用者按住) 按鍵時，按鍵重複的次數。

*nFlags*<br/>
指定掃描碼、按鍵轉換程式碼、先前的主要狀態和內容程式碼，如下列清單所示：

|值|描述|
|-----------|-----------------|
|0-7|)  (OEM 相依值掃描程式碼。 高序位單字的低位元組。|
|8|擴充金鑰（例如，函式金鑰或數位鍵臺上的機碼） (1 （如果它是擴充金鑰）。否則為 0) 。|
|9-10|未使用。|
|11-12|由 Windows 在內部使用。|
|13|內容程式碼 (1 如果按下按鍵時按住 ALT 鍵，則為 < a0/1;否則為 0) 。|
|14|先前的金鑰狀態 (1 如果機碼在呼叫之前關閉，則為0（如果機碼) ）。|
|15|轉換狀態 (1 如果正在釋放機碼，則為0（如果按下按鍵) ）。|

針對 WM_KEYUP 訊息，金鑰轉換位 (位 15) 是1，而內容程式碼位 (位 13) 為0。

### <a name="remarks"></a>備註

非系統機碼是按下 ALT 鍵時所按下的鍵盤按鍵，或是當具有輸入焦點時按下的鍵盤按鍵 `CWnd` 。

針對 IBM 增強的101和102鍵鍵盤，增強型按鍵是鍵盤主要區段上的右 ALT 和右 CTRL 鍵;位於數位鍵台左邊的叢集中的 INS、DEL、HOME、END、PAGE UP、PAGE DOWN 和方向鍵;以及斜線 (/) 並在數位鍵台中輸入按鍵。 有些其他鍵盤可能會支援 *nFlags*中的擴充金鑰位。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonkillfocus"></a><a name="onkillfocus"></a> CWnd：： OnKillFocus

架構會在遺失輸入焦點之前立即呼叫此成員函式。

```
afx_msg void OnKillFocus(CWnd* pNewWnd);
```

### <a name="parameters"></a>參數

*pNewWnd*<br/>
指定接收輸入焦點之視窗的指標 (可能是 Null 或可能是暫時性的) 。

### <a name="remarks"></a>備註

如果 `CWnd` 物件顯示插入號，則應該在此時終結插入點。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonlbuttondblclk"></a><a name="onlbuttondblclk"></a> CWnd：： OnLButtonDblClk

當使用者按兩下滑鼠左鍵時，架構會呼叫這個成員函式。

```
afx_msg void OnLButtonDblClk(
    UINT nFlags,
    CPoint point);
```

### <a name="parameters"></a>參數

*nFlags*<br/>
指出不同的虛擬機器碼是否已關閉。 這個參數可以是下列值的任意組合：

- 如果 CTRL 鍵已關閉，MK_CONTROL 設定。

- MK_LBUTTON 設定滑鼠左鍵是否已關閉。

- 如果中間的滑鼠按鍵已關閉，MK_MBUTTON 設定。

- MK_RBUTTON 設定滑鼠右鍵是否已關閉。

- 如果 SHIFT 鍵已關閉，MK_SHIFT 設定。

*點*<br/>
指定資料指標的 x 和 y 座標。 這些座標一律相對於視窗的左上角。

### <a name="remarks"></a>備註

只有具有 CS_DBLCLKS [WNDCLASS](/windows/win32/api/winuser/ns-winuser-wndclassw) 樣式的視窗才會接收 `OnLButtonDblClk` 呼叫。 這是 Microsoft Foundation Class 視窗的預設值。 `OnLButtonDblClk`當使用者按下、放開，然後在系統的按兩下時間限制內再次按下滑鼠左鍵時，Windows 就會呼叫。 按兩下滑鼠左鍵時，實際上會產生四個事件： [WM_LBUTTONDOWN](#onlbuttondown)、 [WM_LBUTTONUP](#onlbuttonup) 訊息、WM_LBUTTONDBLCLK 呼叫，以及放開按鈕時的另一個 WM_LBUTTONUP 訊息。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonlbuttondown"></a><a name="onlbuttondown"></a> CWnd：： OnLButtonDown

當使用者按下滑鼠左鍵時，架構會呼叫這個成員函式。

```
afx_msg void OnLButtonDown(
    UINT nFlags,
    CPoint point);
```

### <a name="parameters"></a>參數

*nFlags*<br/>
指出不同的虛擬機器碼是否已關閉。 這個參數可以是下列值的任意組合：

- 如果 CTRL 鍵已關閉，MK_CONTROL 設定。

- MK_LBUTTON 設定滑鼠左鍵是否已關閉。

- 如果中間的滑鼠按鍵已關閉，MK_MBUTTON 設定。

- MK_RBUTTON 設定滑鼠右鍵是否已關閉。

- 如果 SHIFT 鍵已關閉，MK_SHIFT 設定。

*點*<br/>
指定資料指標的 x 和 y 座標。 這些座標一律相對於視窗的左上角。

### <a name="remarks"></a>備註

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonlbuttonup"></a><a name="onlbuttonup"></a> CWnd：： OnLButtonUp

當使用者放開滑鼠左鍵時，架構會呼叫這個成員函式。

```
afx_msg void OnLButtonUp(
    UINT nFlags,
    CPoint point);
```

### <a name="parameters"></a>參數

*nFlags*<br/>
指出不同的虛擬機器碼是否已關閉。 這個參數可以是下列值的任意組合：

- 如果 CTRL 鍵已關閉，MK_CONTROL 設定。

- 如果中間的滑鼠按鍵已關閉，MK_MBUTTON 設定。

- MK_RBUTTON 設定滑鼠右鍵是否已關閉。

- 如果 SHIFT 鍵已關閉，MK_SHIFT 設定。

*點*<br/>
指定資料指標的 x 和 y 座標。 這些座標一律相對於視窗的左上角。

### <a name="remarks"></a>備註

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonmbuttondblclk"></a><a name="onmbuttondblclk"></a> CWnd：： OnMButtonDblClk

當使用者按兩下滑鼠中間按鈕時，架構會呼叫這個成員函式。

```
afx_msg void OnMButtonDblClk(
    UINT nFlags,
    CPoint point);
```

### <a name="parameters"></a>參數

*nFlags*<br/>
指出不同的虛擬機器碼是否已關閉。 這個參數可以是下列值的任意組合：

- 如果 CTRL 鍵已關閉，MK_CONTROL 設定。

- MK_LBUTTON 設定滑鼠左鍵是否已關閉。

- 如果中間的滑鼠按鍵已關閉，MK_MBUTTON 設定。

- MK_RBUTTON 設定滑鼠右鍵是否已關閉。

- 如果 SHIFT 鍵已關閉，MK_SHIFT 設定。

*點*<br/>
指定資料指標的 x 和 y 座標。 這些座標一律相對於視窗的左上角。

### <a name="remarks"></a>備註

只有具有 CS_DBLCLKS [WNDCLASS](/windows/win32/api/winuser/ns-winuser-wndclassw) 樣式的視窗才會接收 `OnMButtonDblClk` 呼叫。 這是所有 Microsoft Foundation Class 視窗的預設值。 `OnMButtonDblClk`當使用者按下、放開，然後在系統的按兩下時間限制內再次按下滑鼠按鍵時，Windows 就會產生呼叫。 按兩下滑鼠左鍵會產生四個事件： [WM_MBUTTONDOWN](#onmbuttondown) 和 [WM_MBUTTONUP](#onmbuttonup) 訊息、WM_MBUTTONDBLCLK 呼叫和另一個 WM_MBUTTONUP 訊息。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonmbuttondown"></a><a name="onmbuttondown"></a> CWnd：： OnMButtonDown

當使用者按下滑鼠中間的按鈕時，架構會呼叫這個成員函式。

```
afx_msg void OnMButtonDown(
    UINT nFlags,
    CPoint point);
```

### <a name="parameters"></a>參數

*nFlags*<br/>
指出不同的虛擬機器碼是否已關閉。 這個參數可以是下列值的任意組合：

- 如果 CTRL 鍵已關閉，MK_CONTROL 設定。

- MK_LBUTTON 設定滑鼠左鍵是否已關閉。

- 如果中間的滑鼠按鍵已關閉，MK_MBUTTON 設定。

- MK_RBUTTON 設定滑鼠右鍵是否已關閉。

- 如果 SHIFT 鍵已關閉，MK_SHIFT 設定。

*點*<br/>
指定資料指標的 x 和 y 座標。 這些座標一律相對於視窗的左上角。

### <a name="remarks"></a>備註

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonmbuttonup"></a><a name="onmbuttonup"></a> CWnd：： OnMButtonUp

當使用者放開滑鼠中間按鍵時，架構會呼叫這個成員函式。

```
afx_msg void OnMButtonUp(
    UINT nFlags,
    CPoint point);
```

### <a name="parameters"></a>參數

*nFlags*<br/>
指出不同的虛擬機器碼是否已關閉。 這個參數可以是下列值的任意組合：

- 如果 CTRL 鍵已關閉，MK_CONTROL 設定。

- MK_LBUTTON 設定滑鼠左鍵是否已關閉。

- MK_RBUTTON 設定滑鼠右鍵是否已關閉。

- 如果 SHIFT 鍵已關閉，MK_SHIFT 設定。

*點*<br/>
指定資料指標的 x 和 y 座標。 這些座標一律相對於視窗的左上角。

### <a name="remarks"></a>備註

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonmdiactivate"></a><a name="onmdiactivate"></a> CWnd：： OnMDIActivate

架構會呼叫這個成員函式，讓子視窗被停用，並啟用子視窗。

```
afx_msg void OnMDIActivate(
    BOOL bActivate,
    CWnd* pActivateWnd,
    CWnd* pDeactivateWnd);
```

### <a name="parameters"></a>參數

*bActivate*<br/>
如果子系正在啟用，則為 TRUE，如果正在停用則為 FALSE。

*pActivateWnd*<br/>
包含要啟用之 MDI 子視窗的指標。 當 MDI 子視窗收到時， *pActivateWnd* 會包含要啟動之子視窗的指標。 此指標可能是暫時性的，不應儲存供稍後使用。

*pDeactivateWnd*<br/>
包含要停用之 MDI 子視窗的指標。 此指標可能是暫時性的，不應儲存供稍後使用。

### <a name="remarks"></a>備註

Mdi 子視窗會獨立于 MDI 框架視窗之外啟用。 當框架變成作用中時，上次使用呼叫啟動的子視窗會 `OnMDIActivate` 收到 [WM_NCACTI加值稅E](#onncactivate) 的訊息，以繪製活動視窗框架和標題列，但不會收到另一個 `OnMDIActivate` 呼叫。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonmeasureitem"></a><a name="onmeasureitem"></a> CWnd：： OnMeasureItem

建立控制項時，架構會針對主控描繪按鈕、下拉式方塊、清單方塊或功能表項目的擁有者，呼叫這個成員函式。

```
afx_msg void OnMeasureItem(
    int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct);
```

### <a name="parameters"></a>參數

*nIDCtl*<br/>
控制項的識別碼。

*lpMeasureItemStruct*<br/>
指向包含擁有者繪製控制項之維度的 [MEASUREITEMSTRUCT](/windows/win32/api/winuser/ns-winuser-measureitemstruct) 資料結構。

### <a name="remarks"></a>備註

覆寫這個成員函式，並填入 `MEASUREITEMSTRUCT` *lpMeasureItemStruct* 和 return 所指向的資料結構; 這會通知視窗控制項的維度，讓 windows 能夠正確地處理使用者與控制項的互動。

如果清單方塊或下拉式方塊是使用 [LBS_OWNERDRAWVARIABLE](../../mfc/reference/styles-used-by-mfc.md#list-box-styles) 或 [CBS_OWNERDRAWVARIABLE](../../mfc/reference/styles-used-by-mfc.md#combo-box-styles) 樣式所建立，則架構會針對控制項中的每個專案，呼叫此函式的擁有者;否則會呼叫此函式一次。

在傳送 `OnMeasureItem` [WM_INITDIALOG](/windows/win32/dlgbox/wm-initdialog) 訊息之前，Windows 會針對以 OWNERDRAWFIXED 樣式建立的下拉式方塊和清單方塊的擁有者起始呼叫。 如此一來，當擁有者收到此呼叫時，Windows 尚未判斷控制項中所使用之字型的高度和寬度;需要這些值的函式呼叫和計算應該會出現在應用程式或程式庫的主要功能中。

如果要測量的專案是 `CMenu` `CListBox` 或 `CComboBox` 物件，則 `MeasureItem` 會呼叫適當類別的虛擬函式。 覆寫 `MeasureItem` 適當控制項類別的成員函式，以計算和設定每個專案的大小。

`OnMeasureItem` 只有在執行時間建立控制項的類別，或以 LBS_OWNERDRAWVARIABLE 或 CBS_OWNERDRAWVARIABLE 樣式建立時，才會呼叫。 如果控制項是由對話方塊編輯器所建立， `OnMeasureItem` 則不會呼叫。 這是因為 [WM_MEASUREITEM](/windows/win32/Controls/wm-measureitem) 的訊息會在控制項的建立過程中提早傳送。 如果您使用、或來子類別 `DDX_Control` `SubclassDlgItem` `SubclassWindow` ，通常會在建立程式之後進行子類別化。 因此，無法在控制項的函式中處理 [WM_MEASUREITEM](/windows/win32/Controls/wm-measureitem) 的訊息 `OnChildNotify` ，這是 MFC 用來執行 ON_WM_MEASUREITEM_REFLECT 的機制。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonmenuchar"></a><a name="onmenuchar"></a> CWnd：： OnMenuChar

當使用者按下不符合目前功能表中任何預先定義之助憶鍵的功能表助憶鍵字元時，架構會呼叫這個成員函式。

```
afx_msg LRESULT OnMenuChar(
    UINT nChar,
    UINT nFlags,
    CMenu* pMenu);
```

### <a name="parameters"></a>參數

*nChar*<br/>
根據組建設定，指定使用者按下的 ANSI 或 Unicode 字元。

*nFlags*<br/>
如果功能表是快顯功能表，則包含 MF_POPUP 旗標。 如果功能表是控制項功能表，則包含 MF_SYSMENU 旗標。

*pMenu*<br/>
包含選取之的指標 `CMenu` 。 指標可能是暫時性的，不應該儲存。

### <a name="return-value"></a>傳回值

傳回值的高序位字應該包含下列其中一個命令代碼：

|值|描述|
|-----------|-----------------|
|0|告知 Windows 捨棄使用者所按下的字元，並在系統喇叭上建立短暫的嗶聲。|
|1|告訴 Windows 關閉目前的功能表。|
|2|通知 Windows，傳回值的低序位字包含特定專案的專案編號。 Windows 會選取此專案。|

如果高序位字組包含0或1，則會忽略低序位字組。 當加速器 (快速鍵) 按鍵用來選取放置於功能表中的點陣圖時，應用程式應該處理此訊息。

### <a name="remarks"></a>備註

它會傳送給 `CWnd` 擁有功能表的。 `OnMenuChar` 即使索引鍵未對應到助憶鍵字元，也會在使用者按下 ALT 和其他任何按鍵時呼叫。 在此情況下， *pMenu* 會指向所擁有的功能表 `CWnd` ，而 *nFlags* 為0。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonmenudrag"></a><a name="onmenudrag"></a> CWnd：： OnMenuDrag

當使用者開始拖曳功能表項目時，架構會呼叫目前拖放功能表的這個成員函式。

```
afx_msg UINT OnMenuDrag(
    UINT nPos,
    CMenu* pMenu);
```

### <a name="parameters"></a>參數

*nPos*\
在當拖曳作業開始時，功能表項目的索引位置。

*pMenu*\
在包含功能表項目之 [CMenu](../../mfc/reference/cmenu-class.md) 物件的指標。

### <a name="return-value"></a>傳回值

|傳回值|意義|
|------------------|-------------|
|MND_CONTINUE|功能表應該保持作用中狀態。 如果放開滑鼠，則應該予以忽略。|
|MND_ENDMENU|應結束功能表。|

### <a name="remarks"></a>備註

這個方法會接收 [WM_MENUDRAG](/windows/win32/menurc/wm-menudrag) 通知，如 Windows SDK 所述。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonmenugetobject"></a><a name="onmenugetobject"></a> CWnd：： OnMenuGetObject

當滑鼠游標進入功能表項目，或從專案的中央移至專案的頂端或底部時，架構會呼叫目前拖放功能表的這個成員函式。

```
afx_msg UINT OnMenuGetObject(MENUGETOBJECTINFO* pMenuGetObjectInfo);
```

### <a name="parameters"></a>參數

*pMenu*\
在 [MENUGETOBJECTINFO](/windows/win32/api/winuser/ns-winuser-menugetobjectinfo) 結構的指標，其中包含滑鼠游標所在的拖放功能表的相關資訊。

### <a name="return-value"></a>傳回值

|傳回值|意義|
|------------------|-------------|
|MNGO_NOERROR|在 MENUGETOBJECTINFO 結構的成員中，會傳回支援拖放作業的介面指標 `pvObj` 。 [MENUGETOBJECTINFO](/windows/win32/api/winuser/ns-winuser-menugetobjectinfo) 目前只支援 [IDropTarget](/windows/win32/api/oleidl/nn-oleidl-idroptarget) 介面。|
|MNGO_NOINTERFACE|不支援拖放功能介面。|

### <a name="remarks"></a>備註

這個方法會接收 [WM_MENUGETOBJECT](/windows/win32/menurc/wm-menugetobject) 通知，如 Windows SDK 所述。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonmenurbuttonup"></a><a name="onmenurbuttonup"></a> CWnd：： OnMenuRButtonUp

當使用者放開滑鼠右鍵，而游標位於功能表項目上時，架構會呼叫這個成員函式。

```
afx_msg void OnMenuRButtonUp(
    UINT nPos,
    CMenu* pMenu);
```

### <a name="parameters"></a>參數

*nPos*\
在放開滑鼠右鍵時，功能表項目的索引位置。

*pMenu*\
在包含功能表項目之 [CMenu](../../mfc/reference/cmenu-class.md) 物件的指標。

### <a name="remarks"></a>備註

這個方法會接收 [WM_MENURBUTTONUP](/windows/win32/menurc/wm-menurbuttonup) 通知，如 Windows SDK 所述。 [WM_MENURBUTTONUP](/windows/win32/menurc/wm-menurbuttonup)訊息可讓應用程式為訊息中指定的功能表項目提供內容相關功能表。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonmenuselect"></a><a name="onmenuselect"></a> CWnd：： OnMenuSelect

如果 `CWnd` 物件與功能表相關聯，則 `OnMenuSelect` 當使用者選取功能表項目時，架構會呼叫該物件。

```
afx_msg void OnMenuSelect(
    UINT nItemID,
    UINT nFlags,
    HMENU hSysMenu);
```

### <a name="parameters"></a>參數

*nItemID*<br/>
識別選取的專案。 如果選取的專案是功能表項目， *nItemID* 會包含功能表項目識別碼。 如果選取的專案包含快顯功能表， *nItemID* 會包含快顯功能表索引，而 *hSysMenu* 包含主 (按下) 功能表的控點。

*nFlags*<br/>
包含下列功能表旗標的組合：

- MF_BITMAP 專案是點陣圖。

- 已核取 MF_CHECKED 專案。

- MF_DISABLED 專案已停用。

- MF_GRAYED 專案呈現暗灰色。

- 已使用滑鼠選取 MF_MOUSESELECT 專案。

- MF_OWNERDRAW 專案是主控描繪專案。

- MF_POPUP 專案包含快顯功能表。

- MF_SEPARATOR 專案是功能表項目分隔符號。

- [控制項] 功能表中包含 MF_SYSMENU 專案。

*hSysMenu*<br/>
如果 *nFlags* 包含 MF_SYSMENU，則會識別與訊息相關聯的功能表。 如果 *nFlags* 包含 MF_POPUP，會識別主功能表的控制碼。 如果 *nFlags* 不包含 MF_SYSMENU 也不 MF_POPUP，則未使用。

### <a name="remarks"></a>備註

如果 *nFlags* 包含0Xffff 且 *hSysMenu* 包含0，則 Windows 已關閉功能表，因為使用者按下 ESC 鍵或按一下功能表外部。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonmouseactivate"></a><a name="onmouseactivate"></a> CWnd：： OnMouseActivate

當游標在非作用中視窗，且使用者按下滑鼠按鍵時，架構會呼叫這個成員函式。

```
afx_msg int OnMouseActivate(
    CWnd* pDesktopWnd,
    UINT nHitTest,
    UINT message);
```

### <a name="parameters"></a>參數

*pDesktopWnd*<br/>
指定要啟動之視窗的最上層父視窗的指標。 指標可能是暫時性的，不應該儲存。

*nHitTest*<br/>
指定 [點擊測試區域程式](#onnchittest) 代碼。 點擊測試是判斷資料指標位置的測試。

*message*<br/>
指定滑鼠訊息編號。

### <a name="return-value"></a>傳回值

指定是否要啟動 `CWnd` ，以及是否要捨棄滑鼠事件。 它必須是下列值之一：

- MA_ACTI加值稅E 啟動 `CWnd` 物件。

- MA_NOACTI加值稅E 不啟動 `CWnd` 物件。

- MA_ACTI加值稅EANDEAT 啟動 `CWnd` 物件並捨棄滑鼠事件。

- MA_NOACTI加值稅EANDEAT 不會啟動 `CWnd` 物件並捨棄滑鼠事件。

### <a name="remarks"></a>備註

預設的執行會將此訊息傳遞至父視窗，然後才進行處理。 如果父視窗傳回 TRUE，則會停止處理。

如需個別點擊測試區域程式碼的說明，請參閱 [OnNcHitTest](#onnchittest) 成員函式

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCAxCtl#9](../../mfc/reference/codesnippet/cpp/cwnd-class_49.cpp)]

## <a name="cwndonmousehover"></a><a name="onmousehover"></a> CWnd：： OnMouseHover

當游標停留在先前呼叫 [TrackMouseEvent](/windows/win32/api/winuser/nf-winuser-trackmouseevent)所指定的時間範圍內時，架構會呼叫這個成員函式。

```
afx_msg void OnMouseHover(
    UINT nFlags,
    CPoint point);
```

### <a name="parameters"></a>參數

*nFlags*\
在 () 或旗標的位合，表示所按下的輔助按鍵。 例如，MK_CONTROL 旗標表示按下 CTRL 鍵。

*點*\
在 [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) 物件，指定相對於工作區左上角之游標的 *x* 和 *y* 座標。

### <a name="remarks"></a>備註

這個方法會接收 [WM_MOUSEHOVER](/windows/win32/inputdev/wm-mousehover) 通知，如 Windows SDK 所述。

*NFlags*參數可以是下表所列之輔助按鍵的組合。 如需詳細資訊，請參閱 [關於滑鼠輸入](/windows/win32/inputdev/about-mouse-input)。

|輔助按鍵|描述|
|------------------|-----------------|
|MK_CONTROL|按下 CTRL 鍵。|
|MK_LBUTTON|已按下滑鼠左鍵。|
|MK_MBUTTON|已按下滑鼠中間鍵。|
|MK_RBUTTON|已按下滑鼠右鍵。|
|MK_SHIFT|按下 SHIFT 鍵。|
|MK_XBUTTON1|已按下 Microsoft 滑鼠按鍵的 [XBUTTON1] 滑鼠按鍵。|
|MK_XBUTTON2|已按下 Microsoft 滑鼠按鍵的 [XBUTTON2] 滑鼠按鍵。|

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonmousehwheel"></a><a name="onmousehwheel"></a> CWnd：： OnMouseHWheel

當目前的視窗由桌面視窗管理員 (DWM) 所組成，且該視窗最大化時，架構會呼叫這個成員。

```
afx_msg void OnMouseHWheel(
    UINT nFlags,
    short zDelta,
    CPoint pt);
```

### <a name="parameters"></a>參數

*nFlags*\
在 () 或旗標的位合，表示所按下的輔助按鍵。 例如，MK_CONTROL 旗標表示按下 CTRL 鍵。 如需旗標的清單，請參閱 [關於滑鼠輸入](/windows/win32/inputdev/about-mouse-input)的「訊息參數」副標題。

*zDelta*\
在表示滾輪旋轉的距離，以 WHEEL_DELTA 的倍數或除法表示，也就是120。 正值表示滾輪已向右旋轉;負數值表示滾輪已向左旋轉。

*鉑*\
在 [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) 物件，指定相對於工作區左上角之游標的 *x* 和 *y* 座標。

### <a name="remarks"></a>備註

這個方法會接收 [WM_MOUSEHWHEEL](/windows/win32/inputdev/wm-mousehwheel) 的通知訊息，如 Windows SDK 中所述。 當滑鼠的水準滾輪傾斜或旋轉時，此訊息會傳送至具有焦點的視窗。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonmouseleave"></a><a name="onmouseleave"></a> CWnd：： OnMouseLeave

當資料指標離開先前呼叫 [TrackMouseEvent](/windows/win32/api/winuser/nf-winuser-trackmouseevent)所指定之視窗的工作區時，架構會呼叫這個成員函式。

```
afx_msg void OnMouseLeave();
```

### <a name="remarks"></a>備註

這個方法會接收 [WM_MOUSELEAVE](/windows/win32/inputdev/wm-mouseleave) 通知，如 Windows SDK 所述。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonmousemove"></a><a name="onmousemove"></a> CWnd：： OnMouseMove

當滑鼠游標移動時，架構會呼叫這個成員函式。

```
afx_msg void OnMouseMove(
    UINT nFlags,
    CPoint point);
```

### <a name="parameters"></a>參數

*nFlags*<br/>
指出不同的虛擬機器碼是否已關閉。 這個參數可以是下列值的任意組合：

- 如果 CTRL 鍵已關閉，MK_CONTROL 設定。

- MK_LBUTTON 設定滑鼠左鍵是否已關閉。

- 如果中間的滑鼠按鍵已關閉，MK_MBUTTON 設定。

- MK_RBUTTON 設定滑鼠右鍵是否已關閉。

- 如果 SHIFT 鍵已關閉，MK_SHIFT 設定。

*點*<br/>
指定資料指標的 x 和 y 座標。 這些座標一律相對於視窗的左上角。

### <a name="remarks"></a>備註

如果未捕捉到滑鼠，則在滑鼠游標下的物件會收到 WM_MOUSEMOVE 訊息 `CWnd` ; 否則，訊息會移至已捕捉到滑鼠的視窗。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonmousewheel"></a><a name="onmousewheel"></a> CWnd：： OnMouseWheel

架構會在使用者旋轉滑鼠滾輪時呼叫此成員函式，並遇到滾輪的下一個凹槽。

```
afx_msg BOOL OnMouseWheel(
    UINT nFlags,
    short zDelta,
    CPoint pt);
```

### <a name="parameters"></a>參數

*nFlags*<br/>
指出不同的虛擬機器碼是否已關閉。 這個參數可以是下列值的任意組合：

- 如果 CTRL 鍵已關閉，MK_CONTROL 設定。

- MK_LBUTTON 設定滑鼠左鍵是否已關閉。

- 如果中間的滑鼠按鍵已關閉，MK_MBUTTON 設定。

- MK_RBUTTON 設定滑鼠右鍵是否已關閉。

- 如果 SHIFT 鍵已關閉，MK_SHIFT 設定。

*zDelta*<br/>
指出旋轉的距離。 *ZDelta*值是以 WHEEL_DELTA 的倍數或除法表示，也就是120。 小於零的值表示向使用者) 旋轉 (，而大於零的值表示向前旋轉 (離開使用者) 。 使用者可以藉由變更滑鼠軟體中的滾輪設定來反轉此回應。 如需此參數的詳細資訊，請參閱備註。

*pt*<br/>
指定資料指標的 x 和 y 座標。 這些座標一律相對於畫面的左上角。

### <a name="return-value"></a>傳回值

如果已啟用滑鼠滾輪滾動則為非零;否則為0。

### <a name="remarks"></a>備註

除非遭到覆寫，否則會 `OnMouseWheel` 呼叫 [WM_MOUSEWHEEL](/windows/win32/inputdev/wm-mousewheel)的預設值。 Windows 會自動將訊息路由至具有焦點的控制項或子視窗。 Win32 函數 [DefWindowProc](/windows/win32/api/winuser/nf-winuser-defwindowprocw) 會將訊息向上傳播至處理它的視窗。

*ZDelta*參數是 WHEEL_DELTA 的倍數，其設定為120。 此值是要採取之動作的臨界值，而其中一個這類動作 (例如，每個差異都必須向前滾動一個凹槽) 。

WHEEL_DELTA 設定為120以允許更精細的解析度滾輪，例如無凹槽的自由旋轉滾輪。 更精細的解析度滾輪會每次旋轉傳送更多訊息，但每個訊息都有較小的差異值。 若要使用這類滾輪，請新增傳入的 *zDelta* 值，直到達到 WHEEL_DELTA 為止 (這樣您就能取得指定差異旋轉) 的相同回應，或滾動部分行以回應較頻繁的訊息。 您也可以選擇滾動細微性並累積差異，直到達到 WHEEL_DELTA 為止。

覆寫此成員函式以提供您自己的滑鼠滾輪滾動行為。

> [!NOTE]
> `OnMouseWheel` 處理 Windows NT 4.0 和更新版本的訊息。 若為 Windows 95/98 或 Windows NT 3.51 訊息處理，請使用 [OnRegisteredMouseWheel](#onregisteredmousewheel)。

## <a name="cwndonmove"></a><a name="onmove"></a> CWnd：： OnMove

架構會在移動物件之後呼叫這個成員函式 `CWnd` 。

```
afx_msg void OnMove(
    int x,
    int y);
```

### <a name="parameters"></a>參數

*x*<br/>
指定用戶端區域左上角的新 x 座標位置。 這個新位置是針對重迭和快顯視窗，以及子視窗的父-用戶端座標，提供給螢幕座標。

*y*<br/>
指定用戶端區域左上角的新 y 座標位置。 這個新位置是針對重迭和快顯視窗，以及子視窗的父-用戶端座標，提供給螢幕座標。

### <a name="remarks"></a>備註

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonmoving"></a><a name="onmoving"></a> CWnd：： OnMoving

當使用者移動物件時，架構會呼叫這個成員函式 `CWnd` 。

```
afx_msg void OnMoving(
    UINT nSide,
    LPRECT lpRect);
```

### <a name="parameters"></a>參數

*Russinovich*<br/>
要移動之視窗的邊緣。

*lpRect*<br/>
將包含專案座標的 [CRect](../../atl-mfc-shared/reference/crect-class.md) 或 [RECT 結構](/windows/win32/api/windef/ns-windef-rect) 的位址。

### <a name="remarks"></a>備註

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonncactivate"></a><a name="onncactivate"></a> CWnd：： OnNcActivate

當非工作區需要變更以表示使用中或非作用中狀態時，架構會呼叫這個成員函式。

```
afx_msg BOOL OnNcActivate(BOOL bActive);
```

### <a name="parameters"></a>參數

*bActive*<br/>
指定何時需要變更標題列或圖示，以指出作用中或非作用中狀態。 如果要繪製現用標題或圖示， *bActive* 參數是 TRUE。 非作用中的標題或圖示則為 FALSE。

### <a name="return-value"></a>傳回值

如果 Windows 應該繼續使用預設處理，則為非零。0以防止標題列或圖示被停用。

### <a name="remarks"></a>備註

如果 *bActive* 為 TRUE，則預設值會以現用色彩繪製標題列和標題列文字，如果 *bActive* 為 FALSE，則會以非使用中色彩來繪製。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonnccalcsize"></a><a name="onnccalcsize"></a> CWnd：： OnNcCalcSize

當需要計算用戶端區域的大小和位置時，架構會呼叫這個成員函式。

```
afx_msg void OnNcCalcSize(
    BOOL bCalcValidRects,
    NCCALCSIZE_PARAMS* lpncsp);
```

### <a name="parameters"></a>參數

*bCalcValidRects*<br/>
指定應用程式是否應指定工作區的哪個部分包含有效的資訊。 Windows 會將有效的資訊複製到新工作區中的指定區域。 如果此參數為 TRUE，則應用程式應指定工作區的哪個部分是有效的。

*lpncsp*<br/>
指向 [NCCALCSIZE_PARAMS](/windows/win32/api/winuser/ns-winuser-nccalcsize_params) 資料結構，其中包含應用程式可用來計算矩形新大小和位置的資訊 `CWnd` ， (包括用戶端區域、框線、標題、捲軸等) 。

### <a name="remarks"></a>備註

藉由處理這個訊息，應用程式可以在視窗的大小或位置變更時，控制視窗工作區的內容。

不論 *bCalcValidRects*的值為何，結構的結構成員所指定的陣列中的第一個矩形都會 `rgrc` `NCCALCSIZE_PARAMS` 包含視窗的座標。 如果是子視窗，座標是相對於父視窗的工作區。 針對最上層視窗，座標為螢幕座標。 應用程式應該修改 `rgrc[0]` 矩形，以反映工作區的大小和位置。

`rgrc[1]` `rgrc[2]` 只有當*bCalcValidRects*為 TRUE 時，和矩形才有效。 在此情況下， `rgrc[1]` 矩形會在移動或調整大小之前，包含視窗的座標。 `rgrc[2]`矩形包含視窗移動之前的視窗工作區座標。 所有座標都是相對於父視窗或畫面。

預設的執行會根據視窗特性 (存在捲軸、功能表等) 來計算工作區的大小，並將結果放在 *lpncsp*中。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonnccreate"></a><a name="onnccreate"></a> CWnd：： OnNcCreate

在[WM_CREATE](#oncreate) `CWnd` 第一次建立物件時，架構會呼叫這個成員函式 WM_CREATE 訊息。

```
afx_msg BOOL OnNcCreate(LPCREATESTRUCT lpCreateStruct);
```

### <a name="parameters"></a>參數

*lpCreateStruct*<br/>
指向的 [CREATESTRUCT](/windows/win32/api/winuser/ns-winuser-createstructw) 資料結構 `CWnd` 。

### <a name="return-value"></a>傳回值

如果未建立非工作區，則為非零。 如果發生錯誤，則為 0; `Create` 在此情況下，函數會傳回 **失敗** 。

### <a name="remarks"></a>備註

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonncdestroy"></a><a name="onncdestroy"></a> CWnd：： OnNcDestroy

當非工作區被終結時，由架構呼叫，而是當 Windows 視窗終結時所呼叫的最後一個成員函式。

```
afx_msg void OnNcDestroy();
```

### <a name="remarks"></a>備註

預設的執行會執行一些清除，然後呼叫虛擬成員函式 [PostNcDestroy](#postncdestroy)。

`PostNcDestroy`如果您想要執行自己的清除，例如**刪除此**作業，請覆寫。 如果您覆寫 `OnNcDestroy` ，您必須 `OnNcDestroy` 在基類中呼叫，以確保會釋出任何內部配置給視窗的記憶體。

## <a name="cwndonnchittest"></a><a name="onnchittest"></a> CWnd：： OnNcHitTest

架構 `CWnd` 會針對包含資料指標 (的物件，或在 `CWnd` 每次移動滑鼠時使用 [SetCapture](#setcapture) 成員函式來捕捉滑鼠輸入) 的物件呼叫這個成員函式。

```
afx_msg LRESULT OnNcHitTest(CPoint point);
```

### <a name="parameters"></a>參數

*點*<br/>
包含資料指標的 x 和 y 座標。 這些座標一律為螢幕座標。

### <a name="return-value"></a>傳回值

滑鼠點擊測試列舉值的其中一個。 如需值清單，請參閱 [WM_NCHITTEST](/windows/win32/inputdev/wm-nchittest) 。

### <a name="remarks"></a>備註

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonnclbuttondblclk"></a><a name="onnclbuttondblclk"></a> CWnd：： OnNcLButtonDblClk

當使用者按兩下滑鼠左鍵，而游標位於的非工作區內時，架構會呼叫這個成員函式 `CWnd` 。

```
afx_msg void OnNcLButtonDblClk(
    UINT nHitTest,
    CPoint point);
```

### <a name="parameters"></a>參數

*nHitTest*<br/>
指定 [點擊測試程式碼](#onnchittest)。 點擊測試是判斷資料指標位置的測試。 如需值清單，請參閱 [WM_NCHITTEST](/windows/win32/inputdev/wm-nchittest) 。

*點*<br/>
指定 `CPoint` 物件，該物件包含游標位置的 x 和 y 螢幕座標。 這些座標一律相對於畫面的左上角。

### <a name="remarks"></a>備註

如果適用，則會傳送 [WM_SYSCOMMAND](#onsyscommand) 訊息。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonnclbuttondown"></a><a name="onnclbuttondown"></a> CWnd：： OnNcLButtonDown

當使用者按下滑鼠左鍵，而游標位於物件的非工作區內時，架構會呼叫這個成員函式 `CWnd` 。

```
afx_msg void OnNcLButtonDown(
    UINT nHitTest,
    CPoint point);
```

### <a name="parameters"></a>參數

*nHitTest*<br/>
指定 [點擊測試程式碼](#onnchittest)。 點擊測試是判斷資料指標位置的測試。 如需值清單，請參閱 [WM_NCHITTEST](/windows/win32/inputdev/wm-nchittest) 。

*點*<br/>
指定 `CPoint` 物件，該物件包含游標位置的 x 和 y 螢幕座標。 這些座標一律相對於畫面的左上角。

### <a name="remarks"></a>備註

如果適用，則會傳送 [WM_SYSCOMMAND](#onsyscommand) 。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數會反映接收到訊息時，架構所收到的參數。如果您呼叫此函式的基類執行，則該執行會使用原本與訊息一起傳遞的參數，而不是您提供給函數的參數。

## <a name="cwndonnclbuttonup"></a><a name="onnclbuttonup"></a> CWnd：： OnNcLButtonUp

當使用者放開滑鼠左鍵，而游標位於非工作區時，架構會呼叫這個成員函式。

```
afx_msg void OnNcLButtonUp(
    UINT nHitTest,
    CPoint point);
```

### <a name="parameters"></a>參數

*nHitTest*<br/>
指定 [點擊測試程式碼](#onnchittest)。 點擊測試是判斷資料指標位置的測試。 如需值清單，請參閱 [WM_NCHITTEST](/windows/win32/inputdev/wm-nchittest) 。

*點*<br/>
指定 `CPoint` 物件，該物件包含游標位置的 x 和 y 螢幕座標。 這些座標一律相對於畫面的左上角。

### <a name="remarks"></a>備註

如果適用，則會傳送 [WM_SYSCOMMAND](#onsyscommand) 。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonncmbuttondblclk"></a><a name="onncmbuttondblclk"></a> CWnd：： OnNcMButtonDblClk

當使用者按兩下滑鼠左鍵，而游標位於非工作區時，架構會呼叫這個成員函式。

```
afx_msg void OnNcMButtonDblClk(
    UINT nHitTest,
    CPoint point);
```

### <a name="parameters"></a>參數

*nHitTest*<br/>
指定 [點擊測試程式碼](#onnchittest)。 點擊測試是判斷資料指標位置的測試。

*點*<br/>
指定 `CPoint` 物件，該物件包含游標位置的 x 和 y 螢幕座標。 這些座標一律相對於畫面的左上角。

### <a name="remarks"></a>備註

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonncmbuttondown"></a><a name="onncmbuttondown"></a> CWnd：： OnNcMButtonDown

當使用者按下滑鼠左鍵，而游標位於非工作區時，架構會呼叫這個成員函式。

```
afx_msg void OnNcMButtonDown(
    UINT nHitTest,
    CPoint point);
```

### <a name="parameters"></a>參數

*nHitTest*<br/>
指定 [點擊測試程式碼](#onnchittest)。 點擊測試是判斷資料指標位置的測試。

*點*<br/>
指定 `CPoint` 物件，該物件包含游標位置的 x 和 y 螢幕座標。 這些座標一律相對於畫面的左上角。

### <a name="remarks"></a>備註

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonncmbuttonup"></a><a name="onncmbuttonup"></a> CWnd：： OnNcMButtonUp

當使用者放開滑鼠按鍵時，架構會呼叫這個成員函式，而游標位於非工作區中。

```
afx_msg void OnNcMButtonUp(
    UINT nHitTest,
    CPoint point);
```

### <a name="parameters"></a>參數

*nHitTest*<br/>
指定 [點擊測試程式碼](#onnchittest)。 點擊測試是判斷資料指標位置的測試。

*點*<br/>
指定 `CPoint` 物件，該物件包含游標位置的 x 和 y 螢幕座標。 這些座標一律相對於畫面的左上角。

### <a name="remarks"></a>備註

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonncmousehover"></a><a name="onncmousehover"></a> CWnd：： OnNcMouseHover

當游標停留在視窗的非工作區時，架構會在先前呼叫 [TrackMouseEvent](/windows/win32/api/winuser/nf-winuser-trackmouseevent)所指定的期間內，呼叫這個成員函式。

```
afx_msg void OnNcMouseHover(
    UINT nHitTest,
    CPoint point);
```

### <a name="parameters"></a>參數

*nHitTest*\
在 [CWnd：:D efwindowproc](#defwindowproc) 函式所傳回的點擊測試值，是處理 [WM_NCHITTEST](/windows/win32/inputdev/wm-nchittest) 訊息的結果。

*點*\
在 [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) 物件，指定游標相對於螢幕左上角的 *x* 和 *y* 座標。

### <a name="remarks"></a>備註

這個方法會接收 [WM_NCMOUSEHOVER](/windows/win32/inputdev/wm-ncmousehover) 通知，如 Windows SDK 所述。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonncmouseleave"></a><a name="onncmouseleave"></a> CWnd：： OnNcMouseLeave

當資料指標離開先前呼叫 [TrackMouseEvent](/windows/win32/api/winuser/nf-winuser-trackmouseevent)所指定之視窗的非工作區時，架構會呼叫這個成員函式。

```
afx_msg void OnNcMouseLeave();
```

### <a name="remarks"></a>備註

這個方法會接收 [WM_NCMOUSELEAVE](/windows/win32/inputdev/wm-ncmouseleave) 通知，如 Windows SDK 所述。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonncmousemove"></a><a name="onncmousemove"></a> CWnd：： OnNcMouseMove

當游標在非工作區中移動時，架構會呼叫這個成員函式。

```
afx_msg void OnNcMouseMove(
    UINT nHitTest,
    CPoint point);
```

### <a name="parameters"></a>參數

*nHitTest*<br/>
指定 [點擊測試程式碼](#onnchittest)。 點擊測試是判斷資料指標位置的測試。

*點*<br/>
指定 `CPoint` 物件，該物件包含游標位置的 x 和 y 螢幕座標。 這些座標一律相對於畫面的左上角。

### <a name="remarks"></a>備註

如果適用，則會傳送 [WM_SYSCOMMAND](#onsyscommand) 訊息。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonncpaint"></a><a name="onncpaint"></a> CWnd：： OnNcPaint

當需要繪製非工作區時，架構會呼叫這個成員函式。

```
afx_msg void OnNcPaint();
```

### <a name="remarks"></a>備註

預設的執行會繪製視窗框架。

應用程式可以覆寫此呼叫，並繪製自己的自訂視窗框架。 裁剪區域一律為矩形，即使框架的形狀有改變也一樣。

## <a name="cwndonncrbuttondblclk"></a><a name="onncrbuttondblclk"></a> CWnd：： OnNcRButtonDblClk

當使用者按兩下滑鼠右鍵，而游標位於的非工作區內時，架構會呼叫這個成員函式 `CWnd` 。

```
afx_msg void OnNcRButtonDblClk(
    UINT nHitTest,
    CPoint point);
```

### <a name="parameters"></a>參數

*nHitTest*<br/>
指定 [點擊測試程式碼](#onnchittest)。 點擊測試是判斷資料指標位置的測試。

*點*<br/>
指定 `CPoint` 物件，該物件包含游標位置的 x 和 y 螢幕座標。 這些座標一律相對於畫面的左上角。

### <a name="remarks"></a>備註

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonncrbuttondown"></a><a name="onncrbuttondown"></a> CWnd：： OnNcRButtonDown

當使用者按下滑鼠右鍵，而游標在非工作區內時，架構會呼叫這個成員函式。

```
afx_msg void OnNcRButtonDown(
    UINT nHitTest,
    CPoint point);
```

### <a name="parameters"></a>參數

*nHitTest*<br/>
指定 [點擊測試程式碼](#onnchittest)。 點擊測試是判斷資料指標位置的測試。

*點*<br/>
指定 `CPoint` 物件，該物件包含游標位置的 x 和 y 螢幕座標。 這些座標一律相對於畫面的左上角。

### <a name="remarks"></a>備註

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonncrbuttonup"></a><a name="onncrbuttonup"></a> CWnd：： OnNcRButtonUp

當使用者放開滑鼠右鍵，而游標在非工作區內時，架構會呼叫這個成員函式。

```
afx_msg void OnNcRButtonUp(
    UINT nHitTest,
    CPoint point);
```

### <a name="parameters"></a>參數

*nHitTest*<br/>
指定 [點擊測試程式碼](#onnchittest)。 點擊測試是判斷資料指標位置的測試。

*點*<br/>
指定 `CPoint` 物件，該物件包含游標位置的 x 和 y 螢幕座標。 這些座標一律相對於畫面的左上角。

### <a name="remarks"></a>備註

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonncrenderingchanged"></a><a name="onncrenderingchanged"></a> CWnd：： OnNcRenderingChanged

當非工作區的轉譯原則變更時，架構會呼叫這個成員。

```
afx_msg void OnNcRenderingChanged(BOOL bIsRendering);
```

### <a name="parameters"></a>參數

*bIsRendering*\
在如果已針對視窗的非工作區啟用桌面視窗管理員 (DWM) 轉譯，則為 TRUE。如果已停用轉譯，則為 FALSE。

### <a name="remarks"></a>備註

這個方法會接收 [WM_DWMNCRENDERINGCHANGED](/windows/win32/dwm/wm-dwmncrenderingchanged) 通知，如 Windows SDK 所述。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonncxbuttondblclk"></a><a name="onncxbuttondblclk"></a> CWnd：： OnNcXButtonDblClk

當使用者按兩下 XBUTTON1 或 XBUTTON2，而游標位於視窗的非工作區時，架構會呼叫這個成員函式。

```cpp
void OnNcXButtonDblClk(
    short nHitTest,
    UINT nButton,
    CPoint point);
```

### <a name="parameters"></a>參數

*nHitTest*\
在 [CWnd：:D efwindowproc](#defwindowproc) 函式所傳回的點擊測試值，是處理 [WM_NCHITTEST](/windows/win32/inputdev/wm-nchittest) 訊息的結果。

*nButton*\
在如果按兩下第一個 Microsoft 滑鼠按鍵 X 按鈕，則為 XBUTTON1 的值，如果按兩下第二個 X 按鈕則為 XBUTTON2。

*點*\
在 [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) 物件，指定相對於工作區左上角之游標的 *x* 和 *y* 座標。

### <a name="remarks"></a>備註

這個方法會接收 [WM_XBUTTONDBLCLK](/windows/win32/inputdev/wm-xbuttondblclk) 通知，如 Windows SDK 所述。 這則訊息會張貼至包含資料指標的視窗。 如果視窗已捕捉到滑鼠，則不會張貼此訊息。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonncxbuttondown"></a><a name="onncxbuttondown"></a> CWnd：： OnNcXButtonDown

當使用者按下滑鼠的 XBUTTON1 或 XBUTTON2，而游標位於視窗的非工作區時，架構會呼叫這個成員函式。

```
afx_msg void OnNcXButtonDown(
    short nHitTest,
    UINT nButton,
    CPoint point);
```

### <a name="parameters"></a>參數

*nHitTest*\
在 [CWnd：:D efwindowproc](#defwindowproc) 函式所傳回的點擊測試值，是處理 [WM_NCHITTEST](/windows/win32/inputdev/wm-nchittest) 訊息的結果。

*nButton*\
在如果按下第一個滑鼠 X 按鈕，則為 XBUTTON1 的值，如果按下第二個 X 按鈕則為 XBUTTON2。

*點*\
在 [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) 物件，指定游標相對於螢幕左上角的 *x* 和 *y* 座標。

### <a name="remarks"></a>備註

這個方法會接收 [WM_NCXBUTTONDOWN](/windows/win32/inputdev/wm-ncxbuttondown) 通知，如 Windows SDK 所述。 這則訊息會張貼至包含資料指標的視窗。 如果視窗已捕捉到滑鼠，則不會張貼此訊息。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonncxbuttonup"></a><a name="onncxbuttonup"></a> CWnd：： OnNcXButtonUp

當使用者放開滑鼠的 XBUTTON1 或 XBUTTON2，而游標位於視窗的非工作區時，架構會呼叫這個成員函式。

```
afx_msg void OnNcXButtonUp(
    short nHitTest,
    UINT nButton,
    CPoint point);
```

### <a name="parameters"></a>參數

*nHitTest*\
在 [CWnd：:D efwindowproc](#defwindowproc) 函式所傳回的點擊測試值，是處理 [WM_NCHITTEST](/windows/win32/inputdev/wm-nchittest) 訊息的結果。

*nButton*\
在如果放開第一個滑鼠 X 按鈕則為 XBUTTON1 的值，如果已釋放第二個 X 按鈕則為 XBUTTON2。

*點*\
在 [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) 物件，指定游標相對於螢幕左上角的 *x* 和 *y* 座標。

### <a name="remarks"></a>備註

這個方法會接收 [WM_NCXBUTTONUP](/windows/win32/inputdev/wm-ncxbuttonup) 通知，如 Windows SDK 所述。 這則訊息會張貼至包含資料指標的視窗。 如果視窗已捕捉到滑鼠，則不會張貼此訊息。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonnextmenu"></a><a name="onnextmenu"></a> CWnd：： OnNextMenu

當使用向右鍵或向左鍵來切換功能表列和系統功能表時，架構會呼叫這個成員函式。

```
afx_msg void OnNextMenu(
    UINT nKey,
    LPMDINEXTMENU lpMdiNextMenu);
```

### <a name="parameters"></a>參數

*nKey*\
在 () 或旗標的位合，表示所按下的輔助按鍵。 例如，MK_CONTROL 旗標表示按下 CTRL 鍵。 如需旗標的清單，請參閱 [關於滑鼠輸入](/windows/win32/inputdev/about-mouse-input)的「訊息參數」副標題。

*lpMdiNextMenu*\
在 [MDINEXTMENU](/windows/win32/api/winuser/ns-winuser-mdinextmenu) 結構的指標，其中包含要啟用之功能表的相關資訊。

### <a name="remarks"></a>備註

這個方法會接收 [WM_UNINITMENUPOPUP](/windows/win32/menurc/wm-uninitmenupopup) 通知，如 Windows SDK 所述。 回應此訊息時，您的應用程式可以設定 `hmenuNext` [MDINEXTMENU](/windows/win32/api/winuser/ns-winuser-mdinextmenu) 結構的成員，以指定要切換的功能表，以及指定要 `hwndNext` 接收功能表通知訊息之視窗的成員。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonnotify"></a><a name="onnotify"></a> CWnd：： OnNotify

架構會呼叫這個成員函式，以通知控制項的父視窗，表示控制項中發生事件，或控制項需要某種類型的資訊。

```
virtual BOOL OnNotify(
    WPARAM wParam,
    LPARAM lParam,
    LRESULT* pResult);
```

### <a name="parameters"></a>參數

*wParam*<br/>
識別當訊息來自控制項時傳送訊息的控制項。 否則， *wParam* 是0。

*lParam*<br/>
通知訊息 (`NMHDR`) 結構的指標，其中包含通知碼和其他資訊。 針對某些通知訊息，這個參數會指向較大的結構，該結構的 `NMHDR` 結構是其第一個成員。

*pResult*<br/>
要在處理訊息時儲存結果碼的 LRESULT 變數指標。

### <a name="return-value"></a>傳回值

如果應用程式處理此訊息，則會傳回非零。否則為0。

### <a name="remarks"></a>備註

`OnNotify` 處理用於控制通知的訊息對應。

在您的衍生類別中覆寫這個成員函式，以處理 WM_NOTIFY 的訊息。 除非呼叫基類，否則覆寫不會處理訊息對應 `OnNotify` 。

如需 WM_NOTIFY 訊息的詳細資訊，請參閱技術提示 61 (TN061) 、 [ON_NOTIFY 和 WM_NOTIFY 訊息](../../mfc/tn061-on-notify-and-wm-notify-messages.md)。 您可能也會對 [控制項主題](../../mfc/controls-mfc.md)中所述的相關主題，以及 [Windows 控制項的訊息反映](../../mfc/tn062-message-reflection-for-windows-controls.md)感興趣。

## <a name="cwndonnotifyformat"></a><a name="onnotifyformat"></a> CWnd：： OnNotifyFormat

架構會呼叫這個成員函式，以判斷目前的視窗是否接受 WM_NOTIFY 通知訊息中的 ANSI 或 Unicode 結構。

```
afx_msg UINT OnNotifyFormat(
    CWnd* pWnd,
    UINT nCommand);
```

### <a name="parameters"></a>參數

*pWnd*\
在 `CWnd` 物件的指標，表示傳送 [WM_NOTIFY](/windows/win32/controls/wm-notify) 訊息的視窗。 如果 *nCommand* 參數為，這個參數就是控制項的指標 `NF_QUERY` ，如果 *nCommand* 是，則是控制項父視窗的指標 `NF_REQUERY` 。

*nCommand*\
在專門 WM_NOTIFY 訊息的命令值。 可能的值包括：

- `NF_QUERY` -訊息是用來判斷 WM_NOTIFY 訊息中是否應使用 ANSI 或 Unicode 結構的查詢。 這則訊息會在建立控制項期間從控制項傳送至其父視窗，以及回應 `NF_REQUERY` 此訊息的形式。
- `NF_REQUERY` -訊息是控制項的要求，可將 `NF_QUERY` 此訊息的形式傳送至其父視窗。 此要求是從父視窗傳送，並且要求控制項重新查詢有關要在 WM_NOTIFY 訊息中使用之結構類型的父系。 如果 *nCommand* 參數為，則傳回 `NF_REQUERY` 值是重新查詢作業的結果。

### <a name="return-value"></a>傳回值

|傳回值|意義|
|------------------|-------------|
|NFR_ANSI|ANSI 結構應該用於控制項所傳送 WM_NOTIFY 訊息中。|
|NFR_UNICODE|Unicode 結構應該用於控制項所傳送 WM_NOTIFY 訊息中。|
|0|發生錯誤。|

### <a name="remarks"></a>備註

這個方法會接收 [WM_NOTIFYFORMAT](/windows/win32/Controls/wm-notifyformat) 通知，如 Windows SDK 所述。 WM_NOTIFY 的訊息會從通用控制項傳送至其父視窗，以及從父視窗傳送至通用控制項。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonpaint"></a><a name="onpaint"></a> CWnd：： OnPaint

當 Windows 或應用程式提出重新繪製應用程式視窗部分的要求時，架構會呼叫這個成員函式。

```
afx_msg void OnPaint();
```

### <a name="remarks"></a>備註

呼叫[UpdateWindow](#updatewindow)或[RedrawWindow](#redrawwindow)成員函式時，會傳送[WM_PAINT](/windows/win32/gdi/the-wm-paint-message)訊息。

當呼叫成員函式 `RedrawWindow` 並設定 RDW_INTERNALPAINT 旗標時，視窗可能會接收內部繪製訊息。 在此情況下，視窗可能沒有更新區域。 應用程式應該呼叫 [GetUpdateRect](#getupdaterect) 成員函式，以判斷視窗是否有更新區域。 如果傳回 `GetUpdateRect` 0，則應用程式不應該呼叫 [BeginPaint](#beginpaint) 和 [EndPaint](#endpaint) 成員函式。

應用程式必須藉由查看每個 WM_PAINT 訊息的內部資料結構來檢查是否有任何必要的內部重新繪製或更新，因為 WM_PAINT 訊息可能是因為不正確區域和使用 RDW_INTERNALPAINT 旗標設定的成員函式呼叫所造成 `RedrawWindow` 。

內部 WM_PAINT 訊息只會由 Windows 傳送一次。 成員函式將內部 WM_PAINT 訊息傳送至視窗之後 `UpdateWindow` ，就不會再傳送或張貼任何 WM_PAINT 的訊息，直到視窗失效為止，或直到 `RedrawWindow` 再次呼叫成員函式並設定 RDW_INTERNALPAINT 旗標。

如需在檔/視圖應用程式中呈現影像的詳細資訊，請參閱 [CView：： OnDraw](../../mfc/reference/cview-class.md#ondraw)。

如需使用的詳細資訊 `WM_Paint` ，請參閱 Windows SDK 中的下列主題：

- [WM_PAINT 訊息](/windows/win32/gdi/the-wm-paint-message)

- [使用 WM_PAINT 訊息](/windows/win32/gdi/using-the-wm-paint-message)

## <a name="cwndonpaintclipboard"></a><a name="onpaintclipboard"></a> CWnd：： OnPaintClipboard

`OnPaintClipboard`當剪貼簿擁有者以 CF_OWNERDISPLAY 格式將資料放在剪貼簿上，而剪貼簿檢視器的工作區需要重新繪製時，剪貼簿檢視器就會呼叫剪貼簿擁有者的成員函式。

```
afx_msg void OnPaintClipboard(
    CWnd* pClipAppWnd,
    HGLOBAL hPaintStruct);
```

### <a name="parameters"></a>參數

*pClipAppWnd*<br/>
指定 [剪貼簿] 應用程式視窗的指標。 該指標可能是暫時性的，因此不應該儲存供日後使用。

*hPaintStruct*<br/>
識別 [PAINTSTRUCT](/windows/win32/api/winuser/ns-winuser-paintstruct) 資料結構，其定義要繪製工作區的哪一部分。

### <a name="remarks"></a>備註

若要判斷整個工作區或其中一部分是否需要重新繪製，剪貼簿擁有者必須將結構成員中指定的繪圖區域尺寸，與 `rcpaint` `PAINTSTRUCT` 最新的 [OnSizeClipboard](#onsizeclipboard) 成員函式呼叫中所指定的維度做比較。

`OnPaintClipboard` 應該使用 [GlobalLock](/windows/win32/api/winbase/nf-winbase-globallock) windows 函式來鎖定包含資料結構的記憶體， `PAINTSTRUCT` 並在結束之前，使用 [GlobalUnlock](/windows/win32/api/winbase/nf-winbase-globalunlock) Windows 函數將記憶體解除鎖定。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonpalettechanged"></a><a name="onpalettechanged"></a> CWnd：： OnPaletteChanged

架構會在具有輸入焦點的視窗實現其邏輯調色板之後，針對所有最上層視窗呼叫此成員函式，藉此變更系統調色板。

```
afx_msg void OnPaletteChanged(CWnd* pFocusWnd);
```

### <a name="parameters"></a>參數

*pFocusWnd*<br/>
指定造成系統調色板變更的視窗指標。 指標可能是暫時性的，不應該儲存。

### <a name="remarks"></a>備註

此呼叫可讓沒有輸入焦點的視窗使用色板來瞭解其邏輯調色板，並更新其工作區。

`OnPaletteChanged`成員函式會針對所有最上層和重迭的視窗呼叫，包括變更系統調色板並導致傳送 WM_PALETTECHANGED 訊息的函式。 如果任何子視窗使用調色板，則必須將此訊息傳遞給它。

為了避免無限迴圈，除非視窗判斷 *pFocusWnd* 不包含其本身的指標，否則視窗應該不會實現其調色板。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonpaletteischanging"></a><a name="onpaletteischanging"></a> CWnd：： OnPaletteIsChanging

架構會呼叫這個成員函式，以通知應用程式應用程式要實現它的邏輯調色板。

```
afx_msg void OnPaletteIsChanging(CWnd* pRealizeWnd);
```

### <a name="parameters"></a>參數

*pRealizeWnd*<br/>
指定即將實現其邏輯調色板的視窗。

### <a name="remarks"></a>備註

架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonparentnotify"></a><a name="onparentnotify"></a> CWnd：： OnParentNotify

`OnParentNotify`建立或終結父視窗時，架構會呼叫父系的成員函式，或當使用者在游標位於子視窗上方時按一下滑鼠按鍵時，會呼叫父成員函式。

```
afx_msg void OnParentNotify(
    UINT message,
    LPARAM lParam);
```

### <a name="parameters"></a>參數

*message*<br/>
指定要通知其父代的事件，以及子視窗的識別碼。 事件是 *訊息*的低序位文字。 如果事件是 WM_CREATE 或 WM_DESTROY，則 *訊息* 的高序位文字是子視窗的識別碼;否則，高序位字組是未定義的。 *訊息*) 的低序位文字 (的事件可以是下列其中一個值：

- WM_CREATE 正在建立子視窗。

- WM_DESTROY 正在終結子視窗。

- WM_LBUTTONDOWN 使用者將滑鼠游標放在子視窗上方，然後按下滑鼠左鍵。

- WM_MBUTTONDOWN 使用者將滑鼠游標放在子視窗上方，然後按一下滑鼠左鍵。

- WM_RBUTTONDOWN 使用者將滑鼠游標放在子視窗上方，然後按一下滑鼠右鍵。

*lParam*<br/>
如果 (*訊息* 的低序位單字) 的事件 WM_CREATE 或 WM_DESTROY， *lParam* 會指定子視窗的視窗控制碼;否則， *lParam* 會包含資料指標的 x 和 y 座標。 X 座標是在低序位字組中，而 y 座標則是在高序位字中。

### <a name="remarks"></a>備註

建立子視窗時，系統會在建立視窗的 `OnParentNotify` [Create](#create) 成員函式之前呼叫。 當子視窗被終結時，系統 `OnParentNotify` 會先呼叫，再進行任何處理，以損毀視窗。

`OnParentNotify` 會針對子視窗的所有上階視窗呼叫，包括最上層視窗。

除了具有 [WS_EX_NOPARENTNOTIFY](../../mfc/reference/styles-used-by-mfc.md#extended-window-styles) 樣式的所有子視窗，會將此訊息傳送至其父視窗。 依預設，除非透過呼叫 [CreateEx](#createex) 成員函式而不使用此樣式建立子視窗，否則對話方塊中的子視窗會有 WS_EX_NOPARENTNOTIFY 樣式。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonpowerbroadcast"></a><a name="onpowerbroadcast"></a> CWnd：： OnPowerBroadcast

當發生電源管理事件時，架構會呼叫這個成員函式。

```
afx_msg UINT OnPowerBroadcast(
    UINT nPowerEvent,
    UINT nEventData);
```

### <a name="parameters"></a>參數

*nPowerEvent*\
在電源管理事件。

*nEventData*\
在事件特定資料。

### <a name="return-value"></a>傳回值

如果事件是要求，則傳回 TRUE 以授與要求，或 BROADCAST_QUERY_DENY 拒絕要求。

### <a name="remarks"></a>備註

這個方法會接收 [WM_POWERBROADCAST](/windows/win32/Power/wm-powerbroadcast) 的訊息，如 Windows SDK 中所述。

*NPowerEvent*參數會指定事件，例如電池電力偏低、電源狀態已變更、要求或拒絕暫停作業的許可權、作業在事件之後自動繼續、系統正在暫停作業，或在暫停後繼續作業。 通常不會使用 *nEventData* 參數。 如需詳細資訊，請參閱[WM_POWERBROADCAST](/windows/win32/Power/wm-powerbroadcast)訊息的*wParam*和*lParam*參數。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonquerydragicon"></a><a name="onquerydragicon"></a> CWnd：： OnQueryDragIcon

架構會以最小化的 (iconic) 視窗來呼叫這個成員函式，該視窗沒有針對其類別定義的圖示。

```
afx_msg HCURSOR OnQueryDragIcon();
```

### <a name="return-value"></a>傳回值

包含低序位字組之游標或圖示控制碼的雙全半值。 游標或圖示必須與顯示驅動程式的解析度相容。 如果應用程式傳回 Null，系統就會顯示預設資料指標。 預設的傳回值為 Null。

### <a name="remarks"></a>備註

當使用者拖曳最小化的視窗時，系統會進行此呼叫，以取得要顯示的資料指標。 如果應用程式傳回圖示或游標的控制碼，系統就會將它轉換成黑色和白色。 如果應用程式傳回控制碼，控制碼就必須識別與顯示器驅動程式解析度相容的單色游標或圖示。 應用程式可以呼叫 [CWinApp：： LoadCursor](../../mfc/reference/cwinapp-class.md#loadcursor) 或 [CWinApp：： LoadIcon](../../mfc/reference/cwinapp-class.md#loadicon) 成員函式，從其可執行檔中的資源載入資料指標或圖示，並取得此控制碼。

## <a name="cwndonqueryendsession"></a><a name="onqueryendsession"></a> CWnd：： OnQueryEndSession

當使用者選擇結束 Windows 會話或應用程式呼叫 [ExitWindows](/windows/win32/api/winuser/nf-winuser-exitwindows) windows 函式時，架構會呼叫這個成員函式。

```
afx_msg BOOL OnQueryEndSession();
```

### <a name="return-value"></a>傳回值

如果可以方便地關閉應用程式，則為非零。否則為0。

### <a name="remarks"></a>備註

如果有任何應用程式傳回0，則不會結束 Windows 會話。 當 `OnQueryEndSession` 某個應用程式傳回0時，Windows 就會停止呼叫，並傳送已傳回非零之任何應用程式的參數值為 FALSE 的 [WM_ENDSESSION](#onendsession) 訊息。

## <a name="cwndonquerynewpalette"></a><a name="onquerynewpalette"></a> CWnd：： OnQueryNewPalette

當 `CWnd` 物件即將收到輸入焦點時，架構會呼叫這個成員函式，讓您 `CWnd` 有機會在收到焦點時，實現其邏輯調色板。

```
afx_msg BOOL OnQueryNewPalette();
```

### <a name="return-value"></a>傳回值

如果發現 `CWnd` 其邏輯調色板，則為非零，否則為0。

## <a name="cwndonqueryopen"></a><a name="onqueryopen"></a> CWnd：： OnQueryOpen

當物件最小化時，架構會呼叫這個成員函式 `CWnd` ，而使用者要求將 `CWnd` 還原為其 preminimized 大小和位置。

```
afx_msg BOOL OnQueryOpen();
```

### <a name="return-value"></a>傳回值

如果可以開啟圖示，則為非零，否則為0以防止開啟圖示。

### <a name="remarks"></a>備註

在中 `OnQueryOpen` ， `CWnd` 不應該執行任何會導致啟用或焦點變更 (例如，) 建立對話方塊。

## <a name="cwndonqueryuistate"></a><a name="onqueryuistate"></a> CWnd：： OnQueryUIState

呼叫以擷取視窗的使用者介面 (UI) 狀態。

```
afx_msg UINT OnQueryUIState();
```

### <a name="return-value"></a>傳回值

如果焦點指標和鍵盤快速鍵是可見的，則傳回值為 Null。 否則，傳回值可以是下列一或多個值：

- UISF_HIDEFOCUS 聚焦指標是隱藏的。

- UISF_HIDEACCEL 的鍵盤快捷為隱藏。

- UISF_ACTIVE Windows XP：控制項應以用於作用中控制項的樣式來繪製。

### <a name="remarks"></a>備註

此成員函式會模擬 [WM_QUERYUISTATE](/windows/win32/menurc/wm-queryuistate) 訊息的功能，如 Windows SDK 中所述。

## <a name="cwndonrawinput"></a><a name="onrawinput"></a> CWnd：： OnRawInput

當目前視窗取得原始輸入時，架構會呼叫這個成員函式。

```
afx_msg void OnRawInput(
    UINT nInputCode,
    HRAWINPUT hRawInput);
```

### <a name="parameters"></a>參數

*nInputCode*\
在輸入代碼，指出當應用程式在前景時是否發生輸入。 無論是哪一種情況，應用程式都必須呼叫 [CWnd：:D efwindowproc](#defwindowproc) ，讓系統可以執行清除。 這個參數可以是下列其中一個值：

- `RIM_INPUT` -當應用程式在前景時，就會發生輸入。
- `RIM_INPUTSINK` -當應用程式不在前景時，就會發生輸入。

*hRawInput*\
在 [RAWINPUT](/windows/win32/api/winuser/ns-winuser-rawinput) 結構的控制碼，其中包含來自裝置的原始輸入。

### <a name="remarks"></a>備註

這個方法會接收 [WM_INPUT](/windows/win32/inputdev/wm-appcommand) 通知，如 Windows SDK 所述。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonrbuttondblclk"></a><a name="onrbuttondblclk"></a> CWnd：： OnRButtonDblClk

當使用者按兩下滑鼠右鍵時，架構會呼叫這個成員函式。

```
afx_msg void OnRButtonDblClk(
    UINT nFlags,
    CPoint point);
```

### <a name="parameters"></a>參數

*nFlags*<br/>
指出不同的虛擬機器碼是否已關閉。 這個參數可以是下列值的任意組合：

- 如果 CTRL 鍵已關閉，MK_CONTROL 設定。

- 如果滑鼠左鍵已關閉，MK_LBUTTON 設定。

- MK_MBUTTON 設定是否要關閉中間的滑鼠按鍵。

- 如果滑鼠右鍵關閉，MK_RBUTTON 設定。

- 如果 SHIFT 鍵已關閉，MK_SHIFT 設定。

*點*<br/>
指定資料指標的 x 和 y 座標。 這些座標一律相對於視窗的左上角。

### <a name="remarks"></a>備註

只有具有 CS_DBLCLKS [WNDCLASS](/windows/win32/api/winuser/ns-winuser-wndclassw) 樣式的視窗可以接收 `OnRButtonDblClk` 呼叫。 這是 MFC 程式庫內 windows 的預設值。 當使用者按下放開時，Windows 會呼叫，然後在 `OnRButtonDblClk` 系統的按兩下時間限制內再次按下滑鼠右鍵。 按兩下滑鼠右鍵會產生四個事件： [WM_RBUTTONDOWN](#onrbuttondown) 和 [WM_RBUTTONUP](#onrbuttonup) 訊息、 `OnRButtonDblClk` 呼叫，以及放開按鈕時的另一 WM_RBUTTONUP 訊息。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonrbuttondown"></a><a name="onrbuttondown"></a> CWnd：： OnRButtonDown

當使用者按下滑鼠右鍵時，架構會呼叫這個成員函式。

```
afx_msg void OnRButtonDown(
    UINT nFlags,
    CPoint point);
```

### <a name="parameters"></a>參數

*nFlags*<br/>
指出不同的虛擬機器碼是否已關閉。 這個參數可以是下列值的任意組合：

- 如果 CTRL 鍵已關閉，MK_CONTROL 設定。

- 如果滑鼠左鍵已關閉，MK_LBUTTON 設定。

- MK_MBUTTON 設定是否要關閉中間的滑鼠按鍵。

- 如果滑鼠右鍵關閉，MK_RBUTTON 設定。

- 如果 SHIFT 鍵已關閉，MK_SHIFT 設定。

*點*<br/>
指定資料指標的 x 和 y 座標。 這些座標一律相對於視窗的左上角。

### <a name="remarks"></a>備註

架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonrbuttonup"></a><a name="onrbuttonup"></a> CWnd：： OnRButtonUp

當使用者放開滑鼠右鍵時，架構會呼叫這個成員函式。

```
afx_msg void OnRButtonUp(
    UINT nFlags,
    CPoint point);
```

### <a name="parameters"></a>參數

*nFlags*<br/>
指出不同的虛擬機器碼是否已關閉。 這個參數可以是下列值的任意組合：

- 如果 CTRL 鍵已關閉，MK_CONTROL 設定。

- 如果滑鼠左鍵已關閉，MK_LBUTTON 設定。

- MK_MBUTTON 設定是否要關閉中間的滑鼠按鍵。

- 如果 SHIFT 鍵已關閉，MK_SHIFT 設定。

*點*<br/>
指定資料指標的 x 和 y 座標。 這些座標一律相對於視窗的左上角。

### <a name="remarks"></a>備註

架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonregisteredmousewheel"></a><a name="onregisteredmousewheel"></a> CWnd：： OnRegisteredMouseWheel

架構會在使用者旋轉滑鼠滾輪時呼叫此成員函式，並遇到滾輪的下一個凹槽。

```
afx_msg LRESULT OnRegisteredMouseWheel(
    WPARAM wParam,
    LPARAM lParam);
```

### <a name="parameters"></a>參數

*wParam*<br/>
指標的水準位置。

*lParam*<br/>
指標的垂直位置。

### <a name="return-value"></a>傳回值

目前沒有意義。 一定是零。

### <a name="remarks"></a>備註

除非有覆寫，否則 `OnRegisteredMouseWheel` 會將訊息路由至適當的視窗， (父視窗的焦點) ，然後呼叫該視窗的 [WM_MOUSEWHEEL](/windows/win32/inputdev/wm-mousewheel) 處理常式。

覆寫此成員函式以提供您自己的訊息路由，或改變滑鼠滾輪的滾動行為。

> [!NOTE]
> `OnRegisteredMouseWheel` 處理 Windows 95/98 和 Windows NT 3.51 的訊息。 針對 Windows NT 4.0 訊息處理，請使用 [OnMouseWheel](#onmousewheel)。

## <a name="cwndonrenderallformats"></a><a name="onrenderallformats"></a> CWnd：： OnRenderAllFormats

`OnRenderAllFormats`當擁有者應用程式被終結時，架構會呼叫剪貼簿擁有者的成員函式。

```
afx_msg void OnRenderAllFormats();
```

### <a name="remarks"></a>備註

剪貼簿擁有者應該以它能夠產生的所有格式轉譯資料，並藉由呼叫 [SetClipboardData](/windows/win32/api/winuser/nf-winuser-setclipboarddata) Windows 函式，將每個格式的資料控制碼傳遞到剪貼簿。 這樣可確保剪貼簿包含有效的資料，即使轉譯資料的應用程式已損毀也是一樣。 應用程式應該在呼叫[SetClipboardData](/windows/win32/api/winuser/nf-winuser-setclipboarddata) windows 函式之前呼叫[OpenClipboard](#openclipboard)成員函式，並在之後呼叫[CloseClipboard](/windows/win32/api/winuser/nf-winuser-closeclipboard) windows 函數。

## <a name="cwndonrenderformat"></a><a name="onrenderformat"></a> CWnd：： OnRenderFormat

`OnRenderFormat`當需要呈現具有延遲轉譯的特定格式時，架構會呼叫剪貼簿擁有者的成員函式。

```
afx_msg void OnRenderFormat(UINT nFormat);
```

### <a name="parameters"></a>參數

*nFormat*<br/>
指定剪貼簿格式。

### <a name="remarks"></a>備註

接收者應該以該格式轉譯資料，並藉由呼叫 [SetClipboardData](/windows/win32/api/winuser/nf-winuser-setclipboarddata) Windows 函式將它傳遞給剪貼簿。

請勿 `OpenClipboard` 從內呼叫成員函式或 `CloseClipboard` Windows 函數 `OnRenderFormat` 。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonsessionchange"></a><a name="onsessionchange"></a> CWnd：： OnSessionChange

架構會呼叫這個成員函式，以通知應用程式會話狀態的變更。

```
afx_msg void OnSessionChange(
    UINT nSessionState,
    UINT nId);
```

### <a name="parameters"></a>參數

*nSessionState*\
在狀態碼描述會話狀態變更。

*nId*\
在會話識別碼。

### <a name="remarks"></a>備註

這個方法會接收 [WM_WTSSESSION_CHANGE](/windows/win32/TermServ/wm-wtssession-change) 通知，如 Windows SDK 所述。

*NSessionState*參數會指定會話連線或中斷連線，或從主控台或遠端終端機機、使用者登入或關閉、會話已鎖定或解除鎖定，或會話已變更為遠端控制的狀態。 如需詳細資訊，請參閱[WM_WTSSESSION_CHANGE](/windows/win32/TermServ/wm-wtssession-change)訊息的*wParam*參數。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonsetcursor"></a><a name="onsetcursor"></a> CWnd：： OnSetCursor

架構會呼叫這個成員函式，如果沒有捕捉到滑鼠輸入，而且滑鼠造成游標在 `CWnd` 物件內移動。

```
afx_msg BOOL OnSetCursor(
    CWnd* pWnd,
    UINT nHitTest,
    UINT message);
```

### <a name="parameters"></a>參數

*pWnd*<br/>
指定包含游標之視窗的指標。 該指標可能是暫時性的，因此不應該儲存供日後使用。

*nHitTest*<br/>
指定 [點擊測試區域程式](#onnchittest) 代碼。 點擊測試會判斷資料指標的位置。

*message*<br/>
指定滑鼠訊息編號。

### <a name="return-value"></a>傳回值

非零會停止進一步的處理，或0以繼續。

### <a name="remarks"></a>備註

預設的執行會在處理之前呼叫父視窗 `OnSetCursor` 。 如果父視窗傳回 TRUE，則會停止進一步處理。 呼叫父視窗可讓父視窗控制子視窗中資料指標的設定。

如果它不在工作區中，預設的執行會將資料指標設為箭號，如果是，則會將資料指標設為已註冊的類別。

如果 *nHitTest* 是 HTERROR，而 *message* 是按下滑鼠按鍵的訊息，則 `MessageBeep` 會呼叫成員函式。

進入功能表模式時， *訊息* 參數為 0 `CWnd` 。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonsetfocus"></a><a name="onsetfocus"></a> CWnd：： OnSetFocus

在取得輸入焦點之後，架構會呼叫這個成員函式。

```
afx_msg void OnSetFocus(CWnd* pOldWnd);
```

### <a name="parameters"></a>參數

*pOldWnd*<br/>
包含 `CWnd` 失去輸入焦點的物件 (可能為 Null) 。 該指標可能是暫時性的，因此不應該儲存供日後使用。

### <a name="remarks"></a>備註

若要顯示插入號，此時 `CWnd` 應該呼叫適當的插入號函式。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonsettingchange"></a><a name="onsettingchange"></a> CWnd：： OnSettingChange

`OnSettingChange`當 Win32 SystemParametersInfo 函式變更整個系統的設定時，架構會呼叫所有最上層視窗。

```
afx_msg void OnSettingChange(
    UINT uFlags,
    LPCTSTR lpszSection);
```

### <a name="parameters"></a>參數

*uFlags*<br/>
當系統傳送訊息做為呼叫的結果時 `SystemParametersInfo` ，這個參數就是一個旗標，指出已變更的系統參數。 如需值清單，請參閱 Windows SDK 中的 [SystemParametersInfo](/windows/win32/api/winuser/nf-winuser-systemparametersinfow) 。 當應用程式傳送訊息時，此參數必須為0。

*lpszSection*<br/>
指向字串，這個字串會指定已變更之區段的名稱。  (字串不包含用來括住區段名稱的方括弧 ) 

### <a name="remarks"></a>備註

應用程式應該會在對系統參數進行變更時，將訊息傳送至所有最上層視窗，而當使用者透過主控台變更設定時，Windows 會傳送訊息。

ON_WM_SETTINGCHANGE 訊息類似于 ON_WM_WININICHANGE 訊息，但有下列差異：

- 在執行 Windows NT 4.0 或更新版本，或在 Windows 95/98 下，使用 ON_WM_SETTINGCHANGE。

- 執行 Windows NT 3.51 或更舊版本時，請使用 ON_WININICHANGE。 這則訊息現在已過時。

您的訊息對應中應該只有其中一個宏。 若要撰寫適用于 Windows 95/98 和 Windows NT 4.0 的程式，請撰寫 ON_WM_SETTINGCHANGE 的處理常式。 在 Windows NT 3.51 下，您的處理常式將由 `OnSettingChange` 和 *uFlags* 呼叫，且一律為零。

## <a name="cwndonshowwindow"></a><a name="onshowwindow"></a> CWnd：： OnShowWindow

當 `CWnd` 物件即將隱藏或顯示時，架構會呼叫這個成員函式。

```
afx_msg void OnShowWindow(
    BOOL bShow,
    UINT nStatus);
```

### <a name="parameters"></a>參數

*bShow*<br/>
指定是否顯示視窗。 如果視窗正在顯示，則為 TRUE;如果視窗已隱藏，則為 FALSE。

*nStatus*<br/>
指定所顯示視窗的狀態。 如果因為成員函式呼叫而傳送訊息，則為 0 `ShowWindow` ; 否則 *nStatus* 是下列其中一項：

- SW_PARENTCLOSING 父視窗 (正在進行 iconic) 或隱藏快顯視窗。

- SW_PARENTOPENING 父視窗開啟 (顯示) 或顯示快顯視窗。

### <a name="remarks"></a>備註

當呼叫成員函式、將重迭的 `ShowWindow` 視窗最大化或還原，或當重迭或快顯視窗關閉 (使 iconic) 或開啟 (顯示在畫面) 上時，就會隱藏或顯示視窗。 當重迭視窗關閉時，就會隱藏與該視窗相關聯的所有快顯視窗。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonsize"></a><a name="onsize"></a> CWnd：： OnSize

架構會在視窗大小變更之後呼叫這個成員函式。

```
afx_msg void OnSize(
    UINT nType,
    int cx,
    int cy);
```

### <a name="parameters"></a>參數

*nType*<br/>
指定要求的調整大小類型。 這個參數可以是下列其中一個值：

- 已將 SIZE_MAXIMIZED 視窗最大化。

- SIZE_MINIMIZED 視窗已降至最低。

- SIZE_RESTORED 視窗已調整大小，但 SIZE_MINIMIZED 或 SIZE_MAXIMIZED 都不適用。

- 當某個其他視窗最大化時，SIZE_MAXHIDE 的訊息會傳送至所有快顯視窗。

- 當某個其他視窗還原成先前的大小時，SIZE_MAXSHOW 訊息會傳送至所有快顯視窗。

*殘雪*<br/>
指定工作區的新寬度。

*cy*<br/>
指定工作區的新高度。

### <a name="remarks"></a>備註

如果從呼叫子視窗的 [SetScrollPos](#setscrollpos) 或 [MoveWindow](#movewindow) 成員函式 `OnSize` ， `bRedraw` 或的參數應為 `SetScrollPos` `MoveWindow` 非零，以使重新 `CWnd` 繪製。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#109](../../mfc/reference/codesnippet/cpp/cwnd-class_50.cpp)]

## <a name="cwndonsizeclipboard"></a><a name="onsizeclipboard"></a> CWnd：： OnSizeClipboard

`OnSizeClipboard`當剪貼簿包含具有屬性的資料 `CF_OWNERDISPLAY` ，以及 [剪貼簿-檢視器] 視窗的工作區大小已經變更時，剪貼簿檢視器就會呼叫剪貼簿擁有者的成員函式。

```
afx_msg void OnSizeClipboard(
    CWnd* pClipAppWnd,
    HGLOBAL hRect);
```

### <a name="parameters"></a>參數

*pClipAppWnd*<br/>
識別剪貼簿-應用程式視窗。 指標可能是暫時性的，不應該儲存。

*hRect*<br/>
識別全域記憶體物件。 Memory 物件包含 RECT 資料結構，可指定剪貼簿擁有者繪製的區域。

### <a name="remarks"></a>備註

成員函式 `OnSizeClipboard` 會以 null 矩形呼叫， (0，0，0，0) 作為剪貼簿應用程式即將終結或最小化時的新大小。 這可讓剪貼簿擁有者釋放其顯示資源。

在中 `OnSizeClipboard` ，應用程式必須使用 [GlobalLock](/windows/win32/api/winbase/nf-winbase-globallock) Windows 函數來鎖定包含 RECT 資料結構的記憶體。 讓應用程式在產生或傳回控制項之前，使用 [GlobalUnlock](/windows/win32/api/winbase/nf-winbase-globalunlock) Windows 函式解除鎖定該記憶體。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonsizing"></a><a name="onsizing"></a> CWnd：： OnSizing

架構會呼叫這個成員函式，以指出使用者正在調整矩形的大小。

```
afx_msg void OnSizing(
    UINT nSide,
    LPRECT lpRect);
```

### <a name="parameters"></a>參數

*Russinovich*<br/>
要移動之視窗的邊緣。

*lpRect*<br/>
將包含專案座標的 [CRect](../../atl-mfc-shared/reference/crect-class.md) 或 [RECT 結構](/windows/win32/api/windef/ns-windef-rect) 的位址。

### <a name="remarks"></a>備註

藉由處理此訊息，應用程式可以監視拖曳矩形的大小和位置，並視需要變更其大小或位置。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#110](../../mfc/reference/codesnippet/cpp/cwnd-class_51.cpp)]

## <a name="cwndonspoolerstatus"></a><a name="onspoolerstatus"></a> CWnd：： OnSpoolerStatus

每當在列印管理員佇列中加入或移除工作時，架構會從列印管理員呼叫這個成員函式。

```
afx_msg void OnSpoolerStatus(
    UINT nStatus,
    UINT nJobs);
```

### <a name="parameters"></a>參數

*nStatus*<br/>
指定 SP_JOBSTATUS 旗標。

*nJobs*<br/>
指定列印管理員佇列中剩餘的工作數目。

### <a name="remarks"></a>備註

此呼叫僅供參考之用。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonstylechanged"></a><a name="onstylechanged"></a> CWnd：： OnStyleChanged

架構會在 [SetWindowLong](/windows/win32/api/winuser/nf-winuser-setwindowlongw) 函式變更一個或多個視窗的樣式之後，呼叫這個成員函式。

```
afx_msg void OnStyleChanged(
    int nStyleType,
    LPSTYLESTRUCT lpStyleStruct);
```

### <a name="parameters"></a>參數

*nStyleType*<br/>
指定視窗的延伸或 nonextended 樣式是否已變更。 這個參數可以是下列值的組合：

- GWL_EXSTYLE 視窗的擴充樣式已變更。

- GWL_STYLE 視窗的 nonextended 樣式已變更。

*lpStyleStruct*<br/>
指向 [STYLESTRUCT](/windows/win32/api/winuser/ns-winuser-stylestruct) 結構，其中包含視窗的新樣式。 應用程式可以檢查樣式，但不能變更它們。

### <a name="remarks"></a>備註

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonstylechanging"></a><a name="onstylechanging"></a> CWnd：： OnStyleChanging

當 [SetWindowLong](/windows/win32/api/winuser/nf-winuser-setwindowlongw) 函數即將變更一個或多個視窗的樣式時，架構會呼叫這個成員函式。

```
afx_msg void OnStyleChanging(
    int nStyleType,
    LPSTYLESTRUCT lpStyleStruct);
```

### <a name="parameters"></a>參數

*nStyleType*<br/>
指定視窗的延伸或 nonextended 樣式是否已變更。 這個參數可以是下列值的組合：

- GWL_EXSTYLE 視窗的擴充樣式已變更。

- GWL_STYLE 視窗的 nonextended 樣式已變更。

*lpStyleStruct*<br/>
指向 [STYLESTRUCT](/windows/win32/api/winuser/ns-winuser-stylestruct) 結構，其中包含視窗的新樣式。 應用程式可以檢查樣式並加以變更。

### <a name="remarks"></a>備註

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonsyschar"></a><a name="onsyschar"></a> CWnd：： OnSysChar

如果 `CWnd` 有輸入焦點，而且 [WM_SYSKEYUP](#onsyskeyup) 和 [WM_SYSKEYDOWN](#onsyskeydown) 的訊息已轉譯，則架構會呼叫這個成員函式。

```
afx_msg void OnSysChar(
    UINT nChar,
    UINT nRepCnt,
    UINT nFlags);
```

### <a name="parameters"></a>參數

*nChar*<br/>
指定控制功能表鍵的 ASCII 字元按鍵碼。

*nRepCnt*<br/>
指定重複計數 (當使用者按住) 按鍵時，按鍵重複的次數。

*nFlags*<br/>
*NFlags*參數可以有下列值：

|值|意義|
|-----------|-------------|
|0-15|指定重複計數。 值是當使用者按住索引鍵時，按鍵重複出現的次數。|
|16-23|指定掃描程式碼。 此值取決於原始設備製造商 (OEM) |
|24|指定機碼是否為擴充的索引鍵，例如出現在增強型101或102按鍵鍵盤上的右手 ALT 和 CTRL 鍵。 如果它是擴充索引鍵，則此值為 1;否則，它是0。|
|25-28|由 Windows 在內部使用。|
|29|指定內容程式碼。 如果按下按鍵時按住 ALT 鍵，則此值為 1;否則，此值為0。|
|30|指定先前的金鑰狀態。 如果在傳送訊息之前，金鑰已關閉，則此值為 1; 如果金鑰已啟動，則為0。|
|31|指定轉換狀態。 如果正在釋放金鑰，則值為1，如果正在按下索引鍵，則為0。|

### <a name="remarks"></a>備註

它會指定控制功能表鍵的虛擬按鍵碼。  (如需標準虛擬機器碼的清單，請參閱 Winuser) 

當內容程式碼為0時，WM_SYSCHAR 可以將 [WM_SYSCHAR](/windows/win32/menurc/wm-syschar) 訊息傳遞至 [TranslateAccelerator](/windows/win32/api/winuser/nf-winuser-translateacceleratorw) Windows 函式，它會處理它，就像是一般的按鍵訊息，而不是系統字元金鑰一樣。 這可讓快速鍵與使用中視窗搭配使用，即使使用中視窗沒有輸入焦點也一樣。

針對 IBM 增強的101和102鍵鍵盤，增強型按鍵是鍵盤主要區段上的右 ALT 和右 CTRL 鍵;位於數位鍵台左邊的叢集中的 INS、DEL、HOME、END、PAGE UP、PAGE DOWN 和方向鍵;以及斜線 (/) 並在數位鍵台中輸入按鍵。 有些其他鍵盤可能會支援 *nFlags*中的擴充金鑰位。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonsyscolorchange"></a><a name="onsyscolorchange"></a> CWnd：： OnSysColorChange

架構會在系統色彩設定中進行變更時，針對所有最上層視窗呼叫此成員函式。

```
afx_msg void OnSysColorChange();
```

### <a name="remarks"></a>備註

`OnSysColorChange`受系統色彩變更影響之任何視窗的 Windows 呼叫。

具有使用現有系統色彩之筆刷的應用程式應該刪除這些筆刷，然後使用新的系統色彩重新建立它們。

## <a name="cwndonsyscommand"></a><a name="onsyscommand"></a> CWnd：： OnSysCommand

當使用者選取 [控制台] 中的命令，或當使用者選取 [最大化] 或 [最小化] 按鈕時，架構會呼叫這個成員函式。

```
afx_msg void OnSysCommand(
    UINT nID,
    LPARAM lParam);
```

### <a name="parameters"></a>參數

*nID*<br/>
指定所要求的系統命令類型。 此參數可以是下列其中一個值：

- SC_CLOSE 關閉 `CWnd` 物件。

- SC_HOTKEY 啟動 `CWnd` 與應用程式指定之快速鍵相關聯的物件。 *LParam*的低序位字識別要啟動之視窗的 HWND。

- SC_HSCROLL 水準滾動。

- SC_KEYMENU 透過按鍵取出功能表。

- SC_MAXIMIZE (或 SC_ZOOM) 最大化 `CWnd` 物件。

- SC_MINIMIZE (或 SC_ICON) 將物件最小化 `CWnd` 。

- SC_MOUSEMENU 透過滑鼠點擊來取得功能表。

- SC_MOVE 移動 `CWnd` 物件。

- SC_NEXTWINDOW 移至下一個視窗。

- SC_PREVWINDOW 移至上一個視窗。

- SC_RESTORE 還原] 視窗為正常的位置和大小。

- SC_SCREENSAVE 執行 SYSTEM.INI 檔案的 [boot] 區段中指定的螢幕保護裝置應用程式。

- SC_SIZE 調整 `CWnd` 物件大小。

- SC_TASKLIST 執行或啟動 Windows 工作管理員應用程式。

- SC_VSCROLL 垂直捲動。

*lParam*<br/>
如果您選擇使用滑鼠的功能表命令， *lParam* 會包含游標座標。 低序位單字包含 x 座標，而高序位單字包含 y 座標。 否則，就不會使用此參數。

- SC_HOTKEY 啟動與應用程式指定之快速鍵相關聯的視窗。 *LParam*的低序位字識別要啟動的視窗。

- SC_SCREENSAVE 執行主控台的 Desktop 區段中指定的螢幕儲存應用程式。

### <a name="remarks"></a>備註

根據預設，會 `OnSysCommand` 執行上表中所指定之預先定義動作的 [控制] 功能表要求。

在 WM_SYSCOMMAND 訊息中，Windows 會在內部使用 *nID* 參數的四個低序位位。 當應用程式測試 *nID*的值時，它必須使用位 and 運算子來取得正確的結果，以將值0XFFF0 與 *nID* 值結合。

您可以使用 `GetSystemMenu` 、 `AppendMenu` 、 `InsertMenu` 和成員函式來修改控制項功能表中的功能表項目 `ModifyMenu` 。 修改 [控制] 功能表的應用程式必須處理 WM_SYSCOMMAND 的訊息，而且應用程式未處理的任何 WM_SYSCOMMAND 訊息都必須傳遞至 `OnSysCommand` 。 應用程式所新增的任何命令值都必須由應用程式處理，而且無法傳遞至 `OnSysCommand` 。

應用程式可以在任何時候執行任何系統命令，方法是將 WM_SYSCOMMAND 訊息傳遞至 `OnSysCommand` 。

加速器 (快速鍵) 從 [控制] 功能表中選取專案所定義的按鍵會轉譯成 `OnSysCommand` 呼叫; 所有其他快速鍵按鍵都會轉譯成 [WM_COMMAND](#oncommand) 的訊息。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonsysdeadchar"></a><a name="onsysdeadchar"></a> CWnd：： OnSysDeadChar

當 `CWnd` 呼叫 [OnSysKeyUp](#onsyskeyup) 或 [OnSysKeyDown](#onsyskeydown) 成員函式時，如果物件具有輸入焦點，架構會呼叫這個成員函式。

```
afx_msg void OnSysDeadChar(
    UINT nChar,
    UINT nRepCnt,
    UINT nFlags);
```

### <a name="parameters"></a>參數

*nChar*<br/>
指定不正確索引鍵字元值。

*nRepCnt*<br/>
指定重複計數。

*nFlags*<br/>
指定掃描碼、按鍵轉換程式碼、先前的主要狀態和內容程式碼，如下列清單所示：

|值|意義|
|-----------|-------------|
|0-7|)  (OEM 相依值掃描程式碼。 高序位單字的低位元組。|
|8|擴充金鑰（例如，函式金鑰或數位鍵臺上的機碼） (1 （如果它是擴充金鑰）。否則為 0) 。|
|9-10|未使用。|
|11-12|由 Windows 在內部使用。|
|13|內容程式碼 (1 如果按下按鍵時按住 ALT 鍵，則為 < a0/1;否則為 0) 。|
|14|先前的金鑰狀態 (1 如果機碼在呼叫之前關閉，則為0（如果機碼) ）。|
|15|轉換狀態 (1 如果正在釋放機碼，則為0（如果按下按鍵) ）。|

### <a name="remarks"></a>備註

它會指定死索引鍵的字元值。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonsyskeydown"></a><a name="onsyskeydown"></a> CWnd：： OnSysKeyDown

如果 `CWnd` 物件具有輸入焦點，則 `OnSysKeyDown` 當使用者按住 ALT 鍵，然後按下另一個按鍵時，架構會呼叫成員函式。

```
afx_msg void OnSysKeyDown(
    UINT nChar,
    UINT nRepCnt,
    UINT nFlags);
```

### <a name="parameters"></a>參數

*nChar*<br/>
指定所按下之按鍵的虛擬按鍵碼。 如需標準虛擬金鑰程式碼的清單，請參閱 Winuser。h

*nRepCnt*<br/>
指定重複計數。

*nFlags*<br/>
指定掃描碼、按鍵轉換程式碼、先前的主要狀態和內容程式碼，如下列清單所示：

|值|意義|
|-----------|-------------|
|0-7|)  (OEM 相依值掃描程式碼。 高序位單字的低位元組。|
|8|擴充金鑰（例如，函式金鑰或數位鍵臺上的機碼） (1 （如果它是擴充金鑰）。否則為 0) 。|
|9-10|未使用。|
|11-12|由 Windows 在內部使用。|
|13|內容程式碼 (1 如果按下按鍵時按住 ALT 鍵，則為 0; 否則為) 。|
|14|先前的金鑰狀態 (1 如果在傳送訊息之前，金鑰已關閉，則為0（如果機碼已) ）。|
|15|轉換狀態 (1 如果正在釋放機碼，則為0（如果按下按鍵) ）。|

若為 `OnSysKeyDown` 呼叫，金鑰轉換位 (位 15) 為0。 如果按下按鍵時，在按下 ALT 鍵時，內容程式碼位 (bit 13) 為 1;如果訊息傳送至使用中視窗，則為0，因為沒有視窗具有輸入焦點。

### <a name="remarks"></a>備註

如果視窗目前沒有輸入焦點，則會呼叫使用中視窗的 `OnSysKeyDown` 成員函式。 `CWnd`接收訊息的物件可以藉由檢查中的內容程式碼來區分這兩個內容 `nFlags` 。

當內容程式碼為0時，所接收的 WM_SYSKEYDOWN 訊息 `OnSysKeyDown` 可以傳遞至 [TranslateAccelerator](/windows/win32/api/winuser/nf-winuser-translateacceleratorw) Windows 函式，它會處理它，就像是一般的金鑰訊息，而不是系統金鑰訊息一樣。 這可讓快速鍵與使用中視窗搭配使用，即使使用中視窗沒有輸入焦點也一樣。

由於自動重複， `OnSysKeyDown` 在收到 [WM_SYSKEYUP](#onsyskeyup) 訊息之前，可能會有一個以上的呼叫。 先前的索引鍵狀態 (位 14) 可用來判斷 `OnSysKeyDown` 呼叫是否表示第一個向下轉換或重複的轉換。

針對 IBM 增強的101和102鍵鍵盤，增強型按鍵是鍵盤主要區段上的右 ALT 和右 CTRL 鍵;位於數位鍵台左邊的叢集中的 INS、DEL、HOME、END、PAGE UP、PAGE DOWN 和方向鍵;以及斜線 (/) 並在數位鍵台中輸入按鍵。 有些其他鍵盤可能會支援 *nFlags*中的擴充金鑰位。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonsyskeyup"></a><a name="onsyskeyup"></a> CWnd：： OnSysKeyUp

如果 `CWnd` 物件具有焦點，則在 `OnSysKeyUp` 使用者釋放按住 ALT 鍵時所按下的索引鍵時，架構會呼叫成員函式。

```
afx_msg void OnSysKeyUp(
    UINT nChar,
    UINT nRepCnt,
    UINT nFlags);
```

### <a name="parameters"></a>參數

*nChar*<br/>
指定所按下之按鍵的虛擬按鍵碼。 如需標準虛擬金鑰程式碼的清單，請參閱 Winuser。h

*nRepCnt*<br/>
指定重複計數。

*nFlags*<br/>
指定掃描碼、按鍵轉換程式碼、先前的主要狀態和內容程式碼，如下列清單所示：

|值|意義|
|-----------|-------------|
|0-7|)  (OEM 相依值掃描程式碼。 高序位單字的低位元組。|
|8|擴充金鑰（例如，函式金鑰或數位鍵臺上的機碼） (1 （如果它是擴充金鑰）。否則為 0) 。|
|9-10|未使用。|
|11-12|由 Windows 在內部使用。|
|13|內容程式碼 (1 如果按下按鍵時按住 ALT 鍵，則為 0; 否則為) 。|
|14|先前的金鑰狀態 (1 如果在傳送訊息之前，金鑰已關閉，則為0（如果機碼已) ）。|
|15|轉換狀態 (1 如果正在釋放機碼，則為0（如果按下按鍵) ）。|

若為 `OnSysKeyUp` 呼叫，金鑰轉換位 (位 15) 為1。 如果按下按鍵時，在按下 ALT 鍵時，內容程式碼位 (bit 13) 為 1;如果訊息傳送至使用中視窗，則為0，因為沒有視窗具有輸入焦點。

### <a name="remarks"></a>備註

如果視窗目前沒有輸入焦點，則會呼叫使用中視窗的 `OnSysKeyUp` 成員函式。 `CWnd`接收呼叫的物件可以藉由檢查*nFlags*中的內容程式碼來區分這兩個內容。

當內容程式碼為0時，所接收的 WM_SYSKEYUP 訊息 `OnSysKeyUp` 可以傳遞至 [TranslateAccelerator](/windows/win32/api/winuser/nf-winuser-translateacceleratorw) Windows 函式，它會處理它，就像是一般的金鑰訊息，而不是系統金鑰訊息一樣。 這可讓加速器 (快速鍵) 索引鍵與使用中視窗搭配使用，即使使用中視窗沒有輸入焦點也一樣。

針對 IBM 增強的101和102鍵鍵盤，增強型按鍵是鍵盤主要區段上的右 ALT 和右 CTRL 鍵;位於數位鍵台左邊的叢集中的 INS、DEL、HOME、END、PAGE UP、PAGE DOWN 和方向鍵;以及斜線 (/) 並在數位鍵台中輸入按鍵。 有些其他鍵盤可能會支援 *nFlags*中的擴充金鑰位。

若為非美國的增強型102按鍵鍵盤，則會以 CTRL + ALT 鍵組合的方式來處理右邊的 ALT 鍵。 以下顯示當使用者按下並釋放此機碼時，所產生的訊息和呼叫順序：

|順序|函數存取|傳遞的訊息|
|--------------|-----------------------|--------------------|
|1.|[WM_KEYDOWN](#onkeydown)|VK_CONTROL|
|2.|[WM_KEYDOWN](#onkeydown)|VK_MENU|
|3.|[WM_KEYUP](#onkeyup)|VK_CONTROL|
|4.|[WM_SYSKEYUP](/windows/win32/inputdev/wm-syskeyup)|VK_MENU|

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndontcard"></a><a name="ontcard"></a> CWnd：： OnTCard

當使用者按一下 [authorable] 按鈕時，架構會呼叫這個成員函式。

```
afx_msg void OnTCard(
    UINT idAction,
    DWORD dwActionData);
```

### <a name="parameters"></a>參數

*idAction*<br/>
指出使用者已採取的動作。 此參數可以是下列其中一個值：

- IDABORT 使用者按一下 [authorable 中止] 按鈕。

- IDCANCEL 使用者按一下 authorable 的 [取消] 按鈕。

- IDCLOSE 使用者關閉訓練卡。

- IDHELP 使用者按一下 authorable 的 Windows [說明] 按鈕。

- IDIGNORE 使用者按一下 authorable [略過] 按鈕。

- IDOK 使用者按一下 authorable [確定] 按鈕。

- IDNO 使用者按一下 authorable [否] 按鈕。

- IDRETRY 使用者按一下 authorable 的 [重試] 按鈕。

- HELP_TCARD_DATA 使用者按一下 authorable 按鈕。 *DwActionData*參數包含由說明作者指定的長整數。

- HELP_TCARD_NEXT 使用者按一下 [authorable 下一步] 按鈕。

- HELP_TCARD_OTHER_CALLER 另一個應用程式已要求定型卡。

- IDYES 使用者按一下 [authorable 是] 按鈕。

*dwActionData*<br/>
如果 *idAction* 指定 HELP_TCARD_DATA，此參數是由說明作者指定的長整數。 否則，此參數為零。

### <a name="remarks"></a>備註

只有當應用程式已使用 Windows 說明起始定型卡時，才會呼叫此函式。 應用程式會在對 [WinHelp](../../mfc/reference/cwinapp-class.md#winhelp) 函式的呼叫中指定 HELP_TCARD 命令，以起始定型卡。

## <a name="cwndontimechange"></a><a name="ontimechange"></a> CWnd：： OnTimeChange

架構會在系統時間變更之後呼叫這個成員函式。

```
afx_msg void OnTimeChange();
```

### <a name="remarks"></a>備註

有任何變更系統時間的應用程式，會將此訊息傳送至所有最上層視窗。 若要將 WM_TIMECHANGE 訊息傳送至所有最上層視窗，應用程式可以使用 [SendMessage](/windows/win32/api/winuser/nf-winuser-sendmessage) windows 函式，並將 *hwnd* 參數設定為 HWND_BROADCAST。

## <a name="cwndontimer"></a><a name="ontimer"></a> CWnd：： OnTimer

架構會在用來安裝計時器的 [SetTimer](#settimer) 成員函式中指定的每個間隔之後，呼叫這個成員函式。

```
afx_msg void OnTimer(UINT_PTR nIDEvent);
```

### <a name="parameters"></a>參數

*nIDEvent*<br/>
指定計時器的識別碼。

### <a name="remarks"></a>備註

當應用程式的訊息佇列中沒有其他訊息時， [DispatchMessage](/windows/win32/api/winuser/nf-winuser-dispatchmessage) Windows 函式會傳送 [WM_TIMER](/windows/win32/winmsg/wm-timer) 訊息。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

### <a name="example"></a>範例

  請參閱 [CWnd：： SetTimer](#settimer)中的範例。

## <a name="cwndontoolhittest"></a><a name="ontoolhittest"></a> CWnd：： OnToolHitTest

架構會呼叫這個成員函式，以判斷某個點是否在指定之工具的周框中。

```
virtual INT_PTR OnToolHitTest(
    CPoint point,
    TOOLINFO* pTI) const;
```

### <a name="parameters"></a>參數

*點*<br/>
指定資料指標的 x 和 y 座標。 這些座標一律相對於視窗的左上角。

*Pti*<br/>
[TOOLINFO](/windows/win32/api/commctrl/ns-commctrl-tttoolinfoa)結構的指標。 預設會設定下列結構值：

- *hwnd*  =  hwnd `m_hWnd`視窗的控制碼

- *uId*  =  uId `(UINT)hWndChild`子視窗的控制碼

- *uFlags* &#124;= 工具 TTF_IDISHWND 控制碼

- *lpszText* = 要在指定視窗中顯示的字串指標 LPSTR_TEXTCALLBACK

### <a name="return-value"></a>傳回值

如果找到工具提示控制項，則為視窗控制項識別碼。 如果找不到工具提示控制項，則為-1。

### <a name="remarks"></a>備註

如果該點位於矩形中，則會抓取工具的相關資訊。

如果與工具提示相關聯的區域不是按鈕，則會 `OnToolHitTest` 將結構旗標設定為 TTF_NOTBUTTON 和 TTF_CENTERTIP。

覆寫 `OnToolHitTest` 以提供與預設提供的不同資訊。

如需結構的詳細資訊，請參閱 Windows SDK 中的 [TOOLINFO](/windows/win32/api/commctrl/ns-commctrl-tttoolinfoa)。

## <a name="cwndontouchinput"></a><a name="ontouchinput"></a> CWnd：： OnTouchInput

處理來自 Windows 觸控的單一輸入。

```
virtual BOOL OnTouchInput(
    CPoint pt,
    int nInputNumber,
    int nInputsCount,
    PTOUCHINPUT pInput);
```

### <a name="parameters"></a>參數

*pt*<br/>
在用戶端座標)  (觸及螢幕的位置。

*nInputNumber*<br/>
觸控輸入的數目。

*nInputsCount*<br/>
觸控輸入的總次數。

*pInput*<br/>
TOUCHINPUT 結構的指標。

### <a name="return-value"></a>傳回值

如果應用程式處理 Windows 觸控輸入，則為 TRUE;否則為 FALSE。

### <a name="remarks"></a>備註

## <a name="cwndontouchinputs"></a><a name="ontouchinputs"></a> CWnd：： OnTouchInputs

處理來自 Windows 觸控的輸入。

```
virtual BOOL OnTouchInputs(
    UINT nInputsCount,
    PTOUCHINPUT pInputs);
```

### <a name="parameters"></a>參數

*nInputsCount*<br/>
Windows 觸控輸入的總數目。

*pInputs*<br/>
TOUCHINPUT 的陣列。

### <a name="return-value"></a>傳回值

如果應用程式處理 Windows 觸控輸入，則為 TRUE。否則為 FALSE。

### <a name="remarks"></a>備註

## <a name="cwndonunichar"></a><a name="onunichar"></a> CWnd：： OnUniChar

當按下按鍵時，架構會呼叫這個成員函式。 亦即，目前視窗具有鍵盤焦點，且[TranslateMessage](/windows/win32/api/winuser/nf-winuser-translatemessage)函式會轉譯[WM_KEYDOWN](/windows/win32/inputdev/wm-keydown)的訊息。

```
afx_msg void OnUniChar(
    UINT nChar,
    UINT nRepCnt,
    UINT nFlags);
```

### <a name="parameters"></a>參數

*nChar*\
在指定按下之按鍵的字元碼。

*nRepCnt*\
在指定目前訊息的重複計數。 值是當使用者按住按鍵時，按鍵 autorepeated 的次數。 如果按鍵夠長，則會傳送多則訊息。 不過，重複計數不是累計的。

*nFlags*\
在旗標，指定掃描碼、擴充金鑰、內容程式碼、先前的主要狀態和轉換狀態，如下表所示：

| 旗標位 | 描述 |
|--|--|
| **0-7** | 指定掃描程式碼。 此值取決於原始設備製造商 (OEM) 。 |
| **8** | 指定擴充的按鍵，例如出現在增強型101或102按鍵鍵盤上的右手邊 ALT 和 CTRL 鍵。 如果金鑰是擴充金鑰，則旗標為 1;否則，它是0。 |
| **9-12** | 由 Windows 在內部使用。 |
| **13** | 指定內容程式碼。 如果按下按鍵時按住 ALT 鍵，則旗標為 1;否則，此值為0。 |
| **14**   指定先前的金鑰狀態。 如果金鑰在傳送訊息之前關閉，旗標為1，如果金鑰已啟動，則為0。 |
| **15** | 指定轉換狀態。 如果要釋放機碼，旗標為1，如果按下按鍵，則為0。 |

### <a name="remarks"></a>備註

這個方法會接收 [WM_UNICHAR](/windows/win32/inputdev/wm-unichar) 通知，如 Windows SDK 所述。 [WM_UNICHAR](/windows/win32/inputdev/wm-unichar)訊息的設計目的是要將 Unicode 字元傳送或張貼至 ANSI 視窗。 它相當於 [WM_CHAR](/windows/win32/inputdev/wm-char) 的訊息，但使用 Unicode 轉換格式-32 編碼 (32 utf-8) ，而 [WM_CHAR](/windows/win32/inputdev/wm-char) 訊息使用 utf-16。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonuninitmenupopup"></a><a name="onuninitmenupopup"></a> CWnd：： OnUnInitMenuPopup

當已終結下拉式功能表或子功能表時，架構會呼叫這個成員函式。

```
afx_msg void OnUnInitMenuPopup(
    CMenu* pPopupMenu,
    UINT nFlags);
```

### <a name="parameters"></a>參數

*pMenu*\
在 [CMenu](../../mfc/reference/cmenu-class.md) 物件的指標，該物件表示功能表或子功能表。

*nFlags*\
在已損毀的功能表。 目前只能是 [視窗] 功能表，MF_SYSMENU。

### <a name="remarks"></a>備註

這個方法會接收 [WM_UNINITMENUPOPUP](/windows/win32/menurc/wm-uninitmenupopup) 通知，如 Windows SDK 所述。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonupdateuistate"></a><a name="onupdateuistate"></a> CWnd：： OnUpdateUIState

呼叫以變更指定的視窗及其所有子視窗的使用者介面 (UI) 狀態。

```
afx_msg void OnUpdateUIState(
    UINT nAction,
    UINT nUIElement);
```

### <a name="parameters"></a>參數

*nAction*<br/>
指定要執行的動作。 可以是下列值之一：

- UIS_CLEAR 應隱藏 *nUIElement*) 所指定的 UI 狀態元素 (。

- UIS_INITIALIZE 您應該根據最後一個輸入事件來變更 *nUIElement*) 所指定的 UI 狀態元素 (。 如需詳細資訊，請參閱[WM_UPDATEISTATE](/windows/win32/menurc/wm-updateuistate)的「**備註**」一節。

- UIS_SET *nUIElement*) 指定的 UI 狀態元素 (應該是可見的。

*nUIElement*<br/>
指定受影響的 UI 狀態元素或控制項的樣式。 可以是下列值之一：

- UISF_HIDEACCEL 鍵盤快速鍵盤。

- UISF_HIDEFOCUS 焦點指標。

- UISF_ACTIVE Windows XP：控制項應以用於作用中控制項的樣式來繪製。

### <a name="remarks"></a>備註

此成員函式會模擬 [WM_UPDATEUISTATE](/windows/win32/menurc/wm-updateuistate) 訊息的功能，如 Windows SDK 中所述。

## <a name="cwndonuserchanged"></a><a name="onuserchanged"></a> CWnd：： OnUserChanged

架構會在使用者登入或登出之後，為所有視窗呼叫這個成員。

```
afx_msg void OnUserChanged();
```

### <a name="remarks"></a>備註

這個方法會接收 [WM_USERCHANGED](/windows/win32/winmsg/wm-userchanged) 的通知訊息，如 Windows SDK 中所述。 當使用者登入或登出時，作業系統會更新使用者特定的設定。 系統會在更新設定之後立即傳送此訊息。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonvkeytoitem"></a><a name="onvkeytoitem"></a> CWnd：： OnVKeyToItem

如果 `CWnd` 物件擁有具有 [LBS_WANTKEYBOARDINPUT](../../mfc/reference/styles-used-by-mfc.md#list-box-styles) 樣式的清單方塊，則清單方塊會傳送 WM_VKEYTOITEM 訊息以回應 WM_KEYDOWN 訊息。

```
afx_msg int OnVKeyToItem(
    UINT nKey,
    CListBox* pListBox,
    UINT nIndex);
```

### <a name="parameters"></a>參數

*nKey*<br/>
指定使用者所按下之金鑰的虛擬按鍵碼。 如需標準虛擬金鑰程式碼的清單，請參閱 Winuser。h

*pListBox*<br/>
指定清單方塊的指標。 該指標可能是暫時性的，因此不應該儲存供日後使用。

*nIndex*<br/>
指定目前的插入號位置。

### <a name="return-value"></a>傳回值

指定應用程式在回應訊息時所執行的動作。 傳回值-2 表示應用程式已處理選取專案的所有層面，且清單方塊不需要採取進一步的動作。 傳回值-1 表示清單方塊應該執行預設動作來回應擊鍵。 傳回值0或以上會指定清單方塊中專案的以零為基底的索引，並指出清單方塊應該針對指定的專案執行擊鍵的預設動作。

### <a name="remarks"></a>備註

此成員函式僅適用于具有 [LBS_HASSTRINGS](../../mfc/reference/styles-used-by-mfc.md#list-box-styles) 樣式之清單方塊的架構。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonvscroll"></a><a name="onvscroll"></a> CWnd：： OnVScroll

當使用者按一下視窗的垂直捲動條時，架構會呼叫這個成員函式。

```
afx_msg void OnVScroll(
    UINT nSBCode,
    UINT nPos,
    CScrollBar* pScrollBar);
```

### <a name="parameters"></a>參數

*nSBCode*<br/>
指定捲軸程式碼，指出使用者的滾動要求。 此參數可以是下列其中一項：

- SB_BOTTOM 向下移動。

- SB_ENDSCROLL 結束捲軸。

- SB_LINEDOWN 向下移動一行。

- SB_LINEUP 向上移動一行。

- SB_PAGEDOWN 向下移動一頁。

- SB_PAGEUP 向上滾動一頁。

- SB_THUMBPOSITION 滾動至絕對位置。 目前的位置是在 *nPos*中提供。

- SB_THUMBTRACK 將捲動方塊拖曳至指定的位置。 目前的位置是在 *nPos*中提供。

- SB_TOP 滾動至頂端。

*nPos*<br/>
如果捲軸程式碼 SB_THUMBPOSITION 或 SB_THUMBTRACK，則包含目前的捲動方塊位置;否則不使用。 視初始捲軸範圍而定， *nPos* 可能是負數，且應該在 **`int`** 必要時轉換為。

*pScrollBar*<br/>
如果捲軸訊息來自捲軸控制項，則包含控制項的指標。 如果使用者按一下視窗的捲軸，則此參數為 Null。 該指標可能是暫時性的，因此不應該儲存供日後使用。

### <a name="remarks"></a>備註

`OnVScroll` 一般是由應用程式所使用，這些應用程式會在拖曳捲動方塊時提供一些意見反應。

如果 `OnVScroll` 滾動物件的內容 `CWnd` ，則也必須使用 [SetScrollPos](#setscrollpos) 成員函式重設捲動方塊的位置。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonvscrollclipboard"></a><a name="onvscrollclipboard"></a> CWnd：： OnVScrollClipboard

`OnVScrollClipboard`當剪貼簿資料具有 CF_OWNERDISPLAY 格式，且剪貼簿檢視器的垂直捲動條中有事件時，剪貼簿檢視器會呼叫剪貼簿擁有者的成員函式。

```
afx_msg void OnVScrollClipboard(
    CWnd* pClipAppWnd,
    UINT nSBCode,
    UINT nPos);
```

### <a name="parameters"></a>參數

*pClipAppWnd*<br/>
指定 [剪貼簿-檢視器] 視窗的指標。 該指標可能是暫時性的，因此不應該儲存供日後使用。

*nSBCode*<br/>
指定下列其中一個捲軸值：

- SB_BOTTOM 向下移動。

- SB_ENDSCROLL 結束捲軸。

- SB_LINEDOWN 向下移動一行。

- SB_LINEUP 向上移動一行。

- SB_PAGEDOWN 向下移動一頁。

- SB_PAGEUP 向上滾動一頁。

- SB_THUMBPOSITION 滾動至絕對位置。 目前的位置是在 *nPos*中提供。

- SB_TOP 滾動至頂端。

*nPos*<br/>
如果捲軸程式碼 SB_THUMBPOSITION，則包含捲動方塊位置;否則，就不會使用 *nPos* 。

### <a name="remarks"></a>備註

擁有者應該會滾動剪貼簿影像、使適當的區段失效，並更新捲軸值。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonwindowmaximizedchanged"></a><a name="onwindowmaximizedchanged"></a> CWnd：： OnWindowMaximizedChanged

當目前視窗最大化時，架構會呼叫這個成員，而視窗是由桌面視窗管理員 (DWM) 所組成。

```
afx_msg void OnWindowMaximizedChanged(BOOL bIsMaximized);
```

### <a name="parameters"></a>參數

*bIsMaximized*\
在如果目前的視窗最大化，則為 TRUE，否則為 FALSE。

### <a name="remarks"></a>備註

這個方法會接收 [WM_DWMWINDOWMAXIMIZEDCHANGE](/windows/win32/dwm/wm-dwmwindowmaximizedchange) 的通知訊息，如 Windows SDK 中所述。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonwindowposchanged"></a><a name="onwindowposchanged"></a> CWnd：： OnWindowPosChanged

當大小、位置或迭置順序因為呼叫 [SetWindowPos](/windows/win32/api/winuser/nf-winuser-setwindowpos) 成員函式或其他視窗管理函數而變更時，架構會呼叫這個成員函式。

```
afx_msg void OnWindowPosChanged(WINDOWPOS* lpwndpos);
```

### <a name="parameters"></a>參數

*lpwndpos*<br/>
指向 [WINDOWPOS](/windows/win32/api/winuser/ns-winuser-windowpos) 資料結構，其中包含視窗新大小和位置的相關資訊。

### <a name="remarks"></a>備註

預設的執行會將 [WM_SIZE](/windows/win32/winmsg/wm-size) 和 [WM_MOVE](/windows/win32/winmsg/wm-move) 訊息傳送至視窗。 如果應用程式在 `OnWindowPosChanged` 不呼叫其基類的情況下處理呼叫，就不會傳送這些訊息。 在呼叫期間執行任何移動或大小變更處理的效率較高， `OnWindowPosChanged` 而不需要呼叫其基類。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonwindowposchanging"></a><a name="onwindowposchanging"></a> CWnd：： OnWindowPosChanging

當大小、位置或迭置順序即將因呼叫 [SetWindowPos](/windows/win32/api/winuser/nf-winuser-setwindowpos) 成員函式或其他視窗管理函式而變更時，架構會呼叫這個成員函式。

```
afx_msg void OnWindowPosChanging(WINDOWPOS* lpwndpos);
```

### <a name="parameters"></a>參數

*lpwndpos*<br/>
指向 `WINDOWPOS` 包含視窗新大小和位置相關資訊的資料結構。

### <a name="remarks"></a>備註

應用程式可以在[WINDOWPOS](/windows/win32/api/winuser/ns-winuser-windowpos)結構的**旗標**成員中設定或清除適當的位，以防止視窗的變更。

若為具有 [WS_OVERLAPPED](styles-used-by-mfc.md#window-styles) 或 [WS_THICKFRAME](styles-used-by-mfc.md#window-styles) 樣式的視窗，預設實作為會將 [WM_GETMINMAXINFO](/windows/win32/winmsg/wm-getminmaxinfo) 訊息傳送至視窗。 這樣做的目的是要驗證視窗的新大小和位置，以及強制執行 CS_BYTEALIGNCLIENT 和 CS_BYTEALIGN 用戶端樣式。 應用程式可以藉由不呼叫其基類來覆寫這項功能。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonwininichange"></a><a name="onwininichange"></a> CWnd：： OnWinIniChange

架構在對 Windows 初始化檔案進行變更之後，會呼叫這個成員函式 WIN.INI。

```
afx_msg void OnWinIniChange(LPCTSTR lpszSection);
```

### <a name="parameters"></a>參數

*lpszSection*<br/>
指向字串，這個字串會指定已變更之區段的名稱。  (字串不包含用來括住區段名稱的方括弧 ) 

### <a name="remarks"></a>備註

[SystemParametersInfo](/windows/win32/api/winuser/nf-winuser-systemparametersinfow) Windows 函數會 `OnWinIniChange` 在應用程式使用函式來變更 WIN.INI 檔案中的設定之後呼叫。

若要將 WM_WININICHANGE 訊息傳送至所有最上層視窗，應用程式可以使用 [SendMessage](/windows/win32/api/winuser/nf-winuser-sendmessage) windows 函式，並將 *hwnd* 參數設定為 HWND_BROADCAST。

如果應用程式同時變更 WIN.INI 中的許多不同區段，則應用程式應該傳送一個 WM_WININICHANGE 訊息，並將 *lpszSection* 設定為 Null。 否則，應用程式應該會在每次變更 WIN.INI 時傳送 WM_WININICHANGE。

如果應用程式收到 `OnWinIniChange` 呼叫，且 *lpszSection* 設定為 Null，則應用程式應該檢查 WIN.INI 中會影響應用程式的所有區段。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonwndmsg"></a><a name="onwndmsg"></a> CWnd：： OnWndMsg

呼叫這個成員函式時 `WindowProc` ，會在訊息反映期間呼叫這個成員函式。

```
virtual BOOL OnWndMsg(
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    LRESULT* pResult);
```

### <a name="parameters"></a>參數

*message*<br/>
指定要傳送的訊息。

*wParam*<br/>
指定其他訊息相關資訊。

*lParam*<br/>
指定其他訊息相關資訊。

*pResult*<br/>
[WindowProc](#windowproc)的傳回值。 相依于訊息;可能是 Null。

### <a name="return-value"></a>傳回值

如果已處理訊息，則為 TRUE;否則為 FALSE。

### <a name="remarks"></a>備註

`OnWndMsg` 決定訊息類型，並呼叫適當的架構函數 (例如，WM_COMMAND 的 [OnCommand](#oncommand)) 或在訊息對應中尋找適當的訊息。

如需訊息反映的詳細資訊，請參閱 [處理反映的訊息](../../mfc/handling-reflected-messages.md)。

## <a name="cwndonxbuttondblclk"></a><a name="onxbuttondblclk"></a> CWnd：： OnXButtonDblClk

當使用者按兩下 XBUTTON1 或 XBUTTON2，而游標位於視窗的工作區時，架構會呼叫這個成員函式。

```
afx_msg void OnXButtonDblClk(
    UINT nFlags,
    UINT nButton,
    CPoint point);
```

### <a name="parameters"></a>參數

*nFlags*\
在 () 或旗標的位合，表示所按下的輔助按鍵。 例如，MK_CONTROL 旗標表示按下 CTRL 鍵。

*nButton*\
在如果按兩下第一個 Microsoft 滑鼠按鍵 X 按鈕，則為 XBUTTON1 的值，如果按兩下第二個 X 按鈕則為 XBUTTON2。

*點*\
在 [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) 物件，指定相對於工作區左上角之游標的 *x* 和 *y* 座標。

### <a name="remarks"></a>備註

這個方法會接收 [WM_XBUTTONDBLCLK](/windows/win32/inputdev/wm-xbuttondblclk) 通知，如 Windows SDK 所述。 如果未捕捉到滑鼠，則會將訊息張貼到游標下的視窗。 否則，會將訊息張貼到已捕捉滑鼠的視窗。

*NFlags*參數可以是下表所列之輔助按鍵的組合。 如需詳細資訊，請參閱 [關於滑鼠輸入](/windows/win32/inputdev/about-mouse-input)。

|輔助按鍵|描述|
|------------------|-----------------|
|MK_CONTROL|按下 CTRL 鍵。|
|MK_LBUTTON|已按下滑鼠左鍵。|
|MK_MBUTTON|已按下滑鼠中間鍵。|
|MK_RBUTTON|已按下滑鼠右鍵。|
|MK_SHIFT|按下 SHIFT 鍵。|
|MK_XBUTTON1|已按下 Microsoft 滑鼠按鍵的 [XBUTTON1] 滑鼠按鍵。|
|MK_XBUTTON2|已按下 Microsoft 滑鼠按鍵的 [XBUTTON2] 滑鼠按鍵。|

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonxbuttondown"></a><a name="onxbuttondown"></a> CWnd：： OnXButtonDown

當使用者按下 XBUTTON1 或 XBUTTON2，而游標位於視窗的工作區時，架構會呼叫這個成員函式。

```
afx_msg void OnXButtonDown(
    UINT nFlags,
    UINT nButton,
    CPoint point);
```

### <a name="parameters"></a>參數

*nFlags*\
在 () 或旗標的位合，表示所按下的輔助按鍵。 例如，MK_CONTROL 旗標表示按下 CTRL 鍵。

*nButton*\
在如果按一下第一個 Microsoft 按鍵 X 按鈕，則為 XBUTTON1 的值，如果按一下第二個 X 按鈕則為 XBUTTON2。

*點*\
在 [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) 物件，指定相對於工作區左上角之游標的 *x* 和 *y* 座標。

### <a name="remarks"></a>備註

這個方法會接收 [WM_XBUTTONDOWN](/windows/win32/inputdev/wm-xbuttondown) 通知，如 Windows SDK 所述。 如果未捕捉到滑鼠，則會將訊息張貼到游標下的視窗。 否則，會將訊息張貼到已捕捉滑鼠的視窗。

*NFlags*參數可以是下表所列之輔助按鍵的組合。 如需詳細資訊，請參閱 [關於滑鼠輸入](/windows/win32/inputdev/about-mouse-input)。

|輔助按鍵|描述|
|------------------|-----------------|
|MK_CONTROL|按下 CTRL 鍵。|
|MK_LBUTTON|已按下滑鼠左鍵。|
|MK_MBUTTON|已按下滑鼠中間鍵。|
|MK_RBUTTON|已按下滑鼠右鍵。|
|MK_SHIFT|按下 SHIFT 鍵。|
|MK_XBUTTON1|已按下 Microsoft 滑鼠按鍵的 [XBUTTON1] 滑鼠按鍵。|
|MK_XBUTTON2|已按下 Microsoft 滑鼠按鍵的 [XBUTTON2] 滑鼠按鍵。|

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonxbuttonup"></a><a name="onxbuttonup"></a> CWnd：： OnXButtonUp

當使用者放開 XBUTTON1 或 XBUTTON2，而游標位於視窗的工作區時，架構會呼叫這個成員函式。

```
afx_msg void OnXButtonUp(
    UINT nFlags,
    UINT nButton,
    CPoint point);
```

### <a name="parameters"></a>參數

*nFlags*\
在 () 或旗標的位合，表示所按下的輔助按鍵。 例如，MK_CONTROL 旗標表示按下 CTRL 鍵。

*nButton*\
在如果按兩下第一個 Microsoft 滑鼠按鍵 X 按鈕，則為 XBUTTON1 的值，如果按兩下第二個 X 按鈕則為 XBUTTON2。

*點*\
在 [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) 物件，指定相對於工作區左上角之游標的 *x* 和 *y* 座標。

### <a name="remarks"></a>備註

這個方法會接收 [WM_XBUTTONUP](/windows/win32/inputdev/wm-xbuttonup) 通知，如 Windows SDK 所述。 如果未捕捉到滑鼠，則會將訊息張貼到游標下的視窗。 否則，會將訊息張貼到已捕捉滑鼠的視窗。

*NFlags*參數可以是下表所列之輔助按鍵的組合。 如需詳細資訊，請參閱 [關於滑鼠輸入](/windows/win32/inputdev/about-mouse-input)。

|輔助按鍵|描述|
|------------------|-----------------|
|MK_CONTROL|按下 CTRL 鍵。|
|MK_LBUTTON|已按下滑鼠左鍵。|
|MK_MBUTTON|已按下滑鼠中間鍵。|
|MK_RBUTTON|已按下滑鼠右鍵。|
|MK_SHIFT|按下 SHIFT 鍵。|
|MK_XBUTTON1|已按下 Microsoft 滑鼠按鍵的 [XBUTTON1] 滑鼠按鍵。|
|MK_XBUTTON2|已按下 Microsoft 滑鼠按鍵的 [XBUTTON2] 滑鼠按鍵。|

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndopenclipboard"></a><a name="openclipboard"></a> CWnd：： OpenClipboard

開啟剪貼簿。

```
BOOL OpenClipboard();
```

### <a name="return-value"></a>傳回值

如果透過開啟剪貼簿，則為非零 `CWnd` ，如果另一個應用程式或視窗開啟了剪貼簿，則為0。

### <a name="remarks"></a>備註

在呼叫 [CloseClipboard](/windows/win32/api/winuser/nf-winuser-closeclipboard) Windows 函數之前，其他應用程式將無法修改剪貼簿。

除非呼叫 EmptyClipboard Windows 函式，否則目前的 `CWnd` 物件將不[EmptyClipboard](/windows/win32/api/winuser/nf-winuser-emptyclipboard)會成為剪貼簿的擁有者。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#111](../../mfc/reference/codesnippet/cpp/cwnd-class_52.cpp)]

## <a name="cwndoperator-hwnd"></a><a name="operator_hwnd"></a> CWnd：： operator HWND

使用這個運算子來取得物件的控制碼 `CWnd` 。

```
operator HWND() const;
```

## <a name="cwndoperator-"></a><a name="operator_neq"></a> CWnd：： operator！ =

比較兩個 `CWnd` 物件，判斷它們是否沒有相同的 [m_hWnd](#m_hwnd)。

```
BOOL operator!=(const CWnd& wnd) const;
```

### <a name="parameters"></a>參數

*wnd<>*<br/>
`CWnd` 物件的參考。

### <a name="return-value"></a>傳回值

如果相等則為非零。否則為0。

## <a name="cwndoperator-"></a><a name="operator_eq_eq"></a> CWnd：： operator = =

比較兩個 `CWnd` 物件，以判斷它們是否具有相同的 [m_hWnd](#m_hwnd)。

```
BOOL operator==(const CWnd& wnd) const;
```

### <a name="parameters"></a>參數

*wnd<>*<br/>
`CWnd` 物件的參考。

### <a name="return-value"></a>傳回值

如果相等則為非零。否則為0。

## <a name="cwndpaintwindowlesscontrols"></a><a name="paintwindowlesscontrols"></a> CWnd：:P aintWindowlessControls

在控制項容器上繪製無視窗控制項。

```
BOOL PaintWindowlessControls(CDC* pDC);
```

### <a name="parameters"></a>參數

*Pdc*<br/>
要在其上繪製無視窗控制項的裝置內容。

### <a name="return-value"></a>傳回值

如果有控制項容器且已成功繪製無視窗控制項，則傳回 TRUE，否則傳回 FALSE。

## <a name="cwndpostmessage"></a><a name="postmessage"></a> CWnd：:P ostMessage

將訊息放在視窗的訊息佇列中，然後傳回，而不等候對應的視窗處理訊息。

```
BOOL PostMessage(
    UINT message,
    WPARAM wParam = 0,
    LPARAM lParam = 0);
```

### <a name="parameters"></a>參數

*message*<br/>
指定要張貼的訊息。

*wParam*<br/>
指定其他訊息資訊。 此參數的內容取決於張貼的訊息。

*lParam*<br/>
指定其他訊息資訊。 此參數的內容取決於張貼的訊息。

### <a name="return-value"></a>傳回值

如果已公佈訊息，則為非零。否則為0。

### <a name="remarks"></a>備註

訊息佇列中的訊息會透過呼叫 [GetMessage](/windows/win32/api/winuser/nf-winuser-getmessage) 或 [PeekMessage](/windows/win32/api/winuser/nf-winuser-peekmessagew) Windows 函數來抓取。

Windows [PostMessage](/windows/win32/api/winuser/nf-winuser-postmessagew) 函式可用於存取另一個應用程式。

### <a name="example"></a>範例

  請參閱 [AfxGetMainWnd](../../mfc/reference/application-information-and-management.md#afxgetmainwnd)的範例。

## <a name="cwndpostncdestroy"></a><a name="postncdestroy"></a> CWnd：:P ostNcDestroy

當視窗終結之後，由預設的 [OnNcDestroy](#onncdestroy) 成員函式所呼叫。

```
virtual void PostNcDestroy();
```

### <a name="remarks"></a>備註

衍生的類別可以使用此函式進行自訂清除，例如刪除 **`this`** 指標。

## <a name="cwndprecreatewindow"></a><a name="precreatewindow"></a> CWnd：:P reCreateWindow

在建立附加至此物件的 Windows 視窗之前，由架構呼叫 `CWnd` 。

```
virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
```

### <a name="parameters"></a>參數

*Cs*<br/>
[CREATESTRUCT](/windows/win32/api/winuser/ns-winuser-createstructw)結構。

### <a name="return-value"></a>傳回值

如果視窗建立應該繼續，則為非零;0表示建立失敗。

### <a name="remarks"></a>備註

> [!WARNING]
> `CWnd::PreCreateWindow`*cs* **`this`** 如果功能表是 Null，且樣式包含 WS_CHILD，現在會將 cs 的 hMenu 成員指派給指標。 如需適當的功能，請確定您的對話方塊控制項具有非 Null 的識別碼。
>
> 這項變更會修正 managed/原生 interop 案例中的損毀。 中的追蹤語句會 `CWnd::Create` 警示開發人員有問題。

請勿直接呼叫此函數。

此函式的預設執行會檢查是否有 Null 視窗類別名稱，並替代適當的預設值。 覆寫這個成員函式，以在 `CREATESTRUCT` 建立視窗之前修改結構。

衍生自的每個類別都會 `CWnd` 將本身的功能加入其覆寫中 `PreCreateWindow` 。 根據設計， `PreCreateWindow` 不會記錄這些衍生的。 若要判斷每個類別的適當樣式和樣式之間的相互相關性，您可以檢查應用程式基類的 MFC 原始程式碼。 如果您選擇覆寫 `PreCreateWindow,` ，可以使用從 MFC 原始程式碼收集而來的資訊，來判斷應用程式基類中使用的樣式是否提供您所需的功能。

如需變更視窗樣式的詳細資訊，請參閱 [變更 MFC 所建立之視窗的樣式](../../mfc/changing-the-styles-of-a-window-created-by-mfc.md)。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#112](../../mfc/reference/codesnippet/cpp/cwnd-class_53.cpp)]

## <a name="cwndpresubclasswindow"></a><a name="presubclasswindow"></a> CWnd：:P reSubclassWindow

架構會呼叫這個成員函式，以允許其他必要的子類別化在視窗子類別化之前發生。

```
virtual void PreSubclassWindow();
```

### <a name="remarks"></a>備註

覆寫這個成員函式可讓控制項的動態子類別化。 它是可覆寫的可覆寫。

## <a name="cwndpretranslatemessage"></a><a name="pretranslatemessage"></a> CWnd：:P reTranslateMessage

[CWinApp](../../mfc/reference/cwinapp-class.md) 類別用來轉譯分派至 [TranslateMessage](/windows/win32/api/winuser/nf-winuser-translatemessage) 和 [DispatchMessage](/windows/win32/api/winuser/nf-winuser-dispatchmessage) Windows 函式之前的視窗訊息。

```
virtual BOOL PreTranslateMessage(MSG* pMsg);
```

### <a name="parameters"></a>參數

*pMsg*<br/>
指向包含要處理之訊息的 [MSG](/windows/win32/api/winuser/ns-winuser-msg) 結構。

### <a name="return-value"></a>傳回值

如果訊息已轉譯且不應分派，則為非零;如果訊息未轉譯且應該分派，則為0。

## <a name="cwndprint"></a><a name="print"></a> CWnd：:P rint

呼叫此成員函式，以在指定的裝置內容中繪製目前的視窗，最常見的是在印表機裝置內容中。

```cpp
void Print(
    CDC* pDC,
    DWORD dwFlags) const;
```

### <a name="parameters"></a>參數

*Pdc*<br/>
裝置內容的指標。

*dwFlags*<br/>
指定繪圖選項。 此參數可以是下列其中一個或多個旗標：

- PRF_CHECKVISIBLE 只有在可見時，才會繪製視窗。

- PRF_CHILDREN 繪製所有可見的子系視窗。

- PRF_CLIENT 繪製視窗的工作區。

- PRF_ERASEBKGND 在繪製視窗之前清除背景。

- PRF_NONCLIENT 繪製視窗的非工作區。

- PRF_OWNED 繪製所有擁有的視窗。

### <a name="remarks"></a>備註

[CWnd：:D efwindowproc](#defwindowproc) 函數會根據指定的繪圖選項來處理此訊息：

- 如果指定了 PRF_CHECKVISIBLE 且視窗不可見，就不會執行任何動作。

- 如果指定 PRF_NONCLIENT，請在指定的裝置內容中繪製非工作區。

- 如果指定 PRF_ERASEBKGND，請將 [WM_ERASEBKGND](/windows/win32/winmsg/wm-erasebkgnd) 訊息傳送給視窗。

- 如果指定 PRF_CLIENT，請將 [WM_PRINTCLIENT](/windows/win32/gdi/wm-printclient) 訊息傳送給視窗。

- 如果設定 PRF_CHILDREN，請將 [WM_PRINT](/windows/win32/gdi/wm-print) 訊息傳送給每個可見的子視窗。

- 如果設定 PRF_OWNED，請將 WM_PRINT 訊息傳送給每個可見的擁有視窗。

## <a name="cwndprintclient"></a><a name="printclient"></a> CWnd：:P rintClient

呼叫此成員函式以在指定的裝置內容中繪製任何視窗 (通常是印表機裝置內容) 。

```cpp
void PrintClient(
    CDC* pDC,
    DWORD dwFlags) const;
```

### <a name="parameters"></a>參數

*Pdc*<br/>
裝置內容的指標。

*dwFlags*<br/>
指定繪製選項。 此參數可以是下列其中一個或多個旗標：

- PRF_CHECKVISIBLE 只有在可見時，才會繪製視窗。

- PRF_CHILDREN 繪製所有可見的子系視窗。

- PRF_CLIENT 繪製視窗的工作區。

- PRF_ERASEBKGND 在繪製視窗之前清除背景。

- PRF_NONCLIENT 繪製視窗的非工作區。

- PRF_OWNED 繪製所有擁有的視窗。

## <a name="cwndprintwindow"></a><a name="printwindow"></a> CWnd：:P rintWindow

將視覺視窗複製到指定的裝置內容，通常是印表機 DC。

```
BOOL PrintWindow(
    CDC* pDC,
    UINT nFlags) const;
```

### <a name="parameters"></a>參數

*Pdc*<br/>
要列印到之裝置內容的指標。

*nFlags*<br/>
指定繪圖選項。 如需可能值的清單，請參閱 [PrintWindow](/windows/win32/api/winuser/nf-winuser-printwindow)。

### <a name="return-value"></a>傳回值

如果函式成功則為非零值，否則為 0。

### <a name="remarks"></a>備註

此成員函式會模擬函數 [PrintWindow](/windows/win32/api/winuser/nf-winuser-printwindow)的功能，如 Windows SDK 所述。

## <a name="cwndredrawwindow"></a><a name="redrawwindow"></a> CWnd：： RedrawWindow

在給定視窗的工作區中，更新指定的矩形或區域。

```
BOOL RedrawWindow(
    LPCRECT lpRectUpdate = NULL,
    CRgn* prgnUpdate = NULL,
    UINT flags = RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE);
```

### <a name="parameters"></a>參數

*lpRectUpdate*<br/>
指向包含更新矩形座標的 [矩形結構](/windows/win32/api/windef/ns-windef-rect) 。 如果 *prgnUpdate* 包含有效的區域控制碼，就會忽略這個參數。

*prgnUpdate*<br/>
識別更新區域。 如果 *prgnUpdate* 和 *LPRECTUPDATE* 都是 Null，則會將整個工作區加入至更新區域。

*flags*<br/>
下列旗標可用來讓視窗失效：

- RDW_ERASE 會導致視窗在重新繪製視窗時接收 [WM_ERASEBKGND](/windows/win32/winmsg/wm-erasebkgnd) 訊息。 您也必須指定 RDW_INVALIDATE 旗標;否則 RDW_ERASE 不會有任何作用。

- RDW_FRAME 會導致視窗中非工作區的任何部分與更新區域相交，以接收 [WM_NCPAINT](/windows/win32/gdi/wm-ncpaint) 訊息。 您也必須指定 RDW_INVALIDATE 旗標;否則 RDW_FRAME 不會有任何作用。

- 無論視窗是否包含不正確區域，RDW_INTERNALPAINT 都會將 [WM_PAINT](/windows/win32/gdi/wm-paint) 訊息張貼至視窗。

- RDW_INVALIDATE 使 *lpRectUpdate* 或 *prgnUpdate* 無效 () 不可以是 Null。 如果兩者都是 Null，則整個視窗會失效。

下列旗標用來驗證視窗：

- RDW_NOERASE 隱藏任何擱置中的 WM_ERASEBKGND 訊息。

- RDW_NOFRAME 隱藏任何擱置中的 WM_NCPAINT 訊息。 此旗標必須搭配 RDW_VALIDATE 使用，且通常與 RDW_NOCHILDREN 搭配使用。 此選項應謹慎使用，因為它可以防止視窗的部分正確繪製。

- RDW_NOINTERNALPAINT 隱藏任何擱置中的內部 WM_PAINT 訊息。 此旗標不會影響無效區域所產生的 WM_PAINT 訊息。

- RDW_VALIDATE 會驗證 *lpRectUpdate* 或 *prgnUpdate* (一個) 不可以是 Null。 如果兩者都是 Null，則會驗證整個視窗。 此旗標不會影響內部 WM_PAINT 的訊息。

下列旗標會控制何時發生重新繪製。 `RedrawWindow`除非指定了其中一個位，否則函數不會執行繪製。

- RDW_ERASENOW 會導致 RDW_ALLCHILDREN 和 RDW_NOCHILDREN 旗標所指定的受影響 windows (在函式傳回之前，視需要接收) 和 WM_NCPAINT 訊息。 WM_PAINT 的訊息會延後。

- RDW_UPDATENOW 會導致 RDW_ALLCHILDREN 和 RDW_NOCHILDREN 旗標所指定的受影響 windows (在函式傳回之前，如有必要，) 接收 WM_NCPAINT、WM_ERASEBKGND 和 WM_PAINT 訊息。

根據預設，受函式影響的 windows 會 `RedrawWindow` 根據指定的視窗是否有 WS_CLIPCHILDREN 樣式而定。 WS_CLIPCHILDREN 視窗的子視窗不會受到影響。 不過，在遇到 WS_CLIPCHILDREN 視窗之前，不 WS_CLIPCHILDREN 視窗的視窗會以遞迴方式進行驗證或失效。 下列旗標控制哪些視窗受函式影響 `RedrawWindow` ：

- RDW_ALLCHILDREN 包含重畫作業中的子視窗（如果有的話）。

- RDW_NOCHILDREN 從重新繪製作業中排除子視窗（如果有的話）。

### <a name="return-value"></a>傳回值

如果視窗已成功重繪，則為非零;否則為0。

### <a name="remarks"></a>備註

當成員函式 `RedrawWindow` 用來使部分的桌面視窗失效時，該視窗不會收到 [WM_PAINT](/windows/win32/gdi/wm-paint) 的訊息。 若要重新繪製桌面，應用程式應該使用 [cwnd：： ValidateRgn](#validatergn)、 [Cwnd：： InvalidateRgn](#invalidatergn)、 [CWnd：： UpdateWindow](#updatewindow)或 [RedrawWindow](/windows/win32/api/winuser/nf-winuser-redrawwindow)

## <a name="cwndreflectchildnotify"></a><a name="reflectchildnotify"></a> CWnd：： ReflectChildNotify

此訊息函式是由 [OnChildNotify](#onchildnotify)中的架構所呼叫。

```
BOOL ReflectChildNotify(
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    LRESULT* pResult);
```

### <a name="parameters"></a>參數

*message*<br/>
指定要反映的訊息。

*wParam*<br/>
指定其他訊息相關資訊。

*lParam*<br/>
指定其他訊息相關資訊。

*pResult*<br/>
父視窗要傳回的子視窗所產生的結果。 可以是 NULL。

### <a name="return-value"></a>傳回值

如果訊息已反映，則為 TRUE;否則為 FALSE。

### <a name="remarks"></a>備註

它是反映 *訊息* 至其來源的 helper 函式。

反映的訊息會直接傳送至 [CWnd：： OnWndMsg](#onwndmsg) 或 [CCmdTarget：： OnCmdMsg](../../mfc/reference/ccmdtarget-class.md#oncmdmsg)。

如需訊息反映的詳細資訊，請參閱 [處理反映的訊息](../../mfc/handling-reflected-messages.md)。

## <a name="cwndreflectlastmsg"></a><a name="reflectlastmsg"></a> CWnd：： ReflectLastMsg

架構會呼叫這個成員函式，以反映子視窗的最後一個訊息。

```
static BOOL PASCAL ReflectLastMsg(
    HWND hWndChild,
    LRESULT* pResult = NULL);
```

### <a name="parameters"></a>參數

*hWndChild*<br/>
子視窗的控制碼。

*pResult*<br/>
父視窗要傳回的子視窗所產生的結果。 可以是 NULL。

### <a name="return-value"></a>傳回值

如果已處理訊息，則為非零。否則為0。

### <a name="remarks"></a>備註

如果*hWndChild*所識別的視窗是 OLE 控制項或永久對應中的視窗，此成員函式會呼叫[SendChildNotifyLastMsg](#sendchildnotifylastmsg) 。

如需訊息反映的詳細資訊，請參閱 [處理反映的訊息](../../mfc/handling-reflected-messages.md)。

## <a name="cwndreleasedc"></a><a name="releasedc"></a> CWnd：： ReleaseDC

釋放裝置內容，釋出以供其他應用程式使用。

```
int ReleaseDC(CDC* pDC);
```

### <a name="parameters"></a>參數

*Pdc*<br/>
識別要釋放的裝置內容。

### <a name="return-value"></a>傳回值

如果成功則為非零；否則為 0。

### <a name="remarks"></a>備註

成員函式的效果 `ReleaseDC` 取決於裝置內容類型。

應用程式必須 `ReleaseDC` 針對每個對 [GetWindowDC](#getwindowdc) 成員函式的呼叫，以及對 [GetDC](#getdc) 成員函式的每個呼叫呼叫成員函式。

## <a name="cwndrepositionbars"></a><a name="repositionbars"></a> CWnd：： RepositionBars

呼叫以在視窗的工作區中重新調整控制列的位置並調整其大小。

```cpp
void RepositionBars(UINT nIDFirst,
    UINT nIDLast,
    UINT nIDLeftOver,
    UINT nFlag = reposDefault,
    LPRECT lpRectParam = NULL,
    LPCRECT lpRectClient = NULL,
    BOOL bStretch = TRUE) ;
```

### <a name="parameters"></a>參數

*nIDFirst*<br/>
要重新置放和調整大小之控制列範圍中第一個的識別碼。

*nIDLast*<br/>
要重新置放和調整大小的控制列範圍中，最後一個的識別碼。

*nIDLeftOver*<br/>
指定填滿工作區其餘部分的窗格識別碼。

*nFlag*<br/>
可以具有下列其中一個值：

- `CWnd::reposDefault` 執行控制列的版面配置。 *lpRectParam* 不會使用，而且可以是 Null。

- `CWnd::reposQuery` 控制列的版面配置尚未完成;相反地， *lpRectParam* 是以工作區的大小來初始化，如同配置真的已完成。

- `CWnd::reposExtra` 將 *lpRectParam* 的值加入至 *nIDLast* 的工作區，也會執行版面配置。

*lpRectParam*<br/>
指向 [RECT 結構](/windows/win32/api/windef/ns-windef-rect);的使用方式取決於 *nFlag*的值。

*lpRectClient*<br/>
指向包含可用工作區的 [矩形結構](/windows/win32/api/windef/ns-windef-rect) 。 如果是 Null，則會使用視窗的工作區。

*bStretch*<br/>
指出是否應該將橫條延伸至框架的大小。

### <a name="remarks"></a>備註

*NIDFirst*和*nIDLast*參數會定義要在工作區中重新置放的一系列控制列識別碼。 *NIDLeftOver*參數會指定子視窗的識別碼 (通常是重新置放和調整大小的視圖) ，以填滿未填滿控制列的其他工作區。

## <a name="cwndrunmodalloop"></a><a name="runmodalloop"></a> CWnd：： RunModalLoop

呼叫此成員函式以抓取、轉譯或分派訊息，直到 [ContinueModal](#continuemodal) 傳回 FALSE 為止。

```
int RunModalLoop(DWORD dwFlags = 0);
```

### <a name="parameters"></a>參數

*dwFlags*<br/>
指定要傳送的 Windows 訊息。 可以是下列值之一：

- MLF_NOIDLEMSG 不會將 [WM_ENTERIDLE](/windows/win32/dlgbox/wm-enteridle) 訊息傳送至父代。

- MLF_NOKICKIDLE 不會將 WM_KICKIDLE 訊息傳送至視窗。

- 當訊息佇列變成閒置時，MLF_SHOWONIDLE 顯示視窗。

### <a name="return-value"></a>傳回值

指定傳遞至[EndModalLoop](#endmodalloop)成員函式的*n 結果*參數值，然後用來結束強制回應迴圈。

### <a name="remarks"></a>備註

根據預設， `ContinueModal` 在呼叫之後，會傳回 FALSE `EndModalLoop` 。 傳回做為 *n 結果* 提供的值 `EndModalLoop` 。

## <a name="cwndscreentoclient"></a><a name="screentoclient"></a> CWnd：： ScreenToClient

將畫面上指定的點或矩形的螢幕座標，轉換為用戶端座標。

```cpp
void ScreenToClient(LPPOINT lpPoint) const;  void ScreenToClient(LPRECT lpRect) const;
```

### <a name="parameters"></a>參數

*lpPoint*<br/>
指向包含要轉換之螢幕座標的 [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) 物件或 [點結構](/windows/win32/api/windef/ns-windef-point) 。

*lpRect*<br/>
指向包含要轉換之螢幕座標的 [CRect](../../atl-mfc-shared/reference/crect-class.md) 物件或 [RECT 結構](/windows/win32/api/windef/ns-windef-rect) 。

### <a name="remarks"></a>備註

成員函式會 `ScreenToClient` 以用戶端座標取代 *LpPoint* 或 *lpRect* 中提供的螢幕座標。 新座標是相對於工作區的左上角 `CWnd` 。

### <a name="example"></a>範例

  請參閱 [CListCtrl：： GetItemRect](../../mfc/reference/clistctrl-class.md#getitemrect)的範例。

## <a name="cwndscrollwindow"></a><a name="scrollwindow"></a> CWnd：： ScrollWindow

滾動目前物件的工作區內容 `CWnd` 。

```cpp
void ScrollWindow(
    int xAmount,
    int yAmount,
    LPCRECT lpRect = NULL,
    LPCRECT lpClipRect = NULL);
```

### <a name="parameters"></a>參數

*xAmount*<br/>
指定水準滾動的數量（以裝置單位為單位）。 此參數必須是負數值，才能向左移動。

*yAmount*<br/>
指定垂直捲動的數量（以裝置單位為單位）。 此參數必須是負數值，才能向上滾動。

*lpRect*<br/>
指向 [CRect](../../atl-mfc-shared/reference/crect-class.md) 物件或 [RECT 結構](/windows/win32/api/windef/ns-windef-rect) ，指定要滾動之工作區的部分。 如果 *lpRect* 為 Null，則會滾動整個工作區。 如果游標矩形與捲軸矩形相交，則會重新置放插入號。

*lpClipRect*<br/>
指向 `CRect` 物件或 `RECT` 結構，指定要滾動的剪切矩形。 只有這個矩形內的位會滾動。 即使在 *lpRect* 矩形中，也不會影響此矩形以外的位數。 如果 *lpClipRect* 為 Null，則不會在捲軸矩形上執行裁剪。

### <a name="remarks"></a>備註

如果插入點位於 `CWnd` 正在進行滾動的，則 `ScrollWindow` 會自動隱藏插入號以防止其被清除，然後在捲軸完成之後還原插入號。 插入號位置會據以調整。

成員函式所發現的區域 `ScrollWindow` 不會重新繪製，而會合並到目前 `CWnd` 物件的更新區域中。 應用程式最終會收到 [WM_PAINT](/windows/win32/gdi/wm-paint) 訊息，通知該區域需要重新繪製。 若要在滾動完成時重新繪製未發現的區域，請在呼叫之後立即呼叫 [UpdateWindow](#updatewindow) 成員函式 `ScrollWindow` 。

如果 *lpRect* 為 Null，則視窗中任何子視窗的位置會以 *xAmount* 和 *yAmount*所指定的數量來位移，且中任何不正確 (未) 區域 `CWnd` 也會位移。 `ScrollWindow` 當 *lpRect* 為 Null 時，會更快。

如果 *lpRect* 不是 Null，則不會變更子視窗的位置，且中的無效區域 `CWnd` 不會位移。 若要避免在 *lpRect* 不是 Null 時更新問題，請在 `UpdateWindow` 呼叫之前呼叫成員函式以重新繪製 `CWnd` `ScrollWindow` 。

## <a name="cwndscrollwindowex"></a><a name="scrollwindowex"></a> CWnd：： ScrollWindowEx

滾動視窗工作區的內容。

```
int ScrollWindowEx(
    int dx,
    int dy,
    LPCRECT lpRectScroll,
    LPCRECT lpRectClip,
    CRgn* prgnUpdate,
    LPRECT lpRectUpdate,
    UINT flags);
```

### <a name="parameters"></a>參數

*Dx*<br/>
指定水準滾動的數量（以裝置單位為單位）。 此參數必須有負數值，才能向左移動。

*Dy*<br/>
指定垂直捲動的數量（以裝置單位為單位）。 此參數的值必須是負值才能向上滾動。

*lpRectScroll*<br/>
指向指定要滾動之工作區部分的 [矩形結構](/windows/win32/api/windef/ns-windef-rect) 。 如果此參數為 Null，則會滾動整個工作區。

*lpRectClip*<br/>
指向 `RECT` 結構，指定要滾動的剪切矩形。 此結構優先于 *lpRectScroll*所指向的矩形。 只有這個矩形內的位會滾動。 即使在 *lpRectScroll* 矩形中，也不會影響此矩形以外的位數。 如果這個參數為 Null，則不會在捲軸矩形上執行裁剪。

*prgnUpdate*<br/>
識別為了保存區域而修改的區域（藉由滾動而使其失效）。 此參數可能是 NULL。

*lpRectUpdate*<br/>
指向 `RECT` 結構，此結構將會藉由滾動來接收矩形的界限。 此參數可能是 NULL。

*flags*<br/>
可以具有下列其中一個值：

- 使用 SW_INVALIDATE 指定 SW_ERASE 時，會將 [WM_ERASEBKGND](/windows/win32/winmsg/wm-erasebkgnd) 訊息傳送至視窗，以清除新的無效區域。

- SW_INVALIDATE 在滾動之後使 *prgnUpdate* 所識別的區域失效。

- SW_SCROLLCHILDREN 會以*dx*和*dy*中指定的圖元數*lpRectScroll* ，將與所指向之矩形相交的所有子視窗都滾動。 Windows 會將 [WM_MOVE](/windows/win32/winmsg/wm-move) 訊息傳送至所有與 *lpRectScroll*相交的子視窗，即使它們沒有移動也一樣。 當子視窗滾動時，插入號會重新置放，且游標矩形與捲軸矩形相交。

### <a name="return-value"></a>傳回值

傳回值是 SIMPLEREGION (矩形不正確區域) 、COMPLEXREGION (非矩形的無效區域;如果函式成功，則重迭的矩形) 或 NullREGION (沒有不正確區域) 否則傳回值為 ERROR。

### <a name="remarks"></a>備註

此函式類似于 [ScrollWindow](/windows/win32/api/winuser/nf-winuser-scrollwindow) 函式，還有一些額外的功能。

如果未指定 [SW_INVALIDATE](/windows/win32/api/winuser/nf-winuser-scrollwindowex) 和 [SW_ERASE](/windows/win32/api/winuser/nf-winuser-scrollwindowex) ，成員函式 `ScrollWindowEx` 就不會使滾動的區域失效。 如果設定了其中一個旗標，則會 `ScrollWindowEx` 使此區域失效。 在應用程式呼叫 [UpdateWindow](/windows/win32/api/winuser/nf-winuser-updatewindow) 成員函式之前，不會更新區域、呼叫 [RedrawWindow](/windows/win32/api/winuser/nf-winuser-redrawwindow) 成員函式 (指定 [RDW_UPDATENOW](/windows/win32/api/winuser/nf-winuser-redrawwindow) 或 [RDW_ERASENOW](/windows/win32/api/winuser/nf-winuser-redrawwindow)) ，或從應用程式佇列中抓取 [WM_PAINT](/windows/win32/gdi/wm-paint) 訊息。

如果視窗有 [WS_CLIPCHILDREN](/windows/win32/api/winuser/nf-winuser-createwindoww) 的樣式，則 *prgnUpdate* 和 *lpRectUpdate* 指定的傳回區域代表必須更新之滾動視窗的總區域，包括需要更新之子視窗中的任何區域。

如果指定了 [SW_SCROLLCHILDREN](/windows/win32/api/winuser/nf-winuser-scrollwindowex) 旗標，則 Windows 將無法在部分子視窗滾動時正確地更新畫面。 位於來源矩形外的滾動子視窗的部分將不會被清除，也不會在其新的目的地中正確地重新繪製。 使用 [DeferWindowPos](/windows/win32/api/winuser/nf-winuser-deferwindowpos) Windows 函式來移動不完全位於 *lpRectScroll* 矩形內的子視窗。 如果設定了 SW_SCROLLCHILDREN 旗標，且插入號矩形與捲軸矩形相交，則會重新置放游標。

*LpRectScroll*、 *lpRectClip*、 *lpRectUpdate*和*prgnUpdate*) 的所有輸入和輸出座標 (都會假設在用戶端座標中，不論視窗是否有 CS_OWNDC 或 CS_CLASSDC 類別樣式。 如有必要，請使用 [LPtoDP](/windows/win32/api/wingdi/nf-wingdi-lptodp) 和 [DPtoLP](/windows/win32/api/wingdi/nf-wingdi-dptolp) Windows 函式，在邏輯座標之間進行轉換。

## <a name="cwndsendchildnotifylastmsg"></a><a name="sendchildnotifylastmsg"></a> CWnd：： SendChildNotifyLastMsg

架構會呼叫這個成員函式，從父視窗提供通知訊息給子視窗，讓子視窗可以處理工作。

```
BOOL SendChildNotifyLastMsg(LRESULT* pResult = NULL);
```

### <a name="parameters"></a>參數

*pResult*<br/>
父視窗要傳回的子視窗所產生的結果。

### <a name="return-value"></a>傳回值

如果子視窗已處理傳送至其父系的訊息，則為非零。否則為0。

### <a name="remarks"></a>備註

`SendChildNotifyLastMsg` 如果訊息是反映的訊息，請將目前的訊息傳送至來源。

如需訊息反映的詳細資訊，請參閱 [處理反映的訊息](../../mfc/handling-reflected-messages.md)。

## <a name="cwndsenddlgitemmessage"></a><a name="senddlgitemmessage"></a> CWnd：： SendDlgItemMessage

將訊息傳送至控制項。

```
LRESULT SendDlgItemMessage(
    int nID,
    UINT message,
    WPARAM wParam = 0,
    LPARAM lParam = 0);
```

### <a name="parameters"></a>參數

*nID*<br/>
指定將接收訊息之對話方塊控制項的識別碼。

*message*<br/>
指定要傳送的訊息。

*wParam*<br/>
指定其他訊息相關資訊。

*lParam*<br/>
指定其他訊息相關資訊。

### <a name="return-value"></a>傳回值

指定控制項的視窗程式所傳回的值，如果找不到控制項，則為0。

### <a name="remarks"></a>備註

在 `SendDlgItemMessage` 處理訊息之前，不會傳回成員函式。

使用與 `SendDlgItemMessage` 取得 `CWnd` 指定控制項的 * 以及呼叫 [SendMessage](#sendmessage) 成員函式完全相同。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#113](../../mfc/reference/codesnippet/cpp/cwnd-class_54.cpp)]

## <a name="cwndsendmessage"></a><a name="sendmessage"></a> CWnd：： SendMessage

將指定的訊息傳送至此視窗。

```
LRESULT SendMessage(
    UINT message,
    WPARAM wParam = 0,
    LPARAM lParam = 0);
```

### <a name="parameters"></a>參數

*message*<br/>
指定要傳送的訊息。

*wParam*<br/>
指定其他訊息相關資訊。

*lParam*<br/>
指定其他訊息相關資訊。

### <a name="return-value"></a>傳回值

訊息處理的結果;它的值取決於傳送的訊息。

### <a name="remarks"></a>備註

成員函式 `SendMessage` 會直接呼叫視窗程式，直到該視窗程式處理訊息為止。 這與 [PostMessage](#postmessage) 成員函式相反，它會將訊息放入視窗的訊息佇列，並立即傳回。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#101](../../mfc/reference/codesnippet/cpp/cwnd-class_41.cpp)]

## <a name="cwndsendmessagetodescendants"></a><a name="sendmessagetodescendants"></a> CWnd：： SendMessageToDescendants

呼叫此成員函式，將指定的 Windows 訊息傳送至所有子系視窗。

```cpp
void SendMessageToDescendants(
    UINT message,
    WPARAM wParam = 0,
    LPARAM lParam = 0,
    BOOL bDeep = TRUE,
    BOOL bOnlyPerm = FALSE);
```

### <a name="parameters"></a>參數

*message*<br/>
指定要傳送的訊息。

*wParam*<br/>
指定其他訊息相關資訊。

*lParam*<br/>
指定其他訊息相關資訊。

*bDeep*<br/>
指定要搜尋的層級。 若為 TRUE，則以遞迴方式搜尋所有子系;如果為 FALSE，則只搜尋直屬子系。

*bOnlyPerm*<br/>
指定訊息是否會由暫存視窗接收。 若為 TRUE，則暫存視窗可以接收訊息;如果為 FALSE，則只有永久視窗會接收訊息。 如需有關暫存視窗的詳細資訊，請參閱 [技術提示 3](../../mfc/tn003-mapping-of-windows-handles-to-objects.md)。

### <a name="remarks"></a>備註

如果 *bDeep* 為 FALSE，則訊息只會傳送至視窗的直屬子系;否則，訊息會傳送至所有子系視窗。

如果 *bDeep* 和 *BONLYPERM* 都是 TRUE，則搜尋會繼續在暫存視窗底下。 在此情況下，只有在搜尋期間遇到的永久 windows 才會接收訊息。 如果 *bDeep* 為 FALSE，則訊息只會傳送至視窗的直屬子系。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#114](../../mfc/reference/codesnippet/cpp/cwnd-class_55.cpp)]

## <a name="cwndsendnotifymessage"></a><a name="sendnotifymessage"></a> CWnd：： SendNotifyMessage

將指定的訊息傳送至視窗。

```
BOOL SendNotifyMessage(
    UINT message,
    WPARAM wParam,
    LPARAM lParam);
```

### <a name="parameters"></a>參數

*message*<br/>
指定要傳送的訊息。

*wParam*<br/>
指定其他訊息相關資訊。

*lParam*<br/>
指定其他訊息相關資訊。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

如果視窗是由呼叫執行緒所建立，則 `SendNotifyMessage` 會呼叫視窗的視窗程式，且在視窗程式處理訊息之前不會傳回。 如果視窗是由不同的執行緒所建立，則 `SendNotifyMessage` 會將訊息傳遞至視窗程式並立即傳回，不會等待視窗程式完成處理訊息。

## <a name="cwndsetactivewindow"></a><a name="setactivewindow"></a> CWnd：： SetActiveWindow

建立 `CWnd` 使用中視窗。

```
CWnd* SetActiveWindow();
```

### <a name="return-value"></a>傳回值

先前作用中的視窗。

傳回的指標可能是暫時性的，不應儲存供稍後使用。

### <a name="remarks"></a>備註

`SetActiveWindow`成員函式應謹慎使用，因為它可讓應用程式任意接管使用中視窗和輸入焦點。 一般來說，Windows 會負責所有啟用。

## <a name="cwndsetcapture"></a><a name="setcapture"></a> CWnd：： SetCapture

無論游標的位置為何，都會將所有後續的滑鼠輸入傳送至目前的 `CWnd` 物件。

```
CWnd* SetCapture();
```

### <a name="return-value"></a>傳回值

先前接收所有滑鼠輸入的視窗物件指標。 如果沒有這類視窗，則為 Null。 傳回的指標可能是暫時性的，不應儲存供稍後使用。

### <a name="remarks"></a>備註

當 `CWnd` 不再需要所有滑鼠輸入時，應用程式應該呼叫 [ReleaseCapture](/windows/win32/api/winuser/nf-winuser-releasecapture) 函式，讓其他視窗可以接收滑鼠輸入。

當系統捕捉到滑鼠輸入時，不會 WM_NCHITTEST 或 WM_SETCURSOR 的訊息傳送至使用中視窗。

## <a name="cwndsetcaretpos"></a><a name="setcaretpos"></a> CWnd：： SetCaretPos

設定插入號的位置。

```
static void PASCAL SetCaretPos(POINT point);
```

### <a name="parameters"></a>參數

*點*<br/>
指定新的 x 和 y 座標 (在) 插入號的用戶端座標中。

### <a name="remarks"></a>備註

成員函式 `SetCaretPos` 只有在目前工作中的視窗擁有時，才會移動插入號。 `SetCaretPos` 移動插入號是否隱藏插入號。

插入號是共用的資源。 如果不擁有插入號，則視窗不應移動插入號。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#115](../../mfc/reference/codesnippet/cpp/cwnd-class_56.cpp)]

## <a name="cwndsetclipboardviewer"></a><a name="setclipboardviewer"></a> CWnd：： SetClipboardViewer

將此視窗新增至視窗鏈，這些視窗會在每次剪貼簿的內容變更時，透過 WM_DRAWCLIPBOARD 訊息) 通知 (。

```
HWND SetClipboardViewer();
```

### <a name="return-value"></a>傳回值

如果成功，則為剪貼簿檢視器鏈中下一個視窗的控制碼。 應用程式應該將此控制碼儲存 (它可以儲存為成員變數) ，並在回應剪貼簿-檢視器鏈訊息時使用。

### <a name="remarks"></a>備註

屬於剪貼簿-檢視器鏈一部分的視窗必須回應 [WM_DRAWCLIPBOARD](#ondrawclipboard)、 [WM_CHANGECBCHAIN](#onchangecbchain)和 [WM_DESTROY](#ondestroy) 的訊息，並將訊息傳遞至鏈中的下一個視窗。

此成員函式會將 WM_DRAWCLIPBOARD 訊息傳送至視窗。 由於尚未傳回剪貼簿-檢視器鏈中下一個視窗的控制碼，因此應用程式不應該傳遞在呼叫期間收到的 WM_DRAWCLIPBOARD 訊息 `SetClipboardViewer` 。

若要從剪貼簿-檢視器鏈中移除自己的，應用程式必須呼叫 [ChangeClipboardChain](#changeclipboardchain) 成員函式。

## <a name="cwndsetdlgctrlid"></a><a name="setdlgctrlid"></a> CWnd：： SetDlgCtrlID

將視窗的視窗識別碼或控制項識別碼設定為新的值。

```
int SetDlgCtrlID(int nID);
```

### <a name="parameters"></a>參數

*nID*<br/>
要為控制項的識別碼設定的新值。

### <a name="return-value"></a>傳回值

如果成功，則為視窗的先前識別碼;否則為0。

### <a name="remarks"></a>備註

視窗可以是任何子視窗，而不只是對話方塊中的控制項。 視窗不可以是最上層視窗。

## <a name="cwndsetdlgitemint"></a><a name="setdlgitemint"></a> CWnd：： SetDlgItemInt

將對話方塊中指定之控制項的文字，設定為指定之整數值的字串表示。

```cpp
void SetDlgItemInt(
    int nID,
    UINT nValue,
    BOOL bSigned = TRUE);
```

### <a name="parameters"></a>參數

*nID*<br/>
指定要變更之控制項的整數識別碼。

*N 值*<br/>
指定用來產生專案文字的整數值。

*bSigned*<br/>
指定整數值是否為帶正負號或不帶正負號。 如果此參數為 TRUE，則 *n 值* 會簽署。 如果此參數為 TRUE，且 *n 值* 小於0，則會在字串中的第一個數位之前放置減號。 如果此參數為 FALSE，則 *n 值* 不帶正負號。

### <a name="remarks"></a>備註

`SetDlgItemInt` 將 [WM_SETTEXT](/windows/win32/winmsg/wm-settext) 訊息傳送至指定的控制項。

### <a name="example"></a>範例

  請參閱 [CWnd：： SetDlgItemText](#setdlgitemtext)的範例。

## <a name="cwndsetdlgitemtext"></a><a name="setdlgitemtext"></a> CWnd：： SetDlgItemText

設定視窗或對話方塊所擁有之控制項的標題或文字。

```cpp
void SetDlgItemText(
    int nID,
    LPCTSTR lpszString);
```

### <a name="parameters"></a>參數

*nID*<br/>
識別要設定其文字的控制項。

*lpszString*<br/>
指向 [CString](../../atl-mfc-shared/reference/cstringt-class.md) 物件或以 null 終止的字串，其中包含要複製到控制項的文字。

### <a name="remarks"></a>備註

`SetDlgItemText` 將 [WM_SETTEXT](/windows/win32/winmsg/wm-settext) 訊息傳送至指定的控制項。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#116](../../mfc/reference/codesnippet/cpp/cwnd-class_57.cpp)]

## <a name="cwndsetforegroundwindow"></a><a name="setforegroundwindow"></a> CWnd：： SetForegroundWindow

將建立視窗的執行緒放置到前景並啟動視窗。

```
BOOL SetForegroundWindow();
```

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

鍵盤輸入會導向至視窗，而使用者會變更各種視覺提示。 前景視窗是使用者目前正在使用的視窗。 前景視窗只適用于) 的最上層 windows (框架視窗或對話方塊。

### <a name="example"></a>範例

  請參閱 [CWnd：： FindWindow](#findwindow)的範例。

## <a name="cwndsetfocus"></a><a name="setfocus"></a> CWnd：： SetFocus

宣告輸入焦點。

```
CWnd* SetFocus();
```

### <a name="return-value"></a>傳回值

先前具有輸入焦點之視窗物件的指標。 如果沒有這類視窗，則為 Null。 傳回的指標可能是暫時性的，不應該儲存。

### <a name="remarks"></a>備註

輸入焦點會將所有後續的鍵盤輸入導向至此視窗。 任何先前具有輸入焦點的視窗都會失去它。

成員函式 `SetFocus` 會將 [WM_KILLFOCUS](/windows/win32/inputdev/wm-killfocus) 訊息傳送至遺失輸入焦點的視窗，以及接收輸入焦點之視窗的 [WM_SETFOCUS](/windows/win32/inputdev/wm-setfocus) 訊息。 它也會啟用視窗或其父代。

如果目前的視窗為使用中，但沒有焦點 (也就是沒有焦點) ，任何按下的按鍵都會產生 [WM_SYSCHAR](#onsyschar)、 [WM_SYSKEYDOWN](#onsyskeydown)或 [WM_SYSKEYUP](#onsyskeyup)的訊息。

## <a name="cwndsetfont"></a><a name="setfont"></a> CWnd：： SetFont

將 WM_SETFONT 訊息傳送至視窗，以使用指定的字型。

```cpp
void SetFont(
    CFont* pFont,
    BOOL bRedraw = TRUE);
```

### <a name="parameters"></a>參數

*pFont*<br/>
指向 `CFont` 物件的指標。

*bRedraw*<br/>
若為 TRUE，表示視窗在處理 WM_SETFONT 訊息之後立即重新繪製;否則為 FALSE。

### <a name="remarks"></a>備註

除非視窗處理 WM_SETFONT 訊息，否則此方法不會有任何作用。 衍生自的許多 MFC 類別 `CWnd` 會處理此訊息，因為它們附加到預先定義的視窗類別，其中包含 WM_SETFONT 訊息的訊息處理常式。 若要使用這個方法，您衍生自的類別 `CWnd` 必須定義 WM_SETFONT 訊息的方法處理常式。

## <a name="cwndseticon"></a><a name="seticon"></a> CWnd：： SetIcon

呼叫這個成員函式，將控制碼設定為指定的圖示，如 *hIcon*所識別。

```
HICON SetIcon(
    HICON hIcon,
    BOOL bBigIcon);
```

### <a name="parameters"></a>參數

*hIcon*<br/>
上一個圖示的控制碼。

*bBigIcon*<br/>
若為 TRUE，則指定32圖元乘以32圖元圖示;如果為 FALSE，則指定16圖元 x 16 圖元圖示。

### <a name="return-value"></a>傳回值

圖示的控制代碼。

### <a name="remarks"></a>備註

當視窗類別註冊時，它會選取圖示。

### <a name="example"></a>範例

  請參閱 [CWnd：： GetSystemMenu](#getsystemmenu)的範例。

## <a name="cwndsetlayeredwindowattributes"></a><a name="setlayeredwindowattributes"></a> CWnd：： SetLayeredWindowAttributes

設定分層視窗的不透明和透明色鍵。

```
BOOL SetLayeredWindowAttributes(
    COLORREF crKey,
    BYTE bAlpha,
    DWORD dwFlags);
```

### <a name="parameters"></a>參數

*crKey*<br/>
COLORRE光圈值的指標，此值會指定要在撰寫分層視窗時使用的透明色彩索引鍵。 視窗在此色彩中繪製的所有圖元都是透明的。 若要產生 COLORREF，請使用 RGB 宏。

*bAlpha*<br/>
Alpha 值，用來描述分層視窗的不透明度。 如需詳細資訊，請參閱 `SourceConstantAlpha` [BLENDFUNCTION](/windows/win32/api/wingdi/ns-wingdi-blendfunction) 結構的成員。 當 *bAlpha* 為0時，視窗是完全透明的。 當 *bAlpha* 為255時，此視窗是不透明的。

*dwFlags*<br/>
指定要採取的動作。 這個參數可以是下列一或多個值。 如需可能值的清單，請參閱 [SetLayeredWindowAttributes](/windows/win32/api/winuser/nf-winuser-setlayeredwindowattributes)。

### <a name="return-value"></a>傳回值

如果函式成功則為非零值，否則為 0。

### <a name="remarks"></a>備註

此成員函式會模擬函數 [SetLayeredWindowAttributes](/windows/win32/api/winuser/nf-winuser-setlayeredwindowattributes)的功能，如 Windows SDK 所述。

## <a name="cwndsetmenu"></a><a name="setmenu"></a> CWnd：： SetMenu

將目前的功能表設定為指定的功能表。

```
BOOL SetMenu(CMenu* pMenu);
```

### <a name="parameters"></a>參數

*pMenu*<br/>
識別新功能表。 如果這個參數為 Null，則會移除目前的功能表。

### <a name="return-value"></a>傳回值

如果功能表已變更，則為非零;否則為0。

### <a name="remarks"></a>備註

會重新繪製視窗，以反映功能表變更。

`SetMenu` 將不會摧毀先前的功能表。 應用程式應該呼叫 [CMenu：:D estroymenu](../../mfc/reference/cmenu-class.md#destroymenu) 成員函式來完成這項工作。

### <a name="example"></a>範例

  請參閱 [CMenu：： LoadMenu](../../mfc/reference/cmenu-class.md#loadmenu)的範例。

## <a name="cwndsetowner"></a><a name="setowner"></a> CWnd：： SetOwner

將目前的視窗擁有者設為指定的視窗物件。

```cpp
void SetOwner(CWnd* pOwnerWnd);
```

### <a name="parameters"></a>參數

*pOwnerWnd*<br/>
識別視窗物件的新擁有者。 如果這個參數為 Null，則視窗物件沒有擁有者。

### <a name="remarks"></a>備註

然後，此擁有者就可以從目前的視窗物件接收命令訊息。 根據預設，目前視窗的父系為其擁有者。

建立與視窗階層無關的視窗物件之間的連接通常是很有用的。 例如， [CToolBar](../../mfc/reference/ctoolbar-class.md) 會將通知傳送給它的擁有者，而不是傳送到其父系。 這可讓工具列成為一個視窗 (的子系，例如 OLE 容器應用程式視窗) 將通知傳送至另一個視窗 (例如就地框架視窗) 。 此外，當伺服器視窗在就地編輯期間停用或啟用時，框架視窗所擁有的任何視窗都會隱藏或顯示。 此擁有權是使用的呼叫來明確設定 `SetOwner` 。

此函數的擁有權概念與 [GetWindow](/windows/win32/api/winuser/nf-winuser-getwindow)的擁有權概念不同。

## <a name="cwndsetparent"></a><a name="setparent"></a> CWnd：： SetParent

變更子視窗的父視窗。

```
CWnd* SetParent(CWnd* pWndNewParent);
```

### <a name="parameters"></a>參數

*pWndNewParent*<br/>
識別新的父視窗。

### <a name="return-value"></a>傳回值

如果成功，則為先前父視窗物件的指標。 傳回的指標可能是暫時性的，不應儲存供稍後使用。

### <a name="remarks"></a>備註

如果可以看見子視窗，Windows 會執行適當的重繪和重新繪製。

## <a name="cwndsetproperty"></a><a name="setproperty"></a> CWnd：： SetProperty

呼叫這個成員函式，以設定 *dwDispID*所指定的 OLE 控制項屬性。

```cpp
void AFX_CDECL SetProperty(
    DISPID dwDispID,
    VARTYPE vtProp, ...);
```

### <a name="parameters"></a>參數

*dwDispID*<br/>
識別要設定的屬性。

*vtProp*<br/>
指定要設定的屬性類型。 如需可能的值，請參閱 [COleDispatchDriver::InvokeHelper](../../mfc/reference/coledispatchdriver-class.md#invokehelper)的＜備註＞一節。

*...*<br/>
*VtProp*所指定之類型的單一參數。

### <a name="remarks"></a>備註

> [!NOTE]
> 這個函式應該只在 `CWnd` 代表 OLE 控制項的物件上呼叫。

如需有關搭配使用這個成員函式與 OLE Control 容器的詳細資訊，請參閱 Activex 控制項容器： activex 控制項 [容器中的 activex 控制項程式設計](../../mfc/programming-activex-controls-in-a-activex-control-container.md)（activex control）一文。

## <a name="cwndsetredraw"></a><a name="setredraw"></a> CWnd：： SetRedraw

應用程式 `SetRedraw` 會呼叫以允許重新繪製變更，或防止重新繪製變更。

```cpp
void SetRedraw(BOOL bRedraw = TRUE);
```

### <a name="parameters"></a>參數

*bRedraw*<br/>
指定重繪旗標的狀態。 如果此參數為 TRUE，則會設定重繪旗標;如果為 FALSE，則會清除旗標。

### <a name="remarks"></a>備註

此成員函式會設定或清除重繪旗標。 清除重繪旗標時，不會在每次變更之後更新內容，而且在設定重繪旗標之前不會重新繪製內容。 例如，需要將數個專案加入清單方塊的應用程式可以清除重繪旗標、新增專案，然後設定重繪旗標。 最後，應用程式可以呼叫 [無效](#invalidate) 或 [InvalidateRect](#invalidaterect) 成員函式，使清單方塊重新繪製。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#117](../../mfc/reference/codesnippet/cpp/cwnd-class_58.cpp)]

## <a name="cwndsetscrollinfo"></a><a name="setscrollinfo"></a> CWnd：： SetScrollInfo

呼叫這個成員函式，以設定 `SCROLLINFO` 結構針對捲軸所維護的資訊。

```
BOOL SetScrollInfo(
    int nBar,
    LPSCROLLINFO lpScrollInfo,
    BOOL bRedraw = TRUE);
```

### <a name="parameters"></a>參數

*nBar*<br/>
指定捲軸是否為控制項或視窗非工作區的一部分。 如果它是非工作區的一部分，nBar 也會指出捲軸是水準、垂直或兩者的位置。 它必須是下列其中一項：

- SB_CTL 包含捲軸控制項的參數。 `m_hWnd`資料成員必須是捲軸控制項的控制碼。

- SB_HORZ 指定視窗為水準捲軸。

- SB_VERT 指定視窗是垂直捲動條。

*lpScrollInfo*<br/>
[SCROLLINFO](/windows/win32/api/winuser/ns-winuser-scrollinfo)結構的指標。 如需此結構的詳細資訊，請參閱 Windows SDK。

*bRedraw*<br/>
指定是否應該重新繪製捲軸，以反映新的位置。 如果 *bRedraw* 為 TRUE，則會重新繪製捲軸。 如果為 FALSE，則不會重新繪製。 預設會重新繪製捲軸。

### <a name="return-value"></a>傳回值

如果成功，則傳回 TRUE。 否則為 FALSE。

### <a name="remarks"></a>備註

[SCROLLINFO](/windows/win32/api/winuser/ns-winuser-scrollinfo)結構包含捲軸的相關資訊，包括捲軸位置的最小和最大值、頁面大小，以及捲動方塊 (捲動方塊的位置) 。 如需 `SCROLLINFO` 變更結構預設值的詳細資訊，請參閱 Windows SDK 中的結構主題。

表示捲軸位置的 MFC Windows 訊息處理常式， [CWnd：： OnHScroll](#onhscroll) 和 [CWnd：： OnVScroll](#onvscroll)，只提供16個位的位置資料。 [GetScrollInfo](#getscrollinfo) 並 `SetScrollInfo` 提供32位的捲軸位置資料。 因此，應用程式可以 `GetScrollInfo` 在處理 `CWnd::OnHScroll` 或 `CWnd::OnVScroll` 取得32位捲軸位置資料時呼叫。

> [!NOTE]
> [CWnd：： GetScrollInfo](#getscrollinfo) 可讓應用程式使用32位捲軸位置。

## <a name="cwndsetscrollpos"></a><a name="setscrollpos"></a> CWnd：： SetScrollPos

設定捲動方塊的目前位置，並在要求時，重新繪製捲軸以反映捲動方塊的新位置。

```
int SetScrollPos(
    int nBar,
    int nPos,
    BOOL bRedraw = TRUE);
```

### <a name="parameters"></a>參數

*nBar*<br/>
指定要設定的捲軸。 這個參數可以是下列其中一項：

- SB_HORZ 在視窗的水準捲軸中設定捲動方塊的位置。

- SB_VERT 在視窗的垂直捲動條中設定捲動方塊的位置。

*nPos*<br/>
指定捲動方塊的新位置。 它必須在滾動範圍內。

*bRedraw*<br/>
指定是否應該重新繪製捲軸，以反映新的捲動方塊位置。 如果此參數為 TRUE，則會重新繪製捲軸;如果為 FALSE，則不會重新繪製捲軸。

### <a name="return-value"></a>傳回值

捲動方塊的先前位置。

### <a name="remarks"></a>備註

當後續呼叫另一個函式時，將 *bRedraw* 設定為 FALSE 會很有用。

## <a name="cwndsetscrollrange"></a><a name="setscrollrange"></a> CWnd：： SetScrollRange

設定給定捲軸的最小和最大位置值。

```cpp
void SetScrollRange(
    int nBar,
    int nMinPos,
    int nMaxPos,
    BOOL bRedraw = TRUE);
```

### <a name="parameters"></a>參數

*nBar*<br/>
指定要設定的捲軸。 這個參數可以是下列其中一個值：

- SB_HORZ 設定視窗的水準捲軸範圍。

- SB_VERT 設定視窗垂直捲動條的範圍。

*nMinPos*<br/>
指定最小滾動位置。

*nMaxPos*<br/>
指定最大滾動位置。

*bRedraw*<br/>
指定是否應該重新繪製捲軸以反映變更。 如果 *bRedraw* 為 TRUE，則會重新繪製捲軸;如果為 FALSE，則不會重新繪製捲軸。

### <a name="remarks"></a>備註

它也可以用來隱藏或顯示標準捲軸。

應用程式不應該呼叫此函式，以在處理捲軸通知訊息時隱藏捲軸。

如果 `SetScrollRange` 緊接在呼叫 [SetScrollPos](#setscrollpos) 成員函式之後呼叫，成員函式中的 *bRedraw* 參數 `SetScrollPos` 應為0，以防止繪製兩次的捲軸。

標準捲軸的預設範圍是0到100。 捲軸控制項的預設範圍是空的 (*nMinPos* 和 *nMaxPos* 值都是 0) 。 *NMinPos*和*nMaxPos*所指定值之間的差異不得大於 INT_MAX。

## <a name="cwndsettimer"></a><a name="settimer"></a> CWnd：： SetTimer

安裝系統計時器。

```
UINT_PTR SetTimer(
    UINT_PTR nIDEvent,
    UINT nElapse,
    void (CALLBACK* lpfnTimer)(HWND,
    UINT,
    UINT_PTR,
    DWORD));
```

### <a name="parameters"></a>參數

*nIDEvent*<br/>
指定非零計時器識別碼。 如果計時器識別碼是唯一的，則會傳回這個相同的值 `SetTimer` 。 否則， `SetTimer` 會決定新的唯一值，並傳回該值。 若為具有 Null 回呼函式) 的視窗計時器 (，只有與目前視窗相關聯的其他 windows 計時器值才必須是唯一的。 針對回呼計時器，所有進程中的所有計時器值都必須是唯一的。 因此，當您建立回呼計時器時，傳回的值可能會與您指定的值不同。

*nElapse*<br/>
指定超時值或間隔（以毫秒為單位）。

*lpfnTimer*<br/>
指定處理 WM_TIMER 訊息的應用程式提供 `TimerProc` 回呼函數的位址。 [WM_TIMER](/windows/win32/winmsg/wm-timer) 如果這個參數是 Null，則 WM_TIMER 的訊息會放在應用程式的訊息佇列中，並由 `CWnd` 物件處理。

### <a name="return-value"></a>傳回值

如果函式成功，則為新計時器的計時器識別碼。 此值不一定等於透過 *nIDEvent* 參數傳入的值。 應用程式應該一律將傳回值傳遞給 [KillTimer](#killtimer) 成員函式，以終止計時器。 如果成功，則為非零;否則為0。

### <a name="remarks"></a>備註

系統會指定間隔值，而且每次超過間隔時，系統會將 WM_TIMER 訊息張貼至安裝應用程式的安裝訊息佇列，或將訊息傳遞至應用程式定義的 `TimerProc` 回呼函數。

*LpfnTimer*回呼函式不需要命名 `TimerProc` ，但必須宣告為靜態，並定義如下。

```cpp
void CALLBACK TimerProc(
    HWND hWnd,   // handle of CWnd that called SetTimer
    UINT nMsg,   // WM_TIMER
    UINT_PTR nIDEvent,   // timer identification
    DWORD dwTime    // system time);
```

### <a name="example"></a>範例

這個範例會使用 `CWnd::SetTimer` 、 `CWnd::OnTimer` 和 `CWnd::KillTimer` 來處理 WM_TIMER 的訊息。 第一個計時器會設定為每隔2秒將 WM_TIMER 訊息傳送至主框架視窗 `OnStartTimer` 。 `OnTimer`事件處理常式會處理主框架視窗的 WM_TIMER 訊息。 這種方法會導致電腦喇叭每2秒發出嗶聲。 第二個計時器每隔3.75 秒就會傳送一則訊息給回呼函式。 `OnStopTimer` 會呼叫 `CWnd::KillTimer` 每個計時器識別碼以停止這兩個計時器。

[!code-cpp[NVC_MFCWindowing#118](../../mfc/reference/codesnippet/cpp/cwnd-class_59.cpp)]

## <a name="cwndsetwindowcontexthelpid"></a><a name="setwindowcontexthelpid"></a> CWnd：： SetWindowCoNtextHelpId

呼叫這個成員函式，將說明內容識別碼與指定的視窗產生關聯。

```
BOOL SetWindowContextHelpId(DWORD dwContextHelpId);
```

### <a name="parameters"></a>參數

*dwCoNtextHelpId*<br/>
說明內容識別碼。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

如果子視窗沒有說明內容識別碼，則會繼承其父視窗的識別碼。 同樣地，如果擁有的視窗沒有說明內容識別碼，它會繼承其擁有者視窗的識別碼。 這項說明內容識別碼的繼承可讓應用程式只針對對話方塊和其所有控制項設定一個識別碼。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#119](../../mfc/reference/codesnippet/cpp/cwnd-class_60.cpp)]

## <a name="cwndsetwindowplacement"></a><a name="setwindowplacement"></a> CWnd：： SetWindowPlacement

設定視窗的顯示狀態和一般 (還原)、最小化和最大化位置。

```
BOOL SetWindowPlacement(const WINDOWPLACEMENT* lpwndpl);
```

### <a name="parameters"></a>參數

*lpwndpl*<br/>
指向 [WINDOWPLACEMENT](/windows/win32/api/winuser/ns-winuser-windowplacement) 結構，以指定新的顯示狀態和位置。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

## <a name="cwndsetwindowpos"></a><a name="setwindowpos"></a> CWnd：： SetWindowPos

變更子系、快顯視窗和最上層視窗的大小、位置和迭置順序。

```
BOOL SetWindowPos(
    const CWnd* pWndInsertAfter,
    int x,
    int y,
    int cx,
    int cy,
    UINT nFlags);
```

### <a name="parameters"></a>參數

*pWndInsertAfter*<br/>
識別在 `CWnd` (高於迭置順序中) 此物件之前的物件 `CWnd` 。 這個參數可以是指向 `CWnd` 或下列其中一個值指標的指標：

- `wndBottom` 將視窗放在迭置順序的底部。 如果這 `CWnd` 是最上層的視窗，此視窗會失去其最上層狀態; 系統會將視窗放在所有其他視窗的底部。

- `wndTop` 將視窗放在迭置順序的頂端。

- `wndTopMost` 將視窗放在所有非最上層視窗的上方。 視窗會維持最上層的位置（即使已停用）。

- `wndNoTopMost` 將視窗重新置放至所有非最上層 windows (的頂端，也就是所有最上層的 windows) 。 如果視窗已是非最上層的視窗，此旗標不會有任何作用。

如需有關如何使用此參數的規則，請參閱本主題的「備註」一節。

*x*<br/>
指定視窗左邊的新位置。

*y*<br/>
指定視窗頂端的新位置。

*殘雪*<br/>
指定視窗的新寬度。

*cy*<br/>
指定視窗的新高度。

*nFlags*<br/>
指定調整大小和定位選項。 這個參數可以是下列旗標的組合：

- SWP_DRAWFRAME 會在視窗周圍建立) 時，繪製 (所定義的畫面格。

- SWP_FRAMECHANGED 將 WM_NCCALCSIZE 訊息傳送至視窗，即使視窗的大小未變更也一樣。 如果未指定此旗標，則只有在變更視窗的大小時，才會傳送 WM_NCCALCSIZE。

- SWP_HIDEWINDOW 隱藏視窗。

- SWP_NOACTI加值稅E 不會啟動視窗。 如果未設定此旗標，則會根據 *pWndInsertAfter* 參數) 的設定，啟動視窗並移至最上層或非最上層群組 (的頂端。

- SWP_NOCOPYBITS 捨棄工作區的整個內容。 如果未指定此旗標，則在調整大小或重新置放視窗之後，就會將工作區的有效內容儲存並複製回工作區。

- SWP_NOMOVE 會保留目前的位置 (忽略) 的 *x* 和 *y* 參數。

- SWP_NOOWNERZORDER 不會以迭置順序變更擁有者視窗的位置。

- SWP_NOREDRAW 不會重新繪製變更。 如果設定此旗標，則不會重新繪製任何種類。 這適用于工作區、非工作區 (包括標題和捲軸) ，以及父視窗的任何部分（因為移動的視窗所示）。 當設定這個旗標時，應用程式必須明確地使或重繪視窗的任何部分和必須重新繪製的父視窗。

- SWP_NOREPOSITION 與 SWP_NOOWNERZORDER 相同。

- SWP_NOSENDCHANGING 防止視窗接收 WM_WINDOWPOSCHANGING 訊息。

- SWP_NOSIZE 會保留目前的大小 (忽略) 的 *cx* 和 *cy* 參數。

- SWP_NOZORDER 會保留目前的順序 (忽略 *pWndInsertAfter*) 。

- SWP_SHOWWINDOW 會顯示視窗。

### <a name="return-value"></a>傳回值

如果函式成功，則為非零;否則為0。

### <a name="remarks"></a>備註

視窗會根據其迭置順序排列在畫面上;位於 Z 順序頂端的視窗會出現在順序中的所有其他視窗上方。

子視窗的所有座標都是用戶端座標 (相對於父視窗的工作區) 的左上角。

您可以將 *pWndInsertAfter* 參數設定為 [ **&wndTopMost** ] SWP_NOZORDER，並確定未設定視窗的迭置順序，或設定視窗的迭置順序，使其高於任何現有的最上層視窗，藉以將視窗移至 Z 順序頂端。 當非最上層視窗設為最上層時，也會將其擁有的視窗設為最上層。 其擁有者未變更。

如果最頂端的視窗重新置放至 Z 軸順序的底部 ( **&wndBottom**) ，或在任何非最上層視窗之後，就不再是最上層視窗。 當最上層視窗設為非最上層時，它的所有擁有者及其擁有的視窗也會成為非最上層視窗。

如果未指定 SWP_NOACTI加值稅E 或 SWP_NOZORDER (也就是說，當應用程式要求視窗同時啟用並放在指定的 Z 順序) 時， *pWndInsertAfter* 中指定的值只會在下列情況下使用：

- *PWndInsertAfter*參數中未指定 **&WndTopMost**或 **&wndNoTopMost** 。

- 這個視窗不是使用中視窗。

應用程式無法啟動非使用中的視窗，也不會將它帶到迭置順序的最上層。 應用程式可以變更已啟動視窗的迭置順序，而不受限制。

非最上層視窗可能會擁有最上層視窗，而不是反之亦然。 任何視窗 (例如，) 最上層視窗所擁有的對話方塊本身就會成為最上層視窗，以確保所有擁有的 windows 都維持在其擁有者的上方。

在 Windows 3.1 版和更新版本中，可以將 windows 移至迭置順序的頂端，並藉由設定其 WS_EX_TOPMOST 樣式來鎖定。 即使停用，這種最上層的視窗仍會維持最上層的位置。 例如，選取 WinHelp Always On Top 命令可讓 [說明] 視窗最上層，然後當您返回應用程式時，它就會保持可見。

若要建立最上層的視窗，請 `SetWindowPos` 使用等於 **&WndTopMost**的*pWndInsertAfter*參數來呼叫，或在建立視窗時設定 WS_EX_TOPMOST 的樣式。

如果迭置順序包含任何具有 WS_EX_TOPMOST 樣式的視窗，則會將具有 **&wndTopMost** 值的視窗放在所有非最上層視窗的頂端，但在任何最上層視窗的上方。 當應用程式啟動不含 WS_EX_TOPMOST 位的非作用中視窗時，視窗會移至所有非最上層視窗，但在任何最上層視窗的上方。

如果在 `SetWindowPos` *pWndInsertAfter* 參數 **&wndBottom** 時呼叫，而且 `CWnd` 是最上層的視窗，則視窗會失去其最高的狀態 ( WS_EX_TOPMOST 已清除) ，而且系統會將視窗置於迭置順序的底部。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#120](../../mfc/reference/codesnippet/cpp/cwnd-class_61.cpp)]

## <a name="cwndsetwindowrgn"></a><a name="setwindowrgn"></a> CWnd：： SetWindowRgn

呼叫此成員函式以設定視窗的區域。

```
int SetWindowRgn(
    HRGN hRgn,
    BOOL bRedraw);
```

### <a name="parameters"></a>參數

*hRgn*<br/>
區域的控制碼。

*bRedraw*<br/>
若為 TRUE，則作業系統會在設定區域之後重新繪製視窗;否則，它不會。 一般來說，如果視窗是可見的，則將 *bRedraw* 設為 TRUE。 如果設定為 TRUE，系統就會將 WM_WINDOWPOSCHANGING 並 WM_WINDOWPOSCHANGED 訊息傳送至視窗。

### <a name="return-value"></a>傳回值

如果函式成功，則傳回值為非零。 如果此函式失敗，則傳回值為零。

### <a name="remarks"></a>備註

視窗視窗區域的座標是相對於視窗的左上角，而不是視窗的工作區。

在成功呼叫之後 `SetWindowRgn` ，作業系統會擁有區域控制碼 *hRgn*所指定的區域。 作業系統不會建立區域的複本，因此請勿使用這個區域控制碼進行任何進一步的函式呼叫，也不會關閉此區域控制碼。

## <a name="cwndsetwindowtext"></a><a name="setwindowtext"></a> CWnd：： SetWindowText

將視窗的標題設定為指定的文字。

```cpp
void SetWindowText(LPCTSTR lpszString);
```

### <a name="parameters"></a>參數

*lpszString*<br/>
指向 [CString](../../atl-mfc-shared/reference/cstringt-class.md) 物件或以 null 終止的字串，以作為新的標題或控制項文字使用。

### <a name="remarks"></a>備註

如果視窗是控制項，則會設定控制項內的文字。

此函式會將 [WM_SETTEXT](/windows/win32/winmsg/wm-settext) 訊息傳送到此視窗。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#121](../../mfc/reference/codesnippet/cpp/cwnd-class_62.cpp)]

## <a name="cwndshowcaret"></a><a name="showcaret"></a> CWnd：： ShowCaret

在畫面上插入號的目前位置顯示插入號。

```cpp
void ShowCaret();
```

### <a name="remarks"></a>備註

顯示後，插入號會開始自動閃爍。

成員函式 `ShowCaret` 只有在有目前的圖形，而且未連續隱藏兩次或更多次時，才會顯示插入號。 如果此視窗未擁有插入號，則不會顯示插入號。

隱藏插入號是累計的。 如果連續呼叫 [HideCaret](#hidecaret) 成員函式五次，則 `ShowCaret` 必須呼叫五次以顯示插入號。

插入號是共用的資源。 只有當此視窗具有輸入焦點或作用中時，才會顯示插入號。

### <a name="example"></a>範例

  請參閱 [CWnd：： CreateCaret](#createcaret)的範例。

## <a name="cwndshowownedpopups"></a><a name="showownedpopups"></a> CWnd：： ShowOwnedPopups

顯示或隱藏此視窗擁有的所有快顯視窗。

```cpp
void ShowOwnedPopups(BOOL bShow = TRUE);
```

### <a name="parameters"></a>參數

*bShow*<br/>
指定是否要顯示或隱藏快顯視窗。 如果此參數為 TRUE，則會顯示所有隱藏的快顯視窗。 如果此參數為 FALSE，則會隱藏所有可見的快顯視窗。

### <a name="example"></a>範例

  請參閱 [CWnd：： SetWindowPos](#setwindowpos)的範例。

## <a name="cwndshowscrollbar"></a><a name="showscrollbar"></a> CWnd：： ShowScrollBar

顯示或隱藏捲軸。

```cpp
void ShowScrollBar(
    UINT nBar,
    BOOL bShow = TRUE);
```

### <a name="parameters"></a>參數

*nBar*<br/>
指定捲軸是否為控制項或視窗非工作區的一部分。 如果它是非工作區的一部分， *nBar* 也會指出捲軸是水準、垂直或兩者的位置。 它必須是下列其中一項：

- SB_BOTH 指定視窗的水準和垂直捲動條。

- SB_HORZ 指定視窗為水準捲軸。

- SB_VERT 指定視窗是垂直捲動條。

*bShow*<br/>
指定視窗是否顯示或隱藏捲軸。 如果此參數為 TRUE，則會顯示捲軸;否則，就會隱藏捲軸。

### <a name="remarks"></a>備註

應用程式不應該 `ShowScrollBar` 在處理捲軸通知訊息時呼叫來隱藏捲軸。

## <a name="cwndshowwindow"></a><a name="showwindow"></a> CWnd：： ShowWindow

設定視窗的可見度狀態。

```
BOOL ShowWindow(int nCmdShow);
```

### <a name="parameters"></a>參數

*nCmdShow*<br/>
指定要如何 `CWnd` 顯示。 它必須是下列值之一：

- SW_HIDE 隱藏此視窗，並將啟用傳遞到另一個視窗。

- SW_MINIMIZE 將視窗最小化，並啟用系統清單中的最上層視窗。

- SW_RESTORE 會啟用並顯示視窗。 如果視窗最小化或最大化，Windows 會將其還原為其原始大小和位置。

- SW_SHOW 會啟用視窗，並以其目前的大小和位置顯示。

- SW_SHOWMAXIMIZED 會啟用視窗，並將它顯示為最大化的視窗。

- SW_SHOWMINIMIZED 會啟用視窗，並將它顯示為圖示。

- SW_SHOWMINNOACTIVE 會將視窗顯示為圖示。 目前作用中的視窗會保持作用中狀態。

- SW_SHOWNA 會以目前的狀態顯示視窗。 目前作用中的視窗會保持作用中狀態。

- SW_SHOWNOACTI加值稅E 會以最新的大小和位置顯示視窗。 目前作用中的視窗會保持作用中狀態。

- SW_SHOWNORMAL 會啟用並顯示視窗。 如果視窗最小化或最大化，Windows 會將其還原為其原始大小和位置。

### <a name="return-value"></a>傳回值

如果視窗先前是可見的，則為非零;如果先前已隱藏，則為 0 `CWnd` 。

### <a name="remarks"></a>備註

`ShowWindow` 對於具有 [CWinApp：： m_nCmdShow](../../mfc/reference/cwinapp-class.md#m_ncmdshow)的主視窗，每個應用程式都只能呼叫一次。 後續呼叫 `ShowWindow` 必須使用上列其中一個值，而不是所指定的值 `CWinApp::m_nCmdShow` 。

### <a name="example"></a>範例

  請參閱 [CWnd：： CalcWindowRect](#calcwindowrect)的範例。

## <a name="cwndsubclassdlgitem"></a><a name="subclassdlgitem"></a> CWnd：： SubclassDlgItem

呼叫這個成員函式，將從對話方塊範本建立的控制項動態子類別化，並將它附加至這個 `CWnd` 物件。

```
BOOL SubclassDlgItem(
    UINT nID,
    CWnd* pParent);
```

### <a name="parameters"></a>參數

*nID*<br/>
控制項的識別碼。

*pParent*<br/>
控制項的父 (通常是) 的對話方塊。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

當控制項動態子類別化時，windows 訊息會在的 `CWnd` 訊息對應中進行路由，並先在的類別中呼叫訊息處理常式 `CWnd` 。 傳遞至基類的訊息將會傳遞至控制項中的預設訊息處理常式。

此成員函式會將 Windows 控制項附加至 `CWnd` 物件，並取代控制項的 `WndProc` 和 `AfxWndProc` 函數。 函數會將舊的儲存 `WndProc` 在成員函式所傳回的位置 `GetSuperWndProcAddr` 。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#122](../../mfc/reference/codesnippet/cpp/cwnd-class_63.cpp)]

## <a name="cwndsubclasswindow"></a><a name="subclasswindow"></a> CWnd：： SubclassWindow

呼叫此成員函式以「動態子類別化」視窗，並將它附加至這個 `CWnd` 物件。

```
BOOL SubclassWindow(HWND hWnd);
```

### <a name="parameters"></a>參數

*hWnd*<br/>
視窗的控制碼。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

以動態方式將視窗子類別化時，windows 訊息會在的 `CWnd` 訊息對應中進行路由，並先在的類別中呼叫訊息處理常式 `CWnd` 。 傳遞至基類的訊息將會傳遞至視窗中的預設訊息處理常式。

此成員函式會將 Windows 控制項附加至 `CWnd` 物件，並取代視窗的 `WndProc` 和 `AfxWndProc` 函數。 函式會儲存物件的舊指標 `WndProc` `CWnd` 。

> [!NOTE]
> 呼叫此函式時，此視窗必須已附加至 MFC 物件。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#123](../../mfc/reference/codesnippet/cpp/cwnd-class_64.cpp)]

## <a name="cwndunlockwindowupdate"></a><a name="unlockwindowupdate"></a> CWnd：： UnlockWindowUpdate

呼叫這個成員函式來解除鎖定已鎖定的視窗 `CWnd::LockWindowUpdate` 。

```cpp
void UnlockWindowUpdate();
```

### <a name="remarks"></a>備註

一次只能使用一個視窗來鎖定 `LockWindowUpdate` 。 如需鎖定視窗的詳細資訊，請參閱 [CWnd：： LockWindowUpdate](#lockwindowupdate) 或 Win32 函數 [LockWindowUpdate](/windows/win32/api/winuser/nf-winuser-lockwindowupdate) 。

## <a name="cwndunsubclasswindow"></a><a name="unsubclasswindow"></a> CWnd：： UnsubclassWindow

呼叫此成員函式，將 `WndProc` 其設回其原始值，並從物件卸離 HWND 所識別的視窗 `CWnd` 。

```
HWND UnsubclassWindow();
```

### <a name="return-value"></a>傳回值

Unsubclassed 視窗的控制碼。

### <a name="example"></a>範例

  請參閱 [CWnd：： SubclassWindow](#subclasswindow)的範例。

## <a name="cwndupdatedata"></a><a name="updatedata"></a> CWnd：： UpdateData

呼叫此成員函式以初始化對話方塊中的資料，或抓取和驗證對話資料。

```
BOOL UpdateData(BOOL bSaveAndValidate = TRUE);
```

### <a name="parameters"></a>參數

*bSaveAndValidate*<br/>
此旗標指出是否正在初始化對話方塊 (FALSE) 或正在抓取資料 (TRUE) 。

### <a name="return-value"></a>傳回值

如果作業成功，則為非零;否則為0。 如果 *bSaveAndValidat*e 為 TRUE，則傳回值為非零表示資料已成功驗證。

### <a name="remarks"></a>備註

`UpdateData`當在[CDialog：： OnInitDialog](../../mfc/reference/cdialog-class.md#oninitdialog)的預設實中建立強制回應對話方塊時，架構會自動呼叫，並將*bSaveAndValidate*設定為 FALSE。 呼叫會在對話方塊顯示之前進行。 [CDialog：： OnOK](../../mfc/reference/cdialog-class.md#onok)的預設執行會呼叫此成員函式，並將*BSAVEANDVALIDATE*設定為 TRUE 以取得資料，如果成功，將會關閉對話方塊。  (如果在對話方塊中按一下 [取消] 按鈕，則會在沒有抓取資料的情況下關閉對話方塊。 ) 

## <a name="cwndupdatedialogcontrols"></a><a name="updatedialogcontrols"></a> CWnd：： UpdateDialogControls

呼叫這個成員函式，以在使用 [ON_UPDATE_COMMAND_UI](message-map-macros-mfc.md#on_update_command_ui) 回呼機制的對話方塊或視窗中，更新對話方塊按鈕和其他控制項的狀態。

```cpp
void UpdateDialogControls(
    CCmdTarget* pTarget,
    BOOL bDisableIfNoHndler);
```

### <a name="parameters"></a>參數

*pTarget*<br/>
指向應用程式的主框架視窗，用於路由更新訊息。

*bDisableIfNoHndler*<br/>
指出沒有更新處理常式之控制項是否應該自動顯示為停用的旗標。

### <a name="remarks"></a>備註

如果子控制項沒有處理常式，且 *bDisableIfNoHndler* 為 TRUE，則會停用子控制項。

架構會在應用程式的閒置處理過程中，針對對話方塊列或工具列中的控制項呼叫這個成員函式。

## <a name="cwndupdatelayeredwindow"></a><a name="updatelayeredwindow"></a> CWnd：： UpdateLayeredWindow

更新分層視窗的位置、大小、形狀、內容和透明度。

```
BOOL UpdateLayeredWindow(
    CDC* pDCDst,
    POINT* pptDst,
    SIZE* psize,
    CDC* pDCSrc,
    POINT* pptSrc,
    COLORREF crKey,
    BLENDFUNCTION* pblend,
    DWORD dwFlags);
```

### <a name="parameters"></a>參數

*pDCDst*<br/>
螢幕之裝置內容的指標。 當更新視窗內容時，會使用它來進行調色板色彩比對。 如果 *pDCDst* 為 Null，則會使用預設的調色板。

如果 *pDCSrc* 為 Null， *PDCDST* 必須是 null。

*pptDst*<br/>
結構的指標， `POINT` 指定分層視窗的新螢幕位置。 如果目前的位置未變更， *pptDst* 可以是 Null。

*psize*<br/>
`SIZE`結構的指標，指定分層視窗的新大小。 如果視窗的大小未變更， *psize* 可以是 Null。

如果 *pDCSrc* 為 null， *PSIZE* 必須是 null。

*pDCSrc*<br/>
定義分層視窗之介面的 DC 指標。 如果視窗的圖形和視覺化內容未變更， *pDCSrc* 可以是 Null。

*pptSrc*<br/>
`POINT`結構的指標，指定裝置內容中圖層的位置。

如果 *pDCSrc* 為 Null， *PPTSRC* 應該是 null。

*crKey*<br/>
COLORRE光圈值的指標，此值會指定要在撰寫分層視窗時使用的透明色彩索引鍵。 視窗在此色彩中繪製的所有圖元都是透明的。 若要產生 COLORREF，請使用 RGB 宏。

*pblend*<br/>
[BLENDFUNCTION](/windows/win32/api/wingdi/ns-wingdi-blendfunction)結構的指標，此結構會指定撰寫分層視窗時要使用的透明度值。

*dwFlags*<br/>
指定要採取的動作。 這個參數可以是下列一或多個值。 如需可能值的清單，請參閱 [UpdateLayeredWindow](/windows/win32/api/winuser/nf-winuser-updatelayeredwindow)。

### <a name="return-value"></a>傳回值

如果函式成功則為非零值，否則為 0。

### <a name="remarks"></a>備註

此成員函式會模擬函數 [UpdateLayeredWindow](/windows/win32/api/winuser/nf-winuser-updatelayeredwindow)的功能，如 Windows SDK 所述。

## <a name="cwndupdatewindow"></a><a name="updatewindow"></a> CWnd：： UpdateWindow

如果更新區域不是空的，則藉由傳送 [WM_PAINT](/windows/win32/gdi/wm-paint) 訊息來更新工作區。

```cpp
void UpdateWindow();
```

### <a name="remarks"></a>備註

成員函式會 `UpdateWindow` 直接傳送 WM_PAINT 訊息，略過應用程式佇列。 如果更新區域是空的，則不會傳送 WM_PAINT。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#124](../../mfc/reference/codesnippet/cpp/cwnd-class_65.cpp)]

## <a name="cwndvalidaterect"></a><a name="validaterect"></a> CWnd：： ValidateRect

從視窗的更新區域中移除矩形，以驗證給定矩形內的工作區。

```cpp
void ValidateRect(LPCRECT lpRect);
```

### <a name="parameters"></a>參數

*lpRect*<br/>
指向 [CRect](../../atl-mfc-shared/reference/crect-class.md) 物件或 [RECT 結構](/windows/win32/api/windef/ns-windef-rect) ，其中包含要從更新區域中移除之矩形的用戶端座標。 如果 *lpRect* 為 Null，則會驗證整個視窗。

### <a name="remarks"></a>備註

[BeginPaint](#beginpaint)成員函式會自動驗證整個工作區。 `ValidateRect`如果需要先驗證部分更新區域，才能[WM_PAINT](/windows/win32/gdi/wm-paint)下一次產生，則不應呼叫或[ValidateRgn](#validatergn)成員函式。

Windows 會繼續產生 WM_PAINT 訊息，直到驗證目前的更新區域為止。

## <a name="cwndvalidatergn"></a><a name="validatergn"></a> CWnd：： ValidateRgn

藉由從視窗目前的更新區域中移除區域，驗證給定區域內的工作區。

```cpp
void ValidateRgn(CRgn* pRgn);
```

### <a name="parameters"></a>參數

*pRgn*<br/>
[CRgn](../../mfc/reference/crgn-class.md)物件的指標，該物件會識別定義要從更新區域中移除之區域的區域。 如果此參數為 Null，則會移除整個工作區。

### <a name="remarks"></a>備註

指定的區域必須先前已由區域函數建立。 區域座標會假設為用戶端座標。

[BeginPaint](#beginpaint)成員函式會自動驗證整個工作區。 [ValidateRect](#validaterect) `ValidateRgn` 如果必須先驗證部分更新區域，才能產生下一個[WM_PAINT](/windows/win32/gdi/wm-paint)訊息，則不應呼叫 ValidateRect 和成員函式。

## <a name="cwndwindowfrompoint"></a><a name="windowfrompoint"></a> CWnd：： WindowFromPoint

抓取包含指定點的視窗; *point* 必須指定螢幕上某個點的螢幕座標。

```
static CWnd* PASCAL WindowFromPoint(POINT point);
```

### <a name="parameters"></a>參數

*點*<br/>
指定定義要檢查之點的 [CPoint](../../atl-mfc-shared/reference/cpoint-class.md) 物件或 [點](/windows/win32/api/windef/ns-windef-point) 資料結構。

### <a name="return-value"></a>傳回值

點所在之視窗物件的指標。 如果指定的點沒有視窗存在，則為 Null。 傳回的指標可能是暫時性的，不應儲存供稍後使用。

### <a name="remarks"></a>備註

`WindowFromPoint` 即使點在視窗內，也不會抓取隱藏或停用的視窗。 應用程式應該使用 [ChildWindowFromPoint](#childwindowfrompoint) 成員函式來進行限制性搜尋。

## <a name="cwndwindowproc"></a><a name="windowproc"></a> CWnd：： WindowProc

提供 ( `WindowProc`) 物件的 Windows 程式 `CWnd` 。

```
virtual LRESULT WindowProc(
    UINT message,
    WPARAM wParam,
    LPARAM lParam);
```

### <a name="parameters"></a>參數

*message*<br/>
指定要處理的 Windows 訊息。

*wParam*<br/>
提供用於處理訊息的其他資訊。 參數值取決於訊息。

*lParam*<br/>
提供用於處理訊息的其他資訊。 參數值取決於訊息。

### <a name="return-value"></a>傳回值

傳回值取決於訊息。

### <a name="remarks"></a>備註

它會透過視窗的訊息對應來分派訊息。

## <a name="cwndwinhelp"></a><a name="winhelp"></a> CWnd：： WinHelp

呼叫以初始化 WinHelp 應用程式。

```
virtual void WinHelp(
    DWORD_PTR dwData,
    UINT nCmd = HELP_CONTEXT);
```

### <a name="parameters"></a>參數

*dwData*<br/>
指定其他資料。 使用的值取決於 *nCmd* 參數的值。

*nCmd*<br/>
指定要求的說明類型。 如需可能值的清單，以及它們如何影響 *dwData* 參數，請參閱 Windows SDK 中的 [WinHelp](/windows/win32/api/winuser/nf-winuser-winhelpw) Windows 函數。

### <a name="remarks"></a>備註

如需詳細資訊，請參閱 [CWinApp：： WinHelp](../../mfc/reference/cwinapp-class.md#winhelp) 。

## <a name="cwndregistertouchwindow"></a><a name="registertouchwindow"></a> CWnd：： RegisterTouchWindow

註冊或取消註冊 Windows 觸控支援。

```
BOOL RegisterTouchWindow(
    BOOL bRegister = TRUE,
    ULONG ulFlags = 0);
```

### <a name="parameters"></a>參數

*bRegister*<br/>
TRUE 表示註冊 Windows 觸控支援;否則為 FALSE。

*ulFlags*<br/>
指定選擇性修改的一組位旗標。 此欄位可能包含0或下列其中一個值： TWF_FINETOUCH、TWF_WANTPALM。

### <a name="return-value"></a>傳回值

如果成功，則為 TRUE，否則為 FALSE。

### <a name="remarks"></a>備註

## <a name="cwndresizedynamiclayout"></a><a name="resizedynamiclayout"></a> CWnd：： ResizeDynamicLayout

如果已啟用視窗的動態配置，則會在視窗大小變更以調整子視窗的版面配置時由架構呼叫。

```
virtual void ResizeDynamicLayout();
```

### <a name="remarks"></a>備註

## <a name="see-also"></a>另請參閱

[CCmdTarget 類別](../../mfc/reference/ccmdtarget-class.md)<br/>
[階層架構圖表](../../mfc/hierarchy-chart.md)<br/>
[CFrameWnd 類別](../../mfc/reference/cframewnd-class.md)<br/>
[CView 類別](../../mfc/reference/cview-class.md)
