---
title: CWnd 類別
ms.date: 11/19/2018
f1_keywords:
- CWnd
- AFXWIN/CWnd
- AFXWIN/CWnd::CWnd
- AFXWIN/CWnd::accDoDefaultAction
- AFXWIN/CWnd::accHitTest
- AFXWIN/CWnd::accLocation
- AFXWIN/CWnd::accNavigate
- AFXWIN/CWnd::accSelect
- AFXWIN/CWnd::AnimateWindow
- AFXWIN/CWnd::ArrangeIconicWindows
- AFXWIN/CWnd::Attach
- AFXWIN/CWnd::BeginModalState
- AFXWIN/CWnd::BeginPaint
- AFXWIN/CWnd::BindDefaultProperty
- AFXWIN/CWnd::BindProperty
- AFXWIN/CWnd::BringWindowToTop
- AFXWIN/CWnd::CalcWindowRect
- AFXWIN/CWnd::CancelToolTips
- AFXWIN/CWnd::CenterWindow
- AFXWIN/CWnd::ChangeClipboardChain
- AFXWIN/CWnd::CheckDlgButton
- AFXWIN/CWnd::CheckRadioButton
- AFXWIN/CWnd::ChildWindowFromPoint
- AFXWIN/CWnd::ClientToScreen
- AFXWIN/CWnd::CloseWindow
- AFXWIN/CWnd::ContinueModal
- AFXWIN/CWnd::Create
- AFXWIN/CWnd::CreateAccessibleProxy
- AFXWIN/CWnd::CreateCaret
- AFXWIN/CWnd::CreateControl
- AFXWIN/CWnd::CreateEx
- AFXWIN/CWnd::CreateGrayCaret
- AFXWIN/CWnd::CreateSolidCaret
- AFXWIN/CWnd::DeleteTempMap
- AFXWIN/CWnd::DestroyWindow
- AFXWIN/CWnd::Detach
- AFXWIN/CWnd::DlgDirList
- AFXWIN/CWnd::DlgDirListComboBox
- AFXWIN/CWnd::DlgDirSelect
- AFXWIN/CWnd::DlgDirSelectComboBox
- AFXWIN/CWnd::DragAcceptFiles
- AFXWIN/CWnd::DragDetect
- AFXWIN/CWnd::DrawAnimatedRects
- AFXWIN/CWnd::DrawCaption
- AFXWIN/CWnd::DrawMenuBar
- AFXWIN/CWnd::EnableActiveAccessibility
- AFXWIN/CWnd::EnableDynamicLayout
- AFXWIN/CWnd::EnableD2DSupport
- AFXWIN/CWnd::EnableScrollBar
- AFXWIN/CWnd::EnableScrollBarCtrl
- AFXWIN/CWnd::EnableToolTips
- AFXWIN/CWnd::EnableTrackingToolTips
- AFXWIN/CWnd::EnableWindow
- AFXWIN/CWnd::EndModalLoop
- AFXWIN/CWnd::EndModalState
- AFXWIN/CWnd::EndPaint
- AFXWIN/CWnd::ExecuteDlgInit
- AFXWIN/CWnd::FilterToolTipMessage
- AFXWIN/CWnd::FindWindow
- AFXWIN/CWnd::FindWindowEx
- AFXWIN/CWnd::FlashWindow
- AFXWIN/CWnd::FlashWindowEx
- AFXWIN/CWnd::FromHandle
- AFXWIN/CWnd::FromHandlePermanent
- AFXWIN/CWnd::get_accChild
- AFXWIN/CWnd::get_accChildCount
- AFXWIN/CWnd::get_accDefaultAction
- AFXWIN/CWnd::get_accDescription
- AFXWIN/CWnd::get_accFocus
- AFXWIN/CWnd::get_accHelp
- AFXWIN/CWnd::get_accHelpTopic
- AFXWIN/CWnd::get_accKeyboardShortcut
- AFXWIN/CWnd::get_accName
- AFXWIN/CWnd::get_accParent
- AFXWIN/CWnd::get_accRole
- AFXWIN/CWnd::get_accSelection
- AFXWIN/CWnd::get_accState
- AFXWIN/CWnd::get_accValue
- AFXWIN/CWnd::GetActiveWindow
- AFXWIN/CWnd::GetAncestor
- AFXWIN/CWnd::GetCapture
- AFXWIN/CWnd::GetCaretPos
- AFXWIN/CWnd::GetCheckedRadioButton
- AFXWIN/CWnd::GetClientRect
- AFXWIN/CWnd::GetClipboardOwner
- AFXWIN/CWnd::GetClipboardViewer
- AFXWIN/CWnd::GetControlUnknown
- AFXWIN/CWnd::GetDC
- AFXWIN/CWnd::GetDCEx
- AFXWIN/CWnd::GetDCRenderTarget
- AFXWIN/CWnd::GetDescendantWindow
- AFXWIN/CWnd::GetDesktopWindow
- AFXWIN/CWnd::GetDlgCtrlID
- AFXWIN/CWnd::GetDlgItem
- AFXWIN/CWnd::GetDlgItemInt
- AFXWIN/CWnd::GetDlgItemText
- AFXWIN/CWnd::GetDSCCursor
- AFXWIN/CWnd::GetDynamicLayout
- AFXWIN/CWnd::GetExStyle
- AFXWIN/CWnd::GetFocus
- AFXWIN/CWnd::GetFont
- AFXWIN/CWnd::GetForegroundWindow
- AFXWIN/CWnd::GetIcon
- AFXWIN/CWnd::GetLastActivePopup
- AFXWIN/CWnd::GetLayeredWindowAttributes
- AFXWIN/CWnd::GetMenu
- AFXWIN/CWnd::GetNextDlgGroupItem
- AFXWIN/CWnd::GetNextDlgTabItem
- AFXWIN/CWnd::GetNextWindow
- AFXWIN/CWnd::GetOleControlSite
- AFXWIN/CWnd::GetOpenClipboardWindow
- AFXWIN/CWnd::GetOwner
- AFXWIN/CWnd::GetParent
- AFXWIN/CWnd::GetParentFrame
- AFXWIN/CWnd::GetParentOwner
- AFXWIN/CWnd::GetProperty
- AFXWIN/CWnd::GetRenderTarget
- AFXWIN/CWnd::GetSafeHwnd
- AFXWIN/CWnd::GetSafeOwner
- AFXWIN/CWnd::GetScrollBarCtrl
- AFXWIN/CWnd::GetScrollBarInfo
- AFXWIN/CWnd::GetScrollInfo
- AFXWIN/CWnd::GetScrollLimit
- AFXWIN/CWnd::GetScrollPos
- AFXWIN/CWnd::GetScrollRange
- AFXWIN/CWnd::GetStyle
- AFXWIN/CWnd::GetSystemMenu
- AFXWIN/CWnd::GetTitleBarInfo
- AFXWIN/CWnd::GetTopLevelFrame
- AFXWIN/CWnd::GetTopLevelOwner
- AFXWIN/CWnd::GetTopLevelParent
- AFXWIN/CWnd::GetTopWindow
- AFXWIN/CWnd::GetUpdateRect
- AFXWIN/CWnd::GetUpdateRgn
- AFXWIN/CWnd::GetWindow
- AFXWIN/CWnd::GetWindowContextHelpId
- AFXWIN/CWnd::GetWindowDC
- AFXWIN/CWnd::GetWindowedChildCount
- AFXWIN/CWnd::GetWindowInfo
- AFXWIN/CWnd::GetWindowlessChildCount
- AFXWIN/CWnd::GetWindowPlacement
- AFXWIN/CWnd::GetWindowRect
- AFXWIN/CWnd::GetWindowRgn
- AFXWIN/CWnd::GetWindowText
- AFXWIN/CWnd::GetWindowTextLength
- AFXWIN/CWnd::HideCaret
- AFXWIN/CWnd::HiliteMenuItem
- AFXWIN/CWnd::HtmlHelp
- AFXWIN/CWnd::Invalidate
- AFXWIN/CWnd::InvalidateRect
- AFXWIN/CWnd::InvalidateRgn
- AFXWIN/CWnd::InvokeHelper
- AFXWIN/CWnd::IsChild
- AFXWIN/CWnd::IsD2DSupportEnabled
- AFXWIN/CWnd::IsDialogMessage
- AFXWIN/CWnd::IsDlgButtonChecked
- AFXWIN/CWnd::IsDynamicLayoutEnabled
- AFXWIN/CWnd::IsIconic
- AFXWIN/CWnd::IsTouchWindow
- AFXWIN/CWnd::IsWindowEnabled
- AFXWIN/CWnd::IsWindowVisible
- AFXWIN/CWnd::IsZoomed
- AFXWIN/CWnd::KillTimer
- AFXWIN/CWnd::LockWindowUpdate
- AFXWIN/CWnd::MapWindowPoints
- AFXWIN/CWnd::MessageBox
- AFXWIN/CWnd::ModifyStyle
- AFXWIN/CWnd::ModifyStyleEx
- AFXWIN/CWnd::MoveWindow
- AFXWIN/CWnd::NotifyWinEvent
- AFXWIN/CWnd::OnAmbientProperty
- AFXWIN/CWnd::OnDrawIconicThumbnailOrLivePreview
- AFXWIN/CWnd::OnHelp
- AFXWIN/CWnd::OnHelpFinder
- AFXWIN/CWnd::OnHelpIndex
- AFXWIN/CWnd::OnHelpUsing
- AFXWIN/CWnd::OnToolHitTest
- AFXWIN/CWnd::OpenClipboard
- AFXWIN/CWnd::PaintWindowlessControls
- AFXWIN/CWnd::PostMessage
- AFXWIN/CWnd::PreCreateWindow
- AFXWIN/CWnd::PreSubclassWindow
- AFXWIN/CWnd::PreTranslateMessage
- AFXWIN/CWnd::Print
- AFXWIN/CWnd::PrintClient
- AFXWIN/CWnd::PrintWindow
- AFXWIN/CWnd::RedrawWindow
- AFXWIN/CWnd::RegisterTouchWindow
- AFXWIN/CWnd::ReleaseDC
- AFXWIN/CWnd::RepositionBars
- AFXWIN/CWnd::RunModalLoop
- AFXWIN/CWnd::ScreenToClient
- AFXWIN/CWnd::ScrollWindow
- AFXWIN/CWnd::ScrollWindowEx
- AFXWIN/CWnd::SendChildNotifyLastMsg
- AFXWIN/CWnd::SendDlgItemMessage
- AFXWIN/CWnd::SendMessage
- AFXWIN/CWnd::SendMessageToDescendants
- AFXWIN/CWnd::SendNotifyMessage
- AFXWIN/CWnd::SetActiveWindow
- AFXWIN/CWnd::SetCapture
- AFXWIN/CWnd::SetCaretPos
- AFXWIN/CWnd::SetClipboardViewer
- AFXWIN/CWnd::SetDlgCtrlID
- AFXWIN/CWnd::SetDlgItemInt
- AFXWIN/CWnd::SetDlgItemText
- AFXWIN/CWnd::SetFocus
- AFXWIN/CWnd::SetFont
- AFXWIN/CWnd::SetForegroundWindow
- AFXWIN/CWnd::SetIcon
- AFXWIN/CWnd::SetLayeredWindowAttributes
- AFXWIN/CWnd::SetMenu
- AFXWIN/CWnd::SetOwner
- AFXWIN/CWnd::SetParent
- AFXWIN/CWnd::SetProperty
- AFXWIN/CWnd::SetRedraw
- AFXWIN/CWnd::SetScrollInfo
- AFXWIN/CWnd::SetScrollPos
- AFXWIN/CWnd::SetScrollRange
- AFXWIN/CWnd::SetTimer
- AFXWIN/CWnd::SetWindowContextHelpId
- AFXWIN/CWnd::SetWindowPlacement
- AFXWIN/CWnd::SetWindowPos
- AFXWIN/CWnd::SetWindowRgn
- AFXWIN/CWnd::SetWindowText
- AFXWIN/CWnd::ShowCaret
- AFXWIN/CWnd::ShowOwnedPopups
- AFXWIN/CWnd::ShowScrollBar
- AFXWIN/CWnd::ShowWindow
- AFXWIN/CWnd::SubclassDlgItem
- AFXWIN/CWnd::SubclassWindow
- AFXWIN/CWnd::UnlockWindowUpdate
- AFXWIN/CWnd::UnsubclassWindow
- AFXWIN/CWnd::UpdateData
- AFXWIN/CWnd::UpdateDialogControls
- AFXWIN/CWnd::UpdateLayeredWindow
- AFXWIN/CWnd::UpdateWindow
- AFXWIN/CWnd::ValidateRect
- AFXWIN/CWnd::ValidateRgn
- AFXWIN/CWnd::WindowFromPoint
- AFXWIN/CWnd::WinHelp
- AFXWIN/CWnd::Default
- AFXWIN/CWnd::DefWindowProc
- AFXWIN/CWnd::DoDataExchange
- AFXWIN/CWnd::GetCurrentMessage
- AFXWIN/CWnd::InitDynamicLayout
- AFXWIN/CWnd::LoadDynamicLayoutResource
- AFXWIN/CWnd::OnActivate
- AFXWIN/CWnd::OnActivateApp
- AFXWIN/CWnd::OnAppCommand
- AFXWIN/CWnd::OnAskCbFormatName
- AFXWIN/CWnd::OnCancelMode
- AFXWIN/CWnd::OnCaptureChanged
- AFXWIN/CWnd::OnChangeCbChain
- AFXWIN/CWnd::OnChangeUIState
- AFXWIN/CWnd::OnChar
- AFXWIN/CWnd::OnCharToItem
- AFXWIN/CWnd::OnChildActivate
- AFXWIN/CWnd::OnChildNotify
- AFXWIN/CWnd::OnClipboardUpdate
- AFXWIN/CWnd::OnClose
- AFXWIN/CWnd::OnColorizationColorChanged
- AFXWIN/CWnd::OnCommand
- AFXWIN/CWnd::OnCompacting
- AFXWIN/CWnd::OnCompareItem
- AFXWIN/CWnd::OnCompositionChanged
- AFXWIN/CWnd::OnContextMenu
- AFXWIN/CWnd::OnCopyData
- AFXWIN/CWnd::OnCreate
- AFXWIN/CWnd::OnCtlColor
- AFXWIN/CWnd::OnDeadChar
- AFXWIN/CWnd::OnDeleteItem
- AFXWIN/CWnd::OnDestroy
- AFXWIN/CWnd::OnDestroyClipboard
- AFXWIN/CWnd::OnDeviceChange
- AFXWIN/CWnd::OnDevModeChange
- AFXWIN/CWnd::OnDrawClipboard
- AFXWIN/CWnd::OnDrawItem
- AFXWIN/CWnd::OnDropFiles
- AFXWIN/CWnd::OnEnable
- AFXWIN/CWnd::OnEndSession
- AFXWIN/CWnd::OnEnterIdle
- AFXWIN/CWnd::OnEnterMenuLoop
- AFXWIN/CWnd::OnEnterSizeMove
- AFXWIN/CWnd::OnEraseBkgnd
- AFXWIN/CWnd::OnExitMenuLoop
- AFXWIN/CWnd::OnExitSizeMove
- AFXWIN/CWnd::OnFontChange
- AFXWIN/CWnd::OnGetDlgCode
- AFXWIN/CWnd::OnGetMinMaxInfo
- AFXWIN/CWnd::OnHelpInfo
- AFXWIN/CWnd::OnHotKey
- AFXWIN/CWnd::OnHScroll
- AFXWIN/CWnd::OnHScrollClipboard
- AFXWIN/CWnd::OnIconEraseBkgnd
- AFXWIN/CWnd::OnInitMenu
- AFXWIN/CWnd::OnInitMenuPopup
- AFXWIN/CWnd::OnInputDeviceChange
- AFXWIN/CWnd::OnInputLangChange
- AFXWIN/CWnd::OnInputLangChangeRequest
- AFXWIN/CWnd::OnKeyDown
- AFXWIN/CWnd::OnKeyUp
- AFXWIN/CWnd::OnKillFocus
- AFXWIN/CWnd::OnLButtonDblClk
- AFXWIN/CWnd::OnLButtonDown
- AFXWIN/CWnd::OnLButtonUp
- AFXWIN/CWnd::OnMButtonDblClk
- AFXWIN/CWnd::OnMButtonDown
- AFXWIN/CWnd::OnMButtonUp
- AFXWIN/CWnd::OnMDIActivate
- AFXWIN/CWnd::OnMeasureItem
- AFXWIN/CWnd::OnMenuChar
- AFXWIN/CWnd::OnMenuDrag
- AFXWIN/CWnd::OnMenuGetObject
- AFXWIN/CWnd::OnMenuRButtonUp
- AFXWIN/CWnd::OnMenuSelect
- AFXWIN/CWnd::OnMouseActivate
- AFXWIN/CWnd::OnMouseHover
- AFXWIN/CWnd::OnMouseHWheel
- AFXWIN/CWnd::OnMouseLeave
- AFXWIN/CWnd::OnMouseMove
- AFXWIN/CWnd::OnMouseWheel
- AFXWIN/CWnd::OnMove
- AFXWIN/CWnd::OnMoving
- AFXWIN/CWnd::OnNcActivate
- AFXWIN/CWnd::OnNcCalcSize
- AFXWIN/CWnd::OnNcCreate
- AFXWIN/CWnd::OnNcDestroy
- AFXWIN/CWnd::OnNcHitTest
- AFXWIN/CWnd::OnNcLButtonDblClk
- AFXWIN/CWnd::OnNcLButtonDown
- AFXWIN/CWnd::OnNcLButtonUp
- AFXWIN/CWnd::OnNcMButtonDblClk
- AFXWIN/CWnd::OnNcMButtonDown
- AFXWIN/CWnd::OnNcMButtonUp
- AFXWIN/CWnd::OnNcMouseHover
- AFXWIN/CWnd::OnNcMouseLeave
- AFXWIN/CWnd::OnNcMouseMove
- AFXWIN/CWnd::OnNcPaint
- AFXWIN/CWnd::OnNcRButtonDblClk
- AFXWIN/CWnd::OnNcRButtonDown
- AFXWIN/CWnd::OnNcRButtonUp
- AFXWIN/CWnd::OnNcRenderingChanged
- AFXWIN/CWnd::OnNcXButtonDblClk
- AFXWIN/CWnd::OnNcXButtonDown
- AFXWIN/CWnd::OnNcXButtonUp
- AFXWIN/CWnd::OnNextMenu
- AFXWIN/CWnd::OnNotify
- AFXWIN/CWnd::OnNotifyFormat
- AFXWIN/CWnd::OnPaint
- AFXWIN/CWnd::OnPaintClipboard
- AFXWIN/CWnd::OnPaletteChanged
- AFXWIN/CWnd::OnPaletteIsChanging
- AFXWIN/CWnd::OnParentNotify
- AFXWIN/CWnd::OnPowerBroadcast
- AFXWIN/CWnd::OnQueryDragIcon
- AFXWIN/CWnd::OnQueryEndSession
- AFXWIN/CWnd::OnQueryNewPalette
- AFXWIN/CWnd::OnQueryOpen
- AFXWIN/CWnd::OnQueryUIState
- AFXWIN/CWnd::OnRawInput
- AFXWIN/CWnd::OnRButtonDblClk
- AFXWIN/CWnd::OnRButtonDown
- AFXWIN/CWnd::OnRButtonUp
- AFXWIN/CWnd::OnRenderAllFormats
- AFXWIN/CWnd::OnRenderFormat
- AFXWIN/CWnd::OnSessionChange
- AFXWIN/CWnd::OnSetCursor
- AFXWIN/CWnd::OnSetFocus
- AFXWIN/CWnd::OnSettingChange
- AFXWIN/CWnd::OnShowWindow
- AFXWIN/CWnd::OnSize
- AFXWIN/CWnd::OnSizeClipboard
- AFXWIN/CWnd::OnSizing
- AFXWIN/CWnd::OnSpoolerStatus
- AFXWIN/CWnd::OnStyleChanged
- AFXWIN/CWnd::OnStyleChanging
- AFXWIN/CWnd::OnSysChar
- AFXWIN/CWnd::OnSysColorChange
- AFXWIN/CWnd::OnSysCommand
- AFXWIN/CWnd::OnSysDeadChar
- AFXWIN/CWnd::OnSysKeyDown
- AFXWIN/CWnd::OnSysKeyUp
- AFXWIN/CWnd::OnTCard
- AFXWIN/CWnd::OnTimeChange
- AFXWIN/CWnd::OnTimer
- AFXWIN/CWnd::OnTouchInput
- AFXWIN/CWnd::OnTouchInputs
- AFXWIN/CWnd::OnUniChar
- AFXWIN/CWnd::OnUnInitMenuPopup
- AFXWIN/CWnd::OnUpdateUIState
- AFXWIN/CWnd::OnUserChanged
- AFXWIN/CWnd::OnVKeyToItem
- AFXWIN/CWnd::OnVScroll
- AFXWIN/CWnd::OnVScrollClipboard
- AFXWIN/CWnd::OnWindowPosChanged
- AFXWIN/CWnd::OnWindowPosChanging
- AFXWIN/CWnd::OnWinIniChange
- AFXWIN/CWnd::OnWndMsg
- AFXWIN/CWnd::OnXButtonDblClk
- AFXWIN/CWnd::OnXButtonDown
- AFXWIN/CWnd::OnXButtonUp
- AFXWIN/CWnd::PostNcDestroy
- AFXWIN/CWnd::ReflectChildNotify
- AFXWIN/CWnd::ReflectLastMsg
- AFXWIN/CWnd::ResizeDynamicLayout
- AFXWIN/CWnd::WindowProc
- AFXWIN/CWnd::m_hWnd
helpviewer_keywords:
- CWnd [MFC], CWnd
- CWnd [MFC], accDoDefaultAction
- CWnd [MFC], accHitTest
- CWnd [MFC], accLocation
- CWnd [MFC], accNavigate
- CWnd [MFC], accSelect
- CWnd [MFC], AnimateWindow
- CWnd [MFC], ArrangeIconicWindows
- CWnd [MFC], Attach
- CWnd [MFC], BeginModalState
- CWnd [MFC], BeginPaint
- CWnd [MFC], BindDefaultProperty
- CWnd [MFC], BindProperty
- CWnd [MFC], BringWindowToTop
- CWnd [MFC], CalcWindowRect
- CWnd [MFC], CancelToolTips
- CWnd [MFC], CenterWindow
- CWnd [MFC], ChangeClipboardChain
- CWnd [MFC], CheckDlgButton
- CWnd [MFC], CheckRadioButton
- CWnd [MFC], ChildWindowFromPoint
- CWnd [MFC], ClientToScreen
- CWnd [MFC], CloseWindow
- CWnd [MFC], ContinueModal
- CWnd [MFC], Create
- CWnd [MFC], CreateAccessibleProxy
- CWnd [MFC], CreateCaret
- CWnd [MFC], CreateControl
- CWnd [MFC], CreateEx
- CWnd [MFC], CreateGrayCaret
- CWnd [MFC], CreateSolidCaret
- CWnd [MFC], DeleteTempMap
- CWnd [MFC], DestroyWindow
- CWnd [MFC], Detach
- CWnd [MFC], DlgDirList
- CWnd [MFC], DlgDirListComboBox
- CWnd [MFC], DlgDirSelect
- CWnd [MFC], DlgDirSelectComboBox
- CWnd [MFC], DragAcceptFiles
- CWnd [MFC], DragDetect
- CWnd [MFC], DrawAnimatedRects
- CWnd [MFC], DrawCaption
- CWnd [MFC], DrawMenuBar
- CWnd [MFC], EnableActiveAccessibility
- CWnd [MFC], EnableDynamicLayout
- CWnd [MFC], EnableD2DSupport
- CWnd [MFC], EnableScrollBar
- CWnd [MFC], EnableScrollBarCtrl
- CWnd [MFC], EnableToolTips
- CWnd [MFC], EnableTrackingToolTips
- CWnd [MFC], EnableWindow
- CWnd [MFC], EndModalLoop
- CWnd [MFC], EndModalState
- CWnd [MFC], EndPaint
- CWnd [MFC], ExecuteDlgInit
- CWnd [MFC], FilterToolTipMessage
- CWnd [MFC], FindWindow
- CWnd [MFC], FindWindowEx
- CWnd [MFC], FlashWindow
- CWnd [MFC], FlashWindowEx
- CWnd [MFC], FromHandle
- CWnd [MFC], FromHandlePermanent
- CWnd [MFC], get_accChild
- CWnd [MFC], get_accChildCount
- CWnd [MFC], get_accDefaultAction
- CWnd [MFC], get_accDescription
- CWnd [MFC], get_accFocus
- CWnd [MFC], get_accHelp
- CWnd [MFC], get_accHelpTopic
- CWnd [MFC], get_accKeyboardShortcut
- CWnd [MFC], get_accName
- CWnd [MFC], get_accParent
- CWnd [MFC], get_accRole
- CWnd [MFC], get_accSelection
- CWnd [MFC], get_accState
- CWnd [MFC], get_accValue
- CWnd [MFC], GetActiveWindow
- CWnd [MFC], GetAncestor
- CWnd [MFC], GetCapture
- CWnd [MFC], GetCaretPos
- CWnd [MFC], GetCheckedRadioButton
- CWnd [MFC], GetClientRect
- CWnd [MFC], GetClipboardOwner
- CWnd [MFC], GetClipboardViewer
- CWnd [MFC], GetControlUnknown
- CWnd [MFC], GetDC
- CWnd [MFC], GetDCEx
- CWnd [MFC], GetDCRenderTarget
- CWnd [MFC], GetDescendantWindow
- CWnd [MFC], GetDesktopWindow
- CWnd [MFC], GetDlgCtrlID
- CWnd [MFC], GetDlgItem
- CWnd [MFC], GetDlgItemInt
- CWnd [MFC], GetDlgItemText
- CWnd [MFC], GetDSCCursor
- CWnd [MFC], GetDynamicLayout
- CWnd [MFC], GetExStyle
- CWnd [MFC], GetFocus
- CWnd [MFC], GetFont
- CWnd [MFC], GetForegroundWindow
- CWnd [MFC], GetIcon
- CWnd [MFC], GetLastActivePopup
- CWnd [MFC], GetLayeredWindowAttributes
- CWnd [MFC], GetMenu
- CWnd [MFC], GetNextDlgGroupItem
- CWnd [MFC], GetNextDlgTabItem
- CWnd [MFC], GetNextWindow
- CWnd [MFC], GetOleControlSite
- CWnd [MFC], GetOpenClipboardWindow
- CWnd [MFC], GetOwner
- CWnd [MFC], GetParent
- CWnd [MFC], GetParentFrame
- CWnd [MFC], GetParentOwner
- CWnd [MFC], GetProperty
- CWnd [MFC], GetRenderTarget
- CWnd [MFC], GetSafeHwnd
- CWnd [MFC], GetSafeOwner
- CWnd [MFC], GetScrollBarCtrl
- CWnd [MFC], GetScrollBarInfo
- CWnd [MFC], GetScrollInfo
- CWnd [MFC], GetScrollLimit
- CWnd [MFC], GetScrollPos
- CWnd [MFC], GetScrollRange
- CWnd [MFC], GetStyle
- CWnd [MFC], GetSystemMenu
- CWnd [MFC], GetTitleBarInfo
- CWnd [MFC], GetTopLevelFrame
- CWnd [MFC], GetTopLevelOwner
- CWnd [MFC], GetTopLevelParent
- CWnd [MFC], GetTopWindow
- CWnd [MFC], GetUpdateRect
- CWnd [MFC], GetUpdateRgn
- CWnd [MFC], GetWindow
- CWnd [MFC], GetWindowContextHelpId
- CWnd [MFC], GetWindowDC
- CWnd [MFC], GetWindowedChildCount
- CWnd [MFC], GetWindowInfo
- CWnd [MFC], GetWindowlessChildCount
- CWnd [MFC], GetWindowPlacement
- CWnd [MFC], GetWindowRect
- CWnd [MFC], GetWindowRgn
- CWnd [MFC], GetWindowText
- CWnd [MFC], GetWindowTextLength
- CWnd [MFC], HideCaret
- CWnd [MFC], HiliteMenuItem
- CWnd [MFC], HtmlHelp
- CWnd [MFC], Invalidate
- CWnd [MFC], InvalidateRect
- CWnd [MFC], InvalidateRgn
- CWnd [MFC], InvokeHelper
- CWnd [MFC], IsChild
- CWnd [MFC], IsD2DSupportEnabled
- CWnd [MFC], IsDialogMessage
- CWnd [MFC], IsDlgButtonChecked
- CWnd [MFC], IsDynamicLayoutEnabled
- CWnd [MFC], IsIconic
- CWnd [MFC], IsTouchWindow
- CWnd [MFC], IsWindowEnabled
- CWnd [MFC], IsWindowVisible
- CWnd [MFC], IsZoomed
- CWnd [MFC], KillTimer
- CWnd [MFC], LockWindowUpdate
- CWnd [MFC], MapWindowPoints
- CWnd [MFC], MessageBox
- CWnd [MFC], ModifyStyle
- CWnd [MFC], ModifyStyleEx
- CWnd [MFC], MoveWindow
- CWnd [MFC], NotifyWinEvent
- CWnd [MFC], OnAmbientProperty
- CWnd [MFC], OnDrawIconicThumbnailOrLivePreview
- CWnd [MFC], OnHelp
- CWnd [MFC], OnHelpFinder
- CWnd [MFC], OnHelpIndex
- CWnd [MFC], OnHelpUsing
- CWnd [MFC], OnToolHitTest
- CWnd [MFC], OpenClipboard
- CWnd [MFC], PaintWindowlessControls
- CWnd [MFC], PostMessage
- CWnd [MFC], PreCreateWindow
- CWnd [MFC], PreSubclassWindow
- CWnd [MFC], PreTranslateMessage
- CWnd [MFC], Print
- CWnd [MFC], PrintClient
- CWnd [MFC], PrintWindow
- CWnd [MFC], RedrawWindow
- CWnd [MFC], RegisterTouchWindow
- CWnd [MFC], ReleaseDC
- CWnd [MFC], RepositionBars
- CWnd [MFC], RunModalLoop
- CWnd [MFC], ScreenToClient
- CWnd [MFC], ScrollWindow
- CWnd [MFC], ScrollWindowEx
- CWnd [MFC], SendChildNotifyLastMsg
- CWnd [MFC], SendDlgItemMessage
- CWnd [MFC], SendMessage
- CWnd [MFC], SendMessageToDescendants
- CWnd [MFC], SendNotifyMessage
- CWnd [MFC], SetActiveWindow
- CWnd [MFC], SetCapture
- CWnd [MFC], SetCaretPos
- CWnd [MFC], SetClipboardViewer
- CWnd [MFC], SetDlgCtrlID
- CWnd [MFC], SetDlgItemInt
- CWnd [MFC], SetDlgItemText
- CWnd [MFC], SetFocus
- CWnd [MFC], SetFont
- CWnd [MFC], SetForegroundWindow
- CWnd [MFC], SetIcon
- CWnd [MFC], SetLayeredWindowAttributes
- CWnd [MFC], SetMenu
- CWnd [MFC], SetOwner
- CWnd [MFC], SetParent
- CWnd [MFC], SetProperty
- CWnd [MFC], SetRedraw
- CWnd [MFC], SetScrollInfo
- CWnd [MFC], SetScrollPos
- CWnd [MFC], SetScrollRange
- CWnd [MFC], SetTimer
- CWnd [MFC], SetWindowContextHelpId
- CWnd [MFC], SetWindowPlacement
- CWnd [MFC], SetWindowPos
- CWnd [MFC], SetWindowRgn
- CWnd [MFC], SetWindowText
- CWnd [MFC], ShowCaret
- CWnd [MFC], ShowOwnedPopups
- CWnd [MFC], ShowScrollBar
- CWnd [MFC], ShowWindow
- CWnd [MFC], SubclassDlgItem
- CWnd [MFC], SubclassWindow
- CWnd [MFC], UnlockWindowUpdate
- CWnd [MFC], UnsubclassWindow
- CWnd [MFC], UpdateData
- CWnd [MFC], UpdateDialogControls
- CWnd [MFC], UpdateLayeredWindow
- CWnd [MFC], UpdateWindow
- CWnd [MFC], ValidateRect
- CWnd [MFC], ValidateRgn
- CWnd [MFC], WindowFromPoint
- CWnd [MFC], WinHelp
- CWnd [MFC], Default
- CWnd [MFC], DefWindowProc
- CWnd [MFC], DoDataExchange
- CWnd [MFC], GetCurrentMessage
- CWnd [MFC], InitDynamicLayout
- CWnd [MFC], LoadDynamicLayoutResource
- CWnd [MFC], OnActivate
- CWnd [MFC], OnActivateApp
- CWnd [MFC], OnAppCommand
- CWnd [MFC], OnAskCbFormatName
- CWnd [MFC], OnCancelMode
- CWnd [MFC], OnCaptureChanged
- CWnd [MFC], OnChangeCbChain
- CWnd [MFC], OnChangeUIState
- CWnd [MFC], OnChar
- CWnd [MFC], OnCharToItem
- CWnd [MFC], OnChildActivate
- CWnd [MFC], OnChildNotify
- CWnd [MFC], OnClipboardUpdate
- CWnd [MFC], OnClose
- CWnd [MFC], OnColorizationColorChanged
- CWnd [MFC], OnCommand
- CWnd [MFC], OnCompacting
- CWnd [MFC], OnCompareItem
- CWnd [MFC], OnCompositionChanged
- CWnd [MFC], OnContextMenu
- CWnd [MFC], OnCopyData
- CWnd [MFC], OnCreate
- CWnd [MFC], OnCtlColor
- CWnd [MFC], OnDeadChar
- CWnd [MFC], OnDeleteItem
- CWnd [MFC], OnDestroy
- CWnd [MFC], OnDestroyClipboard
- CWnd [MFC], OnDeviceChange
- CWnd [MFC], OnDevModeChange
- CWnd [MFC], OnDrawClipboard
- CWnd [MFC], OnDrawItem
- CWnd [MFC], OnDropFiles
- CWnd [MFC], OnEnable
- CWnd [MFC], OnEndSession
- CWnd [MFC], OnEnterIdle
- CWnd [MFC], OnEnterMenuLoop
- CWnd [MFC], OnEnterSizeMove
- CWnd [MFC], OnEraseBkgnd
- CWnd [MFC], OnExitMenuLoop
- CWnd [MFC], OnExitSizeMove
- CWnd [MFC], OnFontChange
- CWnd [MFC], OnGetDlgCode
- CWnd [MFC], OnGetMinMaxInfo
- CWnd [MFC], OnHelpInfo
- CWnd [MFC], OnHotKey
- CWnd [MFC], OnHScroll
- CWnd [MFC], OnHScrollClipboard
- CWnd [MFC], OnIconEraseBkgnd
- CWnd [MFC], OnInitMenu
- CWnd [MFC], OnInitMenuPopup
- CWnd [MFC], OnInputDeviceChange
- CWnd [MFC], OnInputLangChange
- CWnd [MFC], OnInputLangChangeRequest
- CWnd [MFC], OnKeyDown
- CWnd [MFC], OnKeyUp
- CWnd [MFC], OnKillFocus
- CWnd [MFC], OnLButtonDblClk
- CWnd [MFC], OnLButtonDown
- CWnd [MFC], OnLButtonUp
- CWnd [MFC], OnMButtonDblClk
- CWnd [MFC], OnMButtonDown
- CWnd [MFC], OnMButtonUp
- CWnd [MFC], OnMDIActivate
- CWnd [MFC], OnMeasureItem
- CWnd [MFC], OnMenuChar
- CWnd [MFC], OnMenuDrag
- CWnd [MFC], OnMenuGetObject
- CWnd [MFC], OnMenuRButtonUp
- CWnd [MFC], OnMenuSelect
- CWnd [MFC], OnMouseActivate
- CWnd [MFC], OnMouseHover
- CWnd [MFC], OnMouseHWheel
- CWnd [MFC], OnMouseLeave
- CWnd [MFC], OnMouseMove
- CWnd [MFC], OnMouseWheel
- CWnd [MFC], OnMove
- CWnd [MFC], OnMoving
- CWnd [MFC], OnNcActivate
- CWnd [MFC], OnNcCalcSize
- CWnd [MFC], OnNcCreate
- CWnd [MFC], OnNcDestroy
- CWnd [MFC], OnNcHitTest
- CWnd [MFC], OnNcLButtonDblClk
- CWnd [MFC], OnNcLButtonDown
- CWnd [MFC], OnNcLButtonUp
- CWnd [MFC], OnNcMButtonDblClk
- CWnd [MFC], OnNcMButtonDown
- CWnd [MFC], OnNcMButtonUp
- CWnd [MFC], OnNcMouseHover
- CWnd [MFC], OnNcMouseLeave
- CWnd [MFC], OnNcMouseMove
- CWnd [MFC], OnNcPaint
- CWnd [MFC], OnNcRButtonDblClk
- CWnd [MFC], OnNcRButtonDown
- CWnd [MFC], OnNcRButtonUp
- CWnd [MFC], OnNcRenderingChanged
- CWnd [MFC], OnNcXButtonDblClk
- CWnd [MFC], OnNcXButtonDown
- CWnd [MFC], OnNcXButtonUp
- CWnd [MFC], OnNextMenu
- CWnd [MFC], OnNotify
- CWnd [MFC], OnNotifyFormat
- CWnd [MFC], OnPaint
- CWnd [MFC], OnPaintClipboard
- CWnd [MFC], OnPaletteChanged
- CWnd [MFC], OnPaletteIsChanging
- CWnd [MFC], OnParentNotify
- CWnd [MFC], OnPowerBroadcast
- CWnd [MFC], OnQueryDragIcon
- CWnd [MFC], OnQueryEndSession
- CWnd [MFC], OnQueryNewPalette
- CWnd [MFC], OnQueryOpen
- CWnd [MFC], OnQueryUIState
- CWnd [MFC], OnRawInput
- CWnd [MFC], OnRButtonDblClk
- CWnd [MFC], OnRButtonDown
- CWnd [MFC], OnRButtonUp
- CWnd [MFC], OnRenderAllFormats
- CWnd [MFC], OnRenderFormat
- CWnd [MFC], OnSessionChange
- CWnd [MFC], OnSetCursor
- CWnd [MFC], OnSetFocus
- CWnd [MFC], OnSettingChange
- CWnd [MFC], OnShowWindow
- CWnd [MFC], OnSize
- CWnd [MFC], OnSizeClipboard
- CWnd [MFC], OnSizing
- CWnd [MFC], OnSpoolerStatus
- CWnd [MFC], OnStyleChanged
- CWnd [MFC], OnStyleChanging
- CWnd [MFC], OnSysChar
- CWnd [MFC], OnSysColorChange
- CWnd [MFC], OnSysCommand
- CWnd [MFC], OnSysDeadChar
- CWnd [MFC], OnSysKeyDown
- CWnd [MFC], OnSysKeyUp
- CWnd [MFC], OnTCard
- CWnd [MFC], OnTimeChange
- CWnd [MFC], OnTimer
- CWnd [MFC], OnTouchInput
- CWnd [MFC], OnTouchInputs
- CWnd [MFC], OnUniChar
- CWnd [MFC], OnUnInitMenuPopup
- CWnd [MFC], OnUpdateUIState
- CWnd [MFC], OnUserChanged
- CWnd [MFC], OnVKeyToItem
- CWnd [MFC], OnVScroll
- CWnd [MFC], OnVScrollClipboard
- CWnd [MFC], OnWindowPosChanged
- CWnd [MFC], OnWindowPosChanging
- CWnd [MFC], OnWinIniChange
- CWnd [MFC], OnWndMsg
- CWnd [MFC], OnXButtonDblClk
- CWnd [MFC], OnXButtonDown
- CWnd [MFC], OnXButtonUp
- CWnd [MFC], PostNcDestroy
- CWnd [MFC], ReflectChildNotify
- CWnd [MFC], ReflectLastMsg
- CWnd [MFC], ResizeDynamicLayout
- CWnd [MFC], WindowProc
- CWnd [MFC], m_hWnd
ms.assetid: 49a832ee-bc34-4126-88b3-bc1d9974f6c4
ms.openlocfilehash: 91acc8255cd5f22092790f9dcf45558012caf7dc
ms.sourcegitcommit: 46d24d6e70c03e05484923d9efc6ed5150e96a64
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/09/2019
ms.locfileid: "68916788"
---
# <a name="cwnd-class"></a>CWnd 類別

提供 MFC 程式庫中所有視窗類別的基本功能。

## <a name="syntax"></a>語法

```
class CWnd : public CCmdTarget
```

## <a name="members"></a>成員

### <a name="public-constructors"></a>公用建構函式

|名稱|描述|
|----------|-----------------|
|[CWnd::CWnd](#cwnd)|建構 `CWnd` 物件。|

### <a name="public-methods"></a>公用方法

|名稱|描述|
|----------|-----------------|
|[CWnd::accDoDefaultAction](#accdodefaultaction)|由架構呼叫以執行物件的預設動作。|
|[CWnd::accHitTest](#acchittest)|由架構呼叫以擷取畫面中給定點的子項目或子物件。|
|[CWnd::accLocation](#acclocation)|由架構呼叫以擷取指定物件目前畫面的位置。|
|[CWnd::accNavigate](#accnavigate)|由架構呼叫以便於周遊容器內的另一使用者介面項目並擷取物件 (如果可能)。|
|[CWnd::accSelect](#accselect)|由架構呼叫以修改選取或移動指定物件的鍵盤焦點。|
|[CWnd::AnimateWindow](#animatewindow)|建立相關聯的視窗物件的動畫。|
|[CWnd::ArrangeIconicWindows](#arrangeiconicwindows)|排列所有最小化 (圖示) 子視窗。|
|[CWnd::Attach](#attach)|將 Windows 控制代碼附加至 `CWnd` 物件。|
|[CWnd::BeginModalState](#beginmodalstate)|呼叫此成員函式以製作框架視窗強制回應。|
|[CWnd::BeginPaint](#beginpaint)|準備 `CWnd` 進行繪製。|
|[CWnd::BindDefaultProperty](#binddefaultproperty)|將呼叫物件的預設簡單繫結屬性 (在類型程式庫中標示)，繫結至資料來源控制項相關聯的游標。|
|[CWnd::BindProperty](#bindproperty)|將資料繫結控制項上的游標繫結屬性繫結至資料來源控制項，並註冊該關聯性與 MFC 繫結管理員。|
|[CWnd::BringWindowToTop](#bringwindowtotop)|將 `CWnd` 帶到重疊視窗堆疊的最上層。|
|[CWnd::CalcWindowRect](#calcwindowrect)|呼叫可從用戶端矩形計算視窗矩形。|
|[CWnd::CancelToolTips](#canceltooltips)|停用工具提示控制項。|
|[CWnd::CenterWindow](#centerwindow)|將相對於其父系的視窗置中。|
|[CWnd::ChangeClipboardChain](#changeclipboardchain)|從剪貼簿檢視器的鏈結中移除 `CWnd`。|
|[CWnd::CheckDlgButton](#checkdlgbutton)|在按鈕控制項旁放置核取記號，或從中移除核取記號。|
|[CWnd::CheckRadioButton](#checkradiobutton)|檢查指定的選項按鈕，及移除指定的按鈕群組中所有其他選項按鈕的核取記號。|
|[CWnd::ChildWindowFromPoint](#childwindowfrompoint)|判斷 (如果有的話) 是否有子視窗包含指定的點。|
|[CWnd::ClientToScreen](#clienttoscreen)|將畫面上指定的點或矩形的用戶端座標，轉換為螢幕座標。|
|[CWnd::CloseWindow](#closewindow)|將視窗最小化。|
|[CWnd::ContinueModal](#continuemodal)|繼續視窗的強制回應狀態。|
|[CWnd::Create](#create)|建立並初始化 `CWnd` 物件相關聯的子視窗。|
|[CWnd::CreateAccessibleProxy](#createaccessibleproxy)|建立指定物件的 Active Accessibility Proxy。|
|[CWnd::CreateCaret](#createcaret)|建立系統游標的新形狀，並取得插入號的擁有權。|
|[CWnd::CreateControl](#createcontrol)|建立將由 `CWnd` 物件在 MFC 程式中表示的 ActiveX 控制項。|
|[CWnd::CreateEx](#createex)|建立 Windows 重疊、快顯視窗或子視窗，並將其附加至 `CWnd` 物件。|
|[CWnd::CreateGrayCaret](#creategraycaret)|建立系統游標的灰色區塊，並取得插入號的擁有權。|
|[CWnd::CreateSolidCaret](#createsolidcaret)|建立系統游標的實心區塊，並取得插入號的擁有權。|
|[CWnd::DeleteTempMap](#deletetempmap)|由 `CWinApp` 閒置時間處理常式自動呼叫，並刪除 `FromHandle` 建立的任何暫存 `CWnd` 物件。|
|[CWnd::DestroyWindow](#destroywindow)|終結附加的 Windowd 視窗。|
|[CWnd::Detach](#detach)|從 `CWnd` 物件卸離 Windows 控制代碼，並傳回控制代碼。|
|[CWnd::DlgDirList](#dlgdirlist)|使用檔案或目錄清單填入清單方塊。|
|[CWnd::DlgDirListComboBox](#dlgdirlistcombobox)|使用檔案或目錄清單來填入下拉式方塊的清單方塊。|
|[CWnd::DlgDirSelect](#dlgdirselect)|從清單方塊擷取目前的選取範圍。|
|[CWnd::DlgDirSelectComboBox](#dlgdirselectcombobox)|從下拉式方塊的清單方塊中擷取目前的選取範圍。|
|[CWnd::DragAcceptFiles](#dragacceptfiles)|指出視窗將接受拖曳的檔案。|
|[CWnd::DragDetect](#dragdetect)|擷取滑鼠並追蹤其移動，直到使用者放開左側按鈕、按下 ESC 鍵，或將滑鼠移到指定點周圍的拖曳矩形外。|
|[CWnd::DrawAnimatedRects](#drawanimatedrects)|繪製框線矩形，並以動畫效果呈現它來指出圖示的開頭，或最小化或最大化視窗。|
|[CWnd::DrawCaption](#drawcaption)|繪製標題。|
|[CWnd::DrawMenuBar](#drawmenubar)|重新繪製功能表列。|
|[CWnd::EnableActiveAccessibility](#enableactiveaccessibility)|啟用使用者定義的 `Active Accessibility` 函式。|
|[CWnd::EnableDynamicLayout](#enabledynamiclayout)|可在使用者調整視窗大小時，動態調整子視窗的位置與大小。|
|[CWnd::EnableD2DSupport](#enabled2dsupport)|啟用或停用視窗 `D2D` 支援。 初始化主視窗之前先呼叫這個方法。|
|[CWnd::EnableScrollBar](#enablescrollbar)|啟用或停用一個捲軸的一或兩個箭號。|
|[CWnd::EnableScrollBarCtrl](#enablescrollbarctrl)|啟用或停用同層級捲軸控制項。|
|[CWnd::EnableToolTips](#enabletooltips)|啟用工具提示控制項。|
|[CWnd::EnableTrackingToolTips](#enabletrackingtooltips)|啟用追蹤模式中的工具提示控制項。|
|[CWnd::EnableWindow](#enablewindow)|啟用或停用滑鼠和鍵盤輸入。|
|[CWnd::EndModalLoop](#endmodalloop)|結束視窗的強制回應狀態。|
|[CWnd::EndModalState](#endmodalstate)|呼叫此成員函式，將框架視窗從強制回應變更為非強制回應。|
|[CWnd::EndPaint](#endpaint)|標記繪製的結束。|
|[CWnd::ExecuteDlgInit](#executedlginit)|初始化對話方塊資源。|
|[CWnd::FilterToolTipMessage](#filtertooltipmessage)|擷取對話方塊中控制項相關聯的標題或文字。|
|[CWnd::FindWindow](#findwindow)|傳回由其視窗名稱和視窗類別識別的視窗控制代碼。|
|[CWnd::FindWindowEx](#findwindowex)|傳回由其視窗名稱和視窗類別識別的視窗控制代碼。|
|[CWnd::FlashWindow](#flashwindow)|閃爍視窗一次。|
|[CWnd::FlashWindowEx](#flashwindowex)|閃爍視窗與其他功能。|
|[CWnd::FromHandle](#fromhandle)|將控制代碼提供給視窗時，將指標傳回至 `CWnd` 物件。 如果 `CWnd` 物件沒有附加至控制代碼，會建立並附加暫存 `CWnd` 物件。|
|[CWnd::FromHandlePermanent](#fromhandlepermanent)|將控制代碼提供給視窗時，將指標傳回至 `CWnd` 物件。 如果 `CWnd` 物件沒有附加至控制代碼，會建立並附加暫存 `CWnd` 物件。|
|[CWnd::get_accChild](#get_accchild)|由架構呼叫以擷取指定子系的 `IDispatch` 介面位址。|
|[CWnd::get_accChildCount](#get_accchildcount)|由架構呼叫以擷取屬於此物件的子物件數目。|
|[CWnd::get_accDefaultAction](#get_accdefaultaction)|由架構呼叫以擷取具有物件預設動作描述的字串。|
|[CWnd::get_accDescription](#get_accdescription)|由架構呼叫以擷取含有指定物件的視覺外觀描述的字串。|
|[CWnd::get_accFocus](#get_accfocus)|由架構呼叫以擷取具有鍵盤焦點的物件。|
|[CWnd::get_accHelp](#get_acchelp)|由架構呼叫以抓取物件的**Help**屬性字串。|
|[CWnd::get_accHelpTopic](#get_acchelptopic)|由架構呼叫以擷取 `WinHelp` 檔 (與指定物件和該檔案中適切主題的識別項關聯) 的完整路徑。|
|[CWnd::get_accKeyboardShortcut](#get_acckeyboardshortcut)|由架構呼叫以擷取指定物件的快速鍵或便捷鍵。|
|[CWnd::get_accName](#get_accname)|由架構呼叫以擷取指定物件的名稱。|
|[CWnd::get_accParent](#get_accparent)|由架構呼叫以擷取物件之父代的 `IDispatch` 介面。|
|[CWnd::get_accRole](#get_accrole)|由架構呼叫以擷取含有指定物件的角色描述資訊。|
|[CWnd::get_accSelection](#get_accselection)|由架構呼叫以擷取此物件的選取子物件。|
|[CWnd::get_accState](#get_accstate)|由架構呼叫以擷取指定物件的目前狀態。|
|[CWnd::get_accValue](#get_accvalue)|由架構呼叫以擷取指定物件的值。|
|[CWnd::GetActiveWindow](#getactivewindow)|擷取使用中視窗。|
|[CWnd::GetAncestor](#getancestor)|擷取指定視窗的上階視窗物件。|
|[CWnd::GetCapture](#getcapture)|擷取具有滑鼠捕捉的 `CWnd`。|
|[CWnd::GetCaretPos](#getcaretpos)|擷取插入號之目前位置的用戶端座標。|
|[CWnd::GetCheckedRadioButton](#getcheckedradiobutton)|傳回按鈕群組中目前核取的選項按鈕的識別碼。|
|[CWnd::GetClientRect](#getclientrect)|取得 `CWnd` 工作區的維度。|
|[CWnd::GetClipboardOwner](#getclipboardowner)|擷取剪貼簿的目前擁有者的指標。|
|[CWnd::GetClipboardViewer](#getclipboardviewer)|擷取剪貼簿檢視器鏈結中的第一個視窗的指標。|
|[CWnd::GetControlUnknown](#getcontrolunknown)|擷取至未知 ActiveX 控制項的指標。|
|[CWnd::GetDC](#getdc)|擷取工作區的顯示內容。|
|[CWnd::GetDCEx](#getdcex)|擷取工作區的顯示內容，並在繪製時啟用裁剪。|
|[CWnd::GetDCRenderTarget](#getdcrendertarget)|擷取裝置內容 (DC) 會呈現 `CWnd` 視窗的目標。|
|[CWnd::GetDescendantWindow](#getdescendantwindow)|搜尋所有下階視窗，並傳回具有指定識別碼的視窗。|
|[CWnd::GetDesktopWindow](#getdesktopwindow)|擷取 Windows 桌面視窗。|
|[CWnd::GetDlgCtrlID](#getdlgctrlid)|如果 `CWnd` 是子視窗，呼叫這個函式會傳回它的識別碼值。|
|[CWnd::GetDlgItem](#getdlgitem)|從指定的對話方塊中擷取具有指定識別碼的控制項。|
|[CWnd::GetDlgItemInt](#getdlgitemint)|將指定對話方塊中的控制項文字轉譯成整數值。|
|[CWnd::GetDlgItemText](#getdlgitemtext)|擷取與控制項相關聯的標題或文字。|
|[CWnd::GetDSCCursor](#getdsccursor)|擷取料來源控制項的 DataSource、UserName、Password 和 SQL 屬性所定義之基礎游標的指標。|
|[CWnd::GetDynamicLayout](#getdynamiclayout)|擷取動態配置管理員物件的指標。|
|[CWnd::GetExStyle](#getexstyle)|傳回視窗的延伸樣式。|
|[CWnd::GetFocus](#getfocus)|擷取目前具有輸入焦點的 `CWnd`。|
|[CWnd::GetFont](#getfont)|擷取目前的字型。|
|[CWnd::GetForegroundWindow](#getforegroundwindow)|讓指標回到前景視窗 (使用者目前使用的最上層視窗)。|
|[CWnd::GetIcon](#geticon)|擷取圖示的控制代碼。|
|[CWnd::GetLastActivePopup](#getlastactivepopup)|判斷 `CWnd` 擁有的快顯視窗哪一個是最近啟用的。|
|[CWnd::GetLayeredWindowAttributes](#getlayeredwindowattributes)|擷取分層視窗的不透明和透明色鍵。|
|[CWnd::GetMenu](#getmenu)|擷取指定功能表的指標。|
|[CWnd::GetNextDlgGroupItem](#getnextdlggroupitem)|搜尋控制項群組內的下一個 (或上一個) 控制項。|
|[CWnd::GetNextDlgTabItem](#getnextdlgtabitem)|使用緊接在指定控制項後面 (或之前) 的[WS_TABSTOP](styles-used-by-mfc.md#window-styles)樣式, 抓取第一個控制項。|
|[CWnd::GetNextWindow](#getnextwindow)|傳回視窗管理員清單中的下一個 (或上一個) 視窗。|
|[CWnd::GetOleControlSite](#getolecontrolsite)|擷取指定的 ActiveX 控制項的自訂網站。|
|[CWnd::GetOpenClipboardWindow](#getopenclipboardwindow)|擷取目前已開啟剪貼簿的視窗指標。|
|[CWnd::GetOwner](#getowner)|擷取 `CWnd` 擁有者的指標。|
|[CWnd::GetParent](#getparent)|擷取 `CWnd` 的父視窗 (如果有的話)。|
|[CWnd::GetParentFrame](#getparentframe)|擷取 `CWnd` 物件的父框架視窗。|
|[CWnd::GetParentOwner](#getparentowner)|傳回子視窗的父視窗指標。|
|[CWnd::GetProperty](#getproperty)|擷取 ActiveX 控制項屬性。|
|[CWnd::GetRenderTarget](#getrendertarget)|取得與此視窗相關聯的呈現目標。|
|[CWnd::GetSafeHwnd](#getsafehwnd)|傳回, 如果 this 指標是 null, 則為 null。 `m_hWnd`|
|[CWnd::GetSafeOwner](#getsafeowner)|擷取給定視窗的安全擁有者。|
|[CWnd::GetScrollBarCtrl](#getscrollbarctrl)|傳回一個同層級捲軸控制項。|
|[CWnd::GetScrollBarInfo](#getscrollbarinfo)|擷取所指定之捲軸的相關資訊。|
|[CWnd::GetScrollInfo](#getscrollinfo)|擷取 `SCROLLINFO` 結構維護的捲軸相關資訊。|
|[CWnd::GetScrollLimit](#getscrolllimit)|擷取捲軸的限制。|
|[CWnd::GetScrollPos](#getscrollpos)|擷取捲動方塊的目前位置。|
|[CWnd::GetScrollRange](#getscrollrange)|複製給定捲軸目前的最小和最大捲軸位置。|
|[CWnd::GetStyle](#getstyle)|傳回目前的視窗樣式。|
|[CWnd::GetSystemMenu](#getsystemmenu)|可讓應用程式存取控制功能表以進行複製和修改。|
|[CWnd::GetTitleBarInfo](#gettitlebarinfo)|擷取指定之標題列的相關資訊。|
|[CWnd::GetTopLevelFrame](#gettoplevelframe)|擷取視窗的最上層框架視窗。|
|[CWnd::GetTopLevelOwner](#gettoplevelowner)|擷取最上層視窗。|
|[CWnd::GetTopLevelParent](#gettoplevelparent)|擷取視窗的最上層父代。|
|[CWnd::GetTopWindow](#gettopwindow)|傳回屬於 `CWnd` 的第一個子視窗。|
|[CWnd::GetUpdateRect](#getupdaterect)|擷取完全圍住 `CWnd` 更新區域的最小矩形座標。|
|[CWnd::GetUpdateRgn](#getupdatergn)|擷取 `CWnd` 更新區域。|
|[CWnd::GetWindow](#getwindow)|傳回與此視窗具有指定關聯性的視窗。|
|[CWnd::GetWindowContextHelpId](#getwindowcontexthelpid)|擷取說明內容識別碼。|
|[CWnd::GetWindowDC](#getwindowdc)|擷取整個視窗的顯示內容，包括標題列、功能表和捲軸。|
|[CWnd::GetWindowedChildCount](#getwindowedchildcount)|傳回相關聯子視窗的數目。|
|[CWnd::GetWindowInfo](#getwindowinfo)|傳回視窗的相關資訊。|
|[CWnd::GetWindowlessChildCount](#getwindowlesschildcount)|傳回相關聯的無視窗子視窗數目。|
|[CWnd::GetWindowPlacement](#getwindowplacement)|擷取視窗的顯示狀態和一般 (還原)、最小化和最大化位置。|
|[CWnd::GetWindowRect](#getwindowrect)|取得 `CWnd` 的螢幕座標。|
|[CWnd::GetWindowRgn](#getwindowrgn)|擷取視窗的視窗區域複本。|
|[CWnd::GetWindowText](#getwindowtext)|傳回視窗文字或標題 (如果有的話)。|
|[CWnd::GetWindowTextLength](#getwindowtextlength)|傳回視窗的文字或標題的長度。|
|[CWnd::HideCaret](#hidecaret)|藉由從顯示畫面移除插入號來隱藏該插入號。|
|[CWnd:: HiliteMenuItem](#hilitemenuitem)|反白顯示或從最上層 (功能表列) 的功能表項目中移除反白顯示。|
|[CWnd::HtmlHelp](#htmlhelp)|呼叫以初始化 HTMLHelp 應用程式。|
|[CWnd::Invalidate](#invalidate)|使整個工作區失效。|
|[CWnd::InvalidateRect](#invalidaterect)|將矩形加入至目前的更新區域，使給定矩形內的工作區失效。|
|[CWnd::InvalidateRgn](#invalidatergn)|將區域加入至目前的更新區域，使給定區域內的工作區失效。|
|[CWnd::InvokeHelper](#invokehelper)|叫用 ActiveX 控制項方法或屬性。|
|[CWnd::IsChild](#ischild)|指出 `CWnd` 是子視窗，還是指定視窗的其他直屬下階。|
|[CWnd::IsD2DSupportEnabled](#isd2dsupportenabled)|判斷是否已啟用 D2D 支援。|
|[CWnd::IsDialogMessage](#isdialogmessage)|判斷指定的訊息是否適用於非強制回應對話方塊，若是則處理它。|
|[CWnd::IsDlgButtonChecked](#isdlgbuttonchecked)|決定是否核取按鈕控制項。|
|[CWnd::IsDynamicLayoutEnabled](#isdynamiclayoutenabled)|決定是否在這個視窗上啟用動態配置。 如果啟用動態配置時，則使用者可在調整父視窗大小時變更子視窗的位置與大小。|
|[CWnd::IsIconic](#isiconic)|決定是否將 `CWnd` 降到最低 (圖示)。|
|[CWnd::IsTouchWindow](#istouchwindow)|指定 `CWnd` 是否有觸控支援。|
|[CWnd::IsWindowEnabled](#iswindowenabled)|決定是否為滑鼠和鍵盤輸入啟用視窗。|
|[CWnd::IsWindowVisible](#iswindowvisible)|決定視窗是否可見。|
|[CWnd:: IsZoomed](#iszoomed)|決定是否將 `CWnd` 最大化。|
|[CWnd::KillTimer](#killtimer)|刪除系統計時器。|
|[CWnd::LockWindowUpdate](#lockwindowupdate)|停用或重新啟用在給定視窗中繪製。|
|[CWnd::MapWindowPoints](#mapwindowpoints)|將一組點從 `CWnd` 的座標空間轉換 (對應) 至另一個視窗的座標空間。|
|[CWnd::MessageBox](#messagebox)|建立並顯示視窗，其中包含應用程式提供的訊息和標題。|
|[CWnd::ModifyStyle](#modifystyle)|修改目前的視窗樣式。|
|[CWnd::ModifyStyleEx](#modifystyleex)|修改視窗的延伸樣式。|
|[CWnd::MoveWindow](#movewindow)|變更 `CWnd` 的位置和維度。|
|[CWnd::NotifyWinEvent](#notifywinevent)|表示發生預先定義之事件的系統。|
|[CWnd::OnAmbientProperty](#onambientproperty)|實作環境屬性值。|
|[CWnd::OnDrawIconicThumbnailOrLivePreview](#ondrawiconicthumbnailorlivepreview)|需要取得點陣圖，在 Windows 7 索引標籤上顯示為縮圖時，或顯示在用戶端上以查看應用程式時，由架構呼叫。|
|[CWnd::OnHelp](#onhelp)|在應用程式 (使用目前的內容) 中處理 F1 說明。|
|[CWnd::OnHelpFinder](#onhelpfinder)|處理 ID_HELP_FINDER 和 ID_DEFAULT_HELP 命令。|
|[CWnd::OnHelpIndex](#onhelpindex)|處理 ID_HELP_INDEX 命令, 並提供預設說明主題。|
|[CWnd::OnHelpUsing](#onhelpusing)|處理 ID_HELP_USING 命令。|
|[CWnd::OnToolHitTest](#ontoolhittest)|決定一個點是否位於指定工具的週框中並擷取工具的相關資訊。|
|[CWnd::OpenClipboard](#openclipboard)|開啟剪貼簿。 其他應用程式將無法修改剪貼簿, 直到呼叫 Windows [CloseClipboard](/windows/desktop/api/winuser/nf-winuser-closeclipboard)函式為止。|
|[CWnd::PaintWindowlessControls](#paintwindowlesscontrols)|在控制項容器上繪製無視窗控制項。|
|[CWnd::PostMessage](#postmessage)|在應用程式佇列中放置訊息，然後傳回，而不需等待視窗處理訊息。|
|[CWnd::PreCreateWindow](#precreatewindow)|在建立附加至此 `CWnd` 物件的 Windows 視窗前呼叫。|
|[CWnd::PreSubclassWindow](#presubclasswindow)|允許在呼叫[subclasswindow 前允許](#subclasswindow)之前, 先進行其他必要的子類別。|
|[CWnd::PreTranslateMessage](#pretranslatemessage)|由 `CWinApp` 使用，可先篩選視窗訊息，再將它們分派至 `TranslateMessage` 和 `DispatchMessage` Windows 函式。|
|[CWnd::Print](#print)|在指定的裝置內容中繪製目前的視窗。|
|[CWnd::PrintClient](#printclient)|在指定的裝置內容中繪製任何視窗 (通常是印表機裝置內容)。|
|[CWnd::PrintWindow](#printwindow)|將視覺視窗複製到指定的裝置內容，通常是印表機 DC。|
|[CWnd::RedrawWindow](#redrawwindow)|更新工作區中指定的矩形或區域。|
|[CWnd::RegisterTouchWindow](#registertouchwindow)|註冊/取消註冊視窗 Windows 觸控支援。|
|[CWnd::ReleaseDC](#releasedc)|釋放用戶端和視窗裝置內容，釋放這些內容供其他應用程式使用。|
|[CWnd::RepositionBars](#repositionbars)|工作區中的重新置放控制列。|
|[CWnd::RunModalLoop](#runmodalloop)|擷取、轉換或分派處於強制回應狀態之視窗的訊息。|
|[CWnd::ScreenToClient](#screentoclient)|將畫面上指定的點或矩形的螢幕座標，轉換為用戶端座標。|
|[CWnd::ScrollWindow](#scrollwindow)|捲動工作區的內容。|
|[CWnd::ScrollWindowEx](#scrollwindowex)|捲動工作區的內容。 類似於 `ScrollWindow`，但具有額外的功能。|
|[CWnd::SendChildNotifyLastMsg](#sendchildnotifylastmsg)|從父視窗中將通知訊息提供給子視窗，讓子視窗可以處理工作。|
|[CWnd::SendDlgItemMessage](#senddlgitemmessage)|將訊息傳送至指定的控制項。|
|[CWnd::SendMessage](#sendmessage)|傳送訊息給 `CWnd` 物件，在處理訊息後才會傳回。|
|[CWnd::SendMessageToDescendants](#sendmessagetodescendants)|傳送訊息給視窗的所有下階視窗。|
|[CWnd::SendNotifyMessage](#sendnotifymessage)|將指定的訊息傳送至視窗並儘速傳回，視呼叫執行緒是否建立視窗而定。|
|[CWnd::SetActiveWindow](#setactivewindow)|啟用視窗。|
|[CWnd::SetCapture](#setcapture)|導致所有後續滑鼠輸入傳送至 `CWnd`。|
|[CWnd::SetCaretPos](#setcaretpos)|將插入號移動到指定的位置。|
|[CWnd::SetClipboardViewer](#setclipboardviewer)|將 `CWnd` 新增到視窗的鏈結，每當剪貼簿的內容變更時就會通知這些視窗。|
|[CWnd::SetDlgCtrlID](#setdlgctrlid)|設定視窗或視窗的控制項識別碼 (這可以是任何子視窗，而不只是對話方塊中的控制項)。|
|[CWnd::SetDlgItemInt](#setdlgitemint)|將控制項的文字設為表示整數值的字串。|
|[CWnd::SetDlgItemText](#setdlgitemtext)|在指定的對話方塊中設定控制項的標題或文字。|
|[CWnd::SetFocus](#setfocus)|宣告輸入焦點。|
|[CWnd::SetFont](#setfont)|設定目前的字型。|
|[CWnd::SetForegroundWindow](#setforegroundwindow)|將建立視窗的執行緒放置到前景並啟動視窗。|
|[CWnd::SetIcon](#seticon)|將控制代碼設為特定的圖示。|
|[CWnd::SetLayeredWindowAttributes](#setlayeredwindowattributes)|設定分層視窗的不透明和透明色鍵。|
|[CWnd::SetMenu](#setmenu)|將功能表設定為指定的功能表。|
|[CWnd::SetOwner](#setowner)|變更 `CWnd` 的擁有者。|
|[CWnd::SetParent](#setparent)|變更父視窗。|
|[CWnd::SetProperty](#setproperty)|設定 ActiveX 控制項屬性。|
|[CWnd::SetRedraw](#setredraw)|允許重新繪製 `CWnd` 中的變更，或防止重新繪製進行變更。|
|[CWnd::SetScrollInfo](#setscrollinfo)|設定捲軸的相關資訊。|
|[CWnd::SetScrollPos](#setscrollpos)|設定捲動方塊的目前位置，而且如果指定，會重新繪製捲軸以反映新位置。|
|[CWnd::SetScrollRange](#setscrollrange)|設定給定捲軸的最小和最大位置值。|
|[CWnd::SetTimer](#settimer)|安裝會在觸發時傳送[WM_TIMER](#ontimer)訊息的系統計時器。|
|[CWnd::SetWindowContextHelpId](#setwindowcontexthelpid)|設定說明內容識別碼。|
|[CWnd::SetWindowPlacement](#setwindowplacement)|設定視窗的顯示狀態和一般 (還原)、最小化和最大化位置。|
|[CWnd::SetWindowPos](#setwindowpos)|變更大小、位置和子系順序、快顯視窗，和最上層視窗。|
|[CWnd::SetWindowRgn](#setwindowrgn)|設定視窗的區域。|
|[CWnd::SetWindowText](#setwindowtext)|將視窗文字或標題 (如果有的話) 設為指定的文字。|
|[CWnd::ShowCaret](#showcaret)|在畫面上插入號的目前位置上顯示插入號。 顯示後，插入號會開始自動閃爍。|
|[CWnd::ShowOwnedPopups](#showownedpopups)|顯示或隱藏視窗擁有的所有快顯視窗。|
|[CWnd::ShowScrollBar](#showscrollbar)|顯示或隱藏捲軸。|
|[CWnd::ShowWindow](#showwindow)|顯示或隱藏視窗。|
|[CWnd::SubclassDlgItem](#subclassdlgitem)|將 Windows 控制項附加至 `CWnd` 物件，並使其透過 `CWnd` 的訊息對應來路由訊息。|
|[CWnd::SubclassWindow](#subclasswindow)|將視窗附加至 `CWnd` 物件，並使其透過 `CWnd` 的訊息對應來路由訊息。|
|[CWnd::UnlockWindowUpdate](#unlockwindowupdate)|解除鎖定已使用 `CWnd::LockWindowUpdate` 鎖定的視窗。|
|[CWnd::UnsubclassWindow](#unsubclasswindow)|從`CWnd`物件卸離視窗|
|[CWnd::UpdateData](#updatedata)|從對話方塊中初始化或擷取資料。|
|[CWnd::UpdateDialogControls](#updatedialogcontrols)|呼叫以更新對話方塊按鈕和其他控制項的狀態。|
|[CWnd::UpdateLayeredWindow](#updatelayeredwindow)|更新分層視窗的位置、大小、形狀、內容和透明度。|
|[CWnd::UpdateWindow](#updatewindow)|更新工作區。|
|[CWnd::ValidateRect](#validaterect)|從目前的更新區域中移除矩形，驗證給定矩形內的工作區。|
|[CWnd::ValidateRgn](#validatergn)|從目前的更新區域中移除區域，驗證給定區域內的工作區。|
|[CWnd::WindowFromPoint](#windowfrompoint)|識別包含指定點的視窗。|
|[CWnd::WinHelp](#winhelp)|呼叫以初始化 WinHelp 應用程式。|

### <a name="protected-methods"></a>保護方法

|名稱|描述|
|----------|-----------------|
|[CWnd::Default](#default)|呼叫預設視窗程序，提供應用程式不會處理的任何視窗訊息的預設處理程序。|
|[CWnd::DefWindowProc](#defwindowproc)|呼叫預設視窗程序，提供應用程式不會處理的任何視窗訊息的預設處理程序。|
|[CWnd::DoDataExchange](#dodataexchange)|適用於對話方塊資料交換和驗證。 由 `UpdateData` 呼叫。|
|[CWnd::GetCurrentMessage](#getcurrentmessage)|傳回此視窗目前正在處理的訊息指標。 只能在*訊息*訊息處理常式成員`On`函式中呼叫。|
|[CWnd::InitDynamicLayout](#initdynamiclayout)|由架構呼叫以初始化視窗的動態配置。|
|[CWnd::LoadDynamicLayoutResource](#loaddynamiclayoutresource)|從資源檔載入動態配置資訊。|
|[CWnd::OnActivate](#onactivate)|當 `CWnd` 啟動或停用時呼叫。|
|[CWnd::OnActivateApp](#onactivateapp)|當應用程式即將啟動或停用時呼叫。|
|[CWnd::OnAppCommand](#onappcommand)|當使用者產生應用程式命令事件時呼叫。|
|[CWnd::OnAskCbFormatName](#onaskcbformatname)|當剪貼簿擁有者將顯示剪貼簿內容時，由剪貼簿檢視器應用程式呼叫。|
|[CWnd::OnCancelMode](#oncancelmode)|呼叫以讓 `CWnd` 取消任何內部的模式，例如滑鼠捕捉。|
|[CWnd::OnCaptureChanged](#oncapturechanged)|將訊息傳送至正失去滑鼠捕捉的視窗。|
|[CWnd::OnChangeCbChain](#onchangecbchain)|通知正在從鏈結中移除指定的視窗。|
|[CWnd::OnChangeUIState](#onchangeuistate)|應變更使用者介面 (UI) 狀態時呼叫。|
|[CWnd::OnChar](#onchar)|按鍵轉譯為非系統字元時呼叫。|
|[CWnd::OnCharToItem](#onchartoitem)|由具有[LBS_WANTKEYBOARDINPUT](../../mfc/reference/styles-used-by-mfc.md#list-box-styles)樣式以回應[WM_CHAR](#onchar)訊息的子清單方塊所呼叫。|
|[CWnd::OnChildActivate](#onchildactivate)|每當 `CWnd` 的大小或位置變更，或 `CWnd` 已啟動時，針對多重文件介面 (MDI) 子視窗呼叫。|
|[CWnd::OnChildNotify](#onchildnotify)|由父視窗呼叫，讓通知控制項有機會回應控制項通知。|
|[CWnd::OnClipboardUpdate](#onclipboardupdate)|於剪貼簿內容已變更時呼叫。|
|[CWnd::OnClose](#onclose)|呼叫以表示 `CWnd` 應該關閉。|
|[CWnd::OnColorizationColorChanged](#oncolorizationcolorchanged)|當非工作區的轉譯原則已變更時呼叫。|
|[CWnd::OnCommand](#oncommand)|當使用者選取命令時呼叫。|
|[CWnd::OnCompacting](#oncompacting)|當 Windows 偵測到系統記憶體過低時呼叫。|
|[CWnd::OnCompareItem](#oncompareitem)|呼叫以判斷子排序之主控描繪的下拉式方塊或清單方塊中新項目的相對位置。|
|[CWnd::OnCompositionChanged](#oncompositionchanged)|當桌面視窗管理員 (DWM) 組合啟用或停用時，為所有最上層視窗呼叫。|
|[CWnd::OnContextMenu](#oncontextmenu)|當使用者在視窗中按一下滑鼠右鍵時呼叫。|
|[CWnd::OnCopyData](#oncopydata)|在應用程式之間複製資料。|
|[CWnd::OnCreate](#oncreate)|在視窗建立過程中呼叫。|
|[CWnd::OnCtlColor](#onctlcolor)|即將繪製控制項時，如果`CWnd` 是控制項的父代則呼叫。|
|[CWnd::OnDeadChar](#ondeadchar)|當按鍵轉譯為非系統無效字元 (例如強調符號) 時呼叫。|
|[CWnd::OnDeleteItem](#ondeleteitem)|當主控描繪子清單方塊或下拉式方塊損毀，或從控制項移除項目時呼叫。|
|[CWnd::OnDestroy](#ondestroy)|`CWnd` 正在損毀時呼叫。|
|[CWnd::OnDestroyClipboard](#ondestroyclipboard)|當剪貼簿透過呼叫 Windows [EmptyClipboard](/windows/desktop/api/winuser/nf-winuser-emptyclipboard)函數清空時呼叫。|
|[CWnd::OnDeviceChange](#ondevicechange)|將裝置或電腦的硬體組態變更通知應用程式或裝置驅動程式。|
|[CWnd::OnDevModeChange](#ondevmodechange)|當使用者變更裝置模式設定時，針對所有最上層視窗呼叫。|
|[CWnd::OnDrawClipboard](#ondrawclipboard)|於剪貼簿內容變更時呼叫。|
|[CWnd::OnDrawItem](#ondrawitem)|主控描繪子按鈕控制項、下拉式方塊控制項、清單方塊控制項或功能表的視覺外觀必須繪製時呼叫。|
|[CWnd::OnDropFiles](#ondropfiles)|當使用者在視窗 (已本身註冊為捨棄檔案的收件者) 上放開滑鼠按鈕時呼叫。|
|[CWnd::OnEnable](#onenable)|啟用或停用 `CWnd` 時呼叫。|
|[CWnd::OnEndSession](#onendsession)|當工作階段正在結束時呼叫。|
|[CWnd::OnEnterIdle](#onenteridle)|呼叫此函式，可將強制回應對話方塊或功能表正在進入閒置狀態的訊息，通知應用程式的主視窗程序。|
|[CWnd::OnEnterMenuLoop](#onentermenuloop)|已進入功能表強制回應迴圈時呼叫。|
|[CWnd::OnEnterSizeMove](#onentersizemove)|在受影響的視窗進入移動或調整大小的強制回應迴圈後呼叫。|
|[CWnd::OnEraseBkgnd](#onerasebkgnd)|視窗背景需要清除時呼叫。|
|[CWnd::OnExitMenuLoop](#onexitmenuloop)|已結束功能表強制回應迴圈時呼叫。|
|[CWnd::OnExitSizeMove](#onexitsizemove)|在受影響的視窗結束移動或調整大小的強制回應迴圈後呼叫。|
|[CWnd::OnFontChange](#onfontchange)|字型資源的集區變更時呼叫。|
|[CWnd::OnGetDlgCode](#ongetdlgcode)|呼叫控制項，讓控制項可以處理方向鍵和 TAB 鍵輸入本身。|
|[CWnd::OnGetMinMaxInfo](#ongetminmaxinfo)|每當 Windows 必須知道最大化的位置或維度，或最小或最大的追蹤大小時呼叫。|
|[CWnd::OnHelpInfo](#onhelpinfo)|當使用者按下 F1 鍵時，由架構呼叫。|
|[CWnd::OnHotKey](#onhotkey)|當使用者按下全系統的便捷鍵時呼叫。|
|[CWnd::OnHScroll](#onhscroll)|當使用者按一下 `CWnd` 的水平捲軸時呼叫。|
|[CWnd::OnHScrollClipboard](#onhscrollclipboard)|當剪貼簿擁有者應該捲動剪貼簿影像、使適當的區段失效，及更新捲軸值時呼叫。|
|[CWnd::OnIconEraseBkgnd](#oniconerasebkgnd)|當 `CWnd` 減到最小 (圖示)，且必須先填入圖示的背景再繪製圖示時呼叫。|
|[CWnd::OnInitMenu](#oninitmenu)|當功能表即將變成現用時呼叫。|
|[CWnd::OnInitMenuPopup](#oninitmenupopup)|當快顯功能表即將變成現用時呼叫。|
|[CWnd::OnInputDeviceChange](#oninputdevicechange)|從系統中新增或移除 I/O 裝置時呼叫。|
|[CWnd::OnInputLangChange](#oninputlangchange)|在應用程式的輸入語言變更後呼叫。|
|[CWnd::OnInputLangChangeRequest](#oninputlangchangerequest)|當使用者選擇新的輸入語言時呼叫。|
|[CWnd::OnKeyDown](#onkeydown)|按下非系統鍵時呼叫。|
|[CWnd::OnKeyUp](#onkeyup)|放開非系統鍵時呼叫。|
|[CWnd::OnKillFocus](#onkillfocus)|在 `CWnd` 遺失輸入焦點前立即呼叫。|
|[CWnd::OnLButtonDblClk](#onlbuttondblclk)|當使用者按兩下滑鼠左鍵時呼叫。|
|[CWnd::OnLButtonDown](#onlbuttondown)|當使用者按下滑鼠左鍵時呼叫。|
|[CWnd::OnLButtonUp](#onlbuttonup)|當使用者放開滑鼠左鍵時呼叫。|
|[CWnd::OnMButtonDblClk](#onmbuttondblclk)|當使用者按兩下滑鼠中鍵時呼叫。|
|[CWnd::OnMButtonDown](#onmbuttondown)|當使用者按下滑鼠中鍵時呼叫。|
|[CWnd::OnMButtonUp](#onmbuttonup)|當使用者放開滑鼠中鍵時呼叫。|
|[CWnd::OnMDIActivate](#onmdiactivate)|當 MDI 子視窗啟用或停用時呼叫。|
|[CWnd::OnMeasureItem](#onmeasureitem)|建立控制項時，針對主控描繪子下拉式方塊、清單方塊或功能表項目呼叫。 `CWnd` 會將控制項維度通知 Windows。|
|[CWnd::OnMenuChar](#onmenuchar)|當使用者按下功能表的助憶鍵字元，且該字元不符合目前功能表中任何預先定義的助憶鍵時呼叫。|
|[CWnd::OnMenuDrag](#onmenudrag)|當使用者開始拖曳功能表項目時呼叫。|
|[CWnd::OnMenuGetObject](#onmenugetobject)|當滑鼠游標進入功能表項目，或從項目中央移到項目上方或下方時呼叫。|
|[CWnd::OnMenuRButtonUp](#onmenurbuttonup)|當游標位於功能表項目上，而使用者放開滑鼠右鍵時呼叫。|
|[CWnd::OnMenuSelect](#onmenuselect)|當使用者選取功能表項目時呼叫。|
|[CWnd::OnMouseActivate](#onmouseactivate)|當游標處於非使用中視窗，且使用者按下滑鼠按鈕時呼叫。|
|[CWnd::OnMouseHover](#onmousehover)|當游標停留在先前呼叫中指定的時間週期 視窗的工作區時呼叫[TrackMouseEvent](/windows/desktop/api/winuser/nf-winuser-trackmouseevent)。|
|[CWnd::OnMouseHWheel](#onmousehwheel)|當目前的視窗由桌面視窗管理員 (DWM) 組成，且該視窗最大化時呼叫。|
|[CWnd::OnMouseLeave](#onmouseleave)|當游標離開先前呼叫[TrackMouseEvent](/windows/desktop/api/winuser/nf-winuser-trackmouseevent)中指定之視窗的工作區時呼叫。|
|[CWnd::OnMouseMove](#onmousemove)|當滑鼠游標移動時呼叫。|
|[CWnd::OnMouseWheel](#onmousewheel)|當使用者旋轉滑鼠滾輪時呼叫。 使用 Windows NT 4.0 訊息處理。|
|[CWnd::OnMove](#onmove)|在 `CWnd` 的位置變更後呼叫。|
|[CWnd::OnMoving](#onmoving)|指出使用者正在移動 `CWnd` 物件。|
|[CWnd::OnNcActivate](#onncactivate)|當非工作區需要變更以表示作用中或非作用中狀態時呼叫。|
|[CWnd::OnNcCalcSize](#onnccalcsize)|需要計算工作區的大小和位置時呼叫。|
|[CWnd::OnNcCreate](#onnccreate)|建立非工作區時, 在[OnCreate](#oncreate)之前呼叫。|
|[CWnd::OnNcDestroy](#onncdestroy)|當非工作區正在損毀時呼叫。|
|[CWnd::OnNcHitTest](#onnchittest)|每次移動滑鼠時，如果 `CWnd` 包含游標，或已使用 `SetCapture` 擷取滑鼠輸入時呼叫。|
|[CWnd::OnNcLButtonDblClk](#onnclbuttondblclk)|當使用者按兩下滑鼠左鍵，而游標位於 `CWnd` 的非工作區內時呼叫。|
|[CWnd::OnNcLButtonDown](#onnclbuttondown)|當使用者按下滑鼠左鍵，而游標位於 `CWnd` 的非工作區內時呼叫。|
|[CWnd::OnNcLButtonUp](#onnclbuttonup)|當使用者放開滑鼠左鍵，而游標位於 `CWnd` 的非工作區內時呼叫。|
|[CWnd::OnNcMButtonDblClk](#onncmbuttondblclk)|當使用者按兩下滑鼠中鍵，而游標位於 `CWnd` 的非工作區內時呼叫。|
|[CWnd::OnNcMButtonDown](#onncmbuttondown)|當使用者按下滑鼠中鍵，而游標位於 `CWnd` 的非工作區內時呼叫。|
|[CWnd::OnNcMButtonUp](#onncmbuttonup)|當使用者放開滑鼠中鍵，而游標位於 `CWnd` 的非工作區內時呼叫。|
|[CWnd::OnNcMouseHover](#onncmousehover)|當游標停留在視窗的非工作區上, 且在先前呼叫[TrackMouseEvent](/windows/desktop/api/winuser/nf-winuser-trackmouseevent)中指定的期間內時呼叫。|
|[CWnd::OnNcMouseLeave](#onncmouseleave)|當游標離開先前呼叫[TrackMouseEvent](/windows/desktop/api/winuser/nf-winuser-trackmouseevent)中指定之視窗的非工作區時, 架構會呼叫這個成員函式。|
|[CWnd::OnNcMouseMove](#onncmousemove)|當游標在 `CWnd` 的非工作區內移動時呼叫。|
|[CWnd::OnNcPaint](#onncpaint)|當非工作區需要繪製時呼叫。|
|[CWnd::OnNcRButtonDblClk](#onncrbuttondblclk)|當使用者按兩下滑鼠右鍵，而游標位於 `CWnd` 的非工作區內時呼叫。|
|[CWnd::OnNcRButtonDown](#onncrbuttondown)|當使用者按下滑鼠右鍵，而游標位於 `CWnd` 的非工作區內時呼叫。|
|[CWnd::OnNcRButtonUp](#onncrbuttonup)|當使用者放開滑鼠右鍵，而游標位於 `CWnd` 的非工作區內時呼叫。|
|[CWnd::OnNcRenderingChanged](#onncrenderingchanged)|當非工作區的轉譯原則已變更時呼叫。|
|[CWnd::OnNcXButtonDblClk](#onncxbuttondblclk)|當使用者按兩下 XBUTTON1 或 XBUTTON2，而游標位於視窗的非工作區時呼叫。|
|[CWnd::OnNcXButtonDown](#onncxbuttondown)|當使用者按下滑鼠的 XBUTTON1 或 XBUTTON2，而游標位於視窗的非工作區時呼叫。|
|[CWnd::OnNcXButtonUp](#onncxbuttonup)|當使用者放開滑鼠的 XBUTTON1 或 XBUTTON2，而游標位於視窗的非工作區時呼叫。|
|[CWnd::OnNextMenu](#onnextmenu)|當使用向右鍵或向左鍵切換功能表列和系統功能表時呼叫。|
|[CWnd::OnNotify](#onnotify)|由架構呼叫，將其中一個控制項已發生的事件，或控制項需要資訊等狀況通知父視窗。|
|[CWnd::OnNotifyFormat](#onnotifyformat)|呼叫以決定目前視窗的 WM_NOTIFY 通知訊息中是否接受 ANSI 或 Unicode 結構。|
|[CWnd::OnPaint](#onpaint)|呼叫以重新繪製視窗的一部份。|
|[CWnd::OnPaintClipboard](#onpaintclipboard)|當需要重新繪製剪貼簿檢視器的工作區時呼叫。|
|[CWnd::OnPaletteChanged](#onpalettechanged)|呼叫以允許使用調色盤的視窗調整其邏輯色板的大小，並更新其工作區。|
|[CWnd::OnPaletteIsChanging](#onpaletteischanging)|當應用程式即將實現其邏輯色板時通知其他應用程式。|
|[CWnd::OnParentNotify](#onparentnotify)|建立或終結子視窗時，或當使用者按一下滑鼠按鈕，而游標移至子視窗上方時，進行呼叫。|
|[CWnd::OnPowerBroadcast](#onpowerbroadcast)|電源管理事件發生時呼叫。|
|[CWnd::OnQueryDragIcon](#onquerydragicon)|最小化 (圖示化) `CWnd` 即將由使用者拖曳時呼叫。|
|[CWnd::OnQueryEndSession](#onqueryendsession)|當使用者選擇結束 Windows 工作階段時呼叫。|
|[CWnd::OnQueryNewPalette](#onquerynewpalette)|通知 `CWnd` 即將接收輸入焦點。|
|[CWnd::OnQueryOpen](#onqueryopen)|當 `CWnd` 是圖示，且使用者要求開啟圖示時呼叫。|
|[CWnd::OnQueryUIState](#onqueryuistate)|呼叫以擷取視窗的使用者介面 (UI) 狀態。|
|[CWnd::OnRawInput](#onrawinput)|當目前視窗取得原始輸入時呼叫。|
|[CWnd::OnRButtonDblClk](#onrbuttondblclk)|當使用者按兩下滑鼠右鍵時呼叫。|
|[CWnd::OnRButtonDown](#onrbuttondown)|當使用者按下滑鼠右鍵時呼叫。|
|[CWnd::OnRButtonUp](#onrbuttonup)|當使用者放開滑鼠右鍵時呼叫。|
|[CWnd::OnRenderAllFormats](#onrenderallformats)|當擁有者應用程式正在被破壞，而且需要呈現其所有格式時呼叫。|
|[CWnd::OnRenderFormat](#onrenderformat)|需要呈現具有延遲轉譯需求的特定格式時，針對剪貼簿擁有者呼叫。|
|[CWnd::OnSessionChange](#onsessionchange)|呼叫以將工作階段狀態的變更通知應用程式。|
|[CWnd::OnSetCursor](#onsetcursor)|如果不擷取滑鼠輸入，而且滑鼠導致游標在視窗內移動，則呼叫。|
|[CWnd::OnSetFocus](#onsetfocus)|在 `CWnd` 取得輸入焦點後呼叫。|
|[CWnd::OnSettingChange](#onsettingchange)|當 Win32 `SystemParametersInfo` 函式變更整個系統的設定時呼叫。|
|[CWnd::OnShowWindow](#onshowwindow)|當 `CWnd` 要隱藏或顯示時呼叫。|
|[CWnd::OnSize](#onsize)|在 `CWnd` 大小變更後呼叫。|
|[CWnd::OnSizeClipboard](#onsizeclipboard)|當剪貼簿檢視器視窗中的工作區大小變更後呼叫。|
|[CWnd::OnSizing](#onsizing)|表示使用者正在重新調整矩形的大小。|
|[CWnd::OnSpoolerStatus](#onspoolerstatus)|每當加入工作或從列印管理員佇列中移除工作時，從列印管理員呼叫。|
|[CWnd::OnStyleChanged](#onstylechanged)|表示[SetWindowLong](/windows/desktop/api/winuser/nf-winuser-setwindowlonga) Windows 函式已變更一或多個視窗的樣式。|
|[CWnd::OnStyleChanging](#onstylechanging)|表示[SetWindowLong](/windows/desktop/api/winuser/nf-winuser-setwindowlonga) Windows 函數即將變更一或多個視窗的樣式。|
|[CWnd::OnSysChar](#onsyschar)|按鍵轉譯為系統字元時呼叫。|
|[CWnd::OnSysColorChange](#onsyscolorchange)|當系統色彩設定中進行變更時，為所有最上層視窗呼叫。|
|[CWnd::OnSysCommand](#onsyscommand)|當使用者從 [控制] 功能表中選取命令時，或在使用者選取 [最大化] 或 [最小化] 按鈕時呼叫。|
|[CWnd::OnSysDeadChar](#onsysdeadchar)|當按鍵轉譯為系統無效字元 (例如強調符號) 時呼叫。|
|[CWnd::OnSysKeyDown](#onsyskeydown)|當使用者按住 ALT 鍵，然後按下另一個按鍵時呼叫。|
|[CWnd::OnSysKeyUp](#onsyskeyup)|當使用者在按住 ALT 鍵時放開按下的按鍵時呼叫。|
|[CWnd::OnTCard](#ontcard)|使用者按一下可設計的按鈕時呼叫。|
|[CWnd::OnTimeChange](#ontimechange)|在系統時間變更後，針對所有最上層視窗呼叫。|
|[CWnd::OnTimer](#ontimer)|在[SetTimer](#settimer)中指定的每個間隔之後呼叫。|
|[CWnd::OnTouchInput](#ontouchinput)|處理來自 Windows 觸控的單一輸入。|
|[CWnd::OnTouchInputs](#ontouchinputs)|處理來自 Windows 觸控的輸入。|
|[CWnd::OnUniChar](#onunichar)|按下按鍵時呼叫。 也就是說, 目前視窗具有鍵盤焦點, 而[WM_KEYDOWN](/windows/desktop/inputdev/wm-keydown)訊息則是由[TranslateMessage](/windows/desktop/api/winuser/nf-winuser-translatemessage)函數轉譯。|
|[CWnd::OnUnInitMenuPopup](#onuninitmenupopup)|於下拉式功能表或子功能表被終結時呼叫。|
|[CWnd::OnUpdateUIState](#onupdateuistate)|呼叫以變更指定的視窗及其所有子視窗的使用者介面 (UI) 狀態。|
|[CWnd::OnUserChanged](#onuserchanged)|在使用者登入或登出後呼叫。|
|[CWnd::OnVKeyToItem](#onvkeytoitem)|由所擁有`CWnd`的清單方塊呼叫, 以回應[WM_KEYDOWN](#onkeydown)訊息。|
|[CWnd::OnVScroll](#onvscroll)|當使用者按一下視窗的垂直捲軸時呼叫。|
|[CWnd::OnVScrollClipboard](#onvscrollclipboard)|當擁有者應該捲動剪貼簿影像、使適當的區段失效，及更新捲軸值時呼叫。|
|[CWnd::OnWindowPosChanged](#onwindowposchanged)|當大小、位置或迭置順序因呼叫[SetWindowPos](#setwindowpos)或另一個視窗管理函式而變更時呼叫。|
|[CWnd::OnWindowPosChanging](#onwindowposchanging)|當大小、位置或迭置順序即將因呼叫[SetWindowPos](#setwindowpos)或另一個視窗管理函式而變更時呼叫。|
|[CWnd::OnWinIniChange](#onwininichange)|在 Windows 初始化檔案 (WIN.INI) 變更後，針所有最上層視窗呼叫。|
|[CWnd::OnWndMsg](#onwndmsg)|指出是否已處理視窗訊息。|
|[CWnd::OnXButtonDblClk](#onxbuttondblclk)|當使用者按兩下 XBUTTON1 或 XBUTTON2，而游標位於視窗的工作區時呼叫。|
|[CWnd::OnXButtonDown](#onxbuttondown)|當使用者按下 XBUTTON1 或 XBUTTON2，而游標位於視窗的工作區時呼叫。|
|[CWnd::OnXButtonUp](#onxbuttonup)|當使用者放開 XBUTTON1 或 XBUTTON2，而游標位於視窗的工作區時呼叫。|
|[CWnd::PostNcDestroy](#postncdestroy)|在終結視窗之後, 預設[OnNcDestroy](#onncdestroy)函式會呼叫這個虛擬函式。|
|[CWnd::ReflectChildNotify](#reflectchildnotify)|將訊息反映至其來源的 Helper 函式。|
|[CWnd::ReflectLastMsg](#reflectlastmsg)|將最後一個訊息反映到子視窗。|
|[CWnd::ResizeDynamicLayout](#resizedynamiclayout)|如果已啟用視窗的動態配置，則會在視窗大小變更以調整子視窗的版面配置時由架構呼叫。|
|[CWnd::WindowProc](#windowproc)|提供 `CWnd` 的視窗程序。 透過訊息對應的預設分派訊息。|

### <a name="public-operators"></a>公用運算子

|名稱|描述|
|----------|-----------------|
|[CWnd:: operator HWND](#operator_hwnd)|呼叫以取得視窗的控制代碼。|
|[CWnd:: operator! =](#operator_neq)|判斷視窗是否與其控制碼為[m_hWnd](#m_hwnd)的視窗不同。|
|[CWnd:: operator = =](#operator_eq_eq)|判斷視窗是否與其控制碼為[m_hWnd](#m_hwnd)的視窗相同。|

### <a name="public-data-members"></a>公用資料成員

|名稱|描述|
|----------|-----------------|
|[CWnd::m_hWnd](#m_hwnd)|表示附加至這個`CWnd`的 HWND。|

## <a name="remarks"></a>備註

`CWnd` 物件不同於 Windows 視窗，但兩者緊密連結。 `CWnd` 物件是由 `CWnd` 建構函式和解構函式所建立或終結。 另一方面, windows 視窗是由`Create`成員函式所建立並`CWnd`由虛擬析構函式終結的 windows 內部資料結構。 [DestroyWindow](#destroywindow)函式會終結 Windows 視窗, 而不會終結物件。

類別和訊息對應機制會`WndProc`隱藏函式。 `CWnd` 傳入的 Windows 通知訊息會透過訊息對應自動路由至<em>訊息</em> `CWnd`成員函式**上**適當的。 您可以覆寫**On**<em>Message</em>成員函式, 以處理衍生類別中的成員特定訊息。

`CWnd` 類別也可讓您建立應用程式的 Windows 子視窗。 自 `CWnd` 衍生類別，然後將成員變數加入至衍生類別以儲存應用程式的特定資料。 實作訊息處理常式成員函式，和衍生類別中對應的訊息，以指定訊息被導向至視窗時會發生什麼事。

您在兩個步驟中建立子視窗。 首先`CWnd` , 呼叫函式`CWnd`來建立物件, 然後呼叫[create](#create)成員函式來建立`CWnd`子視窗, 並將它附加至物件。

當使用者終止子視窗時，摧毀 `CWnd` 物件，或呼叫 `DestroyWindow` 成員函式來移除視窗並摧毀其資料結構。

在 Microsoft Foundation 類別庫中，會自 `CWnd` 衍生進一步類別以提供特定的視窗類型。 其中許多類別 (包括[CFrameWnd](../../mfc/reference/cframewnd-class.md)、 [CMDIFrameWnd](../../mfc/reference/cmdiframewnd-class.md)、 [CMDIChildWnd](../../mfc/reference/cmdichildwnd-class.md)、 [CView](../../mfc/reference/cview-class.md)和[CDialog](../../mfc/reference/cdialog-class.md)) 都是針對進一步的衍生而設計的。 衍生自`CWnd`的控制項類別 (例如[CButton](../../mfc/reference/cbutton-class.md)) 可以直接使用, 或可用於類別的進一步衍生。

如需使用`CWnd`的詳細資訊, 請參閱[框架視窗](../../mfc/frame-windows.md)和[視窗物件](../../mfc/window-objects.md)。

## <a name="inheritance-hierarchy"></a>繼承階層

[CObject](../../mfc/reference/cobject-class.md)

[CCmdTarget](../../mfc/reference/ccmdtarget-class.md)

`CWnd`

## <a name="requirements"></a>需求

**標題:** afxwin.h

##  <a name="accdodefaultaction"></a>  CWnd::accDoDefaultAction

由架構呼叫以執行物件的預設動作。

```
virtual HRESULT accDoDefaultAction(VARIANT varChild);
```

### <a name="parameters"></a>參數

*varChild*<br/>
指定要叫用的預設動作是物件的還是物件的其中一個子專案。 這個參數可以是 CHILDID_SELF (用來執行物件的預設動作) 或子 ID (以執行物件的其中一個子專案的預設動作)。

### <a name="return-value"></a>傳回值

在成功時傳回 S_OK, 失敗時傳回 COM 錯誤碼。 請參閱 Windows SDK 的[IAccessible:: accDoDefaultAction](/windows/desktop/api/oleacc/nf-oleacc-iaccessible-accdodefaultaction)中的傳回**值**。

### <a name="remarks"></a>備註

此函式是 MFC [Active Accessibility](/windows/desktop/WinAuto/microsoft-active-accessibility)支援的一部分。

覆寫衍生類別中`CWnd`的這個函式, 以執行物件的預設動作。 如需詳細資訊, 請參閱 Windows SDK 中的[IAccessible:: accDoDefaultAction](/windows/desktop/api/oleacc/nf-oleacc-iaccessible-accdodefaultaction) 。

##  <a name="acchittest"></a>  CWnd::accHitTest

由架構呼叫以擷取畫面中給定點的子項目或子物件。

```
virtual HRESULT accHitTest(
    long xLeft,
    long yTop,
    VARIANT* pvarChild);
```

### <a name="parameters"></a>參數

*xLeft*<br/>
要點擊測試之點的 X 座標 (以螢幕單位表示)。

*yTop*<br/>
要點擊測試之點的 Y 座標 (以螢幕單位表示)。

*pvarChild*<br/>
接收在*xLeft*和*yTop*所指定的點上識別物件的資訊。 請參閱 Windows SDK 的[IAccessible:: accHitTest](/windows/desktop/api/oleacc/nf-oleacc-iaccessible-acchittest)中的*pvarID* 。

### <a name="return-value"></a>傳回值

在成功時傳回 S_OK, 失敗時傳回 COM 錯誤碼。 請參閱 Windows SDK 中`IAccessible::accHitTest`的傳回值。

### <a name="remarks"></a>備註

此函式是 MFC [Active Accessibility](/windows/desktop/WinAuto/microsoft-active-accessibility)支援的一部分。

如果您有 nonwindowed 使用者`CWnd`介面專案 (MFC 所處理的無視窗 ActiveX 控制項), 請覆寫衍生類別中的這個函式。

如需詳細資訊, 請參閱 Windows SDK 中的[IAccessible:: accHitTest](/windows/desktop/api/oleacc/nf-oleacc-iaccessible-acchittest) 。

##  <a name="acclocation"></a>  CWnd::accLocation

由架構呼叫以擷取指定物件目前畫面的位置。

```
virtual HRESULT accLocation(
    long* pxLeft,
    long* pyTop,
    long* pcxWidth,
    long* pcyHeight,
    VARIANT varChild);
```

### <a name="parameters"></a>參數

*pxLeft*<br/>
接收物件左上角的 x 座標 (以螢幕單位表示)。

*pyTop*<br/>
接收物件左上角的 y 座標 (以螢幕單位表示)。

*pcxWidth*<br/>
接收物件的寬度 (以螢幕單位表示)。

*pcyHeight*<br/>
接收物件的高度 (以螢幕單位表示)。

*varChild*<br/>
指定要抓取的位置是物件或物件的其中一個子項目。 這個參數可以是 CHILDID_SELF (取得物件的相關資訊) 或子識別碼 (以取得物件之子專案的相關資訊)。

### <a name="return-value"></a>傳回值

在成功時傳回 S_OK, 失敗時傳回 COM 錯誤碼。 請參閱 Windows SDK 中`IAccessible::accLocation`的傳回值。

### <a name="remarks"></a>備註

如果您有 nonwindowed 使用者`CWnd`介面專案 (MFC 所處理的無視窗 ActiveX 控制項), 請覆寫衍生類別中的這個函式。

如需詳細資訊, `IAccessible::accLocation`請參閱 Windows SDK 中的。

##  <a name="accnavigate"></a>  CWnd::accNavigate

由架構呼叫以便於周遊容器內的另一使用者介面項目並擷取物件 (如果可能)。

```
virtual HRESULT accNavigate(
    long navDir,
    VARIANT varStart,
    VARIANT* pvarEndUpAt);
```

### <a name="parameters"></a>參數

*navDir*<br/>
指定要流覽的方向。 請參閱 Windows SDK 的[IAccessible:: accNavigate](/windows/desktop/api/oleacc/nf-oleacc-iaccessible-accnavigate)中的*navDir* 。

*varStart*<br/>
指定起始物件。 請參閱 Windows SDK `IAccessible::accNavigate`中的 varStart。

*pvarEndUpAt*<br/>
接收目的地使用者介面物件的相關資訊。 請參閱 Windows SDK `IAccessible::accNavigate`中的 pvarEnd。

### <a name="return-value"></a>傳回值

在成功時傳回 S_OK, 失敗時傳回 COM 錯誤碼。 請參閱 Windows SDK 中`IAccessible::accNavigate`的傳回值。

### <a name="remarks"></a>備註

此函式是 MFC [Active Accessibility](/windows/desktop/WinAuto/microsoft-active-accessibility)支援的一部分。

如果您有 nonwindowed 使用者`CWnd`介面專案 (MFC 所處理的無視窗 ActiveX 控制項), 請覆寫衍生類別中的這個函式。

如需詳細資訊, 請參閱 Windows SDK 中的[IAccessible:: accNavigate](/windows/desktop/api/oleacc/nf-oleacc-iaccessible-accnavigate) 。

##  <a name="accselect"></a>  CWnd::accSelect

由架構呼叫以修改選取或移動指定物件的鍵盤焦點。

```
virtual HRESULT accSelect(
    long flagsSelect,
    VARIANT varChild);
```

### <a name="parameters"></a>參數

*flagsSelect*<br/>
指定如何變更目前的選取範圍或焦點。 請參閱 Windows SDK 的[IAccessible:: accSelect](/windows/desktop/api/oleacc/nf-oleacc-iaccessible-accselect)中的*flagsSelect* 。

*varChild*<br/>
指定要選取的物件。 這個參數可以是 CHILDID_SELF (用來選取物件本身) 或子識別碼 (以選取其中一個物件的子系)。

### <a name="return-value"></a>傳回值

在成功時傳回 S_OK, 失敗時傳回 COM 錯誤碼。 請參閱 Windows SDK 中`IAccessible::accSelect`的傳回值。

### <a name="remarks"></a>備註

此函式是 MFC [Active Accessibility](/windows/desktop/WinAuto/microsoft-active-accessibility)支援的一部分。

如果您有 nonwindowed 使用者`CWnd`介面專案 (MFC 所處理的無視窗 ActiveX 控制項), 請覆寫衍生類別中的這個函式。

如需詳細資訊, 請參閱 Windows SDK 中的[IAccessible:: accSelect](/windows/desktop/api/oleacc/nf-oleacc-iaccessible-accselect) 。

##  <a name="animatewindow"></a>CWnd:: AnimateWindow

會在顯示或隱藏視窗時產生特殊效果。

```
BOOL AnimateWindow(
    DWORD dwTime,
    DWORD dwFlags);
```

### <a name="parameters"></a>參數

*dwTime*<br/>
指定播放動畫所花的時間 (以毫秒為單位)。 通常, 動畫會花費200毫秒來播放。

*dwFlags*<br/>
指定動畫的類型。 如需可能值的完整清單, 請參閱[AnimateWindow](/windows/desktop/api/winuser/nf-winuser-animatewindow)。

### <a name="return-value"></a>傳回值

如果函式成功則為非零值，否則為 0。

### <a name="remarks"></a>備註

此成員函式會模擬函數[AnimateWindow](/windows/desktop/api/winuser/nf-winuser-animatewindow)的功能, 如 Windows SDK 中所述。

##  <a name="arrangeiconicwindows"></a>  CWnd::ArrangeIconicWindows

排列所有最小化 (圖示) 子視窗。

```
UINT ArrangeIconicWindows();
```

### <a name="return-value"></a>傳回值

如果函式成功, 則為一列圖示的高度;否則為0。

### <a name="remarks"></a>備註

此成員函式也會在桌面視窗上排列圖示, 其中涵蓋整個畫面。 [GetDesktopWindow](#getdesktopwindow)成員函式會抓取桌面視窗物件的指標。

若要在 MDI 用戶端視窗中排列 iconic MDI 子視窗, 請呼叫[CMDIFrameWnd:: MDIIconArrange](../../mfc/reference/cmdiframewnd-class.md#mdiiconarrange)。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#66](../../mfc/reference/codesnippet/cpp/cwnd-class_1.cpp)]

##  <a name="attach"></a>  CWnd::Attach

將 Windows 視窗附加至`CWnd`物件。

```
BOOL Attach(HWND hWndNew);
```

### <a name="parameters"></a>參數

*hWndNew*<br/>
指定 Windows 視窗的控制碼。

### <a name="return-value"></a>傳回值

如果成功則為非零；否則為 0。

### <a name="example"></a>範例

這個範例示範如何使用 [附加] 和 [中斷連結] 來對應至 MDI 用戶端視窗。

[!code-cpp[NVC_MFCWindowing#67](../../mfc/reference/codesnippet/cpp/cwnd-class_2.h)]

[!code-cpp[NVC_MFCWindowing#68](../../mfc/reference/codesnippet/cpp/cwnd-class_3.cpp)]

[!code-cpp[NVC_MFCWindowing#69](../../mfc/reference/codesnippet/cpp/cwnd-class_4.cpp)]

##  <a name="beginmodalstate"></a>  CWnd::BeginModalState

呼叫此成員函式以製作框架視窗強制回應。

```
virtual void BeginModalState();
```

##  <a name="beginpaint"></a>  CWnd::BeginPaint

準備`CWnd`使用繪製的相關資訊`PAINTSTRUCT`來繪製和填滿資料結構。

```
CDC* BeginPaint(LPPAINTSTRUCT lpPaint);
```

### <a name="parameters"></a>參數

*lpPaint*<br/>
指向要接收繪製資訊的[PAINTSTRUCT](/windows/desktop/api/winuser/ns-winuser-tagpaintstruct)結構。

### <a name="return-value"></a>傳回值

識別的裝置內容`CWnd`。 指標可能是暫時性的, 不能儲存在[EndPaint](#endpaint)的範圍外。

### <a name="remarks"></a>備註

油漆結構包含矩形資料結構, 其具有完全括住更新區域的最小矩形, 以及指定是否已清除背景的旗標。

更新區域是由 [[無效](#invalidate)]、[ [InvalidateRect](#invalidaterect)] 或 [ [InvalidateRgn](#invalidatergn) ] 成員函式所設定, 而且會在其大小、移動、建立、滾動或執行任何其他會影響工作區的作業之後, 由系統來設定。 如果更新區域已標示為要清除, `BeginPaint`則會傳送[WM_ONERASEBKGND](#onerasebkgnd)訊息。

除了回應[WM_PAINT](#onpaint)訊息`BeginPaint`以外, 請勿呼叫成員函式。 對`BeginPaint`成員函式的每個呼叫都必須與[EndPaint](#endpaint)成員函式具有相符的呼叫。 如果插入號位於要繪製的區域中, 則`BeginPaint`成員函式會自動隱藏插入號, 以防止它被清除。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#70](../../mfc/reference/codesnippet/cpp/cwnd-class_5.cpp)]

##  <a name="binddefaultproperty"></a>CWnd:: BindDefaultProperty

將呼叫物件的預設簡單系結屬性 (例如編輯控制項) 系結至資料來源控制項的 DataSource、使用者名稱、密碼和 SQL 屬性所定義的基礎資料指標 (如類型程式庫中所標記)。

```
void BindDefaultProperty(
    DISPID dwDispID,
    VARTYPE vtProp,
    LPCTSTR szFieldName,
    CWnd* pDSCWnd);
```

### <a name="parameters"></a>參數

*dwDispID*<br/>
在要系結至資料來源控制項的資料繫結控制項上, 指定 DISPID 的屬性。

*vtProp*<br/>
指定要系結之屬性的類型, 例如 VT_BSTR、VT_VARIANT 等等。

*szFieldName*<br/>
在資料來源控制項所提供的資料指標中, 指定要系結屬性的資料行名稱。

*pDSCWnd*<br/>
指向裝載屬性將系結之資料來源控制項的視窗。 使用`GetDlgItem` dc 主機視窗的資源識別碼呼叫來抓取此指標。

### <a name="remarks"></a>備註

您`CWnd`呼叫這個函式的物件必須是資料繫結控制項。

### <a name="example"></a>範例

`BindDefaultProperty`可能用於下列內容:

[!code-cpp[NVC_MFC_AxDataBinding#2](../../mfc/reference/codesnippet/cpp/cwnd-class_7.cpp)]

##  <a name="bindproperty"></a>  CWnd::BindProperty

將資料繫結控制項 (例如方格控制項) 上的游標系結屬性系結至資料來源控制項, 並向 MFC 系結管理員註冊該關聯性。

```
void BindProperty(
    DISPID dwDispId,
    CWnd* pWndDSC);
```

### <a name="parameters"></a>參數

*dwDispId*<br/>
在要系結至資料來源控制項的資料繫結控制項上, 指定 DISPID 的屬性。

*pWndDSC*<br/>
指向裝載屬性將系結之資料來源控制項的視窗。 使用`GetDlgItem` dc 主機視窗的資源識別碼呼叫來抓取此指標。

### <a name="remarks"></a>備註

您`CWnd`呼叫這個函式的物件必須是資料繫結控制項。

### <a name="example"></a>範例

`BindProperty`可能用於下列內容:

[!code-cpp[NVC_MFC_AxDataBinding#4](../../mfc/reference/codesnippet/cpp/cwnd-class_9.cpp)]

##  <a name="bringwindowtotop"></a>  CWnd::BringWindowToTop

將 `CWnd` 帶到重疊視窗堆疊的最上層。

```
void BringWindowToTop();
```

### <a name="remarks"></a>備註

此外，`BringWindowToTop` 會啟用快顯、最上層和 MDI 子視窗。 需使用 `BringWindowToTop` 成員函式，才能顯示出重疊視窗部分或完全遮住的視窗。

此函式只會呼叫 Win32 [BringWindowToTop](/windows/desktop/api/winuser/nf-winuser-bringwindowtotop)函式。 呼叫[SetWindowPos](#setwindowpos)函式以變更視窗在迭置順序中的位置。 `BringWindowToTop` 函式不會將視窗樣式變更為最上層視窗。 如需詳細資訊, 請參閱[HWND_TOP 與 HWND_TOPMOST 之間的差異](https://devblogs.microsoft.com/oldnewthing/?p=33263)

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#71](../../mfc/reference/codesnippet/cpp/cwnd-class_10.cpp)]

##  <a name="calcwindowrect"></a>  CWnd::CalcWindowRect

計算可以包含指定之用戶端矩形的視窗矩形。

```
virtual void CalcWindowRect(
    LPRECT lpClientRect,
    UINT nAdjustType = adjustBorder);
```

### <a name="parameters"></a>參數

*lpClientRect*<br/>
[in、out]矩形結構的指標。 在輸入時, 此結構會包含用戶端矩形。 在方法完成之後, 此結構會包含可以包含指定之用戶端矩形的視窗矩形。

*nAdjustType*<br/>
[in]使用 `CWnd::adjustBorder`來計算視窗座標，而不需要 WS_EX_CLIENTEDGE 樣式; 否則，請使用`CWnd::adjustOutside`。

### <a name="remarks"></a>備註

計算的視窗矩形大小不包含功能表列的空間。

如需更多使用限制, 請參閱[AdjustWindowRectEx](/windows/desktop/api/winuser/nf-winuser-adjustwindowrectex)。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#72](../../mfc/reference/codesnippet/cpp/cwnd-class_11.cpp)]

##  <a name="canceltooltips"></a>  CWnd::CancelToolTips

如果目前顯示工具提示, 請呼叫此成員函式以從螢幕中移除工具提示。

```
static void PASCAL CancelToolTips(BOOL bKeys = FALSE);
```

### <a name="parameters"></a>參數

*bKeys*<br/>
TRUE 表示在按下按鍵時取消工具提示, 並將狀態列文字設定為預設值;否則為 FALSE。

### <a name="remarks"></a>備註

> [!NOTE]
> 使用這個成員函式不會影響您的程式碼所管理的工具提示。 它只會影響[CWnd:: EnableToolTips](#enabletooltips)所管理的工具提示控制項。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#73](../../mfc/reference/codesnippet/cpp/cwnd-class_12.cpp)]

##  <a name="centerwindow"></a>  CWnd::CenterWindow

將相對於其父系的視窗置中。

```
void CenterWindow(CWnd* pAlternateOwner = NULL);
```

### <a name="parameters"></a>參數

*pAlternateOwner*<br/>
相對於其中央位置之替代視窗的指標 (而不是父視窗)。

### <a name="remarks"></a>備註

通常從[CDialog:: OnInitDialog](../../mfc/reference/cdialog-class.md#oninitdialog)呼叫到與應用程式主視窗相對的中央對話方塊。 根據預設, 函式會將相對於其父視窗的子視窗, 和相對於其擁有者的快顯視窗置中。 如果未擁有快顯視窗, 它會以相對於螢幕的方式置中。 若要將視窗置中相對於不是擁有者或父系的特定視窗, *pAlternateOwner*參數可以設定為有效的視窗。 若要強制中心相對於螢幕, 請將[CWnd:: GetDesktopWindow](#getdesktopwindow)所傳回的值傳遞為*pAlternateOwner*。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#74](../../mfc/reference/codesnippet/cpp/cwnd-class_13.cpp)]

##  <a name="changeclipboardchain"></a>CWnd:: ChangeClipboardChain

從`CWnd`剪貼簿檢視器的鏈中移除, 並藉由*hWndNext* `CWnd`鏈中祖系的下階來指定視窗。

```
BOOL ChangeClipboardChain(HWND hWndNext);
```

### <a name="parameters"></a>參數

*hWndNext*<br/>
識別在剪貼簿- `CWnd`檢視器鏈中後面的視窗。

### <a name="return-value"></a>傳回值

如果成功則為非零；否則為 0。

##  <a name="checkdlgbutton"></a>  CWnd::CheckDlgButton

選取 (在旁邊放置核取記號) 或清除 (移除核取記號) 按鈕, 或變更三狀態按鈕的狀態。

```
void CheckDlgButton(
    int nIDButton,
    UINT nCheck);
```

### <a name="parameters"></a>參數

*nIDButton*<br/>
指定要修改的按鈕。

*nCheck*<br/>
指定要採取的動作。 如果*nCheck*為非零值`CheckDlgButton` , 則成員函式會在按鈕旁邊放置核取記號; 如果為 0, 則會移除核取記號。 針對三個狀態的按鈕, 如果*nCheck*為 2, 則按鈕狀態為 [不確定]。

### <a name="remarks"></a>備註

函式會將 [BM_SETCHECK](/windows/desktop/Controls/bm-setcheck) 訊息傳送至指定的按鈕。`CheckDlgButton`

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#75](../../mfc/reference/codesnippet/cpp/cwnd-class_14.cpp)]

##  <a name="checkradiobutton"></a>CWnd:: CheckRadioButton

選取群組中的指定選項按鈕 (將核取記號新增至), 並清除群組中所有其他選項按鈕的 (移除核取記號)。

```
void CheckRadioButton(
    int nIDFirstButton,
    int nIDLastButton,
    int nIDCheckButton);
```

### <a name="parameters"></a>參數

*nIDFirstButton*<br/>
指定群組中第一個選項按鈕的整數識別碼。

*nIDLastButton*<br/>
指定群組中最後一個選項按鈕的整數識別碼。

*nIDCheckButton*<br/>
指定要檢查之選項按鈕的整數識別碼。

### <a name="remarks"></a>備註

函式會將 [BM_SETCHECK](/windows/desktop/Controls/bm-setcheck) 訊息傳送至指定的選項按鈕。`CheckRadioButton`

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#76](../../mfc/reference/codesnippet/cpp/cwnd-class_15.cpp)]

##  <a name="childwindowfrompoint"></a>  CWnd::ChildWindowFromPoint

判斷屬於`CWnd`哪一個子視窗 (如果有的話) 包含指定的點。

```
CWnd* ChildWindowFromPoint(POINT point) const;

CWnd* ChildWindowFromPoint(
    POINT point,
    UINT nFlags) const;
```

### <a name="parameters"></a>參數

*point*<br/>
指定要測試之點的用戶端座標。

*nflags*<br/>
指定要略過的子視窗。 這個參數可以是下列值的組合:

|值|意義|
|-----------|-------------|
|CWP_ALL|不要略過任何子視窗|
|CWP_SKIPINVISIBLE|略過隱藏的子視窗|
|CWP_SKIPDISABLED|略過停用的子視窗|
|CWP_SKIPTRANSPARENT|略過透明子視窗|

### <a name="return-value"></a>傳回值

識別包含點的子視窗。 如果指定的點位於工作區的外部, 則為 Null。 如果點在工作區中, 但不包含在任何子視窗內, `CWnd`則會傳回。

此成員函式會傳回隱藏或停用的子視窗, 其中包含指定的點。

一個以上的視窗可能會包含指定的點。 不過, 此函式只`CWnd`會傳回包含點之第一個視窗中的 *。

傳回`CWnd`的 * 可能是暫時性的, 不應該儲存以供稍後使用。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#77](../../mfc/reference/codesnippet/cpp/cwnd-class_16.cpp)]

##  <a name="clienttoscreen"></a>  CWnd::ClientToScreen

將畫面上指定的點或矩形的用戶端座標，轉換為螢幕座標。

```
void ClientToScreen(LPPOINT lpPoint) const;  void ClientToScreen(LPRECT lpRect) const;
```

### <a name="parameters"></a>參數

*lpPoint*<br/>
指向包含要轉換之客戶`CPoint`端座標的[點結構](/windows/desktop/api/windef/ns-windef-tagpoint)或物件。

*lpRect*<br/>
指向[矩形結構](/windows/desktop/api/windef/ns-windef-tagrect)或`CRect`物件, 其中包含要轉換的用戶端座標。

### <a name="remarks"></a>備註

此`ClientToScreen`成員函式會使用`POINT`或`RECT`結構中的用戶端座標`CPoint` , `CRect`或*lpPoint*或*lpRect*所指向的或物件來計算新的螢幕座標, 然後以新座標取代結構中的座標。 新的螢幕座標會相對於系統顯示的左上角。

此`ClientToScreen`成員函式會假設給定的點或矩形是在用戶端座標中。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#78](../../mfc/reference/codesnippet/cpp/cwnd-class_17.cpp)]

##  <a name="closewindow"></a>  CWnd::CloseWindow

將視窗最小化。

```
void CloseWindow();
```

### <a name="remarks"></a>備註

此成員函式會模擬函數[closewindowsg](/windows/desktop/api/winuser/nf-winuser-closewindow)的功能, 如 Windows SDK 中所述。

##  <a name="continuemodal"></a>  CWnd::ContinueModal

[RunModalLoop](#runmodalloop)會呼叫這個成員函式, 以判斷何時應結束強制回應狀態。

```
virtual BOOL ContinueModal();
```

### <a name="return-value"></a>傳回值

若要繼續強制回應迴圈, 則為非零值;[EndModalLoop](#endmodalloop)被呼叫時為0。

### <a name="remarks"></a>備註

根據預設, 它會傳回非零, `EndModalLoop`直到呼叫為止。

##  <a name="create"></a>CWnd:: Create

建立指定的子視窗, 並將它附加至[CWnd](../../mfc/reference/cwnd-class.md)物件。

```
virtual BOOL Create(
    LPCTSTR lpszClassName,
    LPCTSTR lpszWindowName,
    DWORD dwStyle,
    Const RECT& rect,
    CWnd* pParentWnd,
    UINT nID,
    CCreateContext* pContext = NULL);
```

### <a name="parameters"></a>參數

*lpszClassName*<br/>
在以 null 結束的字串指標, 其中包含已註冊之系統視窗類別的名稱;或是預先定義之系統視窗類別的名稱。

*lpszWindowName*<br/>
在以 null 結束的字串指標, 其中包含視窗顯示名稱;如果沒有視窗顯示名稱, 則為 Null。

*dwStyle*<br/>
在[視窗樣式](styles-used-by-mfc.md#window-styles)的位元組合 (or)。 WS_POPUP 選項不是有效的樣式。

*rect*<br/>
在相對於父視窗左上角的視窗大小和位置。

*pParentWnd*<br/>
在父視窗的指標。

*nID*<br/>
在視窗的識別碼。

*pContext*<br/>
在[CCreateCoNtext](../../mfc/reference/ccreatecontext-structure.md)結構的指標, 用來自訂應用程式的檔視圖架構。

### <a name="return-value"></a>傳回值

如果方法成功, 則為 TRUE;否則為 FALSE。

### <a name="remarks"></a>備註

> [!WARNING]
> `CWnd::PreCreateWindow`如果功能表為 Null, 且樣式`CREATESTRUCT`包含 WS_CHILD, 現在會將其參數的 hMenu 成員指派給**this**指標。 如需適當的功能, 請確定您的對話方塊控制項具有不是 Null 的識別碼。
>
> 這項變更會修正 managed/原生 interop 案例中的損毀。 中`CWnd::Create`的追蹤語句會警示問題的開發人員。

使用[AfxRegisterWndClass](../../mfc/reference/application-information-and-management.md#afxregisterwndclass)函數來註冊視窗類別。 使用者定義 視窗的模組中的類別可註冊的位置。

[CWnd:: OnCreate](#oncreate)方法會在`Create`方法傳回之前, 以及在視窗變成可見之前呼叫。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#79](../../mfc/reference/codesnippet/cpp/cwnd-class_18.cpp)]

##  <a name="createaccessibleproxy"></a>  CWnd::CreateAccessibleProxy

建立指定物件的 Active Accessibility Proxy。

```
virtual HRESULT CreateAccessibleProxy(
    WPARAM wParam,
    LPARAM lParam,
    LRESULT* pResult);
```

### <a name="parameters"></a>參數

*wParam*<br/>
識別 Active Accessibility proxy 所存取的物件。 可以是下列其中一個值

|值|意義|
|-----------|-------------|
|OBJID_CLIENT|參考視窗的工作區。|

*lParam*<br/>
提供與訊息相關的其他資訊。

*pResult*<br/>
儲存結果程式碼之 LRESULT 的指標。

### <a name="remarks"></a>備註

建立指定物件的 Active Accessibility Proxy。

##  <a name="createcaret"></a>  CWnd::CreateCaret

建立系統插入號的新圖形, 並宣告插入號的擁有權。

```
void CreateCaret(CBitmap* pBitmap);
```

### <a name="parameters"></a>參數

*pBitmap*<br/>
識別定義插入號圖形的點陣圖。

### <a name="remarks"></a>備註

點陣圖必須先前由[CBitmap:: CreateBitmap](../../mfc/reference/cbitmap-class.md#createbitmap)成員函式、 [CreateDIBitmap](/windows/desktop/api/wingdi/nf-wingdi-createdibitmap) Windows 函數或[CBitmap:: LoadBitmap](../../mfc/reference/cbitmap-class.md#loadbitmap)成員函式建立。

`CreateCaret`會自動終結先前的插入號圖形 (如果有的話), 而不論哪一個視窗擁有插入號。 一旦建立之後, 插入號就會一開始隱藏。 若要顯示插入號, 必須呼叫[ShowCaret](#showcaret)成員函式。

系統插入號是共用資源。 `CWnd`只有在有輸入焦點或為作用中時, 才應該建立插入號。 它應該先終結插入號, 再失去輸入焦點或變成非作用中。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#80](../../mfc/reference/codesnippet/cpp/cwnd-class_19.cpp)]

##  <a name="createcontrol"></a>  CWnd::CreateControl

使用此成員函式來建立 ActiveX 控制項, 以由`CWnd`物件在 MFC 程式中表示。

```
BOOL CreateControl(
    LPCTSTR pszClass,
    LPCTSTR pszWindowName,
    DWORD dwStyle,
    const RECT& rect,
    CWnd* pParentWnd,
    UINT nID,
    CFile* pPersist = NULL,
    BOOL bStorage = FALSE,
    BSTR bstrLicKey = NULL);

BOOL CreateControl(
    REFCLSID clsid,
    LPCTSTR pszWindowName,
    DWORD dwStyle,
    const RECT& rect,
    CWnd* pParentWnd,
    UINT nID,
    CFile* pPersist = NULL,
    BOOL bStorage = FALSE,
    BSTR bstrLicKey = NULL);

BOOL CreateControl(
    REFCLSID clsid,
    LPCTSTR pszWindowName,
    DWORD dwStyle,
    const POINT* ppt,
    const SIZE* psize,
    CWnd* pParentWnd,
    UINT nID,
    CFile* pPersist = NULL,
    BOOL bStorage = FALSE,
    BSTR bstrLicKey = NULL);
```

### <a name="parameters"></a>參數

*pszClass*<br/>
這個字串可能包含類別的 OLE "short name" (ProgID), 例如 "CIRC3。Circ3Ctrl。 1 "。 名稱必須符合控制項所註冊的相同名稱。 或者, 此字串可能包含以括弧括住之 CLSID 的字串形式, 例如 "{9DBAFCCF-592F-101B-85CE-00608CEC297B}"。 在任一情況下`CreateControl` , 會將字串轉換成對應的類別識別碼。

*pszWindowName*<br/>
要在控制項中顯示的文字指標。 設定控制項的 [標題] 或 [Text] 屬性的值 (如果有的話)。 如果是 Null, 則不會變更控制項的 Caption 或 Text 屬性。

*dwStyle*<br/>
視窗樣式。 可用的樣式會列在 [備註] 底下。

*rect*<br/>
指定控制項的大小和位置。 它可以是[CRect](../../atl-mfc-shared/reference/crect-class.md)物件或[RECT 結構](/windows/desktop/api/windef/ns-windef-tagrect)。

*ppt*<br/>
指向包含控制項左上角的`CPoint` [點結構](/windows/desktop/api/windef/ns-windef-tagpoint)或物件。

*pSize*<br/>
指向包含控制項大小的[大小](/windows/desktop/api/windef/ns-windef-tagsize)`CSize`結構或物件

*pParentWnd*<br/>
指定控制項的父視窗。 不得為 Null。

*nID*<br/>
指定控制項的識別碼。

*pPersist*<br/>
[CFile](../../mfc/reference/cfile-class.md)的指標, 其中包含控制項的持續狀態。 預設值為 Null, 表示控制項會自行初始化, 而不會從任何持續性儲存體還原其狀態。 如果不是 Null, 它應該是衍生物件的`CFile`指標, 其中包含控制項的持續性資料 (以資料流程或儲存體的形式)。 這項資料可能已儲存在用戶端先前的啟用中。 可以包含其他資料, 但在`CreateControl`呼叫時, 必須將其讀寫指標設定為持續性資料的第一個位元組。 `CFile`

*bStorage*<br/>
指出*pPersist*中的資料是否應解讀為 IStorage 或 IStream 資料。 如果*pPersist*中的資料是儲存體, 則*BSTORAGE*應為 TRUE。 如果*pPersist*中的資料是資料流程, *BSTORAGE*應該是 FALSE。 預設值為 FALSE。

*bstrLicKey*<br/>
選擇性的授權金鑰資料。 只有在建立需要執行時間授權金鑰的控制項時, 才需要此資料。 如果控制項支援授權, 您必須提供授權金鑰, 才能成功建立控制項。 預設值為 Null。

*clsid*<br/>
控制項的唯一類別 ID。

### <a name="return-value"></a>傳回值

如果成功則為非零；否則為 0。

### <a name="remarks"></a>備註

`CreateControl`是[CWnd:: Create](#create)函數的直接類比, 它會建立的視窗`CWnd`。 `CreateControl`建立 ActiveX 控制項, 而不是一般視窗。

僅支援`CreateControl`部分的 Windows *dwStyle*旗標:

- WS_VISIBLE 會建立一開始顯示的視窗。 如果您想要立即顯示控制項 (例如一般視窗), 則為必要。

- WS_DISABLED 會建立一開始停用的視窗。 停用的視窗無法接收使用者的輸入。 如果控制項具有已啟用的屬性, 則可以設定。

- WS_BORDER 會建立具有細線條框線的視窗。 如果控制項具有 BorderStyle 屬性, 則可以設定。

- WS_GROUP 指定控制項群組的第一個控制項。 使用者可以使用方向鍵, 將鍵盤焦點從群組中的一個控制項變更為下一個。 在第一個控制項屬於相同群組之後, 以 WS_GROUP 樣式定義的所有控制項。 下一個具有 WS_GROUP 樣式的控制項會結束群組, 並啟動下一個群組。

- WS_TABSTOP 指定當使用者按下 TAB 鍵時, 可接收鍵盤焦點的控制項。 按 TAB 鍵會將鍵盤焦點變更為 WS_TABSTOP 樣式的下一個控制項。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#81](../../mfc/reference/codesnippet/cpp/cwnd-class_20.h)]

##  <a name="createex"></a>  CWnd::CreateEx

建立指定的視窗, 並將它附加`CWnd`至物件。

```
virtual BOOL CreateEx(
    DWORD dwExStyle,
    LPCTSTR lpszClassName,
    LPCTSTR lpszWindowName,
    DWORD dwStyle,
    int x,
    int y,
    int nWidth,
    int nHeight,
    HWND hWndParent,
    HMENU nIDorHMenu,
    LPVOID lpParam = NULL);

virtual BOOL CreateEx(
    DWORD dwExStyle,
    LPCTSTR lpszClassName,
    LPCTSTR lpszWindowName,
    DWORD dwStyle,
    const RECT& rect,
    CWnd* pParentWnd,
    UINT nID,
    LPVOID lpParam = NULL);
```

### <a name="parameters"></a>參數

*dwExStyle*<br/>
[擴充視窗樣式](../../mfc/reference/styles-used-by-mfc.md#extended-window-styles)的位元組合 (or);如果是預設的擴充視窗樣式, 則為 Null。

*lpszClassName*<br/>
以 null 結束的字串指標, 其中包含已註冊之系統視窗類別的名稱;或是預先定義之系統視窗類別的名稱。

*lpszWindowName*<br/>
以 null 結束的字串指標, 其中包含視窗顯示名稱;如果沒有視窗顯示名稱, 則為 Null。

*dwStyle*<br/>
[視窗樣式](styles-used-by-mfc.md#window-styles)的位元組合 (or);若為預設視窗樣式, 則為 Null。

*x*<br/>
從螢幕左邊到視窗的初始水準距離, 或父視窗。

*y*<br/>
視窗在螢幕頂端或父視窗的初始垂直距離。

*nWidth*<br/>
視窗的寬度 (以圖元為單位)。

*nHeight*<br/>
視窗的高度 (以圖元為單位)。

*hwndParent*<br/>
若為子視窗, 則為父視窗的控制碼;否則, 如果視窗具有擁有者, 則為主控視窗的控制碼。

*nIDorHMenu*<br/>
若為子視窗, 則為視窗識別碼;否則為視窗的功能表識別碼。

*lpParam*<br/>
使用者資料的指標, 傳遞至*lpCreateParams*欄位中的[CWnd:: OnCreate](#oncreate)方法。

*rect*<br/>
相對於螢幕或父視窗的視窗大小和位置。

*pParentWnd*<br/>
若為子視窗, 則為父視窗的指標;否則, 如果視窗具有擁有者, 則為擁有者視窗的指標。

*nID*<br/>
若為子視窗, 則為視窗識別碼;否則為視窗的功能表識別碼。

### <a name="return-value"></a>傳回值

如果方法成功, 則為 TRUE;否則為 FALSE。

### <a name="remarks"></a>備註

> [!WARNING]
> `CWnd::PreCreateWindow`如果功能表為 Null, 且樣式`CREATESTRUCT`包含 WS_CHILD, 現在會將其參數的 hMenu 成員指派給**this**指標。 如需適當的功能, 請確定您的對話方塊控制項具有不是 Null 的識別碼。
>
> 這項變更會修正 managed/原生 interop 案例中的損毀。 `TRACE` 中`CWnd::Create`的語句會警示問題的開發人員。

預設的擴充視窗樣式為 WS_EX_LEFT。 預設的視窗樣式為 WS_OVERLAPPED。

使用[AfxRegisterWndClass](../../mfc/reference/application-information-and-management.md#afxregisterwndclass)函數來註冊視窗類別。 使用者定義 視窗的模組中的類別可註冊的位置。

子視窗的維度相對於父視窗工作區的左上角。 最上層視窗的維度相對於螢幕的左上角。

[CWnd:: OnCreate](#oncreate)方法會在`CreateEx`方法傳回之前, 以及在視窗變成可見之前呼叫。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#82](../../mfc/reference/codesnippet/cpp/cwnd-class_21.cpp)]

##  <a name="creategraycaret"></a>  CWnd::CreateGrayCaret

建立系統插入號的灰色矩形和插入號的宣告擁有權。

```
void CreateGrayCaret(
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>參數

*nWidth*<br/>
指定插入號的寬度 (以邏輯單位表示)。 如果此參數為 0, 則寬度會設定為系統定義的視窗框線寬度。

*nHeight*<br/>
指定插入號的高度 (以邏輯單位表示)。 如果此參數為 0, 則高度會設定為系統定義的視窗-框線高度。

### <a name="remarks"></a>備註

插入號圖形可以是線條或區塊。

參數*nWidth*和*nHeight*會指定插入號的寬度和高度 (以邏輯單位表示);確切的寬度和高度 (以圖元為單位) 取決於對應模式。

[GetSystemMetrics](/windows/desktop/api/winuser/nf-winuser-getsystemmetrics) Windows 函數可以使用 SM_CXBORDER 和 SM_CYBORDER 索引來抓取系統的視窗框線寬度或高度。 使用 [視窗框線寬度] 或 [高度] 可確保在高解析度顯示時, 會顯示插入號。

`CreateGrayCaret`成員函式會自動終結先前的插入號圖形 (如果有的話), 而不論哪一個視窗擁有插入號。 一旦建立之後, 插入號就會一開始隱藏。 若要顯示插入號, 必須呼叫[ShowCaret](#showcaret)成員函式。

系統插入號是共用資源。 `CWnd`只有在有輸入焦點或為作用中時, 才應該建立插入號。 它應該先終結插入號, 再失去輸入焦點或變成非作用中。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#83](../../mfc/reference/codesnippet/cpp/cwnd-class_22.cpp)]

##  <a name="createsolidcaret"></a>  CWnd::CreateSolidCaret

建立系統插入號的實心矩形和插入號的宣告擁有權。

```
void CreateSolidCaret(
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>參數

*nWidth*<br/>
指定插入號的寬度 (以邏輯單位表示)。 如果此參數為 0, 則寬度會設定為系統定義的視窗框線寬度。

*nHeight*<br/>
指定插入號的高度 (以邏輯單位表示)。 如果此參數為 0, 則高度會設定為系統定義的視窗-框線高度。

### <a name="remarks"></a>備註

插入號圖形可以是線條或區塊。

參數*nWidth*和*nHeight*會指定插入號的寬度和高度 (以邏輯單位表示);確切的寬度和高度 (以圖元為單位) 取決於對應模式。

[GetSystemMetrics](/windows/desktop/api/winuser/nf-winuser-getsystemmetrics) Windows 函數可以使用 SM_CXBORDER 和 SM_CYBORDER 索引來抓取系統的視窗框線寬度或高度。 使用 [視窗框線寬度] 或 [高度] 可確保在高解析度顯示時, 會顯示插入號。

`CreateSolidCaret`成員函式會自動終結先前的插入號圖形 (如果有的話), 而不論哪一個視窗擁有插入號。 一旦建立之後, 插入號就會一開始隱藏。 若要顯示插入號, 必須呼叫[ShowCaret](#showcaret)成員函式。

系統插入號是共用資源。 `CWnd`只有在有輸入焦點或為作用中時, 才應該建立插入號。 它應該先終結插入號, 再失去輸入焦點或變成非作用中。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#84](../../mfc/reference/codesnippet/cpp/cwnd-class_23.cpp)]

##  <a name="cwnd"></a>  CWnd::CWnd

建構 `CWnd` 物件。

```
CWnd();
```

### <a name="remarks"></a>備註

在呼叫[CreateEx](#createex)或[Create](#create)成員函式之前, 不會建立並附加 Windows 視窗。

##  <a name="default"></a>CWnd::D efault

呼叫預設視窗程式。

```
LRESULT Default();
```

### <a name="return-value"></a>傳回值

取決於傳送的訊息。

### <a name="remarks"></a>備註

預設的視窗程式會針對應用程式不會處理的任何視窗訊息提供預設處理。 這個成員函式可確保處理每個訊息。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#85](../../mfc/reference/codesnippet/cpp/cwnd-class_24.cpp)]

##  <a name="defwindowproc"></a>  CWnd::DefWindowProc

呼叫預設視窗程式, 為應用程式不會處理的任何視窗訊息提供預設處理。

```
virtual LRESULT DefWindowProc(
    UINT message,
    WPARAM wParam,
    LPARAM lParam);
```

### <a name="parameters"></a>參數

*message*<br/>
指定要處理的 Windows 訊息。

*wParam*<br/>
指定與訊息相關的其他資訊。

*lParam*<br/>
指定與訊息相關的其他資訊。

### <a name="return-value"></a>傳回值

取決於傳送的訊息。

### <a name="remarks"></a>備註

這個成員函式可確保處理每個訊息。 您應該使用與視窗程式所接收的參數相同的參數來呼叫它。

##  <a name="deletetempmap"></a>  CWnd::DeleteTempMap

由`CWinApp`物件的閒置時間處理常式自動呼叫。

```
static void PASCAL DeleteTempMap();
```

### <a name="remarks"></a>備註

刪除成員函`CWnd`式所`FromHandle`建立的任何暫存物件。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#86](../../mfc/reference/codesnippet/cpp/cwnd-class_25.cpp)]

##  <a name="destroywindow"></a>  CWnd::DestroyWindow

損毀附加至`CWnd`物件的 Windows 視窗。

```
virtual BOOL DestroyWindow();
```

### <a name="return-value"></a>傳回值

如果視窗已終結, 則為非零;否則為0。

### <a name="remarks"></a>備註

`DestroyWindow`成員函式會將適當的訊息傳送至視窗以停用它, 並移除輸入焦點。 它也會終結視窗的功能表、排清應用程式佇列、終結未處理的計時器、移除剪貼簿擁有權, 以及中斷剪貼`CWnd`簿-檢視器鏈 (如果位於檢視器鏈頂端)。 它會將[WM_DESTROY](#ondestroy)和[WM_NCDESTROY](#onncdestroy)訊息傳送至視窗。 它不會損毀`CWnd`物件。

`DestroyWindow`是用來執行清除的預留位置。 因為`DestroyWindow`是虛擬函式，它會顯示在任何`CWnd`-衍生的類別檢視 中的類別。 但是, 即使您在衍生類別中`CWnd`覆寫這個函式, `DestroyWindow`也不一定會呼叫。 如果`DestroyWindow`不是在 MFC 程式碼中呼叫, 則您必須在您自己的程式碼中明確呼叫它, 才能被呼叫。

例如, 假設您已`DestroyWindow` `CView`在衍生類別中覆寫。 因為 MFC 原始程式碼不會在其`DestroyWindow` `CFrameWnd`衍生的任何類別中呼叫, 除非您明確`DestroyWindow`地呼叫它, 否則將不會呼叫您的覆寫。

如果視窗是任何視窗的父系, 則當父視窗終結時, 會自動終結這些子視窗。 此`DestroyWindow`成員函式會先終結子視窗, 然後再銷毀視窗本身。

成員函式也會終結[CDialog:: Create](../../mfc/reference/cdialog-class.md#create)所建立的非強制回應對話方塊。 `DestroyWindow`

如果被`CWnd`終結的是子視窗, 而且沒有設定[WS_EX_NOPARENTNOTIFY](../../mfc/reference/styles-used-by-mfc.md#extended-window-styles)樣式, 則會將[WM_PARENTNOTIFY](/previous-versions/windows/desktop/inputmsg/wm-parentnotify)訊息傳送至父代。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#87](../../mfc/reference/codesnippet/cpp/cwnd-class_26.cpp)]

##  <a name="detach"></a>  CWnd::Detach

從 `CWnd` 物件卸離 Windows 控制代碼，並傳回控制代碼。

```
HWND Detach();
```

### <a name="return-value"></a>傳回值

Windows 物件的 HWND。

### <a name="example"></a>範例

  請參閱[CWnd:: Attach](#attach)的範例。

##  <a name="dlgdirlist"></a>  CWnd::DlgDirList

使用檔案或目錄清單填入清單方塊。

```
int DlgDirList(
    LPTSTR lpPathSpec,
    int nIDListBox,
    int nIDStaticPath,
    UINT nFileType);
```

### <a name="parameters"></a>參數

*lpPathSpec*<br/>
指向包含路徑或檔案名的以 null 終止的字串。 `DlgDirList`修改這個字串, 其長度必須足以包含修改。 如需詳細資訊, 請參閱下列「備註」一節。

*nIDListBox*<br/>
指定清單方塊的識別碼。 如果*nIDListBox*為 0, `DlgDirList`則會假設沒有清單方塊存在, 而且不會嘗試填入一個。

*nIDStaticPath*<br/>
指定用來顯示目前磁片磁碟機和目錄之靜態文字控制項的識別碼。 如果*nIDStaticPath*為 0, `DlgDirList`則會假設沒有這類文字控制項存在。

*nFileType*<br/>
指定要顯示之檔案的屬性。 它可以是下列值的任意組合:

- DDL_READWRITE 不含其他屬性的讀寫資料檔案。

- DDL_READONLY 唯讀檔案。

- DDL_HIDDEN 隱藏的檔案。

- DDL_SYSTEM 系統檔案。

- DDL_DIRECTORY 目錄。

- DDL_ARCHIVE 封存。

- DDL_POSTMSGS LB_DIR 旗標。 如果已設定 LB_DIR 旗標, Windows 會將產生`DlgDirList`的訊息放在應用程式的佇列中, 否則會直接傳送至對話方塊程式。

- DDL_DRIVES 磁片磁碟機。 如果已設定 DDL_DRIVES 旗標, 則會自動設定 DDL_EXCLUSIVE 旗標。 因此, 若要建立包含磁片磁碟機和檔案的目錄清單, 您必須`DlgDirList`呼叫兩次: 一次是設定 DDL_DRIVES 旗標, 一次使用清單的其餘部分。

- DDL_EXCLUSIVE 專有位。 如果設定獨佔位, 則只會列出指定類型的檔案。否則會列出所指定類型的一般檔案和檔案。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

`DlgDirList`將[LB_RESETCONTENT](/windows/desktop/Controls/lb-resetcontent)和[LB_DIR](/windows/desktop/Controls/lb-dir)訊息傳送至清單方塊。 它會將*nIDListBox*所指定的清單方塊填入所有檔案的名稱, 這些檔案符合*lpPathSpec*所指定的路徑。

*LpPathSpec*參數具有下列格式:

`[drive:] [ [\u]directory[\idirectory]...\u] [filename]`

在此範例中,*磁片磁碟機*是磁碟機號,*目錄*是有效的目錄名稱,*檔案名*則是至少必須包含一個萬用字元的有效檔案名。 萬用字元是一個問號 ( **？** ), 這表示符合任何字元, 而星號 (<strong>\*</strong>) 則表示比對任何字元數。

如果您為*lpPathSpec*指定長度為0的字串, 或只指定目錄名稱, 但未包含任何檔案規格, 則此字串將會變更為 "\*.\*"。

如果*lpPathSpec*包含磁片磁碟機和/或目錄名稱, 則會在填入清單方塊之前, 將目前的磁片磁碟機和目錄變更為指定的磁片磁碟機和目錄。 *NIDStaticPath*所識別的文字控制項也會使用新的磁片磁碟機和 (或) 目錄名稱進行更新。

填入清單方塊之後, 會移除路徑的磁片磁碟機及/或目錄部分, 以更新*lpPathSpec* 。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#88](../../mfc/reference/codesnippet/cpp/cwnd-class_27.cpp)]

##  <a name="dlgdirlistcombobox"></a>  CWnd::DlgDirListComboBox

使用檔案或目錄清單來填入下拉式方塊的清單方塊。

```
int DlgDirListComboBox(
    LPTSTR lpPathSpec,
    int nIDComboBox,
    int nIDStaticPath,
    UINT nFileType);
```

### <a name="parameters"></a>參數

*lpPathSpec*<br/>
指向包含路徑或檔案名的以 null 終止的字串。 `DlgDirListComboBox`修改這個字串, 因此此資料不能以字串常值的形式呈現。 請參閱下列「備註」一節。

*nIDComboBox*<br/>
在對話方塊中指定下拉式方塊的識別碼。 如果*nIDComboBox*為 0, `DlgDirListComboBox`則會假設沒有下拉式方塊存在, 而且不會嘗試填滿一個。

*nIDStaticPath*<br/>
指定用來顯示目前磁片磁碟機和目錄之靜態文字控制項的識別碼。 如果*nIDStaticPath*為 0, `DlgDirListComboBox`則會假設沒有這類文字控制項存在。

*nFileType*<br/>
指定要顯示之檔案的 DOS 檔案屬性。 它可以是下列值的任意組合:

- DDL_READWRITE 不含其他屬性的讀寫資料檔案。

- DDL_READONLY 唯讀檔案。

- DDL_HIDDEN 隱藏的檔案。

- DDL_SYSTEM 系統檔案。

- DDL_DIRECTORY 目錄。

- DDL_ARCHIVE 封存。

- DDL_POSTMSGS CB_DIR 旗標。 如果已設定 CB_DIR 旗標, Windows 會將產生`DlgDirListComboBox`的訊息放在應用程式的佇列中, 否則會直接傳送至對話方塊程式。

- DDL_DRIVES 磁片磁碟機。 如果已設定 DDL_DRIVES 旗標, 則會自動設定 DDL_EXCLUSIVE 旗標。 因此, 若要建立包含磁片磁碟機和檔案的目錄清單, 您必須`DlgDirListComboBox`呼叫兩次: 一次是設定 DDL_DRIVES 旗標, 一次使用清單的其餘部分。

- DDL_EXCLUSIVE 專有位。 如果設定獨佔位, 則只會列出指定類型的檔案。否則會列出所指定類型的一般檔案和檔案。

### <a name="return-value"></a>傳回值

指定函數的結果。 如果已建立清單, 則為非零值, 即使是空的清單也是如此。 0傳回值表示輸入字串未包含有效的搜尋路徑。

### <a name="remarks"></a>備註

`DlgDirListComboBox`將[CB_RESETCONTENT](/windows/desktop/Controls/cb-resetcontent)和[CB_DIR](/windows/desktop/Controls/cb-dir)訊息傳送至下拉式方塊。 它會將*nIDComboBox*所指定之下拉式方塊的清單方塊填入所有檔案的名稱, 這些檔案符合*lpPathSpec*所指定的路徑。

*LpPathSpec*參數具有下列格式:

`[drive:] [ [\u]directory[\idirectory]...\u] [filename]`

在此範例中,*磁片磁碟機*是磁碟機號,*目錄*是有效的目錄名稱,*檔案名*則是至少必須包含一個萬用字元的有效檔案名。 萬用字元是一個問號 ( **？** ), 這表示會比對任何字元和星號 (<strong>\*</strong>), 這表示符合任意數目的字元。

如果您為*lpPathSpec*指定長度為零的字串, 則會使用目前的目錄, 而不會修改*lpPathSpec* 。 如果您只指定目錄名稱, 但未包含任何檔案規格, 則此字串將會變更為 "\*"。

如果*lpPathSpec*包含磁片磁碟機和/或目錄名稱, 則會在填入清單方塊之前, 將目前的磁片磁碟機和目錄變更為指定的磁片磁碟機和目錄。 *NIDStaticPath*所識別的文字控制項也會使用新的磁片磁碟機和 (或) 目錄名稱進行更新。

填入下拉式方塊清單方塊之後, 會移除路徑的磁片磁碟機及/或目錄部分, 以更新*lpPathSpec* 。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#89](../../mfc/reference/codesnippet/cpp/cwnd-class_28.cpp)]

##  <a name="dlgdirselect"></a>  CWnd::DlgDirSelect

從清單方塊擷取目前的選取範圍。

```
BOOL DlgDirSelect(
    LPTSTR lpString,
    int nIDListBox);
```

### <a name="parameters"></a>參數

*lpString*<br/>
指向要接收清單方塊中目前選取範圍的緩衝區。

*nIDListBox*<br/>
在對話方塊中指定清單方塊的整數識別碼。

### <a name="return-value"></a>傳回值

如果成功則為非零；否則為 0。

### <a name="remarks"></a>備註

它假設清單方塊已由[DlgDirList](#dlgdirlist)成員函式填入, 且選取範圍為磁碟機號、檔案或目錄名稱。

此`DlgDirSelect`成員函式會將選取範圍複製到*lpString*所指定的緩衝區。 如果沒有選取專案, *lpString*就不會變更。

`DlgDirSelect`將[LB_GETCURSEL](/windows/desktop/Controls/lb-getcursel)和[LB_GETTEXT](/windows/desktop/Controls/lb-gettext)訊息傳送至清單方塊。

不允許從清單方塊傳回一個以上的檔案名。 清單方塊不得為多重選取清單方塊。

##  <a name="dlgdirselectcombobox"></a>  CWnd::DlgDirSelectComboBox

從下拉式方塊的清單方塊中擷取目前的選取範圍。

```
BOOL DlgDirSelectComboBox(
    LPTSTR lpString,
    int nIDComboBox);
```

### <a name="parameters"></a>參數

*lpString*<br/>
指向要接收所選路徑的緩衝區。

*nIDComboBox*<br/>
指定對話方塊中下拉式方塊的整數識別碼。

### <a name="return-value"></a>傳回值

如果成功則為非零；否則為 0。

### <a name="remarks"></a>備註

它假設清單方塊已由[DlgDirListComboBox](#dlgdirlistcombobox)成員函式填入, 且選取範圍為磁碟機號、檔案或目錄名稱。

此`DlgDirSelectComboBox`成員函式會將選取範圍複製到指定的緩衝區。 如果沒有選取專案, 則不會變更緩衝區的內容。

`DlgDirSelectComboBox`將[CB_GETCURSEL](/windows/desktop/Controls/cb-getcursel)和[CB_GETLBTEXT](/windows/desktop/Controls/cb-getlbtext)訊息傳送至下拉式方塊。

不允許從下拉式方塊傳回一個以上的檔案名。

##  <a name="dodataexchange"></a>  CWnd::DoDataExchange

由架構呼叫以交換和驗證對話資料。

```
virtual void DoDataExchange(CDataExchange* pDX);
```

### <a name="parameters"></a>參數

*pDX*<br/>
`CDataExchange` 物件的指標。

### <a name="remarks"></a>備註

永遠不要直接呼叫此函式。 它是由[UpdateData](#updatedata)成員函式所呼叫。 呼叫`UpdateData`以初始化對話方塊的控制項, 或從對話方塊中取出資料。

當您從[CDialog](../../mfc/reference/cdialog-class.md)衍生應用程式特定的對話方塊類別時, 如果您想要利用架構的自動資料交換和驗證, 則需要覆寫這個成員函式。 加入變數 精靈會為您包含所需撰寫覆寫的版本，此成員函式的 「 資料對應 」 的對話方塊資料交換 (DDX) 和驗證 (DDV) 全域函式呼叫。

若要自動產生這個成員函式的覆寫版本, 請先使用對話方塊編輯器建立對話方塊資源, 然後再衍生應用程式特定的對話方塊類別。 變數、 資料和驗證範圍與新的對話方塊中的各種控制項，然後使用 加入變數的精靈。 然後, 此 wizard 會寫入`DoDataExchange`已覆寫的, 其中包含資料對應。 以下是加入變數 精靈所產生的範例 DDX/DDV 程式碼區塊：

[!code-cpp[NVC_MFCWindowing#90](../../mfc/reference/codesnippet/cpp/cwnd-class_29.cpp)]

覆`DoDataExchange`寫的成員函式必須在原始程式檔中的巨集式之前。

如需對話方塊資料交換和驗證的詳細資訊, 請參閱[顯示和操作表單中的資料](../../data/odbc/displaying-and-manipulating-data-in-a-form.md)和[對話方塊資料交換和驗證](../../mfc/dialog-data-exchange-and-validation.md)。 如需加入變數 精靈所產生的 DDX_ 和 DDV_ 巨集的說明，請參閱[技術提示 26](../../mfc/tn026-ddx-and-ddv-routines.md)。

##  <a name="dragacceptfiles"></a>  CWnd::DragAcceptFiles

在視窗中，呼叫此成員函式，從使用`CWnd`指標，在您的應用程式中[Afxenablecontrolcontainer](../../mfc/reference/cwinapp-class.md#initinstance)函式來表示視窗接受從 Windows 檔案管理員 或 [檔案總管] 中卸除檔案.

```
void DragAcceptFiles(BOOL bAccept = TRUE);
```

### <a name="parameters"></a>參數

*BAccept*<br/>
指出是否接受拖曳的檔案的旗標。

### <a name="remarks"></a>備註

只有呼叫`DragAcceptFiles` *bAccept*參數設為 TRUE 的視窗, 才會將其本身識別為能夠處理 Windows message WM_DROPFILES。 例如, 在 MDI 應用程式中, 如果`CMDIFrameWnd`在`DragAcceptFiles` `CMDIFrameWnd`函式呼叫中使用視窗指標, 只有視窗會取得 WM_DROPFILES 訊息。 此訊息不會傳送至所有開啟`CMDIChildWnd`的視窗。 若要讓`DragAcceptFiles` `CMDIChildWnd`視窗接收此訊息, 您必須使用視窗指標呼叫。 `CMDIChildWnd`

若要停止接收拖曳的檔案, 請呼叫成員函式, 並將*bAccept*設為 FALSE。

##  <a name="dragdetect"></a>  CWnd::DragDetect

擷取滑鼠並追蹤其移動，直到使用者放開左側按鈕、按下 ESC 鍵，或將滑鼠移到指定點周圍的拖曳矩形外。

```
BOOL DragDetect(POINT pt) const;
```

### <a name="parameters"></a>參數

*pt*<br/>
滑鼠的初始位置 (以螢幕座標表示)。 函式會使用此點來決定拖曳矩形的座標。

### <a name="return-value"></a>傳回值

如果使用者在按住左按鈕的情況下, 將滑鼠移到拖曳矩形之外, 則傳回值為非零。

如果使用者未在按住左按鈕的情況下, 將滑鼠移到拖曳矩形之外, 則傳回值會是零。

### <a name="remarks"></a>備註

此成員函式會模擬函數[DragDetect](/windows/desktop/api/winuser/nf-winuser-dragdetect)的功能, 如 Windows SDK 中所述。

##  <a name="drawanimatedrects"></a>CWnd::D rawAnimatedRects

繪製框線矩形，並以動畫效果呈現它來指出圖示的開頭，或最小化或最大化視窗。

```
BOOL DrawAnimatedRects(
    int idAni,
    CONST RECT* lprcFrom,
    CONST RECT* lprcTo);
```

### <a name="parameters"></a>參數

*idAni*<br/>
指定動畫的類型。 如果您指定 IDANI_CAPTION, 視窗標題會從*lprcFrom*所指定的位置以動畫顯示*lprcTo*所指定的位置。 效果類似于將視窗最小化或最大化。

*lprcFrom*<br/>
[矩形](/previous-versions/dd162897\(v=vs.85\))結構的指標, 指定圖示或最小化視窗的位置和大小。

*lprcTo*<br/>
[矩形](/previous-versions/dd162897\(v=vs.85\))結構的指標, 指定還原視窗的位置和大小

### <a name="return-value"></a>傳回值

如果函式成功則為非零值，否則為 0。

### <a name="remarks"></a>備註

此成員函式會模擬函數[DrawAnimatedRects](/windows/desktop/api/winuser/nf-winuser-drawanimatedrects)的功能, 如 Windows SDK 中所述。

##  <a name="drawcaption"></a>CWnd::D rawCaption

繪製視窗標題。

```
BOOL DrawCaption(
    CDC* pDC,
    LPCRECT lprc,
    UINT uFlags);
```

### <a name="parameters"></a>參數

*pDC*<br/>
裝置內容的指標。 函式會將視窗標題繪製到此裝置內容中。

*lprc*<br/>
矩形結構的指標, 指定視窗標題的周框。

*uFlags*<br/>
指定繪圖選項。 如需值的完整清單, 請參閱[DrawCaption](/windows/desktop/api/winuser/nf-winuser-drawcaption)。

### <a name="return-value"></a>傳回值

如果函式成功則為非零值，否則為 0。

### <a name="remarks"></a>備註

此成員函式會模擬函數[DrawCaption](/windows/desktop/api/winuser/nf-winuser-drawcaption)的功能, 如 Windows SDK 中所述。

##  <a name="drawmenubar"></a>CWnd::D rawMenuBar

重新繪製功能表列。

```
void DrawMenuBar();
```

### <a name="remarks"></a>備註

如果在 Windows 建立視窗之後變更功能表列, 請呼叫此函式來繪製已變更的功能表列。

### <a name="example"></a>範例

  請參閱[CWnd:: GetMenu](#getmenu)的範例。

##  <a name="enableactiveaccessibility"></a>  CWnd::EnableActiveAccessibility

啟用使用者定義的 Active Accessibility 函數。

```
void EnableActiveAccessibility();
```

### <a name="remarks"></a>備註

MFC 的預設 Active Accessibility 支援對標準視窗和控制項 (包括 ActiveX 控制項) 而言已足夠。不過, 如果您`CWnd`的衍生類別包含 nonwindowed 的使用者介面元素, MFC 就無法得知它們。 在這種情況下, 您必須在類別中覆寫適當的[Active Accessibility 成員](/windows/desktop/winauto/sdk-components)函式, `EnableActiveAccessibility`而且您必須在類別的函式中呼叫。

##  <a name="enabledynamiclayout"></a>  CWnd::EnableDynamicLayout

啟用或停用動態配置管理員。 啟用動態配置時，會在使用者調整視窗大小時動態調整子視窗的位置與大小。

```
void EnableDynamicLayout(BOOL bEnable = TRUE);
```

### <a name="parameters"></a>參數

*bEnable*<br/>
TRUE 表示啟用動態配置；FALSE 則停用動態配置。

### <a name="remarks"></a>備註

如果您想要啟用動態配置，除了呼叫這個方法之外，還必須執行其他作業。 您還必須提供動態配置資訊，該資訊指定視窗中的控制項如何回應大小變更。 您可以在資源編輯器中或以程式設計方式，為每個控制項指定這項資訊。 請參閱[動態版面](../../mfc/dynamic-layout.md)配置。

##  <a name="enabled2dsupport"></a>  CWnd::EnableD2DSupport

啟用或停用視窗 D2D 支援。 初始化主視窗之前先呼叫這個方法。

```
void EnableD2DSupport(
    BOOL bEnable = TRUE,
    BOOL bUseDCRenderTarget = FALSE);
```

### <a name="parameters"></a>參數

*bEnable*<br/>
指定是否開啟或關閉 D2D 支援。

*bUseDCRenderTarget*<br/>
指定是否要使用裝置內容 (DC) 呈現目標 CDCRenderTarget。 如果為 FALSE，則會使用 CHwndRenderTarget。

##  <a name="enablescrollbar"></a>  CWnd::EnableScrollBar

啟用或停用一個捲軸的一或兩個箭號。

```
BOOL EnableScrollBar(
    int nSBFlags,
    UINT nArrowFlags = ESB_ENABLE_BOTH);
```

### <a name="parameters"></a>參數

*nSBFlags*<br/>
指定捲軸類型。 可以具有下列其中一個值:

- SB_BOTH 啟用或停用與視窗相關聯之水準和垂直捲動條的箭號。

- SB_HORZ 啟用或停用與視窗相關聯之水準捲軸的箭號。

- SB_VERT 啟用或停用與視窗相關聯的垂直捲動條箭號。

*nArrowFlags*<br/>
指定是否啟用或停用捲軸箭號, 以及啟用或停用的箭號。 可以具有下列其中一個值:

- ESB_ENABLE_BOTH 可同時啟用捲軸的兩個箭號 (預設值)。

- ESB_DISABLE_LTUP 會停用水準捲軸的向左箭號或垂直捲動條的向上箭號。

- ESB_DISABLE_RTDN 會停用水準捲軸的向右箭號或垂直捲動條的向下箭號。

- ESB_DISABLE_BOTH 會停用捲軸的兩個箭號。

### <a name="return-value"></a>傳回值

如果依指定啟用或停用箭號, 則為非零值。 否則為 0, 表示箭號已處於要求的狀態或發生錯誤。

##  <a name="enablescrollbarctrl"></a>  CWnd::EnableScrollBarCtrl

啟用或停用此視窗的捲軸。

```
void EnableScrollBarCtrl(
    int nBar,
    BOOL bEnable = TRUE);
```

### <a name="parameters"></a>參數

*nBar*<br/>
捲軸識別碼。

*bEnable*<br/>
指定是否要啟用或停用捲軸。

### <a name="remarks"></a>備註

如果視窗具有同級捲軸控制項, 則會使用該捲軸;否則會使用視窗本身的捲軸。

##  <a name="enabletooltips"></a>  CWnd::EnableToolTips

啟用指定視窗的工具提示。

```
BOOL EnableToolTips(BOOL bEnable = TRUE);
```

### <a name="parameters"></a>參數

*bEnable*<br/>
指定是否啟用或停用工具提示控制項。 TRUE 會啟用控制項;FALSE 會停用控制項。

### <a name="return-value"></a>傳回值

如果已啟用工具提示, 則為 TRUE;否則為 FALSE。

### <a name="remarks"></a>備註

覆寫[OnToolHitTest](#ontoolhittest)以提供視窗的[TOOLINFO](/windows/desktop/api/commctrl/ns-commctrl-tagtoolinfoa)結構或結構。

> [!NOTE]
> 有些視窗 (例如[CToolBar](../../mfc/reference/ctoolbar-class.md)) 會提供內建的[OnToolHitTest](#ontoolhittest)執行。

如需此結構的詳細資訊, 請參閱 Windows SDK 中的[TOOLINFO](/windows/desktop/api/commctrl/ns-commctrl-tagtoolinfoa) 。

除非父`EnableToolTips`視窗是衍生自`CFrameWnd`, 否則只要呼叫就無法顯示子控制項的工具提示。 這是因為`CFrameWnd`會提供 TTN_NEEDTEXT 通知的預設處理常式。 如果您的父視窗並非衍生自`CFrameWnd`, 也就是說, 如果它是對話方塊或表單檢視, 除非您提供 TTN_NEEDTEXT 工具提示通知的處理常式, 否則子控制項的工具提示不會正確顯示。 請參閱[工具提示](../../mfc/tool-tips-in-windows-not-derived-from-cframewnd.md)。

針對您的 windows `EnableToolTips`所提供的預設工具提示並沒有相關聯的文字。 若要取得工具提示顯示的文字, 在顯示工具提示視窗之前, TTN_NEEDTEXT 通知會傳送至工具提示控制項的父視窗。 如果此訊息沒有處理常式可將某個值指派給`TOOLTIPTEXT`結構的*pszText*成員, 則工具提示不會顯示任何文字。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#91](../../mfc/reference/codesnippet/cpp/cwnd-class_30.cpp)]

[!code-cpp[NVC_MFCWindowing#92](../../mfc/reference/codesnippet/cpp/cwnd-class_31.cpp)]

##  <a name="enabletrackingtooltips"></a>  CWnd::EnableTrackingToolTips

啟用或停用追蹤工具提示。

```
BOOL EnableTrackingToolTips(BOOL bEnable = TRUE);
```

### <a name="parameters"></a>參數

*bEnable*<br/>
指定是否啟用或停用追蹤工具提示。 如果此參數為 TRUE, 則會啟用追蹤工具提示。 如果此參數為 FALSE, 則會停用追蹤工具提示。

### <a name="return-value"></a>傳回值

表示呼叫`EnableWindow`成員函式之前的狀態。 如果視窗先前已停用, 則傳回值為非零。 如果先前已啟用視窗或發生錯誤, 則傳回值為0。

### <a name="remarks"></a>備註

追蹤工具提示是工具提示視窗, 可讓您在螢幕上動態定位。 藉由快速更新位置, 工具提示視窗看起來會順暢地移動或「追蹤」。 如果您需要工具提示文字在指標移動時遵循其位置, 這項功能就很有用。

##  <a name="enablewindow"></a>  CWnd::EnableWindow

啟用或停用滑鼠和鍵盤輸入。

```
BOOL EnableWindow(BOOL bEnable = TRUE);
```

### <a name="parameters"></a>參數

*bEnable*<br/>
指定是否要啟用或停用指定的視窗。 如果此參數為 TRUE, 則會啟用視窗。 如果此參數為 FALSE, 則會停用視窗。

### <a name="return-value"></a>傳回值

表示呼叫`EnableWindow`成員函式之前的狀態。 如果視窗先前已停用, 則傳回值為非零。 如果先前已啟用視窗或發生錯誤, 則傳回值為0。

### <a name="remarks"></a>備註

當 [輸入] 停用時, 會忽略輸入, 例如滑鼠點按和按鍵。 啟用輸入時, 視窗會處理所有輸入。

如果 [已啟用] 狀態為 [正在變更], 則會在此函式傳回之前傳送[WM_ENABLE](#onenable)訊息。

若停用, 則會隱含停用所有子視窗, 但不會傳送 WM_ENABLE 訊息給它們。

您必須先啟用視窗, 才可以啟動它。 例如, 如果應用程式顯示非強制回應對話方塊, 並已停用其主視窗, 則必須先啟用主視窗, 才能終結對話方塊。 否則, 另一個視窗會取得輸入焦點並加以啟用。 如果子視窗已停用, 當 Windows 嘗試決定哪一個視窗應該取得滑鼠訊息時, 就會忽略它。

根據預設, 視窗會在建立時啟用。 應用程式可以在[create](#create)或[CreateEx](#createex)成員函式中指定 WS_DISABLED 樣式, 以建立一開始停用的視窗。 建立視窗之後, 應用程式也可以使用`EnableWindow`成員函式來啟用或停用視窗。

應用程式可以使用此函式來啟用或停用對話方塊中的控制項。 停用的控制項無法接收輸入焦點, 使用者也無法存取它。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#93](../../mfc/reference/codesnippet/cpp/cwnd-class_32.cpp)]

##  <a name="endmodalloop"></a>  CWnd::EndModalLoop

終止對的呼叫`RunModalLoop`。

```
virtual void EndModalLoop(int nResult);
```

### <a name="parameters"></a>參數

*nResult*<br/>
包含要傳回給[RunModalLoop](#runmodalloop)呼叫者的值。

### <a name="remarks"></a>備註

*N 結果*參數會從`RunModalLoop`傳播至傳回值。

##  <a name="endmodalstate"></a>  CWnd::EndModalState

呼叫此成員函式，將框架視窗從強制回應變更為非強制回應。

```
virtual void EndModalState();
```

##  <a name="endpaint"></a>  CWnd::EndPaint

標記在給定視窗中繪製的結束。

```
void EndPaint(LPPAINTSTRUCT lpPaint);
```

### <a name="parameters"></a>參數

*lpPaint*<br/>
指向包含[BeginPaint](#beginpaint)成員函式所抓取之繪製資訊的[PAINTSTRUCT](/windows/desktop/api/winuser/ns-winuser-tagpaintstruct)結構。

### <a name="remarks"></a>備註

成員`EndPaint`函式對`BeginPaint`成員函式的每個呼叫都是必要的, 但只有在完成繪製之後。

如果插入號是由`BeginPaint`成員函式所隱藏, 則會將插入號還原到螢幕上。 `EndPaint`

### <a name="example"></a>範例

  請參閱[CWnd:: BeginPaint](#beginpaint)的範例。

##  <a name="executedlginit"></a>  CWnd::ExecuteDlgInit

初始化對話方塊資源。

```
BOOL ExecuteDlgInit(LPCTSTR lpszResourceName);
BOOL ExecuteDlgInit(LPVOID lpResource);
```

### <a name="parameters"></a>參數

*lpszResourceName*<br/>
指定資源名稱之以 null 終止之字串的指標。

*lpResource*<br/>
資源的指標。

### <a name="return-value"></a>傳回值

如果已執行對話方塊資源, 則為 TRUE;否則為 FALSE。

### <a name="remarks"></a>備註

`ExecuteDlgInit`會使用系結至執行中模組的資源, 或其他來源的資源。 若要完成這`ExecuteDlgInit`項操作, 請呼叫`AfxFindResourceHandle`來尋找資源控制碼。 如果您的 MFC 應用程式不使用共用 DLL (MFCx0 [U] [D]。DLL), `AfxFindResourceHandle`會呼叫[AfxGetResourceHandle](application-information-and-management.md#afxgetresourcehandle), 以傳回可執行檔的目前資源控制碼。 如果您的 MFC 應用程式使用 MFCx0 [U] [D]。Dll, `AfxFindResourceHandle`會遍歷`CDynLinkLibrary`共用和 MFC 延伸 dll 的物件清單, 以尋找正確的資源控制碼。

##  <a name="filtertooltipmessage"></a>  CWnd::FilterToolTipMessage

由架構呼叫以顯示工具提示訊息。

```
void FilterToolTipMessage(MSG* pMsg);
```

### <a name="parameters"></a>參數

*pMsg*<br/>
工具提示訊息的指標。

### <a name="remarks"></a>備註

在大部分的 MFC 應用程式中, 此方法是由[PreTranslateMessage](#pretranslatemessage)和[EnableToolTips](#enabletooltips)的架構所呼叫, 而您不需要自行呼叫它。

不過, 在某些應用程式中 (例如, 某些 ActiveX 控制項), 架構可能不會叫用這些方法, 而您必須自行呼叫 FilterToolTipMessage。 如需詳細資訊, 請參閱[建立工具提示的方法](../../mfc/methods-of-creating-tool-tips.md)。

##  <a name="findwindow"></a>  CWnd::FindWindow

傳回最上層`CWnd` , 其 window 類別是由*lpszClassName*所提供, 而其視窗名稱 (或標題) 是由*lpszWindowName*提供。

```
static CWnd* PASCAL FindWindow(
    LPCTSTR lpszClassName,
    LPCTSTR lpszWindowName);
```

### <a name="parameters"></a>參數

*lpszClassName*<br/>
指向以 null 終止的字串, 指定視窗的類別名稱 ( `WNDCLASS`結構)。 如果*lpClassName*為 Null, 則所有類別名稱都符合。

*lpszWindowName*<br/>
指向以 null 終止的字串, 指定視窗名稱 (視窗的標題)。 如果*lpWindowName*為 Null, 則所有視窗名稱都相符。

### <a name="return-value"></a>傳回值

識別具有指定之類別名稱和視窗名稱的視窗。 如果找不到這類視窗, 則為 Null。

\* `CWnd`可能是暫時性的, 不應該儲存以供稍後使用。

### <a name="remarks"></a>備註

此函式不會搜尋子視窗。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#94](../../mfc/reference/codesnippet/cpp/cwnd-class_33.cpp)]

##  <a name="findwindowex"></a>  CWnd::FindWindowEx

抓取的視窗物件, 其類別名稱和視窗名稱符合指定的字串。

```
static CWnd* FindWindowEx(
    HWND hwndParent,
    HWND hwndChildAfter,
    LPCTSTR lpszClass,
    LPCTSTR lpszWindow);
```

### <a name="parameters"></a>參數

*hwndParent*<br/>
要搜尋其子視窗的父視窗的控制碼。

*hwndChildAfter*<br/>
子視窗的控制碼。 搜尋會以 Z 軸順序從下一個子視窗開始。 子視窗必須是*hwndParent*的直接子視窗, 而不只是子代視窗。

*lpszClass*<br/>
以 null 結束的字串指標, 指定類別名稱或先前呼叫[RegisterClass](/windows/desktop/api/winuser/nf-winuser-registerclassa)或[RegisterClassEx](/windows/desktop/api/winuser/nf-winuser-registerclassexa)所建立的類別 atom。

*lpszWindow*<br/>
以 null 結束的字串指標, 指定視窗名稱 (視窗的標題)。 如果此參數為 Null, 則所有視窗名稱都相符。

### <a name="return-value"></a>傳回值

如果函式成功, 則傳回值會是具有指定的類別和視窗名稱之 window 物件的指標。 如果函數失敗, 則傳回值為 Null。

### <a name="remarks"></a>備註

此成員函式會模擬函數[FindWindowEx](/windows/desktop/api/winuser/nf-winuser-findwindowexa)的功能, 如 Windows SDK 中所述。

##  <a name="flashwindow"></a>  CWnd::FlashWindow

指定的視窗 閃爍一次。

```
BOOL FlashWindow(BOOL bInvert);
```

### <a name="parameters"></a>參數

*bInvert*<br/>
指定是否`CWnd`要快閃或回到其原始狀態。 如果*bInvert*為 TRUE, 則會從某個狀態閃至另一個狀態。`CWnd` 如果*bInvert*為 FALSE, 則視窗會回到其原始狀態 (作用中或非作用中)。

### <a name="return-value"></a>傳回值

如果視窗在呼叫`FlashWindow`成員函式之前為作用中, 則為非零, 否則為0。

### <a name="remarks"></a>備註

若為連續閃爍, 請建立系統計時器並重複`FlashWindow`呼叫。 閃爍`CWnd`表示變更其標題列的外觀如同`CWnd`已變更為 作用中的非作用中狀態，從，反之亦然。 (非作用中的標題列會變更為使用中的標題列, 而作用中的標題列則會變更為非作用中的標題列)。

一般來說, 視窗會閃爍以通知使用者它需要注意, 但目前沒有輸入焦點。

只有當視窗取得輸入焦點且不再閃爍時, *bInvert*參數才應該為 FALSE。在等候取得輸入焦點的後續呼叫時, 應為 TRUE。

針對最小化的視窗, 此函式一律會傳回非零。 如果視窗最小化, `FlashWindow`只會將視窗的圖示閃爍;最小化的視窗會忽略*bInvert* 。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#95](../../mfc/reference/codesnippet/cpp/cwnd-class_34.cpp)]

##  <a name="flashwindowex"></a>  CWnd::FlashWindowEx

指定的視窗 閃爍。

```
BOOL FlashWindowEx(
    DWORD dwFlags,
    UINT uCount,
    DWORD dwTimeout);
```

### <a name="parameters"></a>參數

*dwFlags*<br/>
指定 flash 狀態。 如需值的完整清單, 請參閱[FLASHWINFO](/windows/desktop/api/winuser/ns-winuser-flashwinfo)結構。

*uCount*<br/>
指定要快閃視窗的次數。

*dwTimeout*<br/>
指定視窗的閃爍頻率 (以毫秒為單位)。 如果*dwTimeout*為零, 則函數會使用預設資料指標閃爍頻率。

### <a name="return-value"></a>傳回值

傳回值會在呼叫`FlashWindowEx`函式之前, 指定視窗的狀態。 如果視窗標題在呼叫之前已繪製為使用中, 則傳回值為非零。 否則, 傳回值為零。

### <a name="remarks"></a>備註

這個方法會模擬函數[FlashWindowEx](/windows/desktop/api/winuser/nf-winuser-flashwindowex)的功能, 如 Windows SDK 中所述。

##  <a name="fromhandle"></a>  CWnd::FromHandle

將控制代碼提供給視窗時，將指標傳回至 `CWnd` 物件。 如果 `CWnd` 物件沒有附加至控制代碼，會建立並附加暫存 `CWnd` 物件。

```
static CWnd* PASCAL FromHandle(HWND hWnd);
```

### <a name="parameters"></a>參數

*hWnd*<br/>
Windows 視窗的 HWND。

### <a name="return-value"></a>傳回值

將控制代碼提供給視窗時，將指標傳回至 `CWnd` 物件。 如果 `CWnd` 物件沒有附加至控制代碼，會建立並附加暫存 `CWnd` 物件。

該指標可能是暫時性的，因此不應該儲存供日後使用。

##  <a name="fromhandlepermanent"></a>CWnd:: FromHandlePermanent

將控制代碼提供給視窗時，將指標傳回至 `CWnd` 物件。

```
static CWnd* PASCAL FromHandlePermanent(HWND hWnd);
```

### <a name="parameters"></a>參數

*hWnd*<br/>
Windows 視窗的 HWND。

### <a name="return-value"></a>傳回值

`CWnd` 物件的指標。

### <a name="remarks"></a>備註

`CWnd`如果物件未附加至控制碼, 則會傳回 Null。

與[FromHandle](#fromhandle)不同的是, 這個函式不會建立暫存物件。

##  <a name="get_accchild"></a>  CWnd::get_accChild

由架構呼叫以擷取指定子系的 `IDispatch` 介面位址。

```
virtual HRESULT get_accChild(
    VARIANT varChild,
    IDispatch** ppdispChild);
```

### <a name="parameters"></a>參數

*varChild*<br/>
識別要抓取其`IDispatch`介面的子系。

*ppdispChild*<br/>
接收子物件`IDispatch`介面的位址。

### <a name="return-value"></a>傳回值

在成功時傳回 S_OK, 失敗時傳回 COM 錯誤碼。 請參閱 Windows SDK 的[IAccessible:: get_accChild](/windows/desktop/api/oleacc/nf-oleacc-iaccessible-get_accchild)中的傳回**值**。

### <a name="remarks"></a>備註

此函式是 MFC [Active Accessibility](/windows/desktop/WinAuto/microsoft-active-accessibility)支援的一部分。

如果您有 nonwindowed 使用者`CWnd`介面專案 (MFC 所處理的無視窗 ActiveX 控制項), 請覆寫衍生類別中的這個函式。

如需詳細資訊, 請參閱 Windows SDK 中的[IAccessible:: get_accChild](/windows/desktop/api/oleacc/nf-oleacc-iaccessible-get_accchild) 。

##  <a name="get_accchildcount"></a>  CWnd::get_accChildCount

由架構呼叫以擷取屬於此物件的子物件數目。

```
virtual HRESULT get_accChildCount(long* pcountChildren);
```

### <a name="parameters"></a>參數

*pcountChildren*<br/>
接收子系的數目。

### <a name="return-value"></a>傳回值

在成功時傳回 S_OK, 失敗時傳回 COM 錯誤碼。 請參閱 Windows SDK 的[IAccessible:: get_accChildCount](/windows/desktop/api/oleacc/nf-oleacc-iaccessible-get_accchildcount)中的傳回**值**。

### <a name="remarks"></a>備註

此函式是 MFC [Active Accessibility](/windows/desktop/WinAuto/microsoft-active-accessibility)支援的一部分。

如果您有 nonwindowed 使用者`CWnd`介面專案 (MFC 所處理的無視窗 ActiveX 控制項), 請覆寫衍生類別中的這個函式。 呼叫基底類別版本，然後再加入 nonwindowed 子項目。

如需詳細資訊, 請參閱 Windows SDK 中的[IAccessible:: get_accChildCount](/windows/desktop/api/oleacc/nf-oleacc-iaccessible-get_accchildcount) 。

##  <a name="get_accdefaultaction"></a>  CWnd::get_accDefaultAction

由架構呼叫以擷取具有物件預設動作描述的字串。

```
virtual HRESULT get_accDefaultAction(
    VARIANT varChild,
    BSTR* pszDefaultAction);
```

### <a name="parameters"></a>參數

*varChild*<br/>
指定要抓取的預設動作是物件的, 還是物件的其中一個子項目。 這個參數可以是 CHILDID_SELF (取得物件的相關資訊) 或子識別碼 (以取得物件之子專案的相關資訊)。

*pszDefaultAction*<br/>
BSTR 的位址, 會接收描述指定物件之預設動作的當地語系化字串, 如果此物件沒有預設動作, 則為 Null。

### <a name="return-value"></a>傳回值

在成功時傳回 S_OK, 失敗時傳回 COM 錯誤碼。 請參閱 Windows SDK 的[IAccessible:: get_accDefaultAction](/windows/desktop/api/oleacc/nf-oleacc-iaccessible-get_accdefaultaction)中的傳回**值**。

### <a name="remarks"></a>備註

此函式是 MFC [Active Accessibility](/windows/desktop/WinAuto/microsoft-active-accessibility)支援的一部分。

覆寫衍生類別中`CWnd`的這個函式, 以描述物件的預設動作。

如需詳細資訊, 請參閱 Windows SDK 中的[IAccessible:: get_accDefaultAction](/windows/desktop/api/oleacc/nf-oleacc-iaccessible-get_accdefaultaction) 。

##  <a name="get_accdescription"></a>  CWnd::get_accDescription

由架構呼叫以擷取含有指定物件的視覺外觀描述的字串。

```
virtual HRESULT get_accDescription(
    VARIANT varChild,
    BSTR* pszDescription);
```

### <a name="parameters"></a>參數

*varChild*<br/>
指定要抓取的描述是物件或物件的其中一個子項目。 這個參數可以是 CHILDID_SELF (取得物件的相關資訊) 或子識別碼 (以取得物件之子專案的相關資訊)。

*pszDescription*<br/>
BSTR 的位址, 會接收描述指定之物件的當地語系化字串, 如果此物件沒有可用的描述, 則為 Null。

### <a name="return-value"></a>傳回值

在成功時傳回 S_OK, 失敗時傳回 COM 錯誤碼。 請參閱 Windows SDK 的[IAccessible:: get_accDescription](/windows/desktop/api/oleacc/nf-oleacc-iaccessible-get_accdescription)中的傳回**值**。

### <a name="remarks"></a>備註

此函式是 MFC [Active Accessibility](/windows/desktop/WinAuto/microsoft-active-accessibility)支援的一部分。

覆寫衍生類別中`CWnd`的這個函式, 以描述您的物件。 呼叫基類版本, 並新增您的描述。

如需詳細資訊, 請參閱 Windows SDK 中的[IAccessible:: get_accDescription](/windows/desktop/api/oleacc/nf-oleacc-iaccessible-get_accdescription) 。

##  <a name="get_accfocus"></a>  CWnd::get_accFocus

由架構呼叫以擷取具有鍵盤焦點的物件。

```
virtual HRESULT get_accFocus(VARIANT* pvarChild);
```

### <a name="parameters"></a>參數

*pvarChild*<br/>
接收具有焦點之物件的相關資訊。 請參閱 Windows SDK 的[IAccessible:: get_accFocus](/windows/desktop/api/oleacc/nf-oleacc-iaccessible-get_accfocus)中的*pvarID* 。

### <a name="return-value"></a>傳回值

在成功時傳回 S_OK, 失敗時傳回 COM 錯誤碼。 請參閱 Windows SDK 中`IAccessible::get_accFocus`的傳回值。

### <a name="remarks"></a>備註

此函式是 MFC [Active Accessibility](/windows/desktop/WinAuto/microsoft-active-accessibility)支援的一部分。

如果您有 nonwindowed 使用者`CWnd`介面專案 (MFC 所處理的無視窗 ActiveX 控制項), 請覆寫衍生類別中的這個函式。

如需詳細資訊, 請參閱 Windows SDK 中的[IAccessible:: get_accFocus](/windows/desktop/api/oleacc/nf-oleacc-iaccessible-get_accfocus) 。

##  <a name="get_acchelp"></a>  CWnd::get_accHelp

由架構呼叫以抓取物件的**Help**屬性字串。

```
virtual HRESULT get_accHelp(
    VARIANT varChild,
    BSTR* pszHelp);
```

### <a name="parameters"></a>參數

*varChild*<br/>
指定要抓取的說明資訊是物件的還是物件的其中一個子專案。 這個參數可以是 CHILDID_SELF (取得物件的相關資訊) 或子識別碼 (以取得物件之子專案的相關資訊)。

*pszHelp*<br/>
BSTR 的位址, 接收包含指定物件之說明資訊的當地語系化字串, 如果沒有可用的說明資訊, 則為 Null。

### <a name="return-value"></a>傳回值

在成功時傳回 S_OK, 失敗時傳回 COM 錯誤碼。 請參閱 Windows SDK 的[IAccessible:: get_accHelp](/windows/desktop/api/oleacc/nf-oleacc-iaccessible-get_acchelp)中的傳回**值**。

### <a name="remarks"></a>備註

此函式是 MFC [Active Accessibility](/windows/desktop/WinAuto/microsoft-active-accessibility)支援的一部分。

覆寫衍生類別中`CWnd`的這個函式, 以提供物件的解說文字。

如需詳細資訊, 請參閱 Windows SDK 中的[IAccessible:: get_accHelp](/windows/desktop/api/oleacc/nf-oleacc-iaccessible-get_acchelp) 。

##  <a name="get_acchelptopic"></a>  CWnd::get_accHelpTopic

由架構呼叫, 以抓取與指定物件相關聯之**WinHelp**檔案的完整路徑, 以及該檔案內適當主題的識別碼。

```
virtual HRESULT get_accHelpTopic(
    BSTR* pszHelpFile,
    VARIANT varChild,
    long* pidTopic);
```

### <a name="parameters"></a>參數

*pszHelpFile*<br/>
BSTR 的位址, 接收與指定物件相關聯之`WinHelp`檔案的完整路徑 (如果有的話)。

*varChild*<br/>
指定要抓取的說明主題是物件的還是物件的其中一個子專案。 這個參數可以是子的 CHILDID_SELF （若要取得說明 主題的物件） 或 （若要取得說明主題的其中一個物件元素） 的子識別碼。

*pidTopic*<br/>
識別與指定物件相關聯的說明檔主題。 請參閱 Windows SDK 的[IAccessible:: get_accHelpTopic](/windows/desktop/api/oleacc/nf-oleacc-iaccessible-get_acchelptopic)中的*pidTopic* 。

### <a name="return-value"></a>傳回值

在成功時傳回 S_OK, 失敗時傳回 COM 錯誤碼。 請參閱 Windows SDK 中`IAccessible::get_accHelpTopic`的傳回值。

### <a name="remarks"></a>備註

此函式是 MFC [Active Accessibility](/windows/desktop/WinAuto/microsoft-active-accessibility)支援的一部分。

覆寫衍生類別中`CWnd`的這個函式, 以提供有關物件的說明資訊。

如需詳細資訊, 請參閱 Windows SDK 中的[IAccessible:: get_accHelpTopic](/windows/desktop/api/oleacc/nf-oleacc-iaccessible-get_acchelptopic) 。

##  <a name="get_acckeyboardshortcut"></a>  CWnd::get_accKeyboardShortcut

由架構呼叫以擷取指定物件的快速鍵或便捷鍵。

```
virtual HRESULT get_accKeyboardShortcut(
    VARIANT varChild,
    BSTR* pszKeyboardShortcut);
```

### <a name="parameters"></a>參數

*varChild*<br/>
指定要抓取的鍵盤快速鍵是物件的還是物件的其中一個子項目。 這個參數可以是 CHILDID_SELF (取得物件的相關資訊) 或子識別碼 (以取得物件之子專案的相關資訊)。

*pszKeyboardShortcut*<br/>
接收識別鍵盤快速鍵之當地語系化字串的 BSTR 位址, 如果沒有鍵盤快速鍵與指定的物件相關聯, 則為 Null。

### <a name="return-value"></a>傳回值

在成功時傳回 S_OK, 失敗時傳回 COM 錯誤碼。 請參閱 Windows SDK 的[IAccessible:: get_accKeyboardShortcut](/windows/desktop/api/oleacc/nf-oleacc-iaccessible-get_acckeyboardshortcut)中的傳回**值**。

### <a name="remarks"></a>備註

此函式是 MFC [Active Accessibility](/windows/desktop/WinAuto/microsoft-active-accessibility)支援的一部分。

覆寫衍生類別中`CWnd`的這個函式, 以識別物件的鍵盤快速鍵。

如需詳細資訊, 請參閱 Windows SDK 中的[IAccessible:: get_accKeyboardShortcut](/windows/desktop/api/oleacc/nf-oleacc-iaccessible-get_acckeyboardshortcut) 。

##  <a name="get_accname"></a>  CWnd::get_accName

由架構呼叫以擷取指定物件的名稱。

```
virtual HRESULT get_accName(
    VARIANT varChild,
    BSTR* pszName);
```

### <a name="parameters"></a>參數

*varChild*<br/>
指定要抓取的名稱是物件的名稱, 還是物件的其中一個子項目。 這個參數可以是 CHILDID_SELF (取得物件的相關資訊) 或子識別碼 (以取得物件之子專案的相關資訊)。

*pszName*<br/>
接收包含指定物件名稱的字串之 BSTR 的位址。

### <a name="return-value"></a>傳回值

在成功時傳回 S_OK, 失敗時傳回 COM 錯誤碼。 請參閱 Windows SDK 的[IAccessible:: get_accName](/windows/desktop/api/oleacc/nf-oleacc-iaccessible-get_accname)中的傳回**值**。

### <a name="remarks"></a>備註

此函式是 MFC [Active Accessibility](/windows/desktop/WinAuto/microsoft-active-accessibility)支援的一部分。

覆寫衍生類別中`CWnd`的這個函式, 以傳回物件的名稱。

如需詳細資訊, 請參閱 Windows SDK 中的[IAccessible:: get_accName](/windows/desktop/api/oleacc/nf-oleacc-iaccessible-get_accname) 。

##  <a name="get_accparent"></a>  CWnd::get_accParent

由架構呼叫以擷取物件之父代的 `IDispatch` 介面。

```
virtual HRESULT get_accParent(IDispatch** ppdispParent);
```

### <a name="parameters"></a>參數

*ppdispParent*<br/>
接收父物件`IDispatch`介面的位址。 如果父系不存在, 或子系無法存取其父系, 則會將變數設定為 Null。

### <a name="return-value"></a>傳回值

在成功時傳回 S_OK, 失敗時傳回 COM 錯誤碼。 請參閱 Windows SDK 的[IAccessible:: get_accParent](/windows/desktop/api/oleacc/nf-oleacc-iaccessible-get_accparent)中的傳回**值**。

### <a name="remarks"></a>備註

此函式是 MFC [Active Accessibility](/windows/desktop/WinAuto/microsoft-active-accessibility)支援的一部分。

在大多數情況下, 您不需要覆寫此函數。

如需詳細資訊, 請參閱 Windows SDK 中的[IAccessible:: get_accParent](/windows/desktop/api/oleacc/nf-oleacc-iaccessible-get_accparent) 。

##  <a name="get_accrole"></a>  CWnd::get_accRole

由架構呼叫以擷取含有指定物件的角色描述資訊。

```
virtual HRESULT get_accRole(
    VARIANT varChild,
    VARIANT* pvarRole);
```

### <a name="parameters"></a>參數

*varChild*<br/>
指定要抓取的角色資訊是物件的, 還是物件的其中一個子項目。 這個參數可以是 CHILDID_SELF (取得物件的相關資訊) 或子識別碼 (以取得物件之子專案的相關資訊)。

*pvarRole*<br/>
接收角色資訊。 請參閱 Windows SDK 的[IAccessible:: get_accRole](/windows/desktop/api/oleacc/nf-oleacc-iaccessible-get_accrole)中的*pvarRole* 。

### <a name="return-value"></a>傳回值

在成功時傳回 S_OK, 失敗時傳回 COM 錯誤碼。 請參閱 Windows SDK 中`IAccessible::get_accRole`的傳回值。

### <a name="remarks"></a>備註

此函式是 MFC [Active Accessibility](/windows/desktop/WinAuto/microsoft-active-accessibility)支援的一部分。

如果您有 nonwindowed 使用者`CWnd`介面專案 (MFC 所處理的無視窗 ActiveX 控制項), 請覆寫衍生類別中的這個函式。

如需詳細資訊, 請參閱 Windows SDK 中的[IAccessible:: get_accRole](/windows/desktop/api/oleacc/nf-oleacc-iaccessible-get_accrole) 。

##  <a name="get_accselection"></a>  CWnd::get_accSelection

由架構呼叫以擷取此物件的選取子物件。

```
virtual HRESULT get_accSelection(VARIANT* pvarChildren);
```

### <a name="parameters"></a>參數

*pvarChildren*<br/>
接收所選子系的相關資訊。 請參閱 Windows SDK 的[IAccessible:: get_accSelection](/windows/desktop/api/oleacc/nf-oleacc-iaccessible-get_accselection)中的*pvarChildren* 。

### <a name="return-value"></a>傳回值

在成功時傳回 S_OK, 失敗時傳回 COM 錯誤碼。 請參閱 Windows SDK 中`IAccessible::get_accSelection`的傳回值。

### <a name="remarks"></a>備註

此函式是 MFC [Active Accessibility](/windows/desktop/WinAuto/microsoft-active-accessibility)支援的一部分。

如果您有 nonwindowed 使用者`CWnd`介面專案 (MFC 所處理的無視窗 ActiveX 控制項), 請覆寫衍生類別中的這個函式。

如需詳細資訊, 請參閱 Windows SDK 中的[IAccessible:: get_accSelection](/windows/desktop/api/oleacc/nf-oleacc-iaccessible-get_accselection) 。

##  <a name="get_accstate"></a>  CWnd::get_accState

由架構呼叫以擷取指定物件的目前狀態。

```
virtual HRESULT get_accState(
    VARIANT varChild,
    VARIANT* pvarState);
```

### <a name="parameters"></a>參數

*varChild*<br/>
指定要抓取的狀態資訊是物件或物件的其中一個子項目。 這個參數可以是 CHILDID_SELF (取得物件的相關資訊) 或子識別碼 (以取得物件之子專案的相關資訊)。

*pvarState*<br/>
接收物件狀態的相關資訊。 請參閱 Windows SDK 的[IAccessible:: get_accState](/windows/desktop/api/oleacc/nf-oleacc-iaccessible-get_accstate)中的*pvarState* 。

### <a name="return-value"></a>傳回值

在成功時傳回 S_OK, 失敗時傳回 COM 錯誤碼。 請參閱 Windows SDK 中`IAccessible::get_accState`的傳回值。

### <a name="remarks"></a>備註

此函式是 MFC [Active Accessibility](/windows/desktop/WinAuto/microsoft-active-accessibility)支援的一部分。

如果您有 nonwindowed 使用者`CWnd`介面專案 (MFC 所處理的無視窗 ActiveX 控制項), 請覆寫衍生類別中的這個函式。

如需詳細資訊, 請參閱 Windows SDK 中的[IAccessible:: get_accState](/windows/desktop/api/oleacc/nf-oleacc-iaccessible-get_accstate) 。

##  <a name="get_accvalue"></a>  CWnd::get_accValue

由架構呼叫以擷取指定物件的值。

```
virtual HRESULT get_accValue(
    VARIANT varChild,
    BSTR* pszValue);
```

### <a name="parameters"></a>參數

*varChild*<br/>
指定要抓取的值資訊是物件或物件的其中一個子項目。 這個參數可以是 CHILDID_SELF (取得物件的相關資訊) 或子識別碼 (以取得物件之子專案的相關資訊)。

*pszValue*<br/>
接收包含物件目前值的當地語系化字串之 BSTR 的位址。

### <a name="return-value"></a>傳回值

在成功時傳回 S_OK, 失敗時傳回 COM 錯誤碼。 請參閱 Windows SDK 的[IAccessible:: get_accValue](/windows/desktop/api/oleacc/nf-oleacc-iaccessible-get_accvalue)中的傳回**值**。

### <a name="remarks"></a>備註

此函式是 MFC [Active Accessibility](/windows/desktop/WinAuto/microsoft-active-accessibility)支援的一部分。

如果您有 nonwindowed 使用者`CWnd`介面專案 (MFC 所處理的無視窗 ActiveX 控制項), 請覆寫衍生類別中的這個函式。

如需詳細資訊, 請參閱 Windows SDK 中的[IAccessible:: get_accValue](/windows/desktop/api/oleacc/nf-oleacc-iaccessible-get_accvalue) 。

##  <a name="getactivewindow"></a>  CWnd::GetActiveWindow

抓取使用中視窗的指標。

```
static CWnd* PASCAL GetActiveWindow();
```

### <a name="return-value"></a>傳回值

使用中視窗, 如果呼叫時沒有作用中的視窗, 則為 Null。 該指標可能是暫時性的，因此不應該儲存供日後使用。

### <a name="remarks"></a>備註

使用中視窗可能是具有目前輸入焦點的視窗, 或是[SetActiveWindow](#setactivewindow)成員函式明確成為作用中的視窗。

##  <a name="getancestor"></a>  CWnd::GetAncestor

擷取指定視窗的上階視窗物件。

```
CWnd* GetAncestor(UINT gaFlags) const;
```

### <a name="parameters"></a>參數

*gaFlags*<br/>
指定要抓取的祖系。 如需可能值的完整清單, 請參閱[GetAncestor](/windows/desktop/api/winuser/nf-winuser-getancestor)。

### <a name="return-value"></a>傳回值

如果函式成功, 則傳回值會是祖系視窗物件的指標。 如果函數失敗, 則傳回值為 Null。

### <a name="remarks"></a>備註

此成員函式會模擬函數[GetAncestor](/windows/desktop/api/winuser/nf-winuser-getancestor)的功能, 如 Windows SDK 中所述。

##  <a name="getcapture"></a>  CWnd::GetCapture

抓取具有滑鼠捕捉的視窗。

```
static CWnd* PASCAL GetCapture();
```

### <a name="return-value"></a>傳回值

識別具有滑鼠捕捉的視窗。 如果沒有視窗具有滑鼠捕捉, 則為 Null。

傳回值可能是暫時性的, 而且不應該儲存以供稍後使用。

### <a name="remarks"></a>備註

在任何指定時間, 只有一個視窗具有滑鼠捕捉。 呼叫[SetCapture](#setcapture)成員函式時, 視窗會收到滑鼠捕捉。 不論游標是否在其框線中, 此視窗都會收到滑鼠輸入。

##  <a name="getcaretpos"></a>  CWnd::GetCaretPos

抓取插入號之目前位置的用戶端座標, 並將`CPoint`其傳回為。

```
static CPoint PASCAL GetCaretPos();
```

### <a name="return-value"></a>傳回值

[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)物件, 其中包含插入號位置的座標。

### <a name="remarks"></a>備註

插入號位置會在`CWnd`視窗的工作區座標中提供。

##  <a name="getcheckedradiobutton"></a>  CWnd::GetCheckedRadioButton

抓取指定群組中目前已核取之選項按鈕的識別碼。

```
int GetCheckedRadioButton(
    int nIDFirstButton,
    int nIDLastButton);
```

### <a name="parameters"></a>參數

*nIDFirstButton*<br/>
指定群組中第一個選項按鈕的整數識別碼。

*nIDLastButton*<br/>
指定群組中最後一個選項按鈕的整數識別碼。

### <a name="return-value"></a>傳回值

已核取選項按鈕的識別碼, 如果未選取, 則為0。

##  <a name="getclientrect"></a>  CWnd::GetClientRect

將工作區的用戶端`CWnd`座標複製到*lpRect*所指向的結構中。

```
void GetClientRect(LPRECT lpRect) const;
```

### <a name="parameters"></a>參數

*lpRect*<br/>
指向[矩形結構](/windows/desktop/api/windef/ns-windef-tagrect)或`CRect`物件以接收用戶端座標。 `left` 和`top`成員將會是0。 `right` 和`bottom`成員將包含視窗的寬度和高度。

### <a name="remarks"></a>備註

用戶端座標會指定工作區的左上角和右下角。 因為用戶端座標相對於工作區的左上角`CWnd` , 所以左上角的座標為 (0, 0)。

### <a name="example"></a>範例

  請參閱[CWnd:: IsIconic](#isiconic)的範例。

##  <a name="getclipboardowner"></a>CWnd:: GetClipboardOwner

抓取剪貼簿的目前擁有者。

```
static CWnd* PASCAL GetClipboardOwner();
```

### <a name="return-value"></a>傳回值

如果函式成功, 則識別擁有剪貼簿的視窗。 否則, 它會是 Null。

傳回的指標可能是暫時性的, 不應該儲存以供稍後使用。

### <a name="remarks"></a>備註

剪貼簿仍然可以包含資料, 即使它目前並未擁有。

##  <a name="getclipboardviewer"></a>  CWnd::GetClipboardViewer

抓取剪貼簿-檢視器鏈中的第一個視窗。

```
static CWnd* PASCAL GetClipboardViewer();
```

### <a name="return-value"></a>傳回值

識別目前負責顯示剪貼簿的視窗 (如果成功);否則為 Null (例如, 如果沒有檢視器)。

傳回的指標可能是暫時性的, 不應該儲存以供稍後使用。

##  <a name="getcontrolunknown"></a>  CWnd::GetControlUnknown

呼叫這個成員函式可抓取未知 OLE 控制項的指標。

```
LPUNKNOWN GetControlUnknown();
```

### <a name="return-value"></a>傳回值

這個`CWnd`物件所表示之 OLE 控制項的[IUnknown](/windows/desktop/api/unknwn/nn-unknwn-iunknown)介面指標。 如果這個物件不代表 OLE 控制項, 則傳回值會是 Null。

### <a name="remarks"></a>備註

您不應該釋放這個`IUnknown`指標。 一般來說, 您會使用來取得控制項的特定介面。

傳回的介面指標不`GetControlUnknown`是參考計數。 請勿在指標上呼叫[iunknown:: Release](/windows/desktop/api/unknwn/nf-unknwn-iunknown-release) , 除非您先前已在其上呼叫 iunknown [:: AddRef](/windows/desktop/api/unknwn/nf-unknwn-iunknown-addref) 。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#96](../../mfc/reference/codesnippet/cpp/cwnd-class_35.cpp)]

##  <a name="getcurrentmessage"></a>  CWnd::GetCurrentMessage

傳回此視窗目前正在處理的訊息指標。 只有在<em>訊息</em>訊息處理常式成員函式**上**的時, 才應該呼叫。

```
static const MSG* PASCAL GetCurrentMessage();
```

### <a name="return-value"></a>傳回值

傳回包含視窗目前正在處理之訊息的[MSG](/windows/desktop/api/winuser/ns-winuser-tagmsg)結構的指標。 只有在<em>訊息</em>處理常式**上**的時, 才應該呼叫。

### <a name="example"></a>範例

  請參閱[CMDIFrameWnd:: MDICascade](../../mfc/reference/cmdiframewnd-class.md#mdicascade)的範例。

##  <a name="getdc"></a>  CWnd::GetDC

根據為`CWnd`指定的類別樣式, 抓取工作區之通用、類別或私用裝置內容的指標。

```
CDC* GetDC();
```

### <a name="return-value"></a>傳回值

如果成功, 則識別`CWnd`工作區的裝置內容; 否則, 傳回值為 Null。 該指標可能是暫時性的，因此不應該儲存供日後使用。

### <a name="remarks"></a>備註

針對常見的裝置內容`GetDC` , 每次抓取時, 會將預設屬性指派給內容。 針對類別和私用內容`GetDC` , 將先前指派的屬性保留不變。 裝置內容可用於後續的圖形裝置介面 (GDI) 函式, 以便在工作區中繪製。

除非裝置內容屬於視窗類別, 否則必須呼叫[ReleaseDC](#releasedc)成員函式, 以便在繪製之後釋放內容。

當註冊類別時, 如果`CWnd` CS_CLASSDC、CS_OWNDC 或 CS_PARENTDC `GetDC`已指定`WNDCLASS`為結構中的樣式, 則成員函式會傳回屬於該類別的裝置內容。

##  <a name="getdcex"></a>  CWnd::GetDCEx

抓取`CWnd`視窗的裝置內容控制碼。

```
CDC* GetDCEx(
    CRgn* prgnClip,
    DWORD flags);
```

### <a name="parameters"></a>參數

*prgnClip*<br/>
識別可能與用戶端視窗的可見區域結合的裁剪區域。

*flags*<br/>
可以具有下列其中一個預設值:

- DCX_CACHE 會從快取傳回裝置內容, 而不是從 [OWNDC] 或 [CLASSDC] 視窗。 覆寫 CS_OWNDC 和 CS_CLASSDC。

- DCX_CLIPCHILDREN 會排除`CWnd`視窗下方所有子視窗的可見區域。

- DCX_CLIPSIBLINGS 會排除`CWnd`視窗上方所有同輩視窗的可見區域。

- DCX_EXCLUDERGN 會從傳回的裝置內容的可見區域中排除*prgnClip*所識別的裁剪區域。

- DCX_INTERSECTRGN 會與*prgnClip*所識別的裁剪區域交集, 而該區域是由所傳回之裝置內容的可見區域內的。

- DCX_LOCKWINDOWUPDATE 允許繪製, 即使有`LockWindowUpdate`作用中的呼叫, 也會排除此視窗。 這個值會在追蹤期間用於繪製。

- DCX_PARENTCLIP 會使用父視窗的可見區域, 並忽略父視窗的 WS_CLIPCHILDREN 和 WS_PARENTDC 樣式位。 這個值會將裝置內容的原點設定為`CWnd`視窗的左上角。

- DCX_WINDOW 會傳回對應至視窗矩形的裝置內容, 而不是用戶端矩形。

### <a name="return-value"></a>傳回值

如果函式成功, 則為指定之視窗的裝置內容;否則為 Null。

### <a name="remarks"></a>備註

裝置內容可用於後續的 GDI 函式, 以便在工作區中繪製。

此函式是[GetDC](/windows/desktop/api/winuser/nf-winuser-getdc)函數的擴充功能, 可讓應用程式更充分掌控視窗的裝置內容是否已裁剪。

裝置內容所屬的視窗類別，除非[ReleaseDC](/windows/desktop/api/winuser/nf-winuser-releasedc)呼叫函式必須在 繪圖之後釋出內容。 由於在任何指定的時間都只能使用五個常見的裝置內容, 因此無法釋放裝置內容, 可能會導致其他應用程式無法存取裝置內容。

若要取得快取的裝置內容, 應用程式必須指定[DCX_CACHE](/windows/desktop/api/winuser/nf-winuser-getdcex)。 如果未指定 DCX_CACHE, 而且視窗既不是 CS_OWNDC 也不是[CS_CLASSDC](/windows/desktop/api/winuser/ns-winuser-tagwndclassa), 則此函式會傳回 Null。

如果已在註冊類別時, 在[WNDCLASS](/windows/desktop/api/winuser/ns-winuser-tagwndclassa)結構中指定 CS_CLASSDC、 [CS_OWNDC](/windows/desktop/api/winuser/ns-winuser-tagwndclassa)或[CS_PARENTDC](/windows/desktop/api/winuser/ns-winuser-tagwndclassa)樣式, 則[GetDCEx](/windows/desktop/api/winuser/nf-winuser-getdcex)函數會傳回具有特殊特性的裝置內容。

如需有關這些特性的詳細資訊, 請參閱 Windows SDK `WNDCLASS`中結構的描述。

##  <a name="getdcrendertarget"></a>  CWnd::GetDCRenderTarget

擷取裝置內容 (DC) 會呈現 `CWnd` 視窗的目標。

```
CDCRenderTarget* GetDCRenderTarget();
```

### <a name="return-value"></a>傳回值

如果函式成功, 裝置內容會呈現指定視窗的目標;否則為 Null。

### <a name="remarks"></a>備註

##  <a name="getdescendantwindow"></a>  CWnd::GetDescendantWindow

呼叫這個成員函式, 以尋找指定識別碼所指定的子代視窗。

```
CWnd* GetDescendantWindow(
    int nID,
    BOOL bOnlyPerm = FALSE) const;
```

### <a name="parameters"></a>參數

*nID*<br/>
指定要抓取之控制項或子視窗的識別碼。

*bOnlyPerm*<br/>
指定要傳回的視窗是否可以是暫時的。 若為 TRUE, 則只會傳回永久視窗;如果為 FALSE, 則函式可以傳回臨時視窗。 如需有關暫存視窗的詳細資訊, 請參閱[技術提示 3](../../mfc/tn003-mapping-of-windows-handles-to-objects.md)。

### <a name="return-value"></a>傳回值

`CWnd`物件的指標, 如果找不到子視窗, 則為 Null。

### <a name="remarks"></a>備註

此成員函式會搜尋子視窗的整個樹狀目錄, 而不只是直接子系的視窗。

##  <a name="getdesktopwindow"></a>  CWnd::GetDesktopWindow

傳回 Windows 桌面視窗。

```
static CWnd* PASCAL GetDesktopWindow();
```

### <a name="return-value"></a>傳回值

識別 Windows 桌面視窗。 這個指標可能是暫時性的, 不應該儲存以供稍後使用。

### <a name="remarks"></a>備註

桌面視窗會涵蓋整個畫面, 而且是所有圖示和其他視窗繪製在頂端的區域。

##  <a name="getdlgctrlid"></a>  CWnd::GetDlgCtrlID

傳回任何子視窗的視窗或控制項 ID 值, 而不只是對話方塊中的控制項。

```
int GetDlgCtrlID() const;
```

### <a name="return-value"></a>傳回值

如果函式成功, `CWnd`則為子視窗的數值識別碼, 否則為0。

### <a name="remarks"></a>備註

因為最上層視窗沒有識別碼值, 所以如果`CWnd`是最上層視窗, 則此函式的傳回值會無效。

### <a name="example"></a>範例

  請參閱[CWnd:: OnCtlColor](#onctlcolor)的範例。

##  <a name="getdlgitem"></a>  CWnd::GetDlgItem

抓取對話方塊或其他視窗中指定之控制項或子視窗的指標。

```
CWnd* GetDlgItem(int nID) const;

void GetDlgItem(
    int nID,
    HWND* phWnd) const;
```

### <a name="parameters"></a>參數

*nID*<br/>
指定要抓取之控制項或子視窗的識別碼。

*phWnd*<br/>
子視窗的指標。

### <a name="return-value"></a>傳回值

給定控制項或子視窗的指標。 如果具有*nID*參數所指定之整數識別碼的控制項不存在, 則此值為 Null。

傳回的指標可能是暫時性的, 不應該儲存以供稍後使用。

### <a name="remarks"></a>備註

傳回的指標通常會轉換成*nID*所識別的控制項類型。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#97](../../mfc/reference/codesnippet/cpp/cwnd-class_36.cpp)]

##  <a name="getdlgitemint"></a>  CWnd::GetDlgItemInt

抓取*nID*所識別之控制項的文字。

```
UINT GetDlgItemInt(
    int nID,
    BOOL* lpTrans = NULL,
    BOOL bSigned = TRUE) const;
```

### <a name="parameters"></a>參數

*nID*<br/>
指定要轉譯之對話方塊控制項的整數識別碼。

*lpTrans*<br/>
指向用來接收已轉譯旗標的布林值變數。

*bSigned*<br/>
指定要抓取的值是否經過簽署。

### <a name="return-value"></a>傳回值

指定對話方塊專案文字的已翻譯值。 因為0是有效的傳回值, 所以必須使用*lpTrans*來偵測錯誤。 如果需要帶正負號的傳回值, 請將它轉換為**int**型別。

如果轉譯的數位大於 INT_MAX (適用于帶正負號的數位) 或 UINT_MAX (不帶正負號), 則函式會傳回0。

發生錯誤時 (例如遇到非數值字元, 超過上述最大值`GetDlgItemInt` ), 會將0複製到*lpTrans*所指向的位置。 如果沒有任何錯誤, *lpTrans*會收到非零值。 如果*lpTrans*為 Null, `GetDlgItemInt`則不會警告有關錯誤。

### <a name="remarks"></a>備註

它會將指定之控制項的文字轉譯成整數值, 方法是在文字開頭處去除任何多餘的空格並轉換小數位數。 它會在到達文字結尾或遇到任何非數值字元時停止轉譯。

如果*bSigned*為 TRUE, `GetDlgItemInt`則會檢查文字開頭的減號 (-), 並將文字轉譯成帶正負號的數位。 否則, 它會建立不帶正負號的值。

它會將[WM_GETTEXT](/windows/desktop/winmsg/wm-gettext)訊息傳送至控制項。

##  <a name="getdlgitemtext"></a>  CWnd::GetDlgItemText

呼叫這個成員函式, 即可在對話方塊中抓取與控制項相關聯的標題或文字。

```
int GetDlgItemText(
    int nID,
    LPTSTR lpStr,
    int nMaxCount) const;

int GetDlgItemText(
    int nID,
    CString& rString) const;
```

### <a name="parameters"></a>參數

*nID*<br/>
指定要抓取其標題之控制項的整數識別碼。

*lpStr*<br/>
指向緩衝區, 以接收控制項的標題或文字。

*nMaxCount*<br/>
指定要複製到*lpStr*之字串的最大長度 (以字元為單位)。 如果字串長度超過*nMaxCount*, 則會被截斷。

*rString*<br/>
[CString](../../atl-mfc-shared/reference/cstringt-class.md)的參考。

### <a name="return-value"></a>傳回值

指定複製到緩衝區的實際字元數, 不包括終止的 null 字元。 如果沒有複製任何文字, 則值為0。

### <a name="remarks"></a>備註

此`GetDlgItemText`成員函式會將文字複製到*lpStr*所指向的位置, 並傳回其複製的位元組數計數。

##  <a name="getdsccursor"></a>  CWnd::GetDSCCursor

呼叫這個成員函式, 以抓取資料來源控制項的 DataSource、使用者名稱、密碼和 SQL 屬性所定義之基礎指標的指標。

```
IUnknown* GetDSCCursor();
```

### <a name="return-value"></a>傳回值

資料來源控制項所定義之游標的指標。 MFC 會負責呼叫`AddRef`指標。

### <a name="remarks"></a>備註

使用傳回的指標來設定複雜資料繫結控制項的 ICursor 屬性, 例如資料繫結方格控制項。 在第一個繫結控制項要求其資料指標之前, 資料來源控制項將不會變成作用中狀態。 這可能是由 MFC 系結管理員的`GetDSCCursor`呼叫或隱含地發生。 不論是哪一種情況, 您都可以呼叫`GetDSCCursor` , 然後`IUnknown`在傳回的指標上呼叫`Release` , 以強制將資料來源控制項變成使用中狀態。 啟用會導致資料來源控制項嘗試連接到基礎資料來源。 傳回的指標可能會在下列內容中使用:

### <a name="example"></a>範例

[!code-cpp[NVC_MFC_AxDataBinding#5](../../mfc/reference/codesnippet/cpp/cwnd-class_37.cpp)]

##  <a name="getdynamiclayout"></a>  CWnd::GetDynamicLayout

擷取動態配置管理員物件的指標。

```
CMFCDynamicLayout* GetDynamicLayout();
```

### <a name="return-value"></a>傳回值

動態配置管理員物件的指標，或是如果未啟用動態配置，則為 NULL。

### <a name="remarks"></a>備註

視窗物件擁有及管理傳回的指標存留期，因此它只應該用來存取物件；請勿永久刪除指標或儲存指標。

##  <a name="getexstyle"></a>  CWnd::GetExStyle

傳回視窗的延伸樣式。

```
DWORD GetExStyle() const;
```

### <a name="return-value"></a>傳回值

視窗的延伸樣式。 如需 MFC 中使用的擴充視窗樣式的詳細資訊, 請參閱[擴充的視窗樣式](../../mfc/reference/styles-used-by-mfc.md#extended-window-styles)。

##  <a name="getfocus"></a>  CWnd::GetFocus

抓取目前具有輸入焦點`CWnd`之的指標。

```
static CWnd* PASCAL GetFocus();
```

### <a name="return-value"></a>傳回值

具有目前焦點之視窗的指標, 如果沒有焦點視窗, 則為 Null。

該指標可能是暫時性的，因此不應該儲存供日後使用。

##  <a name="getfont"></a>  CWnd::GetFont

將 WM_GETFONT 訊息傳送至視窗, 以取得目前的字型。

```
CFont* GetFont() const;
```

### <a name="return-value"></a>傳回值

[CFont](../../mfc/reference/cfont-class.md)物件的指標, 附加至視窗的目前字型。

### <a name="remarks"></a>備註

除非視窗處理 WM_GETFONT 訊息, 否則此方法不會有任何作用。 許多衍生自`CWnd`的 MFC 類別會處理此訊息, 因為它們會附加至預先定義的視窗類別, 其中包含 WM_GETFONT 訊息的訊息處理常式。 若要使用這個方法, 您衍生自`CWnd`的類別必須定義 WM_GETFONT 訊息的方法處理常式。

##  <a name="getforegroundwindow"></a>  CWnd::GetForegroundWindow

傳回前景視窗 (使用者目前正在使用的視窗) 的指標。

```
static CWnd* PASCAL GetForegroundWindow();
```

### <a name="return-value"></a>傳回值

前景視窗的指標。 這可能是暫存`CWnd`物件。

### <a name="remarks"></a>備註

前景視窗僅適用于最上層視窗 (框架視窗或對話方塊)。

##  <a name="geticon"></a>  CWnd::GetIcon

呼叫這個成員函式可取得大 (32x32) 或控點 (16x16) 圖示的控制碼 (如*bBigIcon*所示)。

```
HICON GetIcon(BOOL bBigIcon) const;
```

### <a name="parameters"></a>參數

*bBigIcon*<br/>
若為 TRUE, 則指定32圖元 (依32圖元圖示)。如果為 FALSE, 則指定16圖元 x 16 圖元圖示。

### <a name="return-value"></a>傳回值

圖示的控制碼。 如果失敗, 則會傳回 Null。

##  <a name="getlastactivepopup"></a>  CWnd::GetLastActivePopup

判斷 `CWnd` 擁有的快顯視窗哪一個是最近啟用的。

```
CWnd* GetLastActivePopup() const;
```

### <a name="return-value"></a>傳回值

識別最近使用的快顯視窗。 如果符合下列任一條件, 則傳回值將會是視窗本身:

- 視窗本身是最近使用中的狀態。

- 視窗不會擁有任何快顯視窗。

- 視窗不是最上層視窗, 也不是由另一個視窗所擁有。

該指標可能是暫時性的，因此不應該儲存供日後使用。

### <a name="example"></a>範例

  請參閱[CWnd:: FindWindow](#findwindow)的範例。

##  <a name="getlayeredwindowattributes"></a>  CWnd::GetLayeredWindowAttributes

擷取分層視窗的不透明和透明色鍵。

```
BOOL GetLayeredWindowAttributes(
    COLORREF* pcrKey,
    BYTE* pbAlpha,
    DWORD* pdwFlags) const;
```

### <a name="parameters"></a>參數

*pcrKey*<br/>
COLORRE光圈值的指標, 它會接收在組成分層視窗時要使用的透明度色彩索引鍵。 視窗在此色彩中繪製的所有圖元都是透明的。 如果不需要引數, 這可能是 Null。

*pbAlpha*<br/>
位元組的指標, 接收用來描述分層視窗不透明度的 Alpha 值。 當*pbAlpha*所參考的變數是0時, 視窗會完全透明。 當*pbAlpha*所參考的變數是255時, 視窗是不透明的。 如果不需要引數, 這可能是 Null。

*pdwFlags*<br/>
接收分層旗標之 DWORD 的指標。 如果不需要引數, 這可能是 Null。 如需可能值的完整清單, 請參閱[GetLayeredWindowAttributes](/windows/desktop/api/winuser/nf-winuser-getlayeredwindowattributes)。

### <a name="return-value"></a>傳回值

如果函式成功則為非零值，否則為 0。

### <a name="remarks"></a>備註

此成員函式會模擬函數[GetLayeredWindowAttributes](/windows/desktop/api/winuser/nf-winuser-getlayeredwindowattributes)的功能, 如 Windows SDK 中所述。

##  <a name="getmenu"></a>  CWnd::GetMenu

抓取此視窗之功能表的指標。

```
CMenu* GetMenu() const;
```

### <a name="return-value"></a>傳回值

識別功能表。 如果`CWnd`沒有功能表, 則此值為 Null。 如果`CWnd`是子視窗, 則傳回值為未定義。

傳回的指標可能是暫時性的, 不應該儲存以供稍後使用。

### <a name="remarks"></a>備註

此函式不應用於子視窗, 因為它們沒有功能表。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#98](../../mfc/reference/codesnippet/cpp/cwnd-class_38.cpp)]

##  <a name="getmenubarinfo"></a>  CWnd::GetMenuBarInfo

抓取指定功能表列的相關資訊。

```
BOOL GetMenuBarInfo(
    LONG idObject,
    LONG idItem,
    PMENUBARINFO pmbi) const;
```

### <a name="parameters"></a>參數

*idObject*<br/>
指定功能表物件。 如需可能值的清單, 請參閱[GetMenuBarInfo](/windows/desktop/api/winuser/nf-winuser-getmenubarinfo)。

*idItem*<br/>
指定要為其取得資訊的專案。 如果此參數為零, 則函式會抓取功能表本身的相關資訊。 如果這個參數是 1, 則函式會抓取功能表上第一個專案的相關資訊, 依此類推。

*pmbi*<br/>
接收資訊之[MENUBARINFO](/windows/desktop/api/winuser/ns-winuser-tagmenubarinfo)結構的指標。

### <a name="return-value"></a>傳回值

如果函式成功則為非零值，否則為 0。

### <a name="remarks"></a>備註

此成員函式會模擬函數[GetMenuBarInfo](/windows/desktop/api/winuser/nf-winuser-getmenubarinfo)的功能, 如 Windows SDK 中所述。

##  <a name="getnextdlggroupitem"></a>  CWnd::GetNextDlgGroupItem

搜尋上一個或下一個控制項 對話方塊中的控制項群組內。

```
CWnd* GetNextDlgGroupItem(
    CWnd* pWndCtl,
    BOOL bPrevious = FALSE) const;

COleControlSiteOrWnd* GetNextDlgGroupItem(
    COleControlSiteOrWnd* pCurSiteOrWnd = NULL) const;
```

### <a name="parameters"></a>參數

*pWndCtl*<br/>
識別要用來做為搜尋起點的控制項。

*bPrevious*<br/>
指定函數如何在對話方塊中搜尋控制項群組。 若為 TRUE, 函式會搜尋群組中的上一個控制項;如果為 FALSE, 則會搜尋群組中的下一個控制項。

*pCurSiteOrWnd*<br/>
`COleControlSiteOrWnd`識別控制項。 如需的詳細`COleControlSiteOrWnd`資訊, 請參閱**備註**。

### <a name="return-value"></a>傳回值

如果成員函式成功, 則為群組中上一個或下一個控制項的指標。

傳回的指標可能是暫時性的, 不應該儲存以供稍後使用。

### <a name="remarks"></a>備註

一組控制項的開頭為使用[WS_GROUP](styles-used-by-mfc.md#window-styles)樣式所建立的控制項, 並以不是使用 WS_GROUP 樣式建立的最後一個控制項做為結尾。

根據預設, 此`GetNextDlgGroupItem`成員函式會傳回群組中下一個控制項的指標。 如果*pWndCtl*識別群組中的第一個控制項, 而*bPrevious*為 TRUE `GetNextDlgGroupItem` , 則會傳回群組中最後一個控制項的指標。

> [!NOTE]
> 因為 MFC 支援無視窗的 ActiveX 控制項、標準 ActiveX 控制項和 windows, 所以只會使用 HWND 來參考控制項, 而不會再尾碼。 物件`COleControlSiteOrWnd`所包含的資訊會將物件識別為視窗型 activex 控制項、無視窗的 activex 控制項或視窗, 如下所示:

|控制項或視窗類型|識別資訊|
|----------------------------|-----------------------------|
|視窗型 ActiveX 控制項|包含 HWND, 並將[COleControlSite](../../mfc/reference/colecontrolsite-class.md)物件與它產生關聯。 的`m_hWnd` `m_pSite` `COleControlSite`成員會設定為控制項的 HWND, 而成員則會指向控制項的。 `COleControlSiteOrWnd`|
|無視窗 ActiveX 控制項|不包含任何 HWND。 的`m_pSite` `COleControlSite`成員`m_hWnd`指向控制項的, 而成員為 Null。 `COleControlSiteOrWnd`|
|標準視窗|只包含 HWND。 的`m_hWnd` `m_pSite`成員設定為視窗的HWND,而`COleControlSiteOrWnd`成員為 Null。|

##  <a name="getnextdlgtabitem"></a>  CWnd::GetNextDlgTabItem

抓取第一個使用[WS_TABSTOP](styles-used-by-mfc.md#window-styles)樣式所建立, 且在指定的控制項之前或之後的控制項指標。

```
CWnd* GetNextDlgTabItem(
    CWnd* pWndCtl,
    BOOL bPrevious = FALSE) const;

COleControlSiteOrWnd* GetNextDlgTabItem(
    COleControlSiteOrWnd* pCurSiteOrWnd,
    BOOL bPrevious) const;
```

### <a name="parameters"></a>參數

*pWndCtl*<br/>
識別要用來做為搜尋起點的控制項。

*pCurSiteOrWnd*<br/>
`COleControlSiteOrWnd`識別控制項。 如需的詳細`COleControlSiteOrWnd`資訊, 請參閱[CWnd:: GetNextDlgGroupItem](#getnextdlggroupitem)。

*bPrevious*<br/>
指定函數如何搜尋對話方塊。 若為 TRUE, 函式會搜尋對話方塊中的上一個控制項;如果為 FALSE, 則會搜尋下一個控制項。

### <a name="return-value"></a>傳回值

如果成員函式成功, 則為具有 WS_TABSTOP 樣式的上一個或下一個控制項的指標。

傳回的指標可能是暫時性的, 不應該儲存以供稍後使用。

如需的詳細`COleControlSiteOrWnd`資訊, 請參閱[CWnd:: GetNextDlgGroupItem](#getnextdlggroupitem)。

##  <a name="getnextwindow"></a>  CWnd::GetNextWindow

搜尋視窗管理員清單中的下一個 (或上一個) 視窗。

```
CWnd* GetNextWindow(UINT nFlag = GW_HWNDNEXT) const;
```

### <a name="parameters"></a>參數

*nFlag*<br/>
指定函數是否會傳回下一個視窗或上一個視窗的指標。 它可以是 GW_HWNDNEXT, 它會傳回在視窗管理員清單上`CWnd`之物件後面的視窗, 或 GW_HWNDPREV, 它會傳回視窗管理員清單上的上一個視窗。

### <a name="return-value"></a>傳回值

如果成員函式成功, 則識別視窗管理員清單中的下一個 (或先前的) 視窗。

傳回的指標可能是暫時性的, 不應該儲存以供稍後使用。

### <a name="remarks"></a>備註

視窗管理員的清單包含所有最上層視窗的專案、其相關聯的子視窗, 以及任何子視窗的子視窗。

如果`CWnd`是最上層視窗, 函式會搜尋下一個 (或上一個) 最上層視窗; 如果`CWnd`是子視窗, 此函式會搜尋下一個 (或上一個) 子視窗。

##  <a name="getolecontrolsite"></a>  CWnd::GetOleControlSite

擷取指定的 ActiveX 控制項的自訂網站。

```
COleControlSite* GetOleControlSite(UINT idControl) const;
```

### <a name="parameters"></a>參數

*idControl*<br/>
ActiveX 控制項的識別碼。

##  <a name="getopenclipboardwindow"></a>CWnd:: GetOpenClipboardWindow

抓取目前已開啟剪貼簿之視窗的控制碼。

```
static CWnd* PASCAL GetOpenClipboardWindow();
```

### <a name="return-value"></a>傳回值

如果函式成功, 則為目前已開啟 [剪貼簿] 之視窗的控制碼;否則為 Null。

##  <a name="getowner"></a>  CWnd::GetOwner

抓取視窗擁有者的指標。

```
CWnd* GetOwner() const;
```

### <a name="return-value"></a>傳回值

`CWnd` 物件的指標。

### <a name="remarks"></a>備註

如果視窗沒有擁有者, 則預設會傳回父視窗物件的指標。 請注意, 擁有者和擁有者之間的關聯性, 與幾個重要層面的父子式層面不同。 例如, 具有父系的視窗會局限于其父視窗的工作區。 您可以在桌面上的任何位置繪製擁有的視窗。

此功能的擁有權概念與[GetWindow](/windows/desktop/api/winuser/nf-winuser-getwindow)的擁有權概念不同。

##  <a name="getparent"></a>  CWnd::GetParent

呼叫此函式可取得子視窗的父視窗 (如果有的話) 的指標。

```
CWnd* GetParent() const;
```

### <a name="return-value"></a>傳回值

請參閱 Windows SDK 中[GetParent](/windows/desktop/api/winuser/nf-winuser-getparent)的傳回值一節。

### <a name="remarks"></a>備註

`GetParent`函式會傳回直屬父系的指標 (如果有的話)。 相反地, [GetParentOwner](#getparentowner)函式會傳回最直接的父系或主控視窗的指標, 而不是子視窗 (沒有 WS_CHILD 樣式)。 如果您在子視窗`GetParent`內有子視窗, 並`GetParentOwner`傳回不同的結果。

##  <a name="getparentframe"></a>  CWnd::GetParentFrame

呼叫這個成員函式, 以取得父框架視窗。

```
CFrameWnd* GetParentFrame() const;
```

### <a name="return-value"></a>傳回值

如果成功, 則為框架視窗的指標;否則為 Null。

### <a name="remarks"></a>備註

成員函式會搜尋父鏈, 直到找到[CFrameWnd](../../mfc/reference/cframewnd-class.md) (或衍生類別) 物件為止。

##  <a name="getparentowner"></a>  CWnd::GetParentOwner

呼叫這個成員函式, 以取得子視窗的父視窗或主控視窗的指標。

```
CWnd* GetParentOwner() const;
```

### <a name="return-value"></a>傳回值

`CWnd` 物件的指標。 如果 `CWnd` 物件沒有附加至控制代碼，會建立並附加暫存 `CWnd` 物件。 該指標可能是暫時性的，因此不應該儲存供日後使用。

### <a name="remarks"></a>備註

`GetParentOwner`傳回不是子視窗之最直屬父系或主控視窗的指標 (不具有 WS_CHILD 樣式)。 目前的擁有者視窗可以使用[SetOwner](#setowner)來設定。 根據預設, 視窗的父系是其擁有者。

相反地, [GetParent](#getparent)函式會傳回直屬父系的指標, 不論它是否為子視窗。 如果您在子視窗`GetParent`內有子視窗, 並`GetParentOwner`傳回不同的結果。

##  <a name="getproperty"></a>  CWnd::GetProperty

呼叫這個成員函式, 以取得*dwDispID*所指定的 ActiveX 控制項屬性。

```
void GetProperty(
    DISPID dwDispID,
    VARTYPE vtProp,
    void* pvProp)const;
```

### <a name="parameters"></a>參數

*dwDispID*<br/>
識別要抓取的屬性。

*vtProp*<br/>
指定要抓取的屬性型別。 如需可能的值，請參閱 [COleDispatchDriver::InvokeHelper](../../mfc/reference/coledispatchdriver-class.md#invokehelper)的＜備註＞一節。

*pvProp*<br/>
將接收屬性值之變數的位址。 它必須符合*vtProp*所指定的類型。

### <a name="remarks"></a>備註

`GetProperty`透過*pvProp*傳回值。

> [!NOTE]
> 此函式只能在代表 ActiveX 控制項`CWnd`的物件上呼叫。

如需搭配使用這個成員函式與 activex 控制項容器的詳細資訊, [請參閱 activex 控制項容器:在 ActiveX 控制項容器](../../mfc/programming-activex-controls-in-a-activex-control-container.md)中程式設計 activex 控制項。

##  <a name="getrendertarget"></a>  CWnd::GetRenderTarget

取得與此視窗相關聯的呈現目標。

```
CHwndRenderTarget* GetRenderTarget();
```

### <a name="return-value"></a>傳回值

呈現目標的指標或 Null。

##  <a name="getsafehwnd"></a>  CWnd::GetSafeHwnd

傳回, 如果 this 指標是 null, 則為 null。 `m_hWnd`

```
HWND GetSafeHwnd() const;
```

### <a name="return-value"></a>傳回值

傳回視窗的視窗控制碼。 如果`CWnd`未附加至視窗, 或與 null `CWnd`指標一起使用, 則會傳回 null。

### <a name="example"></a>範例

  請參閱[CWnd:: subclasswindow 前允許](#subclasswindow)的範例。

##  <a name="getsafeowner"></a>  CWnd::GetSafeOwner

呼叫這個成員函式, 以取得應用於對話方塊或其他強制回應視窗的主控視窗。

```
static CWnd* GetSafeOwner(
    CWnd* pParent = NULL,
    HWND* pWndTop = NULL);
```

### <a name="parameters"></a>參數

*pParent*<br/>
父`CWnd`視窗的指標。 可能是 Null。

*pWndTop*<br/>
目前位於最上層之視窗的指標。 可能是 Null。

### <a name="return-value"></a>傳回值

指定視窗之安全擁有者的指標。

### <a name="remarks"></a>備註

「安全擁有者」是*pParent*的第一個非子父視窗。 如果*pParent*為 Null, 則會使用執行緒的主視窗 (透過[AfxGetMainWnd](../../mfc/reference/application-information-and-management.md#afxgetmainwnd)來抓取) 來尋找擁有者。

> [!NOTE]
> 架構本身會使用此函式來判斷對話方塊的正確擁有者視窗, 以及未指定擁有者的屬性工作表。

##  <a name="getscrollbarctrl"></a>  CWnd::GetScrollBarCtrl

呼叫這個成員函式, 以取得指定之同級捲軸或分隔視窗的指標。

```
virtual CScrollBar* GetScrollBarCtrl(int nBar) const;
```

### <a name="parameters"></a>參數

*nBar*<br/>
指定捲軸的類型。 參數可以採用下列其中一個值:

- SB_HORZ 會抓取水準捲軸的位置。

- SB_VERT 會抓取垂直捲動條的位置。

### <a name="return-value"></a>傳回值

同輩捲軸控制項, 如果沒有則為 Null。

### <a name="remarks"></a>備註

在建立視窗期間設定 WS_HSCROLL 或 WS_VSCROLL 位時, 此成員函式不會在建立的捲軸上運作。 此`CWnd`函式的實作用只會傳回 Null。 衍生的類別 (例如`CView`) 會執行所描述的功能。

##  <a name="getscrollbarinfo"></a>  CWnd::GetScrollBarInfo

擷取所指定之捲軸的相關資訊。

```
BOOL GetScrollBarInfo(
    LONG idObject,
    PSCROLLBARINFO psbi) const;
```

### <a name="parameters"></a>參數

*idObject*<br/>
指定功能表物件。 如需可能值的清單, 請參閱[GetScrollBarInfo](/windows/desktop/api/winuser/nf-winuser-getscrollbarinfo)。

*psbi*<br/>
接收資訊之[SCROLLBARINFO](/windows/desktop/api/winuser/ns-winuser-tagscrollbarinfo)結構的指標。

### <a name="return-value"></a>傳回值

如果函式成功則為非零值，否則為 0。

### <a name="remarks"></a>備註

此成員函式會模擬函數[GetScrollBarInfo](/windows/desktop/api/winuser/nf-winuser-getscrollbarinfo)的功能, 如 Windows SDK 中所述。

##  <a name="getscrollinfo"></a>  CWnd::GetScrollInfo

呼叫這個成員函式, 以抓取`SCROLLINFO`結構針對捲軸所維護的資訊。

```
BOOL GetScrollInfo(
    int nBar,
    LPSCROLLINFO lpScrollInfo,
    UINT nMask = SIF_ALL);
```

### <a name="parameters"></a>參數

*nBar*<br/>
指定捲軸是否為控制項或視窗非工作區的一部分。 如果它是非工作區的一部分, *nBar*也會指出捲軸是以水準、垂直或兩者的方式放置。 它必須是下列其中一項:

- SB_CTL 會抓取捲軸控制項的參數。 `m_hWnd`資料成員必須是捲軸控制項的控制碼。

- SB_HORZ 會抓取視窗標準水準捲軸的參數。

- SB_VERT 會抓取視窗標準垂直捲動條的參數。

*lpScrollInfo*<br/>
[SCROLLINFO](/windows/win32/api/winuser/ns-winuser-scrollinfo)結構的指標。 如需此結構的詳細資訊, 請參閱 Windows SDK。

*nMask*<br/>
指定要取出的捲軸參數。 預設值會指定 SIF_PAGE、SIF_POS、SIF_TRACKPOS 和 SIF_RANGE 的組合。 如`SCROLLINFO`需*nMask*值的詳細資訊, 請參閱。

### <a name="return-value"></a>傳回值

如果訊息已抓取任何值, 則傳回為 TRUE。 否則為 FALSE。

### <a name="remarks"></a>備註

`GetScrollInfo`可讓應用程式使用32位的捲軸位置。

[SCROLLINFO](/windows/win32/api/winuser/ns-winuser-scrollinfo)結構包含捲軸的相關資訊, 包括最小和最大的滾動位置、頁面大小, 以及捲動方塊的位置 (thumb)。 如需`SCROLLINFO`變更結構預設值的詳細資訊, 請參閱 Windows SDK 中的結構主題。

指出捲軸位置[CWnd:: OnHScroll](#onhscroll)和[CWnd:: OnVScroll](#onvscroll)的 MFC Windows 訊息處理常式, 只提供16個位的位置資料。 `GetScrollInfo`和`SetScrollInfo`提供32位的捲軸位置資料。 因此, 應用程式可以在`GetScrollInfo` `CWnd::OnHScroll`處理或`CWnd::OnVScroll`時呼叫, 以取得32位的捲軸位置資料。

##  <a name="getscrolllimit"></a>  CWnd::GetScrollLimit

呼叫這個成員函式, 以取得捲軸的最大滾動位置。

```
int GetScrollLimit(int nBar);
```

### <a name="parameters"></a>參數

*nBar*<br/>
指定捲軸的類型。 參數可以採用下列其中一個值:

- SB_HORZ 會抓取水準捲軸的滾動限制。

- SB_VERT 會抓取垂直捲動條的滾動限制。

### <a name="return-value"></a>傳回值

指定捲軸成功時的最大位置;否則為0。

##  <a name="getscrollpos"></a>  CWnd::GetScrollPos

抓取捲軸之捲動方塊的目前位置。

```
int GetScrollPos(int nBar) const;
```

### <a name="parameters"></a>參數

*nBar*<br/>
指定要檢查的捲軸。 參數可以採用下列其中一個值:

- SB_HORZ 會抓取水準捲軸的位置。

- SB_VERT 會抓取垂直捲動條的位置。

### <a name="return-value"></a>傳回值

在捲軸中, 指定捲動方塊的目前位置 (如果成功);否則為0。

### <a name="remarks"></a>備註

目前的位置是相依于目前滾動範圍的相對值。 例如, 如果捲軸範圍是50到 100, 而且捲動方塊位於橫條的中間, 則目前的位置是75。

##  <a name="getscrollrange"></a>  CWnd::GetScrollRange

將指定捲軸的目前最小和最大捲軸位置複製到*lpMinPos*和*lpMaxPos*所指定的位置。

```
void GetScrollRange(
    int nBar,
    LPINT lpMinPos,
    LPINT lpMaxPos) const;
```

### <a name="parameters"></a>參數

*nBar*<br/>
指定要檢查的捲軸。 參數可以採用下列其中一個值:

- SB_HORZ 會抓取水準捲軸的位置。

- SB_VERT 會抓取垂直捲動條的位置。

*lpMinPos*<br/>
指向要接收最小位置的整數變數。

*lpMaxPos*<br/>
指向要接收最大位置的整數變數。

### <a name="remarks"></a>備註

如果`CWnd`沒有捲軸, `GetScrollRange`則成員函式會將0複製到*lpMinPos*和*lpMaxPos*。

標準捲軸的預設範圍為0到100。 捲軸控制項的預設範圍是空的 (這兩個值都是 0)。

##  <a name="getstyle"></a>  CWnd::GetStyle

傳回目前的視窗樣式。

```
DWORD GetStyle() const;
```

### <a name="return-value"></a>傳回值

視窗的樣式。 如需 MFC 中使用之視窗樣式的詳細資訊, 請參閱[視窗樣式](styles-used-by-mfc.md#window-styles)。

##  <a name="getsystemmenu"></a>  CWnd::GetSystemMenu

可讓應用程式存取控制功能表以進行複製和修改。

```
CMenu* GetSystemMenu(BOOL bRevert) const;
```

### <a name="parameters"></a>參數

*bRevert*<br/>
指定要採取的動作。 如果*bRevert*為 FALSE, `GetSystemMenu`則會傳回目前使用中之控制項功能表複本的控制碼。 這個複本一開始與 [控制項] 功能表相同, 但是可以修改。 如果*bRevert*為 TRUE, `GetSystemMenu`則會將 [控制] 功能表重設回預設狀態。 先前的可能修改過的 [控制項] 功能表 (如果有的話) 會終結。 在此情況下, 傳回值是未定義的。

### <a name="return-value"></a>傳回值

如果*bRevert*為 FALSE, 則識別 [控制] 功能表的複本。 如果*bRevert*為 TRUE, 則傳回值為未定義。

傳回的指標可能是暫時性的, 不應該儲存以供稍後使用。

### <a name="remarks"></a>備註

沒有用`GetSystemMenu`來建立自己的 [控制功能表] 複本的任何視窗都會收到標準 [控制] 功能表。

`GetSystemMenu`成員函式所傳回的指標可以與[CMenu:: AppendMenu](../../mfc/reference/cmenu-class.md#appendmenu)、 [CMenu:: InsertMenu](../../mfc/reference/cmenu-class.md#insertmenu)或[CMenu:: ModifyMenu](../../mfc/reference/cmenu-class.md#modifymenu)函數搭配使用, 以變更 [控制] 功能表。

[控制] 功能表一開始會包含以各種識別碼值 (例如 SC_CLOSE、SC_MOVE 和 SC_SIZE) 識別的專案。 [控制] 功能表上的專案會產生[WM_SYSCOMMAND](#onsyscommand)訊息。 所有預先定義的控制項功能表項目都具有大於0xF000 的 ID 號碼。 如果應用程式將專案新增至 [控制項] 功能表, 它應該使用小於 F000 的識別碼。

Windows 可能會自動使 [標準控制] 功能表上的專案無法使用。 `CWnd`藉由回應[WM_INITMENU](#oninitmenu)的訊息 (在顯示任何功能表之前傳送), 可以執行自己的選擇或無法使用。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#99](../../mfc/reference/codesnippet/cpp/cwnd-class_39.cpp)]

##  <a name="gettitlebarinfo"></a>  CWnd::GetTitleBarInfo

擷取指定之標題列的相關資訊。

```
BOOL GetTitleBarInfo(PTITLEBARINFO pti) const;
```

### <a name="parameters"></a>參數

*pti*<br/>
接收資訊之[TITLEBARINFO](/windows/desktop/api/winuser/ns-winuser-tagtitlebarinfo)結構的指標。

### <a name="remarks"></a>備註

此成員函式會模擬函數[GetTitleBarInfo](/windows/desktop/api/winuser/nf-winuser-gettitlebarinfo)的功能, 如 Windows SDK 中所述。

##  <a name="gettoplevelframe"></a>  CWnd::GetTopLevelFrame

呼叫這個成員函式可抓取視窗的最上層框架視窗 (如果有的話)。

```
CFrameWnd* GetTopLevelFrame() const;
```

### <a name="return-value"></a>傳回值

識別視窗的最上層框架視窗。

傳回的指標可能是暫時性的, 不應該儲存以供稍後使用。

### <a name="remarks"></a>備註

如果`CWnd`沒有附加的視窗, 或其最上層父系不是[CFrameWnd](../../mfc/reference/cframewnd-class.md)衍生的物件, 則此函式會傳回 Null。

##  <a name="gettoplevelowner"></a>  CWnd::GetTopLevelOwner

呼叫這個成員函式, 以取出最上層視窗。

```
CWnd* GetTopLevelOwner() const;
```

### <a name="return-value"></a>傳回值

識別最上層視窗。 傳回的指標可能是暫時性的, 不應該儲存以供稍後使用。

### <a name="remarks"></a>備註

最上層視窗是桌面子系的視窗。 如果`CWnd`沒有附加的視窗, 此函數會傳回 Null。

##  <a name="gettoplevelparent"></a>  CWnd::GetTopLevelParent

呼叫這個成員函式以抓取視窗的最上層父系。

```
CWnd* GetTopLevelParent() const;
```

### <a name="return-value"></a>傳回值

識別視窗的最上層父視窗。

傳回的指標可能是暫時性的, 不應該儲存以供稍後使用。

### <a name="remarks"></a>備註

`GetTopLevelParent`類似于[GetTopLevelFrame](#gettoplevelframe)和[GetTopLevelOwner](#gettoplevelowner);不過, 它會忽略設定為目前擁有者視窗的值。

##  <a name="gettopwindow"></a>  CWnd::GetTopWindow

搜尋屬於`CWnd`的最上層子視窗。

```
CWnd* GetTopWindow() const;
```

### <a name="return-value"></a>傳回值

在子視窗的`CWnd`連結清單中識別最上層的子視窗。 如果沒有子視窗, 則此值為 Null。

傳回的指標可能是暫時性的, 不應該儲存以供稍後使用。

### <a name="remarks"></a>備註

如果`CWnd`沒有子系, 則此函式會傳回 Null。

##  <a name="getupdaterect"></a>  CWnd::GetUpdateRect

抓取完全括住更新區域的最小矩形座標。

```
BOOL GetUpdateRect(
    LPRECT lpRect,
    BOOL bErase = FALSE);
```

### <a name="parameters"></a>參數

*lpRect*<br/>
指向物件或`CRect` [矩形結構](/windows/desktop/api/windef/ns-windef-tagrect), 用來接收包含更新區域之更新的用戶端座標。

將此參數設定為 Null, 以判斷更新區域是否存在於`CWnd`中。 如果*lpRect*為 Null, 則`GetUpdateRect`如果更新區域存在, 成員函式會傳回非零, 如果沒有的話, 則會傳回0。 這會提供一種方式來判斷是否從不正確區域產生 WM_PAINT 訊息。 請勿在 Windows 3.0 版和更早版本中將此參數設定為 Null。

*bErase*<br/>
指定是否要清除更新區域中的背景。

### <a name="return-value"></a>傳回值

指定更新區域的狀態。 如果更新區域不是空的, 則此值為非零;否則為0。

如果*lpRect*參數設定為 Null, 則傳回值為非零 (如果有更新區域存在)。否則為0。

### <a name="remarks"></a>備註

如果`CWnd`是使用 CS_OWNDC 樣式所建立, 而且對應模式不是 MM_TEXT, 則`GetUpdateRect`成員函式會以邏輯座標提供矩形。 否則, `GetUpdateRect`會提供用戶端座標中的矩形。 如果沒有更新區域, `GetUpdateRect`則會將矩形設為空白 (將所有座標設定為 0)。

*BErase*參數會指定是否`GetUpdateRect`應該清除更新區域的背景。 如果*bErase*為 TRUE, 且更新區域不是空的, 則會清除背景。 若要清除背景, `GetUpdateRect`請傳送[WM_ERASEBKGND](#onerasebkgnd)訊息。

[BeginPaint](#beginpaint)成員函式所抓取的更新矩形與`GetUpdateRect`成員函式所抓取的不同。

成員函式會自動驗證更新區域, 因此在呼叫`BeginPaint`之後`GetUpdateRect`立即進行的任何呼叫都會抓取空的更新區域。 `BeginPaint`

##  <a name="getupdatergn"></a>  CWnd::GetUpdateRgn

將更新區域捕獲到*pRgn*所識別的區域。

```
int GetUpdateRgn(
    CRgn* pRgn,
    BOOL bErase = FALSE);
```

### <a name="parameters"></a>參數

*pRgn*<br/>
識別更新區域。

*bErase*<br/>
指定是否要清除背景, 並繪製子視窗的非工作區。 如果值為 FALSE, 則不會進行任何繪製。

### <a name="return-value"></a>傳回值

指定表示產生之區欄位型別的短整數旗標。 此值可接受下列任何一項:

- SIMPLEREGION 區域沒有重迭的框線。

- COMPLEXREGION 區域具有重迭的框線。

- NullREGION 區域是空的。

- 錯誤: 未建立任何區域。

### <a name="remarks"></a>備註

這個區域的座標相對於左上角 (用戶端座標)。

[BeginPaint](#beginpaint)成員函式會自動驗證更新區域, 因此`GetUpdateRgn` `BeginPaint`在呼叫之後立即進行的任何呼叫都會抓取空的更新區域。

##  <a name="getwindow"></a>  CWnd::GetWindow

傳回所要求視窗的指標, 如果沒有, 則傳回 Null。

```
CWnd* GetWindow(UINT nCmd) const;
```

### <a name="parameters"></a>參數

*nCmd*<br/>
指定和傳回的`CWnd`視窗之間的關聯性。 它可以採用下列其中一個值:

- GW_CHILD 可識別`CWnd`第一個子視窗。

- GW_HWNDFIRST 如果`CWnd`是子視窗, 則會傳回第一個兄弟視窗。 否則, 它會傳回清單中的第一個最上層視窗。

- GW_HWNDLAST 如果`CWnd`是子視窗, 則會傳回最後一個兄弟視窗。 否則, 它會傳回清單中的最後一個最上層視窗。

- GW_HWNDNEXT 會傳回視窗管理員清單上的下一個視窗。

- GW_HWNDPREV 會傳回視窗管理員清單上的上一個視窗。

- GW_OWNER 識別`CWnd`擁有者。

### <a name="return-value"></a>傳回值

傳回的指標可能是暫時性的, 不應該儲存以供稍後使用。

##  <a name="getwindowcontexthelpid"></a>  CWnd::GetWindowContextHelpId

呼叫這個成員函式, 以取得與視窗相關聯的說明內容識別碼 (如果有的話)。

```
DWORD GetWindowContextHelpId() const;
```

### <a name="return-value"></a>傳回值

說明內容識別碼。 如果視窗沒有任何, 則傳回0。

##  <a name="getwindowedchildcount"></a>  CWnd::GetWindowedChildCount

呼叫這個成員函式可抓取相關聯的子視窗數目。

```
long GetWindowedChildCount();
```

### <a name="return-value"></a>傳回值

與`CWnd`物件相關聯的子視窗數目。

##  <a name="getwindowdc"></a>  CWnd::GetWindowDC

抓取整個視窗的顯示內容, 包括標題列、功能表和捲軸。

```
CDC* GetWindowDC();
```

### <a name="return-value"></a>傳回值

如果函式成功, 則識別給定視窗的顯示內容;否則為 Null。

傳回的指標可能是暫時性的, 不應該儲存以供稍後使用。 每次成功呼叫`GetWindowDC`時, 應該呼叫一次 [ReleaseDC](#releasedc)。

### <a name="remarks"></a>備註

視窗顯示內容允許在中`CWnd`的任何位置繪製, 因為內容的原點是的左上`CWnd`角, 而非工作區。

預設屬性會在每次抓取內容時指派給顯示內容。 先前的屬性會遺失。

`GetWindowDC`旨在用於非工作`CWnd`區中的特殊繪製效果。 不建議在任何視窗的非工作區中繪製。

[GetSystemMetrics](/windows/desktop/api/winuser/nf-winuser-getsystemmetrics) Windows 函式可以用來抓取非工作區各部分的維度, 例如標題列、功能表和捲軸。

繪製完成之後, 必須呼叫[ReleaseDC](#releasedc)成員函式以釋放顯示內容。 若無法釋放顯示內容, 將會嚴重影響應用程式所要求的繪製, 因為可以同時開啟的裝置內容數目有所限制。

##  <a name="getwindowinfo"></a>  CWnd::GetWindowInfo

抓取視窗的相關資訊。

```
BOOL GetWindowInfo(PWINDOWINFO pwi) const;
```

### <a name="parameters"></a>參數

*pwi*<br/>
[WINDOWINFO](/windows/desktop/api/winuser/ns-winuser-tagwindowinfo)結構的指標。

### <a name="remarks"></a>備註

此成員函式會模擬函數[GetWindowInfo](/windows/desktop/api/winuser/nf-winuser-getwindowinfo)的功能, 如 Windows SDK 中所述。

##  <a name="getwindowlesschildcount"></a>  CWnd::GetWindowlessChildCount

抓取相關聯的無視窗子視窗數目。

```
long GetWindowlessChildCount();
```

### <a name="return-value"></a>傳回值

與`CWnd`物件相關聯的無視窗子視窗數目。

##  <a name="getwindowplacement"></a>CWnd:: GetWindowPlacement

擷取視窗的顯示狀態和一般 (還原)、最小化和最大化位置。

```
BOOL GetWindowPlacement(WINDOWPLACEMENT* lpwndpl) const;
```

### <a name="parameters"></a>參數

*lpwndpl*<br/>
指向接收顯示`WINDOWPLACEMENT`狀態和位置資訊的結構。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

此函式所抓取之[WINDOWPLACEMENT](/windows/desktop/api/winuser/ns-winuser-tagwindowplacement)結構的成員一律為0。`flags` 如果`CWnd`已最大化, `showCmd`則的`WINDOWPLACEMENT`成員為 SW_SHOWMAXIMIZED。 如果視窗最小化, 則會 SW_SHOWMINIMIZED。 否則會 SW_SHOWNORMAL。

##  <a name="getwindowrect"></a>  CWnd::GetWindowRect

將`CWnd`物件周框的維度複製到*lpRect*所指向的結構。

```
void GetWindowRect(LPRECT lpRect) const;
```

### <a name="parameters"></a>參數

*lpRect*<br/>
指向物件或[矩形結構](/windows/desktop/api/windef/ns-windef-tagrect), 其會接收左上角和右下角的螢幕座標。`CRect`

### <a name="remarks"></a>備註

在螢幕座標中, 會以顯示畫面左上角相對的方式提供尺寸。 包含標題、框線和捲軸的維度 (如果有的話)。

##  <a name="getwindowrgn"></a>  CWnd::GetWindowRgn

呼叫這個成員函式以取得視窗的視窗區域。

```
int GetWindowRgn(HRGN hRgn)const;
```

### <a name="parameters"></a>參數

*hRgn*<br/>
視窗區域的控制碼。

### <a name="return-value"></a>傳回值

傳回值會指定函式所取得之區域的類型。 它可以是下列其中一個值:

- NullREGION 區域是空的。

- SIMPLEREGION 區域是一個矩形。

- COMPLEXREGION 區域是一個以上的矩形。

- 錯誤發生錯誤;區域不受影響。

### <a name="remarks"></a>備註

視窗區域決定了作業系統允許繪製的視窗內的區域。 作業系統不會顯示位於視窗區域外之視窗的任何部分。

視窗的視窗區域座標相對於視窗的左上角, 而不是視窗的工作區。

若要設定視窗的視窗區域, 請呼叫[CWnd:: SetWindowRgn](#setwindowrgn)。

##  <a name="getwindowtext"></a>  CWnd::GetWindowText

將標題標題 (如果有的話) 複製到*lpszStringBuf*所指向的緩衝區中, 或複製到目的地字串*rString。* `CWnd`

```
int GetWindowText(
    LPTSTR lpszStringBuf,
    int nMaxCount) const;

void GetWindowText(
    CString& rString) const;
```

### <a name="parameters"></a>參數

*lpszStringBuf*<br/>
指向要接收已複製之視窗標題字串的緩衝區。

*nMaxCount*<br/>
指定要複製到緩衝區的最大字元數, 包括終止的 null 字元。 如果字串長度超過*nMaxCount*中指定的字元數, 則會被截斷。

*rString*<br/>
[CString](../../atl-mfc-shared/reference/cstringt-class.md)物件, 用來接收已複製的視窗標題字串。

### <a name="return-value"></a>傳回值

指定所複製字串的長度 (以字元為單位), 不包括終止的 null 字元。 如果`CWnd`沒有標題, 或標題是空的, 則為0。

### <a name="remarks"></a>備註

如果物件是控制項, 則`GetWindowText`成員函式會複製控制項內的文字, 而不是複製標題。 `CWnd`

此成員函式會將[WM_GETTEXT](/windows/desktop/winmsg/wm-gettext)訊息傳送至`CWnd`物件。

### <a name="example"></a>範例

  請參閱[CWnd:: SetWindowText](#setwindowtext)的範例。

##  <a name="getwindowtextlength"></a>  CWnd::GetWindowTextLength

傳回`CWnd`物件標題標題的長度。

```
int GetWindowTextLength() const;
```

### <a name="return-value"></a>傳回值

指定文字長度 (以字元為單位), 不包括任何 null 終止字元。 如果沒有這類文字存在, 則值為0。

### <a name="remarks"></a>備註

如果`CWnd`是控制項, 則`GetWindowTextLength`成員函式會傳回控制項內的文字長度, 而不是標題。

此成員函式會將[WM_GETTEXTLENGTH](/windows/desktop/winmsg/wm-gettextlength)訊息傳送至`CWnd`物件。

### <a name="example"></a>範例

  請參閱[CWnd:: SetWindowText](#setwindowtext)的範例。

##  <a name="hidecaret"></a>  CWnd::HideCaret

藉由從顯示畫面移除插入號來隱藏該插入號。

```
void HideCaret();
```

### <a name="remarks"></a>備註

雖然不會再看到插入號, 但可以使用[ShowCaret](#showcaret)成員函式再次顯示。 隱藏插入號並不會損毀其目前的形狀。

隱藏是累計的。 如果`HideCaret`在資料列中呼叫了五次`ShowCaret` , 成員函式必須呼叫五次, 才會顯示插入號。

##  <a name="hilitemenuitem"></a>CWnd:: HiliteMenuItem

反白顯示或移除最上層 (功能表列) 功能表項目中的醒目提示。

```
BOOL HiliteMenuItem(
    CMenu* pMenu,
    UINT nIDHiliteItem,
    UINT nHilite);
```

### <a name="parameters"></a>參數

*pMenu*<br/>
識別包含要反白顯示之專案的最上層功能表。

*nIDHiliteItem*<br/>
根據*nHilite*參數的值, 指定要反白顯示的功能表項目。

*nHilite*<br/>
指定功能表項目是否已反白顯示或已移除醒目提示。 它可以是 MF_HILITE 或 MF_UNHILITE 與 MF_BYCOMMAND 或 MF_BYPOSITION 的組合。 這些值可以使用位 OR 運算子結合。 這些值具有下列意義:

- MF_BYCOMMAND 會將*NIDHiliteItem*解讀為功能表項目識別碼 (預設轉譯)。

- MF_BYPOSITION 會將*NIDHiliteItem*解讀為功能表項目的以零為起始的位移。

- MF_HILITE 會反白顯示專案。 如果未提供此值, 則會從專案中移除反白顯示。

- MF_UNHILITE 會從專案中移除反白顯示。

### <a name="return-value"></a>傳回值

指定是否反白顯示功能表項目。 如果專案已反白顯示, 則為非零;否則為0。

### <a name="remarks"></a>備註

MF_HILITE 和 MF_UNHILITE 旗標只能與此成員函式搭配使用;它們不能與[CMenu:: ModifyMenu](../../mfc/reference/cmenu-class.md#modifymenu)成員函式搭配使用。

##  <a name="htmlhelp"></a>  CWnd::HtmlHelp

呼叫這個成員函式來叫用 HTMLHelp 應用程式。

```
virtual void HtmlHelp(
    DWORD_PTR dwData,
    UINT nCmd = 0x000F);
```

### <a name="parameters"></a>參數

*dwData*<br/>
指定其他資料。 使用的值取決於*nCmd*參數的值。

*nCmd*<br/>
指定要求的說明類型。 如需可能值的清單, 以及它們如何影響*dwData*參數, 請參閱 WINDOWS SDK 的 HTML 說明 API 參考中所述的*uCommand*參數。

### <a name="remarks"></a>備註

如需詳細資訊, 請參閱[CWinApp:: HtmlHelp](../../mfc/reference/cwinapp-class.md#htmlhelp) 。

##  <a name="initdynamiclayout"></a>  CWnd::InitDynamicLayout

由架構呼叫以初始化視窗的動態配置。

```
void InitDynamicLayout();
```

### <a name="remarks"></a>備註

請勿直接呼叫這個方法。

##  <a name="invalidate"></a>  CWnd::Invalidate

使的整個工作區`CWnd`失效。

```
void Invalidate(BOOL bErase = TRUE);
```

### <a name="parameters"></a>參數

*bErase*<br/>
指定是否要清除更新區域內的背景。

### <a name="remarks"></a>備註

工作區已標示為繪製時的下一步 [WM_PAINT](#onpaint)就會出現訊息。 在[ValidateRect](#validaterect)或[ValidateRgn](#validatergn)成員函式發生 WM_PAINT 訊息之前, 也可以驗證該區域。

*BErase*參數會指定在處理更新區域時, 是否要清除更新區域內的背景。 如果*bErase*為 TRUE, 則會在呼叫[BeginPaint](#beginpaint)成員函式時清除背景;如果*bErase*為 FALSE, 則背景會保持不變。 如果更新區域的任何部分*bErase*為 TRUE, 則會清除整個區域中的背景, 而不只是在指定的部分。

每當`CWnd`更新區域不是空的, 而且該視窗的應用程式佇列中沒有其他訊息時, Windows 就會傳送[WM_PAINT](#onpaint)訊息。

### <a name="example"></a>範例

  請參閱[CWnd:: UpdateWindow](#updatewindow)的範例。

##  <a name="invalidaterect"></a>  CWnd::InvalidateRect

將矩形加入至`CWnd`更新區域, 使給定矩形內的工作區失效。

```
void InvalidateRect(
    LPCRECT lpRect,
    BOOL bErase = TRUE);
```

### <a name="parameters"></a>參數

*lpRect*<br/>
指向物件或[矩形結構](/windows/desktop/api/windef/ns-windef-tagrect), 其中包含要新增至更新區域的矩形 (以工作區座標表示)。`CRect` 如果*lpRect*為 Null, 則會將整個工作區新增至區域。

*bErase*<br/>
指定是否要清除更新區域內的背景。

### <a name="remarks"></a>備註

失效的矩形，以及所有的其他區域中更新區域中，標示為進行繪製時的下一步 [WM_PAINT](#onpaint)傳送訊息。 失效的區域會累積在更新區域中, 直到下一次 WM_PAINT 呼叫發生時處理區域, 或直到[ValidateRect](#validaterect)或[ValidateRgn](#validatergn)成員函式驗證該區域為止。

*BErase*參數會指定在處理更新區域時, 是否要清除更新區域內的背景。 如果*bErase*為 TRUE, 則會在呼叫[BeginPaint](#beginpaint)成員函式時清除背景;如果*bErase*為 FALSE, 則背景會保持不變。 如果更新區域的任何部分*bErase*為 TRUE, 則會清除整個區域中的背景, 而不只是在指定的部分。

每當`CWnd`更新區域不是空的, 而且該視窗的應用程式佇列中沒有其他訊息時, Windows 就會傳送[WM_PAINT](#onpaint)訊息。

##  <a name="invalidatergn"></a>  CWnd::InvalidateRgn

藉由將指定區域中的工作區加入至目前的更新區域`CWnd`, 使其失效。

```
void InvalidateRgn(
    CRgn* pRgn,
    BOOL bErase = TRUE);
```

### <a name="parameters"></a>參數

*pRgn*<br/>
[CRgn](../../mfc/reference/crgn-class.md)物件的指標, 識別要新增至更新區域的區域。 區域會假設有用戶端座標。 如果此參數為 Null, 則會將整個工作區新增至更新區域。

*bErase*<br/>
指定是否要清除更新區域內的背景。

### <a name="remarks"></a>備註

當下一次傳送[WM_PAINT](#onpaint)訊息時, 不正確區域以及更新區域中的其他所有區域, 都會標示為進行繪製。 失效的區域會累積在更新區域中, 直到下一次傳送 WM_PAINT 訊息時, 或直到[ValidateRect](#validaterect)或[ValidateRgn](#validatergn)成員函式驗證該區域為止。

*BErase*參數會指定在處理更新區域時, 是否要清除更新區域內的背景。 如果*bErase*為 TRUE, 則會在呼叫[BeginPaint](#beginpaint)成員函式時清除背景;如果*bErase*為 FALSE, 則背景會保持不變。 如果更新區域的任何部分*bErase*為 TRUE, 則會清除整個區域中的背景, 而不只是在指定的部分。

每當`CWnd`更新區域不是空的, 而且該視窗的應用程式佇列中沒有其他訊息時, Windows 就會傳送[WM_PAINT](#onpaint)訊息。

指定的區域必須先前已由其中一個區域函數所建立。

##  <a name="invokehelper"></a>  CWnd::InvokeHelper

呼叫這個成員函式可在*wFlags*所指定的內容中, 叫用*dwDispID*所指定的 ActiveX 控制項方法或屬性。

```
void AFX_CDECL InvokeHelper(
    DISPID dwDispID,
    WORD wFlags,
    VARTYPE vtRet,
    void* pvRet,
    const BYTE* pbParamInfo,
    ... );
```

### <a name="parameters"></a>參數

*dwDispID*<br/>
指定所要叫用的屬性或方法。

*wFlags*<br/>
描述呼叫`IDispatch::Invoke`之內容的旗標。

*vtRet*<br/>
指定傳回值的類型。 如需可能的值，請參閱 [COleDispatchDriver::InvokeHelper](../../mfc/reference/coledispatchdriver-class.md#invokehelper)的＜備註＞一節。

*pvRet*<br/>
將接收屬性值或傳回值之變數的位址。 它必須符合*vtRet*所指定的類型。

*pbParamInfo*<br/>
以 null 結束的位元組字串指標, 指定*pbParamInfo*之後的參數類型。 如需可能的值, 請參閱的`COleDispatchDriver::InvokeHelper`「備註」一節。

*...*<br/>
參數的變數清單, 屬於*pbParamInfo*中指定的類型。

### <a name="remarks"></a>備註

*PbParamInfo*參數會指定傳遞至方法或屬性的參數類型。 引數的變數清單會以 *...* 語法宣告代表。

此函式會將參數轉換為 VARIANTARG 值, 然後`IDispatch::Invoke`在 ActiveX 控制項上叫用方法。 若呼叫 `IDispatch::Invoke` 失敗，此函式會擲回例外狀況。 如果所傳回`IDispatch::Invoke`的 SCODE (狀態碼) 是 DISP_E_EXCEPTION, 則此函式會擲回[COleException](../../mfc/reference/coleexception-class.md)物件, 否則會擲回[COleDispatchException](../../mfc/reference/coledispatchexception-class.md)。

> [!NOTE]
> 此函式只能在代表 ActiveX 控制項`CWnd`的物件上呼叫。

如需搭配使用這個成員函式與 activex 控制項容器的詳細資訊, [請參閱 activex 控制項容器:在 ActiveX 控制項容器](../../mfc/programming-activex-controls-in-a-activex-control-container.md)中程式設計 activex 控制項。

##  <a name="ischild"></a>  CWnd::IsChild

指出*pWnd*所指定的視窗是否為子視窗或的`CWnd`其他直接下階。

```
BOOL IsChild(const CWnd* pWnd) const;
```

### <a name="parameters"></a>參數

*pWnd*<br/>
識別要測試的視窗。

### <a name="return-value"></a>傳回值

指定函數的結果。 如果*pWnd*所識別的視窗是的子視窗`CWnd`, 此值為非零, 否則為0。

### <a name="remarks"></a>備註

`CWnd`如果物件位於父視窗鏈中 (從原始快顯視窗導向至子視窗), 則子視窗是的直接子代。 `CWnd`

##  <a name="isd2dsupportenabled"></a>  CWnd::IsD2DSupportEnabled

判斷是否已啟用 D2D 支援。

```
BOOL IsD2DSupportEnabled();
```

### <a name="return-value"></a>傳回值

如果已啟用此功能, 則為 TRUE;否則為 FALSE。

##  <a name="isdialogmessage"></a>  CWnd::IsDialogMessage

呼叫這個成員函式, 以判斷指定的訊息是否適用于非強制回應對話方塊;如果是, 則此函式會處理訊息。

```
BOOL IsDialogMessage(LPMSG lpMsg);
```

### <a name="parameters"></a>參數

*lpMsg*<br/>
指向包含要檢查之訊息的[MSG](/windows/desktop/api/winuser/ns-winuser-tagmsg)結構。

### <a name="return-value"></a>傳回值

指定成員函式是否已處理指定的訊息。 如果訊息已經過處理, 則為非零值;否則為0。 如果傳回的是 0, 請呼叫基類的[CWnd::P retranslatemessage](#pretranslatemessage)成員函式來處理訊息。 在`CWnd::PreTranslateMessage`成員函式的覆寫中, 程式碼看起來像這樣:

[!code-cpp[NVC_MFCWindowing#100](../../mfc/reference/codesnippet/cpp/cwnd-class_40.cpp)]

### <a name="remarks"></a>備註

`IsDialogMessage`當函式處理訊息時, 它會檢查鍵盤訊息, 並將它們轉換成對應對話方塊的選擇命令。 例如, TAB 鍵會選取下一個控制項或控制項群組, 而向下鍵則會選取群組中的下一個控制項。

您不能將處理`IsDialogMessage`的訊息傳遞至[TranslateMessage](/windows/desktop/api/winuser/nf-winuser-translatemessage)或[DispatchMessage](/windows/desktop/api/winuser/nf-winuser-dispatchmessage) Windows 函式, 因為它已經過處理。

##  <a name="isdlgbuttonchecked"></a>  CWnd::IsDlgButtonChecked

判斷按鈕控制項旁邊是否有核取記號。

```
UINT IsDlgButtonChecked(int nIDButton) const;
```

### <a name="parameters"></a>參數

*nIDButton*<br/>
指定按鈕控制項的整數識別碼。

### <a name="return-value"></a>傳回值

如果已檢查指定的控制項, 則為非零, 如果未核取, 則為0。 只能檢查選項按鈕和核取方塊。 針對三個狀態的按鈕, 如果按鈕不確定, 則傳回值可以是2。 此成員函式會針對按鈕傳回0。

### <a name="remarks"></a>備註

如果按鈕是三個狀態的控制項, 則成員函式會判斷其為灰色、已核取, 或兩者皆非。

##  <a name="isdynamiclayoutenabled"></a>  CWnd::IsDynamicLayoutEnabled

決定是否在這個視窗上啟用動態配置。 如果啟用動態配置時，則使用者可在調整父視窗大小時變更子視窗的位置與大小。

```
BOOL IsDynamicLayoutEnabled() const;
```

### <a name="return-value"></a>傳回值

如果啟用動態配置則為 TRUE，否則為 FALSE。

### <a name="remarks"></a>備註

##  <a name="isiconic"></a>  CWnd::IsIconic

指定是否`CWnd`最小化 (iconic)。

```
BOOL IsIconic() const;
```

### <a name="return-value"></a>傳回值

如果`CWnd`已最小化, 則為非零, 否則為0。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#101](../../mfc/reference/codesnippet/cpp/cwnd-class_41.cpp)]

##  <a name="istouchwindow"></a>  CWnd::IsTouchWindow

指定 `CWnd` 是否有觸控支援。

```
BOOL IsTouchWindow() const;
```

### <a name="return-value"></a>傳回值

如果`CWnd`具有觸控支援, 則為 TRUE, 否則為 FALSE。

### <a name="remarks"></a>備註

##  <a name="iswindowenabled"></a>  CWnd::IsWindowEnabled

指定是否`CWnd`啟用滑鼠和鍵盤輸入。

```
BOOL IsWindowEnabled() const;
```

### <a name="return-value"></a>傳回值

如果`CWnd`已啟用, 則為非零, 否則為0。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#102](../../mfc/reference/codesnippet/cpp/cwnd-class_42.cpp)]

##  <a name="iswindowvisible"></a>  CWnd::IsWindowVisible

決定給定視窗的可見度狀態。

```
BOOL IsWindowVisible() const;
```

### <a name="return-value"></a>傳回值

如果`CWnd`是可見的, 則為非零 (已設定[WS_VISIBLE](styles-used-by-mfc.md#window-styles)樣式位, 且父視窗為可見)。 由於傳回值會反映 WS_VISIBLE 樣式位的狀態, 因此傳回值可能為非零, 即使其他`CWnd`視窗完全遮蔽也一樣。

### <a name="remarks"></a>備註

視窗擁有 WS_VISIBLE 樣式位所指示的可見度狀態。 當此樣式位設定為呼叫[ShowWindow](#showwindow)成員函式時, 只要視窗已設定樣式位, 就會顯示視窗, 並顯示後續繪製至視窗。

如果視窗是由其他視窗所涵蓋, 或由其父視窗裁剪, 則不會顯示任何具有 WS_VISIBLE 樣式之視窗的繪圖。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#103](../../mfc/reference/codesnippet/cpp/cwnd-class_43.cpp)]

##  <a name="iszoomed"></a>CWnd:: IsZoomed

判斷是否`CWnd`已最大化。

```
BOOL IsZoomed() const;
```

### <a name="return-value"></a>傳回值

如果`CWnd`已最大化則為非零; 否則為0。

##  <a name="killtimer"></a>  CWnd::KillTimer

刪除所識別的計時器事件*nIDEvent*從  苺巃`SetTimer`。

```
BOOL KillTimer(UINT_PTR nIDEvent);
```

### <a name="parameters"></a>參數

*nIDEvent*<br/>
傳遞至[SetTimer](#settimer)之計時器事件的值。

### <a name="return-value"></a>傳回值

指定函數的結果。 如果事件已被終止, 此值為非零。 如果`KillTimer`成員函式找不到指定的計時器事件, 則為0。

### <a name="remarks"></a>備註

與計時器相關聯的暫止[WM_TIMER](#ontimer)訊息不會從訊息佇列中移除。

### <a name="example"></a>範例

  請參閱[CWnd:: SetTimer](#settimer)的範例。

##  <a name="loaddynamiclayoutresource"></a>  CWnd::LoadDynamicLayoutResource

由架構呼叫以從資源檔載入動態配置資訊。

```
BOOL LoadDynamicLayoutResource(LPCTSTR lpszResourceName);
```

### <a name="parameters"></a>參數

*lpszResourceName*<br/>
包含此視窗所需之動態配置資訊的資源名稱。

### <a name="return-value"></a>傳回值

如果函式成功，則為非零。 如果發生失敗，則為 0。

### <a name="remarks"></a>備註

請勿直接呼叫這個方法。

##  <a name="lockwindowupdate"></a>  CWnd::LockWindowUpdate

在指定的視窗中停用繪製。

```
BOOL LockWindowUpdate();
```

### <a name="return-value"></a>傳回值

如果函式成功，則為非零。 如果發生失敗, 或`LockWindowUpdate`函數已用來鎖定另一個視窗, 則為0。

### <a name="remarks"></a>備註

無法移動鎖定的視窗。 一次只能鎖定一個視窗。 若要解除鎖定已鎖定`LockWindowUpdate`的視窗, 請呼叫[UnlockWindowUpdate](#unlockwindowupdate)。

如果具有鎖定視窗的應用程式 (或任何已鎖定的子視窗) 呼叫[GetDC、](/windows/desktop/api/winuser/nf-winuser-getdc) [GetDCEx](/windows/desktop/api/winuser/nf-winuser-getdcex)或[BeginPaint](/windows/desktop/api/winuser/nf-winuser-beginpaint) windows 函數, 則被呼叫的函式會傳回其可見區域為空白的裝置內容。 在應用程式藉由呼叫`UnlockWindowUpdate`成員函式來解除鎖定視窗之前, 會發生這種情況。

當視窗更新被鎖定時, 系統會將任何繪圖作業的周框矩形, 追蹤到與鎖定視窗相關聯的裝置內容。 重新啟用繪製時, 這個周框矩形在鎖定的視窗及其子視窗中會失效, 以強制最終的[WM_PAINT](/windows/desktop/gdi/wm-paint)訊息更新畫面。 如果視窗更新鎖定時沒有發生任何繪製, 則沒有任何區域失效。

成員函式不會使指定的視窗變成可見, 且不會清除 [WS_VISIBLE](styles-used-by-mfc.md#window-styles) 樣式位。`LockWindowUpdate`

##  <a name="m_hwnd"></a>  CWnd::m_hWnd

附加至此`CWnd`的 Windows 視窗的控制碼。

```
HWND m_hWnd;
```

### <a name="remarks"></a>備註

`m_hWnd`資料成員是 HWND 類型的公用變數。

##  <a name="mapwindowpoints"></a>  CWnd::MapWindowPoints

將一組點從 `CWnd` 的座標空間轉換 (對應) 至另一個視窗的座標空間。

```
void MapWindowPoints(
    CWnd* pwndTo,
    LPRECT lpRect) const;

void MapWindowPoints(
    CWnd* pwndTo,
    LPPOINT lpPoint,
    UINT nCount) const;
```

### <a name="parameters"></a>參數

*pwndTo*<br/>
識別要轉換點的目標視窗。 如果此參數為 Null, 則會將這些點轉換成螢幕座標。

*lpRect*<br/>
指定要轉換其點的矩形。 此函式的第一個版本僅適用于 Windows 3.1 和更新版本。

*lpPoint*<br/>
[POINT 結構](/windows/desktop/api/windef/ns-windef-tagpoint)陣列的指標, 其中包含要轉換的點集合。

*nCount*<br/>
指定 lpPoint 所指向`POINT`之陣列中的結構數目。

##  <a name="messagebox"></a>  CWnd::MessageBox

建立並顯示一個視窗, 其中包含應用程式提供的訊息和標題, 加上 [[訊息方塊樣式](../../mfc/reference/styles-used-by-mfc.md#message-box-styles)] 清單中所述之預先定義圖示和按鈕的組合。

```
int MessageBox(
    LPCTSTR lpszText,
    LPCTSTR lpszCaption = NULL,
    UINT nType = MB_OK);
```

### <a name="parameters"></a>參數

*lpszText*<br/>
`CString`指向物件或以 null 終止的字串, 其中包含要顯示的訊息。

*lpszCaption*<br/>
指向要用於訊息方塊標題的物件或以null結束的字串。`CString` 如果*lpszCaption*為 Null, 則會使用預設標題 "Error"。

*nType*<br/>
指定訊息方塊的內容和行為。

### <a name="return-value"></a>傳回值

這個方法會利用 Windows SDK 中所定義的[MessageBox](/windows/desktop/api/winuser/nf-winuser-messagebox)函數。 這個方法會傳回呼叫此函式的結果。

### <a name="remarks"></a>備註

使用全域函式[AfxMessageBox](../../mfc/reference/cstring-formatting-and-message-box-display.md#afxmessagebox) , 而不是這個成員函式, 在您的應用程式中執行訊息方塊。

以下顯示可以在訊息方塊中使用的各種系統圖示:

|||
|-|-|
|![停止&#40;x&#41;圖示](../../mfc/reference/media/vc364f1.gif "停止&#40;x&#41;圖示")|MB_ICONHAND、MB_ICONSTOP 和 MB_ICONERROR|
|![有&#40;説明嗎？圖示&#41; ](../../mfc/reference/media/vc364f2.gif "說明&#40;？&#41;圖示")|MB_ICONQUESTION|
|![&#33;重要&#40; &#41;圖示](../../mfc/reference/media/vc364f3.gif "重要&#41;圖示&#40; &#33; ")|MB_ICONEXCLAMATION 和 MB_ICONWARNING|
|![資訊&#40;i&#41;圖示](../../mfc/reference/media/vc364f4.gif "資訊&#40;i&#41;圖示")|MB_ICONASTERISK 和 MB_ICONINFORMATION|

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#104](../../mfc/reference/codesnippet/cpp/cwnd-class_44.cpp)]

##  <a name="modifystyle"></a>  CWnd::ModifyStyle

呼叫這個成員函式以修改視窗的樣式。

```
BOOL ModifyStyle(
    DWORD dwRemove,
    DWORD dwAdd,
    UINT nFlags = 0);
```

### <a name="parameters"></a>參數

*dwRemove*<br/>
指定在修改樣式時要移除的視窗樣式。

*dwAdd*<br/>
指定在修改樣式時要加入的視窗樣式。

*nFlags*<br/>
要傳遞至[SetWindowPos](#setwindowpos)的旗標, 如果`SetWindowPos`不應該呼叫, 則為零。 預設值是零。 如需預設旗標的清單, 請參閱備註一節。

### <a name="return-value"></a>傳回值

如果成功修改樣式, 則為非零值;否則為0。

### <a name="remarks"></a>備註

您可以使用位 OR (&#124;) 運算子來結合要加入或移除的樣式。 如需可用視窗樣式的詳細資訊, 請參閱 Windows SDK 中的主題[視窗樣式](/windows/desktop/winmsg/window-styles)和[CreateWindow](/windows/desktop/api/winuser/nf-winuser-createwindowa) 。

如果*nFlags*為非零`ModifyStyle`值, 則會呼叫 Windows API 函式[SetWindowPos](/windows/desktop/api/winuser/nf-winuser-setwindowpos) , 並藉由結合*nFlags*與下列四個預設旗標來重新繪製視窗:

- SWP_NOSIZE 會保留目前的大小。

- SWP_NOMOVE 會保留目前的位置。

- SWP_NOZORDER 會保留目前的 Z 順序。

- SWP_NOACTI加值稅E 不會啟動視窗。

若要修改視窗的延伸樣式, 請參閱[ModifyStyleEx](#modifystyleex)。

> [!NOTE]
> 對於某些控制項中的某些樣式 (例如, 編輯控制項中的 ES_READONLY 樣式), 可能`ModifyStyle`不會適當地變更樣式, 因為控制項可能需要執行特殊的內部處理。 在這些情況下, 將會提供要變更樣式的對應訊息 (在所述範例中為 EM_SETREADONLY)。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#105](../../mfc/reference/codesnippet/cpp/cwnd-class_45.cpp)]

##  <a name="modifystyleex"></a>  CWnd::ModifyStyleEx

呼叫這個成員函式以修改視窗的延伸樣式。

```
BOOL ModifyStyleEx(
    DWORD dwRemove,
    DWORD dwAdd,
    UINT nFlags = 0);
```

### <a name="parameters"></a>參數

*dwRemove*<br/>
指定在修改樣式時要移除的擴充樣式。

*dwAdd*<br/>
指定在修改樣式時要新增的擴充樣式。

*nFlags*<br/>
要傳遞至[SetWindowPos](#setwindowpos)的旗標, 如果`SetWindowPos`不應該呼叫, 則為零。 預設值是零。 如需預設旗標的清單, 請參閱備註一節。

### <a name="return-value"></a>傳回值

如果成功修改樣式, 則為非零值;否則為0。

### <a name="remarks"></a>備註

您可以使用位 OR (&#124;) 運算子來結合要加入或移除的樣式。 如需可用擴充樣式的詳細資訊, 請參閱本書中的主題[延伸視窗樣式](../../mfc/reference/styles-used-by-mfc.md#extended-window-styles)和 Windows SDK [CreateWindowEx](/windows/desktop/api/winuser/nf-winuser-createwindowexa)

如果*nFlags*為非零`ModifyStyleEx`值, 則會呼叫 Windows API 函式[SetWindowPos](/windows/desktop/api/winuser/nf-winuser-setwindowpos) , 並藉由結合*nFlags*與下列四個預設旗標來重新繪製視窗:

- SWP_NOSIZE 會保留目前的大小。

- SWP_NOMOVE 會保留目前的位置。

- SWP_NOZORDER 會保留目前的 Z 順序。

- SWP_NOACTI加值稅E 不會啟動視窗。

若要使用一般視窗樣式來修改 windows, 請參閱[ModifyStyle](#modifystyle)。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#106](../../mfc/reference/codesnippet/cpp/cwnd-class_46.cpp)]

##  <a name="movewindow"></a>  CWnd::MoveWindow

變更位置和維度。

```
void MoveWindow(
    int x,
    int y,
    int nWidth,
    int nHeight,
    BOOL bRepaint = TRUE);

void MoveWindow(
    LPCRECT lpRect,
    BOOL bRepaint = TRUE);
```

### <a name="parameters"></a>參數

*x*<br/>
指定左邊`CWnd`的新位置。

*y*<br/>
指定頂端`CWnd`的新位置。

*nWidth*<br/>
指定的新寬度`CWnd`。

*nHeight*<br/>
指定的新高度`CWnd`。

*bRepaint*<br/>
指定是否`CWnd`要重新繪製。 若為 TRUE `CWnd` , 則會如往常般在其[OnPaint](#onpaint)訊息處理常式中接收[WM_PAINT](/windows/desktop/gdi/wm-paint)訊息。 如果此參數為 FALSE, 則不會重新繪製任何類型。 這適用于工作區、非工作區 (包括標題和捲軸), 以及由移動後所發現`CWnd`之父視窗的任何部分。 當此參數為 FALSE 時, 應用程式必須明確地使必須重新繪製`CWnd`的部分和父視窗失效。

*lpRect*<br/>
[CRect](../../atl-mfc-shared/reference/crect-class.md)物件或[RECT 結構](/windows/desktop/api/windef/ns-windef-tagrect), 指定新的大小和位置。

### <a name="remarks"></a>備註

如果是最上層`CWnd`物件, *x*和*y*參數會相對於螢幕的左上角。 針對子`CWnd`物件, 它們會相對於父視窗工作區的左上角。

函式會傳送[WM_GETMINMAXINFO 訊息。](#ongetminmaxinfo) `MoveWindow` 處理此訊息可`CWnd`讓您有機會修改最大和最小可能視窗的預設值。 如果`MoveWindow`成員函式的參數超出這些值, 則可以使用 WM_GETMINMAXINFO 處理常式中的最小或最大值來取代這些值。

### <a name="example"></a>範例

  請參閱[CWnd:: ClientToScreen](#clienttoscreen)的範例。

##  <a name="notifywinevent"></a>  CWnd::NotifyWinEvent

表示發生預先定義之事件的系統。 如果有任何用戶端應用程式已註冊事件的攔截函式, 系統會呼叫用戶端的攔截函式。

```
void NotifyWinEvent(
    DWORD event,
    LONG idObjectType,
    LONG idObject);
```

### <a name="parameters"></a>參數

*event*<br/>
指定發生的事件。 這個值必須是其中一個[事件常數](/windows/desktop/WinAuto/event-constants)。

*idObjectType*<br/>
識別產生事件的物件種類。 這個值是其中一個預先定義的[物件識別碼](/windows/desktop/WinAuto/object-identifiers)或自訂物件識別碼值。

*idObject*<br/>
識別事件是由物件的物件或子項目所產生。 如果這個值是 CHILDID_SELF, 則事件是由物件本身產生。 如果不是, 這個值就是產生事件之元素的子系識別碼。

### <a name="remarks"></a>備註

此成員函式會模擬函數[NotifyWinEvent](/windows/desktop/api/winuser/nf-winuser-notifywinevent)的功能, 如 Windows SDK 中所述。

##  <a name="onactivate"></a>  CWnd::OnActivate

當`CWnd`物件正在啟動或停用時, 架構會呼叫這個成員函式。

```
afx_msg void OnActivate(
    UINT nState,
    CWnd* pWndOther,
    BOOL bMinimized);
```

### <a name="parameters"></a>參數

*nState*<br/>
指定是否`CWnd`正在啟動或停用。 它可以是下列其中一個值:

- WA_INACTIVE 視窗已停用。

- WA_ACTIVE 視窗是透過滑鼠按一下以外的某種方法來啟動 (例如, 藉由使用鍵盤介面來選取視窗)。

- WA_CLICKACTIVE 視窗是透過滑鼠按一下來啟動。

*pWndOther*<br/>
要啟用或`CWnd`停用之的指標。 指標可以是 Null, 而且可能是暫時性的。

*bMinimized*<br/>
指定要啟用或停用`CWnd`之的最小化狀態。 值為 TRUE 表示視窗最小化。

如果為 TRUE, `CWnd`則表示正在啟用, 否則會停用。

### <a name="remarks"></a>備註

如果使用滑鼠按一下來啟動 物件,它也會收到[OnMouseActivate](#onmouseactivate)成員函數`CWnd`調用。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onactivateapp"></a>  CWnd::OnActivateApp

此架構會將此成員函式, 呼叫至正在啟動之工作的所有最上層視窗, 以及停用工作的所有最上層視窗。

```
afx_msg void OnActivateApp(
    BOOL bActive,
    DWORD dwThreadID);
```

### <a name="parameters"></a>參數

*bActive*<br/>
指定是否`CWnd`正在啟動或停用。 TRUE 表示`CWnd`正在啟用。 FALSE 表示`CWnd`正在停用。

*dwThreadID*<br/>
指定執行緒識別碼的值。 如果*bActive*為 TRUE, *dwThreadID*會識別擁有要停用`CWnd`之的執行緒。 如果*bActive*為 FALSE, *dwThreadID*會識別擁有要啟動之`CWnd`的執行緒。

### <a name="remarks"></a>備註

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onambientproperty"></a>CWnd:: OnAmbientProperty

架構會呼叫這個成員函式, 從包含 OLE 控制項的視窗中取得環境屬性值。

```
virtual BOOL OnAmbientProperty(
    COleControlSite* pSite,
    DISPID dispid,
    VARIANT* pvar);
```

### <a name="parameters"></a>參數

*pSite*<br/>
要求環境屬性之控制項的網站指標。

*dispid*<br/>
所要求環境屬性的分派識別碼。

*pvar*<br/>
呼叫端`VARIANT`配置的結構的指標, 將傳回環境屬性的值。

### <a name="return-value"></a>傳回值

如果支援環境屬性, 則為 TRUE;如果不是, 則為 FALSE。

### <a name="remarks"></a>備註

覆寫此函式, 以將 OLE 控制項容器傳回的預設環境屬性值變更為其控制項。 不是由覆寫函式處理的任何環境屬性要求都應該轉送到基類的實作為。

##  <a name="onappcommand"></a>  CWnd::OnAppCommand

當使用者產生應用程式命令事件時, 架構會呼叫這個成員函式。 當使用者按一下應用程式命令按鈕或輸入應用程式命令鍵時, 就會發生這類事件。

```
afx_msg void OnAppCommand(
    CWnd* pWnd,
    UINT nCmd,
    UINT nDevice,
    UINT nKey);
```

### <a name="parameters"></a>參數

|參數|描述|
|---------------|-----------------|
|*pWnd*|在`CWnd`物件的指標, 表示使用者按一下命令按鈕或按下命令鍵的視窗。 這個視窗可以是接收訊息之視窗的子視窗。|
|*nCmd*|在表示應用程式命令。 如需可能值的清單, 請參閱[WM_APPCOMMAND](/windows/desktop/inputdev/wm-appcommand)的*lParam*參數之*cmd*區段底下的命令。|
|*nDevice*|在產生輸入事件的輸入裝置。 如需可能值的清單, 請參閱[WM_APPCOMMAND](/windows/desktop/inputdev/wm-appcommand)之*LParam*參數的*uDevice*區段底下的裝置。|
|*nKey*|在表示任何關閉的虛擬機器碼, 例如 CTRL 鍵或滑鼠左鍵。 如需可能值的清單, 請參閱[WM_APPCOMMAND](/windows/desktop/inputdev/wm-appcommand)之*LParam*參數的*dwKeys*區段下的索引鍵。 如需詳細資訊, 請參閱[關於滑鼠輸入](/windows/desktop/inputdev/about-mouse-input)中的「訊息參數」子標題。|

### <a name="remarks"></a>備註

這個方法會接收[WM_APPCOMMAND](/windows/desktop/inputdev/wm-appcommand)通知, 如 Windows SDK 中所述。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onaskcbformatname"></a>  CWnd::OnAskCbFormatName

當剪貼簿包含 CF_OWNERDISPLAY 格式的資料控制碼時, 架構會呼叫這個成員函式 (也就是當剪貼簿擁有者顯示剪貼簿內容時)。

```
afx_msg void OnAskCbFormatName(
    UINT nMaxCount,
    LPTSTR lpszString);
```

### <a name="parameters"></a>參數

*nMaxCount*<br/>
指定要複製的最大位元組數。

*lpszString*<br/>
指向要儲存格式名稱複本的緩衝區。

### <a name="remarks"></a>備註

剪貼簿擁有者應提供其格式的名稱。

覆寫這個成員函式, 並將 CF_OWNERDISPLAY 格式的名稱複製到指定的緩衝區中, 而不超過指定的最大位元組數目。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="oncancelmode"></a>CWnd:: OnCancelMode

架構會呼叫這個成員函式, `CWnd`以通知取消任何內部模式。

```
afx_msg void OnCancelMode();
```

### <a name="remarks"></a>備註

如果物件具有焦點, 則會在`OnCancelMode`顯示對話方塊或訊息方塊時呼叫它的成員函式。 `CWnd` 這讓`CWnd`您有機會取消模式, 例如滑鼠捕捉。

預設的實作用是藉由呼叫[ReleaseCapture](/windows/desktop/api/winuser/nf-winuser-releasecapture) Windows 函式來回應。 覆寫衍生類別中的這個成員函式, 以處理其他模式。

##  <a name="oncapturechanged"></a>CWnd:: OnCaptureChanged

架構會呼叫這個成員函式, 以通知視窗遺失滑鼠捕捉。

```
afx_msg void OnCaptureChanged(CWnd* pWnd);
```

### <a name="parameters"></a>參數

*pWnd*<br/>
要取得滑鼠捕捉的視窗指標

### <a name="remarks"></a>備註

視窗會接收此訊息, 即使它呼叫[ReleaseCapture](/windows/desktop/api/winuser/nf-winuser-releasecapture)本身也一樣。 應用程式不應該嘗試設定滑鼠捕捉以回應此訊息。 當它收到此訊息時, 視窗應該視需要重繪本身, 以反映新的滑鼠捕捉狀態。

如需`ReleaseCapture` Windows 函數的詳細資訊, 請參閱 Windows SDK。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onchangecbchain"></a>CWnd:: OnChangeCbChain

架構會針對剪貼簿-檢視器鏈中的每個視窗呼叫這個成員函式, 以通知它正在從鏈中移除視窗。

```
afx_msg void OnChangeCbChain(
    HWND hWndRemove,
    HWND hWndAfter);
```

### <a name="parameters"></a>參數

*hWndRemove*<br/>
指定要從剪貼簿-檢視器鏈中移除的視窗控制碼。

*hWndAfter*<br/>
指定要從剪貼簿-檢視器鏈中移除的視窗後面的視窗控制碼。

### <a name="remarks"></a>備註

`CWnd`  `SetClipboardViewer` 接收呼叫的每個物件都應該使用 [SendMessage](/windows/desktop/api/winuser/nf-winuser-sendmessage) Windows 函式, 將 [WM_CHANGECBCHAIN](/windows/desktop/dataxchg/wm-changecbchain) 訊息傳送至剪貼簿檢視器鏈中的下一個視窗 (所傳回的控制碼)。`OnChangeCbChain` 如果*hWndRemove*是鏈中的下一個視窗, *hWndAfter*所指定的視窗就會變成下一個視窗, 並將剪貼簿訊息傳遞給它。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onchangeuistate"></a>CWnd:: OnChangeUIState

應變更使用者介面 (UI) 狀態時呼叫。

```
afx_msg void OnChangeUIState(
    UINT nAction,
    UINT nUIElement);
```

### <a name="parameters"></a>參數

*nAction*<br/>
指定要採取的動作。 可為下列其中一個值：

- UIS_CLEAR UI state 元素 (由*nUIElement*指定) 應該隱藏起來。

- UIS_INITIALIZE UI state 元素 (由*nUIElement*指定) 應該根據最後一個輸入事件來變更。 如需詳細資訊, 請參閱[WM_CHANGEUISTATE](/windows/desktop/menurc/wm-changeuistate)的「**備註**」一節。

- UIS_SET UI state 元素 (由*nUIElement*指定) 應該是可見的。

*nUIElement*<br/>
指定受影響的 UI 狀態元素或控制項的樣式。 可為下列其中一個值：

- UISF_HIDEACCEL 鍵盤快速鍵。

- UISF_HIDEFOCUS 焦點指標。

- UISF_ACTIVE Windows XP:控制項應以用於現用控制項的樣式繪製。

### <a name="remarks"></a>備註

此成員函式會模擬[WM_CHANGEUISTATE](/windows/desktop/menurc/wm-changeuistate)訊息的功能, 如 Windows SDK 中所述。

##  <a name="onchar"></a>  CWnd::OnChar

當按鍵轉譯為非系統字元時, 架構會呼叫這個成員函式。

```
afx_msg void OnChar(
    UINT nChar,
    UINT nRepCnt,
    UINT nFlags);
```

### <a name="parameters"></a>參數

*nChar*<br/>
包含索引鍵的字元碼值。

*nRepCnt*<br/>
包含重複計數, 也就是使用者按住按鍵時重複擊鍵的次數。

*nFlags*<br/>
包含掃描程式碼、金鑰轉換程式碼、先前的索引鍵狀態和內容程式碼, 如下列清單所示:

|值|意義|
|-----------|-------------|
|0-15|指定重複計數。 這個值是使用者按住按鍵後, 重複擊鍵的次數。|
|16-23|指定掃描程式碼。 此值取決於原始設備製造商 (OEM)|
|24|指定索引鍵是否為延伸的索引鍵, 例如在增強的101或102鍵鍵盤上出現的右 ALT 和 CTRL 鍵。 如果它是擴充索引鍵, 則值為 1;否則, 它是0。|
|25-28|由 Windows 在內部使用。|
|29|指定內容代碼。 如果在按下按鍵時按住 ALT 鍵, 則此值為 1;否則, 此值為0。|
|30|指定先前的索引鍵狀態。 如果在傳送訊息之前, 金鑰已關閉, 此值為 1, 如果索引鍵已啟動, 則為0。|
|31|指定轉換狀態。 如果要釋放金鑰, 此值為 1, 如果按下按鍵則為0。|

### <a name="remarks"></a>備註

這個函式會在[OnKeyUp](#onkeyup)成員函式之前, 以及在呼叫[OnKeyDown](#onkeydown)成員函式之後呼叫。 `OnChar`包含所按下或已釋放之鍵盤按鍵的值。

因為所按下的索引鍵與`OnChar`產生的呼叫之間不一定會有一對一的對應關係, 所以*nFlags*中的資訊通常對應用程式而言並不實用。 *NFlags*中的資訊只會套用至`OnKeyUp` `OnKeyDown`成員函式的最新呼叫, 或呼叫之前的`OnChar`成員函式。

針對 IBM 增強的101和102金鑰鍵盤, 增強式金鑰是鍵盤主要區段上的右 ALT 和右 CTRL 鍵;數位鍵臺上左邊的叢集中的 INS、DEL、HOME、END、PAGE UP、PAGE DOWN 和方向鍵;和斜線 (/), 然後在數位鍵臺上輸入按鍵。 有些其他鍵盤可能支援*nFlags*中的延伸金鑰位。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onchartoitem"></a>CWnd:: OnCharToItem

當具有[LBS_WANTKEYBOARDINPUT](../../mfc/reference/styles-used-by-mfc.md#list-box-styles)樣式的清單方塊將[WM_CHARTOITEM](/windows/desktop/Controls/wm-chartoitem)訊息傳送給其擁有者時呼叫, 以回應[WM_CHAR](#onchar)訊息。

```
afx_msg int OnCharToItem(
    UINT nChar,
    CListBox* pListBox,
    UINT nIndex);
```

### <a name="parameters"></a>參數

*nChar*<br/>
指定使用者所按下的金鑰值。

*pListBox*<br/>
指定清單方塊的指標。 這可能是暫時性的。

*nIndex*<br/>
指定目前的插入號位置。

### <a name="return-value"></a>傳回值

架構會呼叫這個成員函式, 以指定應用程式為了回應呼叫而執行的動作。 傳回值-2 表示應用程式已處理選取專案的所有層面, 而不想由清單方塊進行進一步的動作。 傳回值-1 表示清單方塊應執行預設動作以回應按鍵。 傳回值為0或更大, 會指定清單方塊中專案以零為起始的索引, 並指出清單方塊應該對指定專案上的擊鍵執行預設動作。

### <a name="remarks"></a>備註

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onchildactivate"></a>  CWnd::OnChildActivate

如果物件是多重文件介面 (MDI) 子視窗, `OnChildActivate`當使用者按一下視窗的標題列或視窗已啟動、移動或調整大小時, 架構會呼叫。 `CWnd`

```
afx_msg void OnChildActivate();
```

##  <a name="onchildnotify"></a>  CWnd::OnChildNotify

此成員函式會在收到適用于此視窗的通知訊息時, 由這個視窗的父視窗呼叫。

```
virtual BOOL OnChildNotify(
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    LRESULT* pResult);
```

### <a name="parameters"></a>參數

*message*<br/>
傳送至父視窗的 Windows 訊息編號。

*wParam*<br/>
與訊息相關聯的*wparam* 。

*lParam*<br/>
與訊息相關聯的*lparam* 。

*pLResult*<br/>
要從父系的視窗程式傳回的值指標。 如果不需要傳回值, 此指標會是 Null。

### <a name="return-value"></a>傳回值

若此視窗負責處理傳送至其父系的訊息, 則為非零值;否則為0。

### <a name="remarks"></a>備註

永遠不要直接呼叫這個成員函式。

這個成員函式的預設實值會傳回 0, 這表示父系應該處理訊息。

覆寫這個成員函式, 以擴充控制項回應通知訊息的方式。

##  <a name="onclipboardupdate"></a>CWnd:: OnClipboardUpdate

當剪貼簿的內容變更時, 架構會呼叫這個成員函式。

```
afx_msg void OnClipboardUpdate();
```

##  <a name="onclose"></a>CWnd:: OnClose

架構會呼叫這個成員函式, 做為`CWnd`或應用程式要終止的信號。

```
afx_msg void OnClose();
```

### <a name="remarks"></a>備註

預設的執行會`DestroyWindow`呼叫。

##  <a name="oncolorizationcolorchanged"></a>  CWnd::OnColorizationColorChanged

當非工作區的轉譯原則變更時, 架構會呼叫這個成員。

```
afx_msg void OnColorizationColorChanged(
    DWORD dwColorizationColor,
    BOOL bOpacity);
```

### <a name="parameters"></a>參數

|參數|描述|
|---------------|-----------------|
|*dwColorizationColor*|在指定新的顏色標示色彩。<br /><br /> 色彩格式是格式為0xAARRGGBB 的十六進位數位, 其中的四個元件中的每一個都是從0x00 到0xFF 的範圍。 AA 元件是 Alpha 值, RR 是紅色, GG 是綠色, 而 BB 是藍色。|
|*bOpacity*|在如果新的色彩與不透明度混合, 則為 TRUE;如果不是, 則為 FALSE。|

### <a name="remarks"></a>備註

這個方法會接收[WM_DWMNCRENDERINGCHANGED](/windows/desktop/dwm/wm-dwmcolorizationcolorchanged)通知訊息, 如 Windows SDK 中所述。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="oncommand"></a>  CWnd::OnCommand

當使用者從功能表選取專案、當子控制項傳送通知訊息, 或轉譯快速鍵按鍵時, 架構會呼叫這個成員函式。

```
virtual BOOL OnCommand(
    WPARAM wParam,
    LPARAM lParam);
```

### <a name="parameters"></a>參數

*wParam*<br/>
*WParam*的低序位字組會識別功能表項目、控制項或快速鍵的命令識別碼。 *WParam*的高序位單字會指定訊息是否來自控制項時的通知訊息。 如果是來自快速鍵的訊息, 則高序位單字為1。 如果訊息來自功能表, 則高序位單字為0。

*lParam*<br/>
識別當訊息來自控制項時, 傳送訊息的控制項。 否則, *lParam*為0。

### <a name="return-value"></a>傳回值

如果應用程式處理此訊息, 則會傳回非零值;否則為0。

### <a name="remarks"></a>備註

`OnCommand`處理控制項通知和 ON_COMMAND 專案的訊息對應, 並呼叫適當的成員函式。

覆寫衍生類別中的這個成員函式, 以處理[WM_COMMAND](/windows/desktop/menurc/wm-command)訊息。 除非呼叫基類`OnCommand` , 否則覆寫將不會處理訊息對應。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="oncompacting"></a>CWnd:: OnCompacting

當 Windows 偵測到超過 12.5% 的系統時間超過30到60秒的間隔時間, 此架構會為所有最上層視窗呼叫這個成員函式。

```
afx_msg void OnCompacting(UINT nCpuTime);
```

### <a name="parameters"></a>參數

*nCpuTime*<br/>
指定 Windows 壓縮記憶體到執行其他作業所花費的 CPU 時間時, 目前花費的 CPU 時間比例。 例如, 8000h 代表花在壓縮記憶體的 CPU 時間 50%。

### <a name="remarks"></a>備註

這表示系統記憶體偏低。

`CWnd`當物件收到此呼叫時, 應該盡可能釋放最多的記憶體, 將應用程式的目前活動層級, 以及在 Windows 中執行的應用程式總數列入考慮。 應用程式可以呼叫 Windows 函式來判斷有多少應用程式正在執行。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="oncompareitem"></a>  CWnd::OnCompareItem

架構會呼叫這個成員函式, 在子排序的主控描繪組合或清單方塊中指定新專案的相對位置。

```
afx_msg int OnCompareItem(
    int nIDCtl,
    LPCOMPAREITEMSTRUCT lpCompareItemStruct);
```

### <a name="parameters"></a>參數

*nIDCtl*<br/>
傳送 WM_COMPAREITEM 訊息之控制項的識別碼。

*lpCompareItemStruct*<br/>
包含[COMPAREITEMSTRUCT](/windows/desktop/api/winuser/ns-winuser-tagcompareitemstruct)資料結構的長指標, 其中包含下拉式方塊或清單方塊中兩個專案的識別碼和應用程式提供的資料。

### <a name="return-value"></a>傳回值

表示兩個專案的相對位置。 它可以是下列任何一個值:

|值|意義|
|-----------|-------------|
|-1|專案1會在專案2之前排序。|
|0|專案1和專案2會排序相同的。|
|1|專案1會在專案2之後排序。|

### <a name="remarks"></a>備註

如果使用[CBS_SORT](../../mfc/reference/styles-used-by-mfc.md#combo-box-styles)或[LBS_SORT](../../mfc/reference/styles-used-by-mfc.md#list-box-styles)樣式建立組合或清單方塊, 每當應用程式加入新專案時, WINDOWS 就會傳送 WM_COMPAREITEM 訊息給下拉式方塊或清單方塊擁有者。

下拉式方塊或清單方塊中的兩個專案會在`COMPAREITEMSTRUCT` *lpCompareItemStruct*所指向的結構中 reformed。 `OnCompareItem`應該會傳回值, 指出哪些專案應該出現在另一個之前。 一般來說, Windows 會進行此呼叫數次, 直到判斷新專案的確切位置為止。

`COMPAREITEMSTRUCT`如果結構`hwndItem`的成員屬於[CListBox](../../mfc/reference/clistbox-class.md)或[CComboBox](../../mfc/reference/ccombobox-class.md)物件, `CompareItem`則會呼叫適當類別的虛擬函式。 在`CComboBox::CompareItem`您`CListBox::CompareItem`的衍生`CListBox` 或`CComboBox`類別中覆寫或, 以執行專案比較。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="oncompositionchanged"></a>CWnd:: OnCompositionChanged

當已啟用或停用桌面視窗管理員 (DWM) 組合時, 架構會針對所有最上層視窗呼叫這個成員函式。

```
afx_msg void OnCompositionChanged();
```

### <a name="remarks"></a>備註

這個方法會接收[WM_DWMCOMPOSITIONCHANGED](/windows/desktop/dwm/wm-dwmcompositionchanged)通知, 如 Windows SDK 中所述。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="oncontextmenu"></a>  CWnd::OnContextMenu

當使用者在視窗中按一下滑鼠右鍵 (以滑鼠右鍵按一下) 時, 由架構呼叫。

```
afx_msg void OnContextMenu(
    CWnd* pWnd,
    CPoint pos);
```

### <a name="parameters"></a>參數

*pWnd*<br/>
使用者在其中按一下滑鼠右鍵之視窗的控制碼。 這可以是接收訊息之視窗的子視窗。 如需有關處理此訊息的詳細資訊, 請參閱備註一節。

*採購*<br/>
游標在滑鼠按一下時的位置 (以螢幕座標表示)。

### <a name="remarks"></a>備註

您可以使用[trackpopupmenu 讓](../../mfc/reference/cmenu-class.md#trackpopupmenu)來顯示內容功能表來處理此訊息。

如果您沒有顯示內容功能表, 您應該將此訊息傳遞至[DefWindowProc](#defwindowproc)函式。 如果您的視窗是子視窗, `DefWindowProc`則會將訊息傳送至父系。 否則, `DefWindowProc`如果指定的位置是在視窗的標題中, 則會顯示預設的內容功能表。

##  <a name="oncopydata"></a>  CWnd::OnCopyData

此成員函式是由架構呼叫, 以將資料從一個應用程式複製到另一個。

```
afx_msg BOOL OnCopyData(
    CWnd* pWnd,
    COPYDATASTRUCT* pCopyDataStruct);
```

### <a name="parameters"></a>參數

*pWnd*<br/>
傳送資料之`CWnd`物件的指標。

*pCopyDataStruct*<br/>
[COPYDATASTRUCT](/windows/desktop/api/winuser/ns-winuser-tagcopydatastruct)結構的指標, 其中包含要傳送的資料。

### <a name="return-value"></a>傳回值

如果接收應用程式成功接受資料, 則傳回 TRUE。 否則, 會傳回 FALSE。

### <a name="remarks"></a>備註

所傳遞的資料不得包含接收資料之應用程式無法存取之物件的指標或其他參考。

複製資料時, 傳送程式的另一個執行緒就不能變更它。

接收應用程式應該將資料視為唯讀。 只有在資料傳輸期間, 參數*pCopyDataStruct*所指向的結構才有效;不過, 接收應用程式不應該釋放與結構相關聯的記憶體。

如果接收的應用程式在此函式傳回之後需要存取資料, 則必須將接收到的資料複製到本機緩衝區。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="oncreate"></a>  CWnd::OnCreate

當應用程式要求藉由呼叫[Create](#create)或[CreateEx](#createex)成員函式來建立 Windows 視窗時, 架構會呼叫這個成員函式。

```
afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
```

### <a name="parameters"></a>參數

*lpCreateStruct*<br/>
指向[CREATESTRUCT](/windows/desktop/api/winuser/ns-winuser-tagcreatestructa)結構, 其中包含所建立物件的`CWnd`相關資訊。

### <a name="return-value"></a>傳回值

`OnCreate`必須傳回 0, 才能繼續建立`CWnd`物件。 如果應用程式傳回-1, 則會終結視窗。

### <a name="remarks"></a>備註

`CWnd`物件會在視窗建立後但顯示為可見之前, 接收此呼叫。 `OnCreate`會在`Create`或`CreateEx`成員函式傳回之前呼叫。

覆寫這個成員函式, 以執行任何必要的衍生類別初始化。

`CREATESTRUCT`結構包含用來建立視窗的參數複本。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onctlcolor"></a>  CWnd::OnCtlColor

當要繪製子控制項時, 架構會呼叫這個成員函式。

```
afx_msg HBRUSH OnCtlColor(
    CDC* pDC,
    CWnd* pWnd,
    UINT nCtlColor);
```

### <a name="parameters"></a>參數

*pDC*<br/>
包含子視窗之顯示內容的指標。 可能是暫時性的。

*pWnd*<br/>
包含要求色彩之控制項的指標。 可能是暫時性的。

*nCtlColor*<br/>
包含下列其中一個值, 指定控制項的類型:

- CTLCOLOR_BTN 按鈕控制項

- CTLCOLOR_DLG 對話方塊

- CTLCOLOR_EDIT 編輯控制項

- CTLCOLOR_LISTBOX 清單方塊控制項

- CTLCOLOR_MSGBOX 訊息方塊

- CTLCOLOR_SCROLLBAR 捲軸控制項

- CTLCOLOR_STATIC 靜態控制項

### <a name="return-value"></a>傳回值

`OnCtlColor`必須將控制碼傳回給用來繪製控制項背景的筆刷。

### <a name="remarks"></a>備註

大部分的控制項都會將此訊息傳送至其父系 (通常是對話方塊), 以準備*pDC*以使用正確的色彩繪製控制項。

若要變更文字色彩, 請使用`SetTextColor`所需的紅色、綠色和藍色 (RGB) 值來呼叫成員函式。

若要變更單行編輯控制項的背景色彩, 請在 CTLCOLOR_EDIT 和 CTLCOLOR_MSGBOX 訊息代碼中設定筆刷控點, 並呼叫[CDC:: SetBkColor](../../mfc/reference/cdc-class.md#setbkcolor)函式以回應 CTLCOLOR_EDIT 程式碼。

`OnCtlColor`不會針對下拉下拉式方塊的清單方塊呼叫, 因為下拉式清單方塊實際上是下拉式方塊的子系, 而不是視窗的子系。 若要變更下拉式清單方塊的色彩, 請建立`CComboBox` , 並在`nCtlColor`參數中檢查是否`OnCtlColor`有 CTLCOLOR_LISTBOX 的覆寫。 在此處理程式中`SetBkColor` , 必須使用成員函式來設定文字的背景色彩。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。 將下列方法加入至對話方塊類別，使用 Visual Studio 屬性 窗格加入 WM_CTLCOLOR 訊息處理常式。 或者, 您也可以手動將 ON_WM_CTLCOLOR () 專案新增至訊息對應。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#107](../../mfc/reference/codesnippet/cpp/cwnd-class_47.cpp)]

##  <a name="ondeadchar"></a>CWnd:: OnDeadChar

當呼叫[OnKeyUp](#onkeyup)成員函式和[OnKeyDown](#onkeydown)成員函式時, 架構會呼叫這個成員函式。

```
afx_msg void OnDeadChar(
    UINT nChar,
    UINT nRepCnt,
    UINT nFlags);
```

### <a name="parameters"></a>參數

*nChar*<br/>
指定失效索引鍵的字元值。

*nRepCnt*<br/>
指定重複計數。

*nFlags*<br/>
指定掃描碼、金鑰轉換程式碼、先前的金鑰狀態和內容程式碼, 如下列清單所示:

|值|描述|
|-----------|-----------------|
|0-7|掃描程式碼 (OEM 相依值)。 高序位單字的低位元組。|
|8|擴充索引鍵, 例如數位鍵臺上的函式金鑰或索引鍵 (如果它是擴充索引鍵, 則為 1), 否則為0。|
|9-10|未使用。|
|11-12|由 Windows 在內部使用。|
|13|內容代碼 (如果在按下按鍵時, 會按住 ALT 鍵, 則為 1, 否則為 0)。|
|14|先前的索引鍵狀態 (1, 如果金鑰在呼叫前關閉, 則為 0, 如果索引鍵已啟動)。|
|15|轉換狀態 (如果正在釋放索引鍵, 則為 1, 如果按下按鍵則為 0)。|

### <a name="remarks"></a>備註

這個成員函式可以用來指定失效索引鍵的字元值。 無作用的索引鍵是一個索引鍵 (例如, 加上變音符號 (雙點) 字元), 會與其他字元結合以形成複合字元。 例如, 變音符號的 O 字元是由不正確索引鍵、變音符號和 O 鍵所組成。

應用程式通常會`OnDeadChar`使用, 為使用者提供每個按鍵的意見反應。 例如, 應用程式可以在目前的字元位置顯示輔色, 而不移動插入號。

由於所按下的按鍵和`OnDeadChar`呼叫之間不一定會有一對一的對應關係, 因此*nFlags*中的資訊通常對應用程式而言並不實用。 *NFlags*中的資訊僅適用于對[OnKeyUp](#onkeyup)成員函式的最新呼叫, 或在`OnDeadChar`呼叫之前的 [OnKeyDown](#onkeydown) 成員函式。

針對 IBM 增強的101和102金鑰鍵盤, 增強式金鑰是鍵盤主要區段上的右 ALT 和右 CTRL 鍵;數位鍵臺上左邊的叢集中的 INS、DEL、HOME、END、PAGE UP、PAGE DOWN 和方向鍵;和斜線 (/), 然後在數位鍵臺上輸入按鍵。 有些其他鍵盤可能支援*nFlags*中的延伸金鑰位。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="ondeleteitem"></a>  CWnd::OnDeleteItem

此架構會呼叫這個成員函式, 以通知主控描繪清單方塊或下拉式方塊的擁有者, 清單方塊或下拉式方塊已終結, 或已由 CComboBox 移除專案[::D eletestring](../../mfc/reference/ccombobox-class.md#deletestring)、 [CListBox::D eletestring](../../mfc/reference/clistbox-class.md#deletestring)、 [CComboBox::ResetContent](../../mfc/reference/ccombobox-class.md#resetcontent), 或[CListBox:: ResetContent](../../mfc/reference/clistbox-class.md#resetcontent)。

```
afx_msg void OnDeleteItem(
    int nIDCtl,
    LPDELETEITEMSTRUCT lpDeleteItemStruct);
```

### <a name="parameters"></a>參數

*nIDCtl*<br/>
傳送 WM_DELETEITEM 訊息之控制項的識別碼。

*lpDeleteItemStruct*<br/>
指定[DELETEITEMSTRUCT](/windows/desktop/api/winuser/ns-winuser-tagdeleteitemstruct)資料結構的長指標, 其中包含已刪除清單方塊專案的相關資訊。

### <a name="remarks"></a>備註

如果`DELETEITEMSTRUCT`結構`hwndItem`的成員屬於下拉式方塊或清單方塊, 則會呼叫適當類別的`DeleteItem`虛擬函式。 覆寫適當控制項類別的成員函式,以刪除專案特定資料。`DeleteItem`

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="ondestroy"></a>  CWnd::OnDestroy

架構會呼叫這個成員函式, 以`CWnd`通知物件它正在終結。

```
afx_msg void OnDestroy();
```

### <a name="remarks"></a>備註

`OnDestroy`從螢幕中移除`CWnd`物件之後, 會呼叫。

`OnDestroy`會先針對被終結`CWnd`的呼叫, 然後在的子`CWnd`視窗中被終結。 在執行時`OnDestroy` , 它可以假設所有子視窗仍然存在。

如果要終結的`CWnd`  物件是剪貼簿-檢視器鏈的一部分(藉由呼叫[SetClipboardViewer](#setclipboardviewer)成員函式設定),必須呼叫,將其本身從剪貼簿-檢視器鏈`CWnd`中移除[ChangeClipboardChain](#changeclipboardchain)成員函式, `OnDestroy`然後再從函式傳回。

##  <a name="ondestroyclipboard"></a>  CWnd::OnDestroyClipboard

當您透過呼叫[EmptyClipboard](/windows/desktop/api/winuser/nf-winuser-emptyclipboard) Windows 函式清空剪貼簿時, 架構會為剪貼簿擁有者呼叫這個成員函式。

```
afx_msg void OnDestroyClipboard();
```

##  <a name="ondevicechange"></a>  CWnd::OnDeviceChange

此架構會呼叫此成員函式, 以通知應用程式或設備磁碟機變更裝置或電腦的硬體設定。

```
afx_msg BOOL OnDeviceChange(
    UINT nEventType,
    DWORD_PTR dwData);
```

### <a name="parameters"></a>參數

*nEventType*<br/>
事件種類。 如需可用值的說明, 請參閱備註一節。

*dwData*<br/>
包含事件特定資料的結構位址。 其意義取決於指定的事件。

### <a name="remarks"></a>備註

對於提供軟體可控制功能的裝置 (例如, 彈出和鎖定), 作業系統通常會傳送 DBT_DEVICEREMOVEPENDING 訊息, 讓應用程式和設備磁碟機正常地結束使用裝置。

如果作業系統強制移除裝置, 則在執行此動作之前, 它可能不會傳送 DBT_DEVICEQUERYREMOVE 訊息。

*NEvent*參數可以是下列其中一個值:

- [DBT_DEVICEARRIVAL](/windows/desktop/DevIO/dbt-devicearrival)已插入裝置, 且現在已可使用。

- [DBT_DEVICEQUERYREMOVE](/windows/desktop/DevIO/dbt-devicequeryremove)已要求移除裝置的許可權。 任何應用程式都可以拒絕此要求並取消移除。

- [DBT_DEVICEQUERYREMOVEFAILED](/windows/desktop/DevIO/dbt-devicequeryremovefailed)已取消移除裝置的要求。

- [DBT_DEVICEREMOVEPENDING](/windows/desktop/DevIO/dbt-deviceremovepending)即將移除裝置。 無法拒絕。

- [DBT_DEVICEREMOVECOMPLETE](/windows/desktop/DevIO/dbt-deviceremovecomplete)裝置已移除。

- [DBT_DEVICETYPESPECIFIC](/windows/desktop/DevIO/dbt-devicetypespecific)裝置特定事件。

- [DBT_CONFIGCHANGED](/windows/desktop/DevIO/dbt-configchanged)目前的設定已變更。

- DBT_DEVNODES_CHANGED 裝置節點已變更。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="ondevmodechange"></a>  CWnd::OnDevModeChange

當使用者變更裝置模式設定時, 架構會針對`CWnd`所有最上層物件呼叫這個成員函式。

```
afx_msg void OnDevModeChange(LPTSTR lpDeviceName);
```

### <a name="parameters"></a>參數

*lpDeviceName*<br/>
指向 Windows 初始化檔中指定的裝置名稱, WIN.INI.

### <a name="remarks"></a>備註

處理 WM_DEVMODECHANGE 訊息的應用程式可能會重新初始化其裝置模式設定。 使用 Windows `ExtDeviceMode`功能儲存和還原裝置設定的應用程式, 通常不會處理此功能。

當使用者從 [控制台] 變更預設印表機時, 不會呼叫此函式。 在此情況下, `OnWinIniChange`會呼叫函式。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="ondrawclipboard"></a>  CWnd::OnDrawClipboard

當剪貼簿的內容變更時, 架構會在剪貼簿-檢視器鏈中針對每個視窗呼叫這個成員函式。

```
afx_msg void OnDrawClipboard();
```

### <a name="remarks"></a>備註

只有已藉由呼叫[SetClipboardViewer](#setclipboardviewer)成員函式加入剪貼簿檢視器鏈的應用程式, 才需要回應此呼叫。

接收`OnDrawClipboard`呼叫的每個視窗都應該呼叫[SendMessage](/windows/desktop/api/winuser/nf-winuser-sendmessage) Windows 函式, 將[WM_DRAWCLIPBOARD](/windows/desktop/dataxchg/wm-drawclipboard)訊息傳遞至剪貼簿檢視器鏈中的下一個視窗。 下一個視窗的控制碼是由[SetClipboardViewer](#setclipboardviewer)成員函式傳回;它可能會修改以回應[OnChangeCbChain](#onchangecbchain)成員函式呼叫。

##  <a name="ondrawiconicthumbnailorlivepreview"></a>  CWnd::OnDrawIconicThumbnailOrLivePreview

需要取得點陣圖，在 Windows 7 索引標籤上顯示為縮圖時，或顯示在用戶端上以查看應用程式時，由架構呼叫。

```
virtual void OnDrawIconicThumbnailOrLivePreview(
    CDC& dc,
    CRect rect,
    CSize szRequiredThumbnailSize,
    BOOL bIsThumbnail,
    BOOL& bAlphaChannelSet);
```

### <a name="parameters"></a>參數

*dc*<br/>
指定裝置內容。

*rect*<br/>
指定要呈現之區域的周框。

*szRequiredThumbnailSize*<br/>
指定目標縮圖的大小。 如果*bIsThumbnail*為 FALSE, 則應該忽略。

*bIsThumbnail*<br/>
指定是否針對 iconic 縮圖或即時預覽 (查看) 呼叫此方法。

*bAlphaChannelSet*<br/>
脫銷如果您的執行會初始化在*dc*中選取之點陣圖的 Alpha 色板, 請將它設定為 TRUE。

### <a name="remarks"></a>備註

覆寫衍生類別中的這個方法, 並在指定的裝置內容上繪製, 以便自訂縮圖和查看。 如果*bThumbnail*為 TRUE, 則可以忽略*szRequiredThumbnailSize* 。 在此情況下, 您應該知道您繪製的是完整大小的點陣圖 (也就是涵蓋整個工作區的點陣圖)。 裝置內容 ( *dc*) 隨附選取的32位點陣圖。 預設的執行會使用 PRF_CLIENT、PRF_CHILDREN 和 PRF_NONCLIENT 旗標, 將 WM_PRINT 傳送至這個視窗。

##  <a name="ondrawitem"></a>  CWnd::OnDrawItem

當控制項或功能表的視覺外觀變更時, 架構會為主控描繪按鈕控制項、下拉式方塊控制項、清單方塊控制項或功能表的擁有者呼叫這個成員函式。

```
afx_msg void OnDrawItem(
    int nIDCtl,
    LPDRAWITEMSTRUCT lpDrawItemStruct);
```

### <a name="parameters"></a>參數

*nIDCtl*<br/>
包含傳送 WM_DRAWITEM 訊息之控制項的識別碼。 如果功能表傳送了訊息, 則*nIDCtl*會包含0。

*lpDrawItemStruct*<br/>
指定`DRAWITEMSTRUCT`資料結構的長指標, 其中包含要繪製之專案的相關資訊, 以及所需的繪圖類型。

### <a name="remarks"></a>備註

[DRAWITEMSTRUCT 結構](/windows/desktop/api/winuser/ns-winuser-tagdrawitemstruct)的成員會定義要執行的繪製`itemAction`作業。 這個成員中的資料可讓控制項的擁有者判斷需要何種繪圖動作。

在從處理此訊息傳回之前, 應用程式應該確保`DRAWITEMSTRUCT`結構的*hDC*成員所識別的裝置內容已還原為預設狀態。

`DrawItem`如果成員屬於 [CButton](../../mfc/reference/cbutton-class.md)、[CMenu](../../mfc/reference/cmenu-class.md)、[CListBox](../../mfc/reference/clistbox-class.md) 或 [CComboBox](../../mfc/reference/ccombobox-class.md) 物件, 則會呼叫適當類別的虛擬函式。`hwndItem` 覆寫適當控制項類別的成員函式,以繪製專案。`DrawItem`

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="ondropfiles"></a>  CWnd::OnDropFiles

當使用者在已將本身註冊為已卸載檔案收件者的視窗上放開滑鼠左鍵時, 此架構會呼叫這個成員函式。

```
afx_msg void OnDropFiles(HDROP hDropInfo);
```

### <a name="parameters"></a>參數

*hDropInfo*<br/>
內部資料結構的指標, 描述已卸載的檔案。 `DragFinish` 、`DragQueryFile`和Windows`DragQueryPoint`函式會使用此控制碼來取得已卸載檔案的相關資訊。

### <a name="remarks"></a>備註

一般來說, 衍生類別的設計是支援卸載的檔案, 而且它會在視窗結構期間自我註冊。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onenable"></a>  CWnd::OnEnable

當應用程式變更`CWnd`物件的啟用狀態時, 架構會呼叫這個成員函式。

```
afx_msg void OnEnable(BOOL bEnable);
```

### <a name="parameters"></a>參數

*bEnable*<br/>
指定`CWnd`物件是否已啟用或停用。 如果已啟用, `CWnd`則此參數為 TRUE, `CWnd`如果已停用, 則為 FALSE。

### <a name="remarks"></a>備註

`OnEnable`會在[EnableWindow](#enablewindow)成員函式傳回之前呼叫, 但是在視窗啟用狀態 ( [WS_DISABLED](styles-used-by-mfc.md#window-styles)樣式位) 變更後。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onendsession"></a>  CWnd::OnEndSession

當`CWnd`物件從[OnQueryEndSession](#onqueryendsession)成員函式呼叫傳回非零值之後, 架構會呼叫這個成員函式。

```
afx_msg void OnEndSession(BOOL bEnding);
```

### <a name="parameters"></a>參數

*bEnding*<br/>
指定是否要結束會話。 如果會話已結束, 則為 TRUE;否則為 FALSE。

### <a name="remarks"></a>備註

此`OnEndSession`呼叫會`CWnd`通知物件會話是否實際結束。

如果*彎曲*為 TRUE, 則在所有應用程式從處理此呼叫傳回之後, Windows 可以隨時終止。 因此, 讓應用程式執行在中`OnEndSession`終止所需的所有工作。

當會話結束時, 您不需要呼叫[DestroyWindow](#destroywindow)成員函式或[PostQuitMessage](/windows/desktop/api/winuser/nf-winuser-postquitmessage) Windows 函式。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onenteridle"></a>  CWnd::OnEnterIdle

此架構會呼叫這個成員函式, 以通知應用程式的主視窗進程, 強制回應對話方塊或功能表正在進入閒置狀態。

```
afx_msg void OnEnterIdle(
    UINT nWhy,
    CWnd* pWho);
```

### <a name="parameters"></a>參數

*nWhy*<br/>
指定訊息是對話方塊或功能表顯示的結果。 這個參數可以是下列其中一個值:

- MSGF_DIALOGBOX 系統閒置, 因為正在顯示對話方塊。

- MSGF_MENU 系統閒置, 因為正在顯示功能表。

*pWho*<br/>
指定對話方塊的指標 (如果*nWhy*是 MSGF_DIALOGBOX), 或是包含所顯示功能表的視窗 (如果*nWhy*是 MSGF_MENU)。 這個指標可能是暫時性的, 不應該儲存以供稍後使用。

### <a name="remarks"></a>備註

當強制回應對話方塊或功能表在處理一或多個先前的訊息之後, 其佇列中沒有等待的訊息時, 就會進入閒置狀態。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onentermenuloop"></a>CWnd:: OnEnterMenuLoop

當已經輸入功能表強制回應迴圈時, 架構會呼叫這個成員函式。

```
afx_msg void OnEnterMenuLoop(BOOL bIsTrackPopupMenu);
```

### <a name="parameters"></a>參數

*bIsTrackPopupMenu*<br/>
指定相關功能表是否為快顯功能表。 如果函式成功, 則為非零值;否則為0。

### <a name="remarks"></a>備註

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onentersizemove"></a>CWnd:: OnEnterSizeMove

在受影響的視窗進入移動或調整大小的強制回應迴圈之後, 此架構會呼叫這個成員函式一次。

```
afx_msg void OnEnterSizeMove();
```

### <a name="remarks"></a>備註

這個方法會接收[WM_ENTERSIZEMOVE](/windows/desktop/winmsg/wm-entersizemove)通知, 如 Windows SDK 中所述。

當使用者按一下視窗的標題列或調整大小框線, 或當視窗將[WM_SYSCOMMAND](/windows/desktop/menurc/wm-syscommand)訊息傳遞給[CWnd::D efwindowproc](#defwindowproc)函式和該訊息的*wParam*參數時, 視窗會進入移動或調整大小的強制回應迴圈指定 SC_MOVE 或 SC_SIZE。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onerasebkgnd"></a>  CWnd::OnEraseBkgnd

當`CWnd`物件背景需要清除時, 架構會呼叫這個成員函式 (例如, 調整大小時)。

```
afx_msg BOOL OnEraseBkgnd(CDC* pDC);
```

### <a name="parameters"></a>參數

*pDC*<br/>
指定裝置內容物件。

### <a name="return-value"></a>傳回值

如果清除背景, 則為非零值;否則為0。

### <a name="remarks"></a>備註

系統會呼叫它來準備用於繪製的無效區域。

預設的執行會使用視窗類別結構`hbrBackground`成員所指定的視窗類別背景筆刷來清除背景。

如果成員為 Null, 您的`OnEraseBkgnd`覆寫版本應該會清除背景色彩。 `hbrBackground` 您的版本也應該對齊與預期的筆刷的原點`CWnd`藉由第一個呼叫的座標[UnrealizeObject](/windows/desktop/api/wingdi/nf-wingdi-unrealizeobject)的筆刷，，然後選取 筆刷。

如果它`OnEraseBkgnd`處理訊息並清除背景, 則覆寫的會傳回非零以回應 WM_ERASEBKGND; 這表示不需要進一步清除。 如果傳回 0, 視窗仍會標示為需要清除。 (一般而言, 這表示`fErase` `PAINTSTRUCT`結構的成員將會是 TRUE)。

Windows 假設背景是以 MM_TEXT 對應模式來計算。 如果裝置內容使用任何其他對應模式, 則清除的區域可能不在工作區的可見部分內。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onexitmenuloop"></a>  CWnd::OnExitMenuLoop

當功能表強制回應迴圈結束時, 架構會呼叫這個成員函式。

```
afx_msg void OnExitMenuLoop(BOOL bIsTrackPopupMenu);
```

### <a name="parameters"></a>參數

*bIsTrackPopupMenu*<br/>
指定相關功能表是否為快顯功能表。 如果函式成功, 則為非零值;否則為0。

### <a name="remarks"></a>備註

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onexitsizemove"></a>  CWnd::OnExitSizeMove

在受影響的視窗結束移動或調整大小的強制回應迴圈之後, 架構會呼叫這個成員函式一次。

```
afx_msg void OnExitSizeMove();
```

### <a name="remarks"></a>備註

這個方法會接收[WM_EXITSIZEMOVE](/windows/desktop/winmsg/wm-exitsizemove)通知, 如 Windows SDK 中所述。

當使用者按一下視窗的標題列或調整大小框線, 或當視窗將[WM_SYSCOMMAND](/windows/desktop/menurc/wm-syscommand)訊息傳遞給[CWnd::D efwindowproc](#defwindowproc)函式和該訊息的*wParam*參數時, 視窗會進入移動或調整大小的強制回應迴圈指定 SC_MOVE 或 SC_SIZE。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onfontchange"></a>  CWnd::OnFontChange

在應用程式變更字型資源集區之後, `OnFontChange`系統中的所有最上層視窗都會收到來自架構的呼叫。

```
afx_msg void OnFontChange();
```

### <a name="remarks"></a>備註

在系統中新增或移除字型的應用程式 (例如, 透過[AddFontResource](/windows/desktop/api/wingdi/nf-wingdi-addfontresourcea)或[RemoveFontResource](/windows/desktop/api/wingdi/nf-wingdi-removefontresourcea) Windows 函式), 應該將[WM_FONTCHANGE](/windows/desktop/gdi/wm-fontchange)訊息傳送至所有最上層視窗。

若要傳送此訊息, 請使用[SendMessage](/windows/desktop/api/winuser/nf-winuser-sendmessage) Windows 函數, 並將*hWnd*參數設為 HWND_BROADCAST。

##  <a name="ongetdlgcode"></a>  CWnd::OnGetDlgCode

呼叫控制項，讓控制項可以處理方向鍵和 TAB 鍵輸入本身。

```
afx_msg UINT OnGetDlgCode();
```

### <a name="return-value"></a>傳回值

下列一或多個值, 指出應用程式處理的輸入類型:

- DLGC_BUTTON 按鈕 (一般)。

- DLGC_DEFPUSHBUTTON 預設按鈕。

- DLGC_HASSETSEL EM_SETSEL 訊息。

- DLGC_UNDEFPUSHBUTTON 沒有預設的按鈕處理。 (應用程式可以搭配 DLGC_BUTTON 使用此旗標, 表示它會處理按鈕輸入, 但會依賴系統進行預設的按鍵處理)。

- DLGC_RADIOBUTTON 選項按鈕。

- DLGC_STATIC 靜態控制項。

- DLGC_WANTALLKEYS 所有鍵盤輸入。

- DLGC_WANTARROWS 方向鍵。

- DLGC_WANTCHARS WM_CHAR 訊息。

- DLGC_WANTMESSAGE 所有鍵盤輸入。 應用程式會將此訊息傳送至控制項。

- DLGC_WANTTAB TAB 鍵。

### <a name="remarks"></a>備註

一般來說, Windows 會處理控制項的`CWnd`所有箭號鍵和 TAB 鍵輸入。 藉由`OnGetDlgCode`覆寫`CWnd` , 控制項可以選擇特定類型的輸入來處理本身。

預先定義`OnGetDlgCode`之控制項類別的預設函式會傳回適用于每個類別的程式碼。

##  <a name="ongetminmaxinfo"></a>  CWnd::OnGetMinMaxInfo

每當 Windows 需要知道最大化的位置或維度, 或最小或最大的追蹤大小時, 架構就會呼叫這個成員函式。

```
afx_msg void OnGetMinMaxInfo(MINMAXINFO* lpMMI);
```

### <a name="parameters"></a>參數

*lpMMI*<br/>
`MINMAXINFO`指向結構, 其中包含視窗最大化大小和位置及其最小和最大追蹤大小的相關資訊。 如需此結構的詳細資訊, 請參閱[MINMAXINFO](/windows/desktop/api/winuser/ns-winuser-tagminmaxinfo)結構。

### <a name="remarks"></a>備註

最大化的大小是當其框線完全延伸時的視窗大小。 視窗的追蹤大小上限是最大的視窗大小, 可使用框線來調整視窗大小。 視窗的最小追蹤大小是最小的視窗大小, 可使用框線調整視窗大小來達到。

Windows 會填入點陣列, 以指定不同位置和維度的預設值。 應用程式可能會在中`OnGetMinMaxInfo`變更這些值。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onhelp"></a>CWnd:: OnHelp

在應用程式 (使用目前的內容) 中處理 F1 說明。

```
afx_msg void OnHelp();
```

### <a name="remarks"></a>備註

如需詳細資訊, 請參閱[CWinApp:: OnHelp](../../mfc/reference/cwinapp-class.md#onhelp) 。

##  <a name="onhelpfinder"></a>  CWnd::OnHelpFinder

處理 ID_HELP_FINDER 和 ID_DEFAULT_HELP 命令。

```
afx_msg void OnHelpFinder();
```

### <a name="remarks"></a>備註

如需詳細資訊, 請參閱[CWinApp:: OnHelpFinder](../../mfc/reference/cwinapp-class.md#onhelpfinder) 。

##  <a name="onhelpindex"></a>CWnd:: OnHelpIndex

處理 ID_HELP_INDEX 命令, 並提供預設說明主題。

```
afx_msg void OnHelpIndex();
```

### <a name="remarks"></a>備註

如需詳細資訊, 請參閱[CWinApp:: OnHelpIndex](../../mfc/reference/cwinapp-class.md#onhelpindex) 。

##  <a name="onhelpinfo"></a>CWnd:: OnHelpInfo

當使用者按下 F1 鍵時，由架構呼叫。

```
afx_msg BOOL OnHelpInfo(HELPINFO* lpHelpInfo);
```

### <a name="parameters"></a>參數

*lpHelpInfo*<br/>
指標[HELPINFO](/windows/desktop/api/winuser/ns-winuser-taghelpinfo)包含功能表項目、 控制項、 對話方塊中或要求說明 視窗的相關資訊的結構。

### <a name="return-value"></a>傳回值

如果視窗具有鍵盤焦點, 或視窗內有作用中的功能表, 則傳回 TRUE。 如果沒有視窗具有鍵盤焦點, 則會傳回 FALSE。

### <a name="remarks"></a>備註

當按下 F1 鍵時, 如果功能表處於作用中狀態, 則會將 WM_HELP 傳送至與功能表關聯的視窗;否則, WM_HELP 會傳送至具有鍵盤焦點的視窗。 如果沒有視窗具有鍵盤焦點, 則會將 WM_HELP 傳送至目前的使用中視窗。

##  <a name="onhelpusing"></a>CWnd:: OnHelpUsing

處理 ID_HELP_USING 命令。

```
afx_msg void OnHelpUsing();
```

### <a name="remarks"></a>備註

如需詳細資訊, 請參閱[CWinApp:: OnHelpUsing](../../mfc/reference/cwinapp-class.md#onhelpusing) 。

##  <a name="onhotkey"></a>  CWnd::OnHotKey

當使用者按下全系統的熱鍵時, 架構會呼叫這個成員函式。

```
afx_msg void OnHotKey(
    UINT nHotKeyId,
    UINT nKey1,
    UINT nKey2);
```

### <a name="parameters"></a>參數

|參數|說明|
|---------------|-----------------|
|*nHotKeyId*|在產生訊息之熱鍵的識別碼。 如果訊息是由系統定義的熱鍵所產生, 此參數將會是下列其中一個值:<br /><br /> -IDHOT_SNAPDESKTOP-已按下 [貼齊桌面] 快速鍵。<br />-IDHOT_SNAPWINDOW-已按下 [嵌入式管理單元] 快速鍵。|
|*nKey1*|在旗標的位元組合 (OR), 表示與*nKey2*參數所指定之索引鍵一起按下的按鍵。 可能值為：<br /><br /> -MOD_ALT-已按住 ALT 鍵。<br />-MOD_CONTROL-已按住 CTRL 鍵。<br />-MOD_SHIFT-已按住 SHIFT 鍵。<br />-MOD_WIN-其中一個 WINDOWS 金鑰已被保留。 這些金鑰會加上 Microsoft Windows 標誌的標籤。|
|*nKey2*|在熱鍵的虛擬按鍵碼。|

### <a name="remarks"></a>備註

這個方法會接收[WM_HOTKEY](/windows/desktop/inputdev/wm-hotkey)通知, 如 Windows SDK 中所述。 此訊息會放在與登錄熱鍵的執行緒相關聯之訊息佇列的頂端。 使用[RegisterHotKey](/windows/desktop/api/winuser/nf-winuser-registerhotkey)函數來註冊全系統的熱鍵。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onhscroll"></a>  CWnd::OnHScroll

當使用者按一下視窗的水準捲軸時, 架構會呼叫這個成員函式。

```
afx_msg void OnHScroll(
    UINT nSBCode,
    UINT nPos,
    CScrollBar* pScrollBar);
```

### <a name="parameters"></a>參數

*nSBCode*<br/>
指定指出使用者的滾動要求的捲軸程式碼。 這個參數可以是下列其中一項:

- SB_LEFT 滾動到最左邊。

- SB_ENDSCROLL 結束捲軸。

- SB_LINELEFT 向左滾動。

- 向右 SB_LINERIGHT。

- SB_PAGELEFT 向左滾動一頁。

- SB_PAGERIGHT 向右滾動一頁。

- SB_RIGHT 向右滾動到最右側。

- SB_THUMBPOSITION 會滾動到絕對位置。 目前的位置是由*nPos*參數所指定。

- SB_THUMBTRACK 將捲動方塊拖曳至指定的位置。 目前的位置是由*nPos*參數所指定。

*nPos*<br/>
指定捲軸程式碼為 SB_THUMBPOSITION 或 SB_THUMBTRACK 時的捲動方塊位置;否則, 就不會使用。 視初始捲軸範圍而定, *nPos*可能是負值, 而且應該在必要時轉換成**int** 。

*pScrollBar*<br/>
如果捲軸訊息來自捲軸控制項, 則會包含控制項的指標。 如果使用者已按下視窗的捲軸, 則此參數為 Null。 該指標可能是暫時性的，因此不應該儲存供日後使用。

### <a name="remarks"></a>備註

SB_THUMBTRACK 捲軸程式碼通常是由在拖曳捲動方塊時提供一些意見反應的應用程式所使用。

如果應用程式會滾動捲軸所控制的內容, 則也必須使用[SetScrollPos](#setscrollpos)成員函式重設捲動方塊的位置。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#108](../../mfc/reference/codesnippet/cpp/cwnd-class_48.cpp)]

##  <a name="onhscrollclipboard"></a>  CWnd::OnHScrollClipboard

剪貼簿擁有者`OnHScrollClipboard`的成員函式會在剪貼簿資料`CF_OWNERDISPLAY`具有格式, 且剪貼簿檢視器的水準捲軸中有事件時, 由剪貼簿檢視器呼叫。

```
afx_msg void OnHScrollClipboard(
    CWnd* pClipAppWnd,
    UINT nSBCode,
    UINT nPos);
```

### <a name="parameters"></a>參數

*pClipAppWnd*<br/>
指定 剪貼簿檢視器視窗的指標。 該指標可能是暫時性的，因此不應該儲存供日後使用。

*nSBCode*<br/>
以低序位字組指定下列捲軸代碼的其中一個:

- SB_BOTTOM 向右下方移動。

- SB_ENDSCROLL 結束捲軸。

- SB_LINEDOWN 向下滾動一行。

- SB_LINEUP 向上滾動一行。

- SB_PAGEDOWN 向下滾動一頁。

- SB_PAGEUP 向上滾動一頁。

- SB_THUMBPOSITION 會滾動到絕對位置。 目前的位置是在*nPos*中提供。

- SB_TOP 向左上方移動。

*nPos*<br/>
如果捲軸程式碼為 SB_THUMBPOSITION, 則包含捲動方塊位置。否則不會使用。

### <a name="remarks"></a>備註

擁有者應該滾動剪貼簿影像、使適當的區段失效, 並更新捲軸值。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="oniconerasebkgnd"></a>  CWnd::OnIconEraseBkgnd

當圖示的背景必須在繪製圖示之前填滿時`CWnd` , 架構會為最小化 (iconic) 物件呼叫這個成員函式。

```
afx_msg void OnIconEraseBkgnd(CDC* pDC);
```

### <a name="parameters"></a>參數

*pDC*<br/>
指定圖示的裝置內容物件。 可能是暫時性的, 不應該儲存以供稍後使用。

### <a name="remarks"></a>備註

`CWnd`只有在已定義視窗預設實值的類別圖示時, 才會接收此呼叫。否則會呼叫[OnEraseBkgnd](#onerasebkgnd) 。

[DefWindowProc](#defwindowproc)成員函式會使用父視窗的背景筆刷來填滿圖示背景。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="oninitmenu"></a>  CWnd::OnInitMenu

當功能表即將成為作用中時, 架構會呼叫這個成員函式。

```
afx_msg void OnInitMenu(CMenu* pMenu);
```

### <a name="parameters"></a>參數

*pMenu*<br/>
指定要初始化的功能表。 可能是暫時性的, 不應該儲存以供稍後使用。

### <a name="remarks"></a>備註

`OnInitMenu`當使用者按一下功能表列上的專案或按下功能表鍵時, 會呼叫。 覆寫此成員函式, 以在顯示功能表之前加以修改。

`OnInitMenu`只有在第一次存取功能表時 (例如, 當使用者按一下功能表列上的專案時), 才會呼叫一次。 這個方法不會提供功能表項目的相關資訊。 當使用者移至功能表中的專案時 (例如, 藉由將滑鼠移至數個功能表項目上), 不會再次呼叫函式。 當使用者從功能表結束後 (例如, 按一下應用程式用戶端區域), 然後按一下功能表列上的某個專案時, 就會再次呼叫該函數。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="oninitmenupopup"></a>  CWnd::OnInitMenuPopup

當快顯功能表即將變成作用中時, 架構會呼叫這個成員函式。

```
afx_msg void OnInitMenuPopup(
    CMenu* pPopupMenu,
    UINT nIndex,
    BOOL bSysMenu);
```

### <a name="parameters"></a>參數

*pPopupMenu*<br/>
指定快顯功能表的功能表物件。 可能是暫時性的, 不應該儲存以供稍後使用。

*nIndex*<br/>
指定主功能表中快顯功能表的索引。

*bSysMenu*<br/>
如果快顯功能表是 [控制] 功能表, 則為 TRUE;否則為 FALSE。

### <a name="remarks"></a>備註

如此一來, 應用程式就可以在顯示快顯功能表之後, 不需要變更整個功能表就加以修改。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="oninputdevicechange"></a>  CWnd::OnInputDeviceChange

在系統中新增或移除 i/o 裝置時, 架構會呼叫這個成員函式。

```
afx_msg void OnInputDeviceChange(unsigned short uFlag);
```

### <a name="parameters"></a>參數

|參數|描述|
|---------------|-----------------|
|*uFlag*|在此旗標可以包含下列值:<br /><br /> -GIDC_ARRIVAL-已將新裝置新增至系統。<br />-GIDC_REMOVAL-裝置已從系統中移除。|

### <a name="remarks"></a>備註

這個方法會接收[WM_INPUT_DEVICE_CHANGE](/windows/desktop/inputdev/wm-input-device-change)通知, 如 Windows SDK 中所述。 是一般輸入裝置訊息。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="oninputlangchange"></a>  CWnd::OnInputLangChange

架構會在應用程式的輸入語言變更後, 對最上層受影響的視窗呼叫這個成員。

```
afx_msg void OnInputLangChange(
    UINT nCharSet,
    UINT nLocaleId);
```

### <a name="parameters"></a>參數

|參數|描述|
|---------------|-----------------|
|*nCharSet*|在新地區設定的字元集。 如需詳細資訊, 請參閱[LOGFONT](/windows/desktop/api/wingdi/ns-wingdi-taglogfonta)結構的*lfCharSet*參數。|
|*nLocaleId*|在輸入地區設定識別碼。 如需詳細資訊, 請參閱[語言識別項常數和字串](/windows/desktop/Intl/language-identifier-constants-and-strings)。|

### <a name="remarks"></a>備註

這個方法會接收[WM_INPUTLANGCHANGE](/windows/desktop/winmsg/wm-inputlangchange)通知訊息, 如 Windows SDK 中所述。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="oninputlangchangerequest"></a>  CWnd::OnInputLangChangeRequest

當使用者選擇新的輸入語言時, 架構會針對具有焦點的 window 呼叫這個成員。

```
afx_msg void OnInputLangChangeRequest(
    UINT nFlags,
    UINT nLocaleId);
```

### <a name="parameters"></a>參數

|參數|描述|
|---------------|-----------------|
|*nFlags*|在旗標的位 (OR) 組合, 表示已從已安裝之地區設定清單中的上一個或下一個地區設定選取了新的地區設定, 或新輸入地區設定的鍵盤配置可與系統字元集搭配使用。<br /><br /> 可能的值為 INPUTLANGCHANGE_BACKWARD、INPUTLANGCHANGE_FORWARD 和 INPUTLANGCHANGE_SYSCHARSET。|
|*nLocaleId*|在輸入地區設定識別碼。 如需詳細資訊, 請參閱[語言識別項常數和字串](/windows/desktop/Intl/language-identifier-constants-and-strings)。|

### <a name="remarks"></a>備註

這個方法會接收[WM_INPUTLANGCHANGEREQUEST](/windows/desktop/winmsg/wm-inputlangchangerequest)通知訊息, 如 Windows SDK 中所述。 當使用者使用鍵盤控制台應用程式中指定的熱鍵, 或從系統工作列上的指標來選擇新的輸入語言時, 就會張貼此訊息。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onkeydown"></a>  CWnd::OnKeyDown

當按下非系統鍵時, 架構會呼叫這個成員函式。

```
afx_msg void OnKeyDown(
    UINT nChar,
    UINT nRepCnt,
    UINT nFlags);
```

### <a name="parameters"></a>參數

*nChar*<br/>
指定指定之索引鍵的虛擬按鍵碼。 如需標準虛擬按鍵代碼的清單, 請參閱 Winuser。

*nRepCnt*<br/>
重複計數 (擊鍵因使用者按住鍵而重複的次數)。

*nFlags*<br/>
指定掃描碼、金鑰轉換程式碼、先前的金鑰狀態和內容程式碼, 如下列清單所示:

|值|描述|
|-----------|-----------------|
|0-7|掃描程式碼 (OEM 相依值)。|
|8|擴充的索引鍵, 例如在數位鍵臺上的功能鍵或索引鍵 (如果它是擴充索引鍵, 則為 1)。|
|9-10|未使用。|
|11-12|由 Windows 在內部使用。|
|13|內容代碼 (如果在按下按鍵時, 會按住 ALT 鍵, 則為 1, 否則為 0)。|
|14|先前的索引鍵狀態 (1, 如果金鑰在呼叫前關閉, 則為 0, 如果索引鍵已啟動)。|
|15|轉換狀態 (如果正在釋放索引鍵, 則為 1, 如果按下按鍵則為 0)。|

若為 WM_KEYDOWN 訊息, 金鑰轉換位 (位 15) 為 0, 且內容代碼位 (位 13) 為0。

### <a name="remarks"></a>備註

非系統按鍵是鍵盤按鍵, 會在未按下 ALT 鍵時按下, 或在具有輸入焦點時`CWnd`按下鍵盤按鍵。

由於自動重複, 因此在進行[OnKeyUp](#onkeyup)成員`OnKeyDown`函式呼叫之前, 可能會發生一個以上的呼叫。 表示前一個索引鍵狀態的位, 可以用來判斷`OnKeyDown`呼叫是第一個向下轉換還是重複的向下轉換。

針對 IBM 增強的101和102金鑰鍵盤, 增強式金鑰是鍵盤主要區段上的右 ALT 和右 CTRL 鍵;數位鍵臺上左邊的叢集中的 INS、DEL、HOME、END、PAGE UP、PAGE DOWN 和方向鍵;和斜線 (/), 然後在數位鍵臺上輸入按鍵。 有些其他鍵盤可能支援*nFlags*中的延伸金鑰位。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onkeyup"></a>  CWnd::OnKeyUp

釋放非系統金鑰時, 架構會呼叫這個成員函式。

```
afx_msg void OnKeyUp(
    UINT nChar,
    UINT nRepCnt,
    UINT nFlags);
```

### <a name="parameters"></a>參數

*nChar*<br/>
指定指定之索引鍵的虛擬按鍵碼。 如需標準虛擬按鍵代碼的清單, 請參閱 Winuser。

*nRepCnt*<br/>
重複計數 (擊鍵因使用者按住鍵而重複的次數)。

*nFlags*<br/>
指定掃描碼、金鑰轉換程式碼、先前的金鑰狀態和內容程式碼, 如下列清單所示:

|值|描述|
|-----------|-----------------|
|0-7|掃描程式碼 (OEM 相依值)。 高序位單字的低位元組。|
|8|擴充索引鍵, 例如數位鍵臺上的函式金鑰或索引鍵 (如果它是擴充索引鍵, 則為 1), 否則為0。|
|9-10|未使用。|
|11-12|由 Windows 在內部使用。|
|13|內容代碼 (如果在按下按鍵時, 會按住 ALT 鍵, 則為 1, 否則為 0)。|
|14|先前的索引鍵狀態 (1, 如果金鑰在呼叫前關閉, 則為 0, 如果索引鍵已啟動)。|
|15|轉換狀態 (如果正在釋放索引鍵, 則為 1, 如果按下按鍵則為 0)。|

若為 WM_KEYUP 訊息, 金鑰轉換位 (位 15) 為 1, 且內容代碼位 (位 13) 為0。

### <a name="remarks"></a>備註

非系統按鍵是鍵盤按鍵, 當未按下 ALT 鍵, 或`CWnd`具有輸入焦點時所按下的鍵盤按鍵時, 就會按下。

針對 IBM 增強的101和102金鑰鍵盤, 增強式金鑰是鍵盤主要區段上的右 ALT 和右 CTRL 鍵;數位鍵臺上左邊的叢集中的 INS、DEL、HOME、END、PAGE UP、PAGE DOWN 和方向鍵;和斜線 (/), 然後在數位鍵臺上輸入按鍵。 有些其他鍵盤可能支援*nFlags*中的延伸金鑰位。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onkillfocus"></a>  CWnd::OnKillFocus

架構會在失去輸入焦點之前立即呼叫此成員函式。

```
afx_msg void OnKillFocus(CWnd* pNewWnd);
```

### <a name="parameters"></a>參數

*pNewWnd*<br/>
指定接收輸入焦點之視窗的指標 (可能是 Null 或可能是暫時性的)。

### <a name="remarks"></a>備註

`CWnd`如果物件正在顯示插入號, 就應該在此時終結插入號。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onlbuttondblclk"></a>  CWnd::OnLButtonDblClk

當使用者按兩下滑鼠左鍵時, 架構會呼叫這個成員函式。

```
afx_msg void OnLButtonDblClk(
    UINT nFlags,
    CPoint point);
```

### <a name="parameters"></a>參數

*nFlags*<br/>
指出各種虛擬機器碼是否已關閉。 這個參數可以是下列值的任意組合:

- 如果 CTRL 鍵已關閉, 則為 MK_CONTROL 設定。

- 如果滑鼠左按鈕已關閉, 則為 MK_LBUTTON 設定。

- 如果中間滑鼠按鍵已關閉, 則為 MK_MBUTTON 設定。

- 如果滑鼠右鍵已關閉, 則為 MK_RBUTTON 設定。

- 如果 SHIFT 鍵已關閉, 則 MK_SHIFT 設定。

*point*<br/>
指定游標的 x 和 y 座標。 這些座標一律相對於視窗的左上角。

### <a name="remarks"></a>備註

只有具有 CS_DBLCLKS [WNDCLASS](/windows/desktop/api/winuser/ns-winuser-tagwndclassa)樣式的 windows 才會收到`OnLButtonDblClk`呼叫。 這是 Microsoft Foundation Class windows 的預設值。 當使用者`OnLButtonDblClk`按下、放開, 然後在系統的按兩下時間限制內再次按下滑鼠左鍵時, Windows 就會呼叫。 按兩下滑鼠左鍵, 實際上會產生四個事件:[WM_LBUTTONDOWN](#onlbuttondown)、 [WM_LBUTTONUP](#onlbuttonup)訊息、WM_LBUTTONDBLCLK 呼叫, 以及釋放按鈕時的另一個 WM_LBUTTONUP 訊息。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onlbuttondown"></a>  CWnd::OnLButtonDown

當使用者按下滑鼠左鍵時, 架構會呼叫這個成員函式。

```
afx_msg void OnLButtonDown(
    UINT nFlags,
    CPoint point);
```

### <a name="parameters"></a>參數

*nFlags*<br/>
指出各種虛擬機器碼是否已關閉。 這個參數可以是下列值的任意組合:

- 如果 CTRL 鍵已關閉, 則為 MK_CONTROL 設定。

- 如果滑鼠左按鈕已關閉, 則為 MK_LBUTTON 設定。

- 如果中間滑鼠按鍵已關閉, 則為 MK_MBUTTON 設定。

- 如果滑鼠右鍵已關閉, 則為 MK_RBUTTON 設定。

- 如果 SHIFT 鍵已關閉, 則 MK_SHIFT 設定。

*point*<br/>
指定游標的 x 和 y 座標。 這些座標一律相對於視窗的左上角。

### <a name="remarks"></a>備註

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onlbuttonup"></a>  CWnd::OnLButtonUp

當使用者放開滑鼠左鍵時, 架構會呼叫這個成員函式。

```
afx_msg void OnLButtonUp(
    UINT nFlags,
    CPoint point);
```

### <a name="parameters"></a>參數

*nFlags*<br/>
指出各種虛擬機器碼是否已關閉。 這個參數可以是下列值的任意組合:

- 如果 CTRL 鍵已關閉, 則為 MK_CONTROL 設定。

- 如果中間滑鼠按鍵已關閉, 則為 MK_MBUTTON 設定。

- 如果滑鼠右鍵已關閉, 則為 MK_RBUTTON 設定。

- 如果 SHIFT 鍵已關閉, 則 MK_SHIFT 設定。

*point*<br/>
指定游標的 x 和 y 座標。 這些座標一律相對於視窗的左上角。

### <a name="remarks"></a>備註

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onmbuttondblclk"></a>  CWnd::OnMButtonDblClk

當使用者按兩下滑鼠中鍵時, 架構會呼叫這個成員函式。

```
afx_msg void OnMButtonDblClk(
    UINT nFlags,
    CPoint point);
```

### <a name="parameters"></a>參數

*nFlags*<br/>
指出各種虛擬機器碼是否已關閉。 這個參數可以是下列值的任意組合:

- 如果 CTRL 鍵已關閉, 則為 MK_CONTROL 設定。

- 如果滑鼠左按鈕已關閉, 則為 MK_LBUTTON 設定。

- 如果中間滑鼠按鍵已關閉, 則為 MK_MBUTTON 設定。

- 如果滑鼠右鍵已關閉, 則為 MK_RBUTTON 設定。

- 如果 SHIFT 鍵已關閉, 則 MK_SHIFT 設定。

*point*<br/>
指定游標的 x 和 y 座標。 這些座標一律相對於視窗的左上角。

### <a name="remarks"></a>備註

只有具有 CS_DBLCLKS [WNDCLASS](/windows/desktop/api/winuser/ns-winuser-tagwndclassa)樣式的 windows 才會收到`OnMButtonDblClk`呼叫。 這是所有 [Microsoft Foundation Class] 視窗的預設值。 當使用者按`OnMButtonDblClk`下、放開, 然後在系統的按兩下時間限制內再次按下滑鼠按鍵時, Windows 就會產生呼叫。 按兩下滑鼠中間按鈕, 實際上會產生四個事件:[WM_MBUTTONDOWN](#onmbuttondown)和[WM_MBUTTONUP](#onmbuttonup)訊息、WM_MBUTTONDBLCLK 呼叫, 以及另一個 WM_MBUTTONUP 訊息。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onmbuttondown"></a>  CWnd::OnMButtonDown

當使用者按下滑鼠中間鍵時, 架構會呼叫這個成員函式。

```
afx_msg void OnMButtonDown(
    UINT nFlags,
    CPoint point);
```

### <a name="parameters"></a>參數

*nFlags*<br/>
指出各種虛擬機器碼是否已關閉。 這個參數可以是下列值的任意組合:

- 如果 CTRL 鍵已關閉, 則為 MK_CONTROL 設定。

- 如果滑鼠左按鈕已關閉, 則為 MK_LBUTTON 設定。

- 如果中間滑鼠按鍵已關閉, 則為 MK_MBUTTON 設定。

- 如果滑鼠右鍵已關閉, 則為 MK_RBUTTON 設定。

- 如果 SHIFT 鍵已關閉, 則 MK_SHIFT 設定。

*point*<br/>
指定游標的 x 和 y 座標。 這些座標一律相對於視窗的左上角。

### <a name="remarks"></a>備註

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onmbuttonup"></a>  CWnd::OnMButtonUp

當使用者放開滑鼠中鍵時, 架構會呼叫這個成員函式。

```
afx_msg void OnMButtonUp(
    UINT nFlags,
    CPoint point);
```

### <a name="parameters"></a>參數

*nFlags*<br/>
指出各種虛擬機器碼是否已關閉。 這個參數可以是下列值的任意組合:

- 如果 CTRL 鍵已關閉, 則為 MK_CONTROL 設定。

- 如果滑鼠左按鈕已關閉, 則為 MK_LBUTTON 設定。

- 如果滑鼠右鍵已關閉, 則為 MK_RBUTTON 設定。

- 如果 SHIFT 鍵已關閉, 則 MK_SHIFT 設定。

*point*<br/>
指定游標的 x 和 y 座標。 這些座標一律相對於視窗的左上角。

### <a name="remarks"></a>備註

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onmdiactivate"></a>  CWnd::OnMDIActivate

架構會針對停用的子視窗呼叫這個成員函式, 並啟用子視窗。

```
afx_msg void OnMDIActivate(
    BOOL bActivate,
    CWnd* pActivateWnd,
    CWnd* pDeactivateWnd);
```

### <a name="parameters"></a>參數

*bActivate*<br/>
如果子系正在啟動, 則為 TRUE, 如果停用, 則為 FALSE。

*pActivateWnd*<br/>
包含要啟用之 MDI 子視窗的指標。 由 MDI 子視窗接收時, *pActivateWnd*會包含要啟動之子視窗的指標。 這個指標可能是暫時性的, 不應該儲存以供稍後使用。

*pDeactivateWnd*<br/>
包含要停用之 MDI 子視窗的指標。 這個指標可能是暫時性的, 不應該儲存以供稍後使用。

### <a name="remarks"></a>備註

MDI 子視窗會在 MDI 框架視窗之外獨立啟用。 當框架變成作用中狀態時, 最後使用`OnMDIActivate`呼叫啟動的子視窗會收到[WM_NCACTI加值稅E](#onncactivate)訊息, 以繪製活動視窗框架和標題列, 但不會收到其他`OnMDIActivate`呼叫。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onmeasureitem"></a>CWnd:: OnMeasureItem

建立控制項時, 此架構會由主控描繪按鈕、下拉式方塊、清單方塊或功能表項目的擁有者, 在架構中呼叫這個成員函式。

```
afx_msg void OnMeasureItem(
    int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct);
```

### <a name="parameters"></a>參數

*nIDCtl*<br/>
控制項的識別碼。

*lpMeasureItemStruct*<br/>
指向包含擁有者繪製控制項之維度的[MEASUREITEMSTRUCT](/windows/desktop/api/winuser/ns-winuser-tagmeasureitemstruct)資料結構。

### <a name="remarks"></a>備註

覆寫這個成員函式, 並`MEASUREITEMSTRUCT`填入*lpMeasureItemStruct*所指向的資料結構並傳回; 這會通知視窗控制項的維度, 並允許 windows 正確地處理使用者與控制項的互動。

如果清單方塊或下拉式方塊是以[LBS_OWNERDRAWVARIABLE](../../mfc/reference/styles-used-by-mfc.md#list-box-styles)或[CBS_OWNERDRAWVARIABLE](../../mfc/reference/styles-used-by-mfc.md#combo-box-styles)樣式建立的, 則架構會針對控制項中的每個專案, 呼叫此函式的擁有者。否則, 會呼叫此函數一次。

在傳送[WM_INITDIALOG](/windows/desktop/dlgbox/wm-initdialog)訊息之前`OnMeasureItem` , Windows 會針對使用 OWNERDRAWFIXED 樣式所建立的下拉式方塊和清單方塊的擁有者, 起始的呼叫。 因此, 當擁有者收到此呼叫時, Windows 尚未決定控制項中所使用字型的高度和寬度;需要這些值的函式呼叫和計算, 應出現在應用程式或程式庫的 main 函式中。

如果要`CMenu`測量的專案是`CListBox`或`CComboBox`物件, 則會呼叫適當`MeasureItem`類別的虛擬函式。 覆寫適當控制項類別的成員函式,以計算和設定每個專案的大小。`MeasureItem`

`OnMeasureItem`只有在執行時間建立控制項的類別, 或使用 LBS_OWNERDRAWVARIABLE 或 CBS_OWNERDRAWVARIABLE 樣式建立時, 才會呼叫。 如果控制項是由對話方塊編輯器所建立, `OnMeasureItem`則不會呼叫。 這是因為[WM_MEASUREITEM](/windows/desktop/Controls/wm-measureitem)訊息會在控制項的建立過程中及早傳送。 如果您使用`DDX_Control`、 `SubclassDlgItem`或`SubclassWindow`來子類別化, 通常會在建立程式之後發生子類別化。 因此, 沒有任何方法可以處理控制項`OnChildNotify`函式中的[WM_MEASUREITEM](/windows/desktop/Controls/wm-measureitem)訊息, 這是 MFC 用來執行 ON_WM_MEASUREITEM_REFLECT 的機制。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onmenuchar"></a>CWnd:: OnMenuChar

當使用者按下不符合目前功能表中任何預先定義助憶鍵的功能表助憶鍵字元時, 架構會呼叫這個成員函式。

```
afx_msg LRESULT OnMenuChar(
    UINT nChar,
    UINT nFlags,
    CMenu* pMenu);
```

### <a name="parameters"></a>參數

*nChar*<br/>
視組建設定而定, 指定使用者所按的 ANSI 或 Unicode 字元。

*nFlags*<br/>
如果功能表是快顯功能表, 則包含 MF_POPUP 旗標。 如果功能表是 [控制項] 功能表, 它就會包含 MF_SYSMENU 旗標。

*pMenu*<br/>
包含所選取`CMenu`的指標。 指標可能是暫時性的, 不應儲存。

### <a name="return-value"></a>傳回值

傳回值的高序位單字應該包含下列其中一個命令碼:

|值|描述|
|-----------|-----------------|
|0|告訴 Windows 捨棄使用者按下的字元, 並在系統喇叭上建立短暫的嗶聲。|
|1|告訴 Windows 關閉目前的功能表。|
|2|通知 Windows, 傳回值的低序位字組包含特定專案的專案編號。 Windows 會選取此專案。|

如果高序位字組包含0或 1, 則會忽略低序位字組。 當快速鍵 (快捷方式) 按鍵用來選取放在功能表中的點陣圖時, 應用程式應該處理此訊息。

### <a name="remarks"></a>備註

它會傳送至擁有`CWnd`功能表的。 `OnMenuChar`當使用者按下 ALT 和任何其他按鍵時也會呼叫, 即使索引鍵並未對應到助憶鍵字元。 在此情況下, *pMenu*會指向所擁有`CWnd`的功能表, 而*nFlags*則是0。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onmenudrag"></a>CWnd:: OnMenuDrag

當使用者開始拖曳功能表項目時, 架構會呼叫目前拖放功能表的這個成員函式。

```
afx_msg UINT OnMenuDrag(
    UINT nPos,
    CMenu* pMenu);
```

### <a name="parameters"></a>參數

|參數|描述|
|---------------|-----------------|
|*nPos*|在當拖曳作業開始時, 功能表項目的索引位置。|
|*pMenu*|在包含功能表項目之[CMenu](../../mfc/reference/cmenu-class.md)物件的指標。|

### <a name="return-value"></a>傳回值

|傳回值|意義|
|------------------|-------------|
|MND_CONTINUE|功能表應該保持作用中狀態。 若已釋放滑鼠, 就應該予以忽略。|
|MND_ENDMENU|功能表應該會結束。|

### <a name="remarks"></a>備註

這個方法會接收[WM_MENUDRAG](/windows/desktop/menurc/wm-menudrag)通知, 如 Windows SDK 中所述。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onmenugetobject"></a>  CWnd::OnMenuGetObject

當滑鼠游標進入功能表項目, 或從專案中央移到專案的頂端或底部時, 此架構會呼叫目前拖放功能表的這個成員函式。

```
afx_msg UINT OnMenuGetObject(MENUGETOBJECTINFO* pMenuGetObjectInfo);
```

### <a name="parameters"></a>參數

|參數|說明|
|---------------|-----------------|
|*pMenu*|在[MENUGETOBJECTINFO](/windows/desktop/api/winuser/ns-winuser-tagmenugetobjectinfo)結構的指標, 其中包含滑鼠游標所在之拖放功能表的相關資訊。|

### <a name="return-value"></a>傳回值

|傳回值|意義|
|------------------|-------------|
|MNGO_NOERROR|支援拖放作業的介面指標會在`pvObj` [MENUGETOBJECTINFO](/windows/desktop/api/winuser/ns-winuser-tagmenugetobjectinfo)結構的成員中傳回。 目前只支援[IDropTarget](/windows/desktop/api/oleidl/nn-oleidl-idroptarget)介面。|
|MNGO_NOINTERFACE|不支援拖放式和拖曳介面。|

### <a name="remarks"></a>備註

這個方法會接收[WM_MENUGETOBJECT](/windows/desktop/menurc/wm-menugetobject)通知, 如 Windows SDK 中所述。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onmenurbuttonup"></a>CWnd:: OnMenuRButtonUp

當游標位於功能表項目上, 而使用者放開滑鼠右鍵時, 此架構會呼叫這個成員函式。

```
afx_msg void OnMenuRButtonUp(
    UINT nPos,
    CMenu* pMenu);
```

### <a name="parameters"></a>參數

|參數|描述|
|---------------|-----------------|
|*nPos*|在放開滑鼠右鍵時, 功能表項目的索引位置。|
|*pMenu*|在包含功能表項目之[CMenu](../../mfc/reference/cmenu-class.md)物件的指標。|

### <a name="remarks"></a>備註

這個方法會接收[WM_MENURBUTTONUP](/windows/desktop/menurc/wm-menurbuttonup)通知, 如 Windows SDK 中所述。 [WM_MENURBUTTONUP](/windows/desktop/menurc/wm-menurbuttonup)訊息可讓應用程式為訊息中指定的功能表項目提供內容相關性功能表。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onmenuselect"></a>CWnd:: OnMenuSelect

如果物件與功能表相關聯, `OnMenuSelect`架構會在使用者選取功能表項目時呼叫。 `CWnd`

```
afx_msg void OnMenuSelect(
    UINT nItemID,
    UINT nFlags,
    HMENU hSysMenu);
```

### <a name="parameters"></a>參數

*nItemID*<br/>
識別選取的專案。 如果選取的專案是功能表項目, *nItemID*會包含功能表項目識別碼。 如果選取的專案包含快顯功能表, 則*nItemID*會包含快顯功能表索引, 而*hSysMenu*則包含主要 (按下) 功能表的控制碼。

*nFlags*<br/>
包含下列功能表旗標的組合:

- MF_BITMAP 專案是點陣圖。

- 已核取 MF_CHECKED 專案。

- 已停用 MF_DISABLED 專案。

- MF_GRAYED 專案呈現暗灰色。

- 已使用滑鼠選取 MF_MOUSESELECT 專案。

- MF_OWNERDRAW 專案是主控描繪專案。

- MF_POPUP 專案包含快顯功能表。

- [MF_SEPARATOR 專案] 是功能表項目分隔符號。

- MF_SYSMENU 專案包含在 [控制] 功能表中。

*hSysMenu*<br/>
如果*nFlags*包含 MF_SYSMENU, 則會識別與訊息相關聯的功能表。 如果*nFlags*包含 MF_POPUP, 則會識別主功能表的控制碼。 如果*nFlags*不包含 MF_SYSMENU 或 MF_POPUP, 則不會使用。

### <a name="remarks"></a>備註

如果*nFlags*包含 0xffff, 而*hSysMenu*包含 0, 則 Windows 已關閉功能表, 因為使用者已按下 ESC 鍵或在功能表外部按一下。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onmouseactivate"></a>  CWnd::OnMouseActivate

當游標位於非作用中視窗, 且使用者按下滑鼠按鍵時, 架構會呼叫這個成員函式。

```
afx_msg int OnMouseActivate(
    CWnd* pDesktopWnd,
    UINT nHitTest,
    UINT message);
```

### <a name="parameters"></a>參數

*pDesktopWnd*<br/>
指定要啟用之視窗最上層父視窗的指標。 指標可能是暫時性的, 不應儲存。

*nHitTest*<br/>
指定[點擊測試區域程式](#onnchittest)代碼。 點擊測試是判斷游標位置的測試。

*message*<br/>
指定滑鼠的訊息編號。

### <a name="return-value"></a>傳回值

指定是否要啟用`CWnd` , 以及是否要捨棄滑鼠事件。 它必須是下列其中一個值:

- MA_ACTI加值稅E 啟用`CWnd`物件。

- MA_NOACTI加值稅E 不啟動`CWnd`物件。

- MA_ACTI加值稅EANDEAT 啟用`CWnd`物件 並捨棄滑鼠事件。

- MA_NOACTI加值稅EANDEAT 不要啟動`CWnd`物件並捨棄滑鼠事件。

### <a name="remarks"></a>備註

預設的執行會先將此訊息傳遞至父視窗, 然後再進行任何處理。 如果父視窗傳回 TRUE, 處理就會停止。

如需個別點擊測試區域程式碼的說明, 請參閱[OnNcHitTest](#onnchittest)成員函式

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCAxCtl#9](../../mfc/reference/codesnippet/cpp/cwnd-class_49.cpp)]

##  <a name="onmousehover"></a>  CWnd::OnMouseHover

當游標停留在先前呼叫中指定的時間週期 視窗的工作區時，架構會呼叫此成員函式[TrackMouseEvent](/windows/desktop/api/winuser/nf-winuser-trackmouseevent)。

```
afx_msg void OnMouseHover(
    UINT nFlags,
    CPoint point);
```

### <a name="parameters"></a>參數

|參數|描述|
|---------------|-----------------|
|*nFlags*|在旗標的位元組合 (OR), 指出所按的輔助按鍵。 例如, MK_CONTROL 旗標表示已按下 CTRL 鍵。|
|*point*|在[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)物件, 指定相對於工作區左上角之游標的*x*和*y*座標。|

### <a name="remarks"></a>備註

這個方法會接收[WM_MOUSEHOVER](/windows/desktop/inputdev/wm-mousehover)通知, 如 Windows SDK 中所述。

*NFlags*參數可以是下表所列輔助按鍵的組合。 如需詳細資訊, 請參閱[關於滑鼠輸入](/windows/desktop/inputdev/about-mouse-input)。

|輔助按鍵|描述|
|------------------|-----------------|
|MK_CONTROL|CTRL 鍵已按下。|
|MK_LBUTTON|滑鼠左鍵已按下。|
|MK_MBUTTON|按下滑鼠鍵。|
|MK_RBUTTON|滑鼠右鍵已按下。|
|MK_SHIFT|SHIFT 鍵已按下。|
|MK_XBUTTON1|Microsoft 智慧按鈕的 [XBUTTON1 滑鼠] 按鈕已按下。|
|MK_XBUTTON2|Microsoft 智慧按鈕的 [XBUTTON2 滑鼠] 按鈕已按下。|

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onmousehwheel"></a>  CWnd::OnMouseHWheel

當目前的視窗由桌面視窗管理員 (DWM) 組成, 而且該視窗最大化時, 架構會呼叫這個成員。

```
afx_msg void OnMouseHWheel(
    UINT nFlags,
    short zDelta,
    CPoint pt);
```

### <a name="parameters"></a>參數

|參數|說明|
|---------------|-----------------|
|*nFlags*|在旗標的位元組合 (OR), 指出所按的輔助按鍵。 例如, MK_CONTROL 旗標表示已按下 CTRL 鍵。<br /><br /> 如需旗標的清單, 請參閱[關於滑鼠輸入](/windows/desktop/inputdev/about-mouse-input)中的「訊息參數」子標題。|
|*zDelta*|在表示滾輪旋轉的距離, 以 WHEEL_DELTA 的倍數或除法表示, 也就是120。 正數值表示滾輪已旋轉至右側;負數值表示滾輪已旋轉至左邊。|
|*pt*|在[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)物件, 指定相對於工作區左上角之游標的*x*和*y*座標。|

### <a name="remarks"></a>備註

這個方法會接收[WM_MOUSEHWHEEL](/windows/desktop/inputdev/wm-mousehwheel)通知訊息, 如 Windows SDK 中所述。 當滑鼠的水準滾輪為傾斜或旋轉時, 此訊息會傳送至具有焦點的視窗。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onmouseleave"></a>  CWnd::OnMouseLeave

當游標離開先前呼叫[TrackMouseEvent](/windows/desktop/api/winuser/nf-winuser-trackmouseevent)中指定之視窗的工作區時, 架構會呼叫這個成員函式。

```
afx_msg void OnMouseLeave();
```

### <a name="remarks"></a>備註

這個方法會接收[WM_MOUSELEAVE](/windows/desktop/inputdev/wm-mouseleave)通知, 如 Windows SDK 中所述。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onmousemove"></a>  CWnd::OnMouseMove

當滑鼠游標移動時, 架構會呼叫這個成員函式。

```
afx_msg void OnMouseMove(
    UINT nFlags,
    CPoint point);
```

### <a name="parameters"></a>參數

*nFlags*<br/>
指出各種虛擬機器碼是否已關閉。 這個參數可以是下列值的任意組合:

- 如果 CTRL 鍵已關閉, 則為 MK_CONTROL 設定。

- 如果滑鼠左按鈕已關閉, 則為 MK_LBUTTON 設定。

- 如果中間滑鼠按鍵已關閉, 則為 MK_MBUTTON 設定。

- 如果滑鼠右鍵已關閉, 則為 MK_RBUTTON 設定。

- 如果 SHIFT 鍵已關閉, 則 MK_SHIFT 設定。

*point*<br/>
指定游標的 x 和 y 座標。 這些座標一律相對於視窗的左上角。

### <a name="remarks"></a>備註

如果未捕捉到滑鼠, `CWnd`物件會在滑鼠游標下收到 WM_MOUSEMOVE 訊息; 否則, 訊息會移至已捕獲滑鼠的視窗。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onmousewheel"></a>CWnd:: OnMouseWheel

當使用者旋轉滑鼠滾輪並遇到滾輪的下一個凹槽時, 架構會呼叫這個成員函式。

```
afx_msg BOOL OnMouseWheel(
    UINT nFlags,
    short zDelta,
    CPoint pt);
```

### <a name="parameters"></a>參數

*nFlags*<br/>
指出各種虛擬機器碼是否已關閉。 這個參數可以是下列值的任意組合:

- 如果 CTRL 鍵已關閉, 則為 MK_CONTROL 設定。

- 如果滑鼠左按鈕已關閉, 則為 MK_LBUTTON 設定。

- 如果中間滑鼠按鍵已關閉, 則為 MK_MBUTTON 設定。

- 如果滑鼠右鍵已關閉, 則為 MK_RBUTTON 設定。

- 如果 SHIFT 鍵已關閉, 則 MK_SHIFT 設定。

*zDelta*<br/>
表示旋轉的距離。 *ZDelta*值會以 WHEEL_DELTA 的倍數或除法表示, 也就是120。 小於零的值表示旋轉 (朝向使用者), 而大於零的值表示向前復原 (遠離使用者)。 使用者可以藉由變更滑鼠軟體中的滾輪設定來反轉此回應。 如需此參數的詳細資訊, 請參閱備註。

*pt*<br/>
指定游標的 x 和 y 座標。 這些座標一律相對於螢幕的左上角。

### <a name="return-value"></a>傳回值

如果已啟用滑鼠滾輪滾動, 則為非零;否則為0。

### <a name="remarks"></a>備註

除非予以覆`OnMouseWheel`寫, 否則會呼叫[WM_MOUSEWHEEL](/windows/desktop/inputdev/wm-mousewheel)的預設值。 Windows 會自動將訊息路由至具有焦點的控制項或子視窗。 Win32 函式[DefWindowProc](/windows/desktop/api/winuser/nf-winuser-defwindowproca)會將訊息向上傳播到處理它的視窗。

*ZDelta*參數是 WHEEL_DELTA 的倍數, 其設定為120。 此值是要採取之動作的閾值, 而每個差異都應該執行一個這類動作 (例如, 向前滾動一個凹槽)。

WHEEL_DELTA 已設為 120, 以允許更精細的解析度滾輪, 例如無凹槽的自由旋轉滾輪。 更精細的解析度滾輪會針對每個旋轉傳送更多訊息, 但每個訊息的差異值較小。 若要使用這種滾輪, 請新增傳入的*zDelta*值, 直到到達 WHEEL_DELTA 為止 (如此一來, 您就可以取得相同的差異旋轉的相同回應), 或滾動部分行以回應較頻繁的訊息。 您也可以選擇捲軸資料細微性, 並累積差異直到到達 WHEEL_DELTA 為止。

覆寫這個成員函式, 以提供您自己的滑鼠滾輪滾動行為。

> [!NOTE]
> `OnMouseWheel`處理 Windows NT 4.0 和更新版本的訊息。 對於 Windows 95/98 或 Windows NT 3.51 訊息處理, 請使用[OnRegisteredMouseWheel](#onregisteredmousewheel)。

##  <a name="onmove"></a>  CWnd::OnMove

架構會在移動`CWnd`物件之後呼叫這個成員函式。

```
afx_msg void OnMove(
    int x,
    int y);
```

### <a name="parameters"></a>參數

*x*<br/>
指定工作區左上角的新 x 座標位置。 這個新位置會以螢幕座標提供, 用於重迭和快顯視窗, 以及子視窗的父用戶端座標。

*y*<br/>
指定工作區左上角的新 y 座標位置。 這個新位置會以螢幕座標提供, 用於重迭和快顯視窗, 以及子視窗的父用戶端座標。

### <a name="remarks"></a>備註

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onmoving"></a>CWnd:: OnMoving

當使用者移動`CWnd`物件時, 架構會呼叫這個成員函式。

```
afx_msg void OnMoving(
    UINT nSide,
    LPRECT lpRect);
```

### <a name="parameters"></a>參數

*nSide*<br/>
要移動的視窗邊緣。

*lpRect*<br/>
將包含專案座標的[CRect](../../atl-mfc-shared/reference/crect-class.md)或[RECT 結構](/windows/desktop/api/windef/ns-windef-tagrect)的位址。

### <a name="remarks"></a>備註

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onncactivate"></a>  CWnd::OnNcActivate

當非工作區需要變更以指出作用中或非作用中狀態時, 架構會呼叫這個成員函式。

```
afx_msg BOOL OnNcActivate(BOOL bActive);
```

### <a name="parameters"></a>參數

*bActive*<br/>
指定何時需要變更標題列或圖示, 以指出作用中或非作用中的狀態。 如果要繪製現用標題或圖示, *bActive*參數為 TRUE。 若為非使用中的標題或圖示, 則為 FALSE。

### <a name="return-value"></a>傳回值

如果 Windows 應該繼續進行預設處理, 則為非零值;0以防止標題列或圖示停用。

### <a name="remarks"></a>備註

如果*bActive*為 TRUE, 則預設的執行會以其現用色彩繪製標題列和標題列文字, 如果*bActive*為 FALSE, 則以非使用中的色彩表示。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onnccalcsize"></a>  CWnd::OnNcCalcSize

當需要計算工作區的大小和位置時, 架構會呼叫這個成員函式。

```
afx_msg void OnNcCalcSize(
    BOOL bCalcValidRects,
    NCCALCSIZE_PARAMS* lpncsp);
```

### <a name="parameters"></a>參數

*bCalcValidRects*<br/>
指定應用程式是否應指定工作區的哪個部分包含有效的資訊。 Windows 會將有效的資訊複製到新工作區中的指定區域。 如果此參數為 TRUE, 則應用程式應該指定工作區的哪個部分是有效的。

*lpncsp*<br/>
指向[NCCALCSIZE_PARAMS](/windows/desktop/api/winuser/ns-winuser-tagnccalcsize_params)資料結構, 其中包含應用程式可用來計算`CWnd`矩形新大小和位置的資訊 (包括工作區、框線、標題、捲軸等等)。

### <a name="remarks"></a>備註

藉由處理此訊息, 應用程式可以在視窗的大小或位置變更時, 控制視窗工作區的內容。

不論*bCalcValidRects*的值為何, `rgrc` `NCCALCSIZE_PARAMS`結構的結構成員所指定之陣列中的第一個矩形都會包含視窗的座標。 若為子視窗, 座標會相對於父視窗的工作區。 若為最上層視窗, 座標為螢幕座標。 應用程式應該修改`rgrc[0]`矩形以反映工作區的大小和位置。

只有在`rgrc[2]` *bCalcValidRects*為 TRUE 時,和矩形才有效。`rgrc[1]` 在此情況下, `rgrc[1]`矩形在移動或調整大小之前, 會包含視窗的座標。 `rgrc[2]`矩形包含視窗在移動之前的工作區座標。 所有座標都是相對於父視窗或螢幕。

預設的執行會根據視窗特性 (捲軸、功能表等) 來計算工作區的大小, 並將結果放在*lpncsp*中。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onnccreate"></a>  CWnd::OnNcCreate

架構會在第一次建立`CWnd`物件時, 于[WM_CREATE](#oncreate)訊息之前呼叫這個成員函式。

```
afx_msg BOOL OnNcCreate(LPCREATESTRUCT lpCreateStruct);
```

### <a name="parameters"></a>參數

*lpCreateStruct*<br/>
指向的[CREATESTRUCT](/windows/desktop/api/winuser/ns-winuser-tagcreatestructa)資料結構`CWnd`。

### <a name="return-value"></a>傳回值

如果建立非工作區, 則為非零值。 如果發生錯誤, 則為 0;在`Create`此情況下, 函數會傳回**失敗**。

### <a name="remarks"></a>備註

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onncdestroy"></a>  CWnd::OnNcDestroy

當非工作區被終結時, 由架構呼叫, 而則是在終結 Windows 視窗時呼叫的最後一個成員函式。

```
afx_msg void OnNcDestroy();
```

### <a name="remarks"></a>備註

預設的實作用會執行一些清除, 然後呼叫虛擬成員函式[PostNcDestroy](#postncdestroy)。

如果`PostNcDestroy`您想要執行自己的清除作業, 例如**刪除此**作業, 請覆寫。 如果您覆`OnNcDestroy`寫, 就必須`OnNcDestroy`在基類中呼叫, 以確保會釋出內部配置給視窗的任何記憶體。

##  <a name="onnchittest"></a>  CWnd::OnNcHitTest

架構會在每次移動滑鼠時`CWnd` , 針對包含游標 ( `CWnd`或使用[SetCapture](#setcapture)成員函式來捕捉滑鼠輸入的物件) 的物件呼叫這個成員函式。

```
afx_msg LRESULT OnNcHitTest(CPoint point);
```

### <a name="parameters"></a>參數

*point*<br/>
包含游標的 x 和 y 座標。 這些座標一律為螢幕座標。

### <a name="return-value"></a>傳回值

其中一個滑鼠點擊測試列舉值。 如需值清單, 請參閱[WM_NCHITTEST](/windows/desktop/inputdev/wm-nchittest) 。

### <a name="remarks"></a>備註

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onnclbuttondblclk"></a>  CWnd::OnNcLButtonDblClk

當使用者按兩下滑鼠左鍵, 而游標位於非工作區`CWnd`中時, 架構會呼叫這個成員函式。

```
afx_msg void OnNcLButtonDblClk(
    UINT nHitTest,
    CPoint point);
```

### <a name="parameters"></a>參數

*nHitTest*<br/>
指定[點擊測試程式碼](#onnchittest)。 點擊測試是判斷游標位置的測試。 如需值清單, 請參閱[WM_NCHITTEST](/windows/desktop/inputdev/wm-nchittest) 。

*point*<br/>
`CPoint`指定物件, 其中包含游標位置的 x 和 y 螢幕座標。 這些座標一律相對於螢幕的左上角。

### <a name="remarks"></a>備註

如果適用, 則會傳送[WM_SYSCOMMAND](#onsyscommand)訊息。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onnclbuttondown"></a>  CWnd::OnNcLButtonDown

當使用者按下滑鼠左鍵, 而游標位於`CWnd`物件的非工作區域內時, 架構會呼叫這個成員函式。

```
afx_msg void OnNcLButtonDown(
    UINT nHitTest,
    CPoint point);
```

### <a name="parameters"></a>參數

*nHitTest*<br/>
指定[點擊測試程式碼](#onnchittest)。 點擊測試是判斷游標位置的測試。 如需值清單, 請參閱[WM_NCHITTEST](/windows/desktop/inputdev/wm-nchittest) 。

*point*<br/>
`CPoint`指定物件, 其中包含游標位置的 x 和 y 螢幕座標。 這些座標一律相對於螢幕的左上角。

### <a name="remarks"></a>備註

如果適用, 則會傳送[WM_SYSCOMMAND](#onsyscommand) 。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞給函式的參數會反映架構在收到訊息時所收到的參數。如果您呼叫此函式的基類執行, 該執行將會使用原本與訊息一起傳遞的參數, 而不是您提供給函式的參數。

##  <a name="onnclbuttonup"></a>  CWnd::OnNcLButtonUp

當使用者放開滑鼠左鍵, 而游標位於非工作區時, 架構會呼叫這個成員函式。

```
afx_msg void OnNcLButtonUp(
    UINT nHitTest,
    CPoint point);
```

### <a name="parameters"></a>參數

*nHitTest*<br/>
指定[點擊測試程式碼](#onnchittest)。 點擊測試是判斷游標位置的測試。 如需值清單, 請參閱[WM_NCHITTEST](/windows/desktop/inputdev/wm-nchittest) 。

*point*<br/>
`CPoint`指定物件, 其中包含游標位置的 x 和 y 螢幕座標。 這些座標一律相對於螢幕的左上角。

### <a name="remarks"></a>備註

如果適用, 則會傳送[WM_SYSCOMMAND](#onsyscommand) 。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onncmbuttondblclk"></a>  CWnd::OnNcMButtonDblClk

當使用者按兩下滑鼠中鍵, 而游標位於非工作區時, 架構會呼叫這個成員函式。

```
afx_msg void OnNcMButtonDblClk(
    UINT nHitTest,
    CPoint point);
```

### <a name="parameters"></a>參數

*nHitTest*<br/>
指定[點擊測試程式碼](#onnchittest)。 點擊測試是判斷游標位置的測試。

*point*<br/>
`CPoint`指定物件, 其中包含游標位置的 x 和 y 螢幕座標。 這些座標一律相對於螢幕的左上角。

### <a name="remarks"></a>備註

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onncmbuttondown"></a>  CWnd::OnNcMButtonDown

當使用者按下滑鼠中鍵, 而游標位於非工作區時, 架構會呼叫這個成員函式。

```
afx_msg void OnNcMButtonDown(
    UINT nHitTest,
    CPoint point);
```

### <a name="parameters"></a>參數

*nHitTest*<br/>
指定[點擊測試程式碼](#onnchittest)。 點擊測試是判斷游標位置的測試。

*point*<br/>
`CPoint`指定物件, 其中包含游標位置的 x 和 y 螢幕座標。 這些座標一律相對於螢幕的左上角。

### <a name="remarks"></a>備註

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onncmbuttonup"></a>  CWnd::OnNcMButtonUp

當使用者放開滑鼠中鍵, 而游標位於非工作區時, 架構會呼叫這個成員函式。

```
afx_msg void OnNcMButtonUp(
    UINT nHitTest,
    CPoint point);
```

### <a name="parameters"></a>參數

*nHitTest*<br/>
指定[點擊測試程式碼](#onnchittest)。 點擊測試是判斷游標位置的測試。

*point*<br/>
`CPoint`指定物件, 其中包含游標位置的 x 和 y 螢幕座標。 這些座標一律相對於螢幕的左上角。

### <a name="remarks"></a>備註

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onncmousehover"></a>  CWnd::OnNcMouseHover

當游標停留在先前呼叫中指定的時間週期 視窗中非工作區時，架構會呼叫此成員函式[TrackMouseEvent](/windows/desktop/api/winuser/nf-winuser-trackmouseevent)。

```
afx_msg void OnNcMouseHover(
    UINT nHitTest,
    CPoint point);
```

### <a name="parameters"></a>參數

|參數|描述|
|---------------|-----------------|
|*nHitTest*|在[CWnd::D efwindowproc](#defwindowproc)函數所傳回的點擊測試值, 是處理[WM_NCHITTEST](/windows/desktop/inputdev/wm-nchittest)訊息的結果。|
|*point*|在[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)物件, 指定相對於螢幕左上角之游標的*x*和*y*座標。|

### <a name="remarks"></a>備註

這個方法會接收[WM_NCMOUSEHOVER](/windows/desktop/inputdev/wm-ncmousehover)通知, 如 Windows SDK 中所述。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onncmouseleave"></a>  CWnd::OnNcMouseLeave

當游標離開先前呼叫[TrackMouseEvent](/windows/desktop/api/winuser/nf-winuser-trackmouseevent)中指定之視窗的非工作區時, 架構會呼叫這個成員函式。

```
afx_msg void OnNcMouseLeave();
```

### <a name="remarks"></a>備註

這個方法會接收[WM_NCMOUSELEAVE](/windows/desktop/inputdev/wm-ncmouseleave)通知, 如 Windows SDK 中所述。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onncmousemove"></a>  CWnd::OnNcMouseMove

當資料指標在非工作區中移動時, 架構會呼叫這個成員函式。

```
afx_msg void OnNcMouseMove(
    UINT nHitTest,
    CPoint point);
```

### <a name="parameters"></a>參數

*nHitTest*<br/>
指定[點擊測試程式碼](#onnchittest)。 點擊測試是判斷游標位置的測試。

*point*<br/>
`CPoint`指定物件, 其中包含游標位置的 x 和 y 螢幕座標。 這些座標一律相對於螢幕的左上角。

### <a name="remarks"></a>備註

如果適用, 則會傳送[WM_SYSCOMMAND](#onsyscommand)訊息。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onncpaint"></a>  CWnd::OnNcPaint

當需要繪製非工作區時, 架構會呼叫這個成員函式。

```
afx_msg void OnNcPaint();
```

### <a name="remarks"></a>備註

預設的執行會繪製視窗框架。

應用程式可以覆寫這個呼叫, 並繪製它自己的自訂視窗框架。 裁剪區域一律是矩形, 即使框架的形狀已改變也一樣。

##  <a name="onncrbuttondblclk"></a>  CWnd::OnNcRButtonDblClk

當使用者按兩下滑鼠右鍵, 而游標位於非工作區`CWnd`中時, 架構會呼叫這個成員函式。

```
afx_msg void OnNcRButtonDblClk(
    UINT nHitTest,
    CPoint point);
```

### <a name="parameters"></a>參數

*nHitTest*<br/>
指定[點擊測試程式碼](#onnchittest)。 點擊測試是判斷游標位置的測試。

*point*<br/>
`CPoint`指定物件, 其中包含游標位置的 x 和 y 螢幕座標。 這些座標一律相對於螢幕的左上角。

### <a name="remarks"></a>備註

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onncrbuttondown"></a>  CWnd::OnNcRButtonDown

當使用者按下滑鼠右鍵, 而游標位於非工作區時, 架構會呼叫這個成員函式。

```
afx_msg void OnNcRButtonDown(
    UINT nHitTest,
    CPoint point);
```

### <a name="parameters"></a>參數

*nHitTest*<br/>
指定[點擊測試程式碼](#onnchittest)。 點擊測試是判斷游標位置的測試。

*point*<br/>
`CPoint`指定物件, 其中包含游標位置的 x 和 y 螢幕座標。 這些座標一律相對於螢幕的左上角。

### <a name="remarks"></a>備註

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onncrbuttonup"></a>  CWnd::OnNcRButtonUp

當使用者放開滑鼠右鍵時, 架構會呼叫這個成員函式, 而游標位於非工作區中。

```
afx_msg void OnNcRButtonUp(
    UINT nHitTest,
    CPoint point);
```

### <a name="parameters"></a>參數

*nHitTest*<br/>
指定[點擊測試程式碼](#onnchittest)。 點擊測試是判斷游標位置的測試。

*point*<br/>
`CPoint`指定物件, 其中包含游標位置的 x 和 y 螢幕座標。 這些座標一律相對於螢幕的左上角。

### <a name="remarks"></a>備註

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onncrenderingchanged"></a>  CWnd::OnNcRenderingChanged

當非工作區的轉譯原則變更時, 架構會呼叫這個成員。

```
afx_msg void OnNcRenderingChanged(BOOL bIsRendering);
```

### <a name="parameters"></a>參數

|參數|說明|
|---------------|-----------------|
|*bIsRendering*|在如果已針對視窗的非工作區啟用桌面視窗管理員 (DWM) 轉譯, 則為 TRUE;如果已停用轉譯, 則為 FALSE。|

### <a name="remarks"></a>備註

這個方法會接收[WM_DWMNCRENDERINGCHANGED](/windows/desktop/dwm/wm-dwmncrenderingchanged)通知, 如 Windows SDK 中所述。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onncxbuttondblclk"></a>  CWnd::OnNcXButtonDblClk

當使用者按兩下 XBUTTON1 或 XBUTTON2, 而游標位於視窗的非工作區時, 架構會呼叫這個成員函式。

```
void OnNcXButtonDblClk(
    short nHitTest,
    UINT nButton,
    CPoint point);
```

### <a name="parameters"></a>參數

|參數|描述|
|---------------|-----------------|
|*nHitTest*|在[CWnd::D efwindowproc](#defwindowproc)函數所傳回的點擊測試值, 是處理[WM_NCHITTEST](/windows/desktop/inputdev/wm-nchittest)訊息的結果。|
|*nButton*|在如果按兩下第一個 Microsoft 的 [全選] X 按鈕, 則為 XBUTTON1 的值, 如果按兩下第二個 X 按鈕, 則為 XBUTTON2。|
|*point*|在[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)物件, 指定相對於工作區左上角之游標的*x*和*y*座標。|

### <a name="remarks"></a>備註

這個方法會接收[WM_XBUTTONDBLCLK](/windows/desktop/inputdev/wm-xbuttondblclk)通知, 如 Windows SDK 中所述。 這則訊息會張貼至包含資料指標的視窗中。 如果視窗已捕捉滑鼠, 則不會張貼此訊息。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onncxbuttondown"></a>  CWnd::OnNcXButtonDown

當使用者按下滑鼠的 XBUTTON1 或 XBUTTON2, 而游標位於視窗的非工作區時, 架構會呼叫這個成員函式。

```
afx_msg void OnNcXButtonDown(
    short nHitTest,
    UINT nButton,
    CPoint point);
```

### <a name="parameters"></a>參數

|參數|描述|
|---------------|-----------------|
|*nHitTest*|在[CWnd::D efwindowproc](#defwindowproc)函數所傳回的點擊測試值, 是處理[WM_NCHITTEST](/windows/desktop/inputdev/wm-nchittest)訊息的結果。|
|*nButton*|在如果按下第一個滑鼠 X 按鈕, 則為 XBUTTON1 的值, 如果按下第二個 X 按鈕, 則為 XBUTTON2。|
|*point*|在[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)物件, 指定相對於螢幕左上角之游標的*x*和*y*座標。|

### <a name="remarks"></a>備註

這個方法會接收[WM_NCXBUTTONDOWN](/windows/desktop/inputdev/wm-ncxbuttondown)通知, 如 Windows SDK 中所述。 這則訊息會張貼至包含資料指標的視窗中。 如果視窗已捕捉滑鼠, 則不會張貼此訊息。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onncxbuttonup"></a>  CWnd::OnNcXButtonUp

當使用者放開滑鼠的 XBUTTON1 或 XBUTTON2, 而游標位於視窗的非工作區時, 架構會呼叫這個成員函式。

```
afx_msg void OnNcXButtonUp(
    short nHitTest,
    UINT nButton,
    CPoint point);
```

### <a name="parameters"></a>參數

|參數|說明|
|---------------|-----------------|
|*nHitTest*|在[CWnd::D efwindowproc](#defwindowproc)函數所傳回的點擊測試值, 是處理[WM_NCHITTEST](/windows/desktop/inputdev/wm-nchittest)訊息的結果。|
|*nButton*|在若已釋放第一個滑鼠 X 按鈕, 則為 XBUTTON1 的值, 如果已釋放第二個 X 按鈕, 則為 XBUTTON2。|
|*point*|在[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)物件, 指定相對於螢幕左上角之游標的*x*和*y*座標。|

### <a name="remarks"></a>備註

這個方法會接收[WM_NCXBUTTONUP](/windows/desktop/inputdev/wm-ncxbuttonup)通知, 如 Windows SDK 中所述。 這則訊息會張貼至包含資料指標的視窗中。 如果視窗已捕捉滑鼠, 則不會張貼此訊息。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onnextmenu"></a>  CWnd::OnNextMenu

當使用向右鍵或向左鍵切換功能表列和系統功能表時, 架構會呼叫這個成員函式。

```
afx_msg void OnNextMenu(
    UINT nKey,
    LPMDINEXTMENU lpMdiNextMenu);
```

### <a name="parameters"></a>參數

|參數|說明|
|---------------|-----------------|
|*nKey*|在旗標的位元組合 (OR), 指出所按的輔助按鍵。 例如, MK_CONTROL 旗標表示已按下 CTRL 鍵。<br /><br /> 如需旗標的清單, 請參閱[關於滑鼠輸入](/windows/desktop/inputdev/about-mouse-input)中的「訊息參數」子標題。|
|*lpMdiNextMenu*|在[MDINEXTMENU](/windows/desktop/api/winuser/ns-winuser-tagmdinextmenu)結構的指標, 其中包含要啟用之功能表的相關資訊。|

### <a name="remarks"></a>備註

這個方法會接收[WM_UNINITMENUPOPUP](/windows/desktop/menurc/wm-uninitmenupopup)通知, 如 Windows SDK 中所述。 回應此訊息時, 您的應用程式可以設定`hmenuNext` [MDINEXTMENU](/windows/desktop/api/winuser/ns-winuser-tagmdinextmenu)結構的成員, 以指定要切換的功能表, 以及`hwndNext`指定要接收功能表通知訊息之視窗的成員。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onnotify"></a>  CWnd::OnNotify

此架構會呼叫這個成員函式, 以通知控制項的父視窗, 表示控制項中發生事件, 或控制項需要某種類型的資訊。

```
virtual BOOL OnNotify(
    WPARAM wParam,
    LPARAM lParam,
    LRESULT* pResult);
```

### <a name="parameters"></a>參數

*wParam*<br/>
識別當訊息來自控制項時, 傳送訊息的控制項。 否則, *wParam*為0。

*lParam*<br/>
通知訊息 (`NMHDR`) 結構的指標, 其中包含通知碼和其他資訊。 對於某些通知訊息, 此參數會`NMHDR`指向結構為其第一個成員的較大結構。

*pResult*<br/>
要在處理訊息時儲存結果碼的 LRESULT 變數指標。

### <a name="return-value"></a>傳回值

如果應用程式處理此訊息, 則會傳回非零值;否則為0。

### <a name="remarks"></a>備註

`OnNotify`處理訊息對應以取得控制項通知。

覆寫衍生類別中的這個成員函式, 以處理 WM_NOTIFY 訊息。 除非呼叫基類`OnNotify` , 否則覆寫將不會處理訊息對應。

如需 WM_NOTIFY 訊息的詳細資訊, 請參閱技術提示 61 (TN061)、 [ON_NOTIFY 和 WM_NOTIFY 訊息](../../mfc/tn061-on-notify-and-wm-notify-messages.md)。 您可能也會對[控制項主題](../../mfc/controls-mfc.md)和 TN062、 [Windows 控制項的訊息反映](../../mfc/tn062-message-reflection-for-windows-controls.md)中所述的相關主題感興趣。

##  <a name="onnotifyformat"></a>  CWnd::OnNotifyFormat

架構會呼叫這個成員函式, 以判斷目前的視窗是否接受 WM_NOTIFY 通知訊息中的 ANSI 或 Unicode 結構。

```
afx_msg UINT OnNotifyFormat(
    CWnd* pWnd,
    UINT nCommand);
```

### <a name="parameters"></a>參數

|參數|描述|
|---------------|-----------------|
|*pWnd*|在`CWnd`物件的指標, 表示傳送[WM_NOTIFY](/windows/desktop/controls/wm-notify)訊息的視窗。<br /><br /> 如果*nCommand*參數是 NF_QUERY, 則此參數是控制項的指標, 如果*nCommand*為 NF_REQUERY, 則為控制項父視窗的指標。|
|*nCommand*|在專門用來 WM_NOTIFY 訊息的命令值。 可能值為：<br /><br /> - NF_QUERY -<br />     此訊息是用來判斷是否應該在 WM_NOTIFY 訊息中使用 ANSI 或 Unicode 結構的查詢。 這則訊息會在建立控制項時, 從控制項傳送至其父視窗, 並回應此訊息的 NF_REQUERY 表單。<br />- NF_REQUERY -<br />     訊息是控制項的要求, 可將此訊息的 NF_QUERY 表單傳送至其父視窗。 此要求會從父視窗傳送, 並要求控制項重新查詢父項, 以在 WM_NOTIFY 訊息中使用的結構類型。 如果*nCommand*參數是 NF_REQUERY, 則傳回值會是重新查詢作業的結果。|

### <a name="return-value"></a>傳回值

|傳回值|意義|
|------------------|-------------|
|NFR_ANSI|ANSI 結構應該用於 WM_NOTIFY 控制項所傳送的訊息。|
|NFR_UNICODE|Unicode 結構應該用於 WM_NOTIFY 控制項所傳送的訊息。|
|0|發生錯誤。|

### <a name="remarks"></a>備註

這個方法會接收[WM_NOTIFYFORMAT](/windows/desktop/Controls/wm-notifyformat)通知, 如 Windows SDK 中所述。 WM_NOTIFY 訊息會從通用控制項傳送至其父視窗, 並從父視窗傳送到通用控制項。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onpaint"></a>  CWnd::OnPaint

當 Windows 或應用程式要求重新繪製應用程式視窗的某個部分時, 架構會呼叫這個成員函式。

```
afx_msg void OnPaint();
```

### <a name="remarks"></a>備註

呼叫[UpdateWindow](#updatewindow)或[RedrawWindow](#redrawwindow)成員函式時, 會傳送[WM_PAINT](/windows/desktop/gdi/the-wm-paint-message)訊息。

視窗可能會因呼叫`RedrawWindow`具有 RDW_INTERNALPAINT 旗標的成員函式而收到內部繪製訊息。 在此情況下, 視窗可能不會有更新區域。 應用程式應該呼叫[GetUpdateRect](#getupdaterect)成員函式, 以判斷視窗是否具有更新區域。 如果`GetUpdateRect`傳回 0, 則應用程式不應呼叫[BeginPaint](#beginpaint)和[EndPaint](#endpaint)成員函式。

藉由查看每個 WM_PAINT 訊息的內部資料結構, 讓應用程式負責檢查是否有任何必要的內部重新繪製或更新, 因為 WM_PAINT 訊息可能是由不正確區域和呼叫所`RedrawWindow`造成已設定 RDW_INTERNALPAINT 旗標的成員函式。

內部 WM_PAINT 訊息只會由 Windows 傳送一次。 由`UpdateWindow`成員函式將內部 WM_PAINT 訊息傳送至視窗之後, 將不會再傳送或張貼任何進一步的 WM_PAINT 訊息, 直到視窗失效或`RedrawWindow`再次呼叫成員函式與 RDW_INTERNALPAINT旗標設定。

如需在檔/視圖應用程式中呈現影像的相關資訊, 請參閱[CView:: OnDraw](../../mfc/reference/cview-class.md#ondraw)。

如需有關使用`WM_Paint`的詳細資訊, 請參閱 Windows SDK 中的下列主題:

- [WM_PAINT 訊息](/windows/desktop/gdi/the-wm-paint-message)

- [使用 WM_PAINT 訊息](/windows/desktop/gdi/using-the-wm-paint-message)

##  <a name="onpaintclipboard"></a>  CWnd::OnPaintClipboard

當剪貼簿擁有`OnPaintClipboard`者以 CF_OWNERDISPLAY 格式將資料放在剪貼簿上, 而剪貼簿檢視器的工作區需要重新繪製時, 剪貼簿的成員函式會由剪貼簿檢視器呼叫。

```
afx_msg void OnPaintClipboard(
    CWnd* pClipAppWnd,
    HGLOBAL hPaintStruct);
```

### <a name="parameters"></a>參數

*pClipAppWnd*<br/>
指定 [剪貼簿] 應用程式視窗的指標。 該指標可能是暫時性的，因此不應該儲存供日後使用。

*hPaintStruct*<br/>
識別 [PAINTSTRUCT](/windows/desktop/api/winuser/ns-winuser-tagpaintstruct) 資料結構，其定義要繪製工作區的哪一部分。

### <a name="remarks"></a>備註

若要判斷整個工作區或其中一部分是否需要重新繪製, 剪貼簿擁有者必須將`rcpaint` `PAINTSTRUCT`結構成員中所指定之繪圖區域的維度, 與最近的[OnSizeClipboard](#onsizeclipboard)成員函式呼叫。

`OnPaintClipboard`應該使用[GlobalLock](/windows/desktop/api/winbase/nf-winbase-globallock) windows 函式鎖定包含`PAINTSTRUCT`資料結構的記憶體, 並在結束前使用[GlobalUnlock](/windows/desktop/api/winbase/nf-winbase-globalunlock) Windows 函式解除鎖定該記憶體。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onpalettechanged"></a>  CWnd::OnPaletteChanged

架構會在具有輸入焦點的視窗實現其邏輯調色板之後, 針對所有最上層視窗呼叫這個成員函式, 因此會變更系統調色板。

```
afx_msg void OnPaletteChanged(CWnd* pFocusWnd);
```

### <a name="parameters"></a>參數

*pFocusWnd*<br/>
指定導致系統元件變更的視窗指標。 指標可能是暫時性的, 不應儲存。

### <a name="remarks"></a>備註

此呼叫允許沒有輸入焦點的視窗, 其使用色板來實現其邏輯調色板並更新其工作區。

此`OnPaletteChanged`成員函式會針對所有最上層和重迭的視窗呼叫, 包括變更系統調色板並導致傳送 WM_PALETTECHANGED 訊息的工作區。 如果任何子視窗使用調色板, 則必須將此訊息傳遞給它。

若要避免無限迴圈, 視窗應該不會實現其調色板, 除非它判斷*pFocusWnd*不包含其本身的指標。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onpaletteischanging"></a>  CWnd::OnPaletteIsChanging

架構會呼叫這個成員函式, 以通知應用程式應用程式要實現它的邏輯調色板。

```
afx_msg void OnPaletteIsChanging(CWnd* pRealizeWnd);
```

### <a name="parameters"></a>參數

*pRealizeWnd*<br/>
指定要實現其邏輯調色板的視窗。

### <a name="remarks"></a>備註

架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onparentnotify"></a>  CWnd::OnParentNotify

在建立或`OnParentNotify`終結子視窗時, 架構會呼叫父系的成員函式, 或當使用者按一下滑鼠按鍵, 而游標位於子視窗上方時, 就會呼叫它。

```
afx_msg void OnParentNotify(
    UINT message,
    LPARAM lParam);
```

### <a name="parameters"></a>參數

*message*<br/>
指定要通知父代的事件和子視窗的識別碼。 事件是*訊息*的低順序單字。 如果事件是 WM_CREATE 或 WM_DESTROY, 則*message*的高序位單字就是子視窗的識別碼;否則, 高階單字會是未定義的。 事件 (*訊息*的低序位字組) 可以是下列其中一個值:

- 正在建立子視窗的 WM_CREATE。

- 正在終結子視窗的 WM_DESTROY。

- WM_LBUTTONDOWN 使用者已將滑鼠游標放在子視窗上方, 並按一下滑鼠左鍵。

- WM_MBUTTONDOWN 使用者已將滑鼠游標放在子視窗上方, 並按一下滑鼠中間按鈕。

- WM_RBUTTONDOWN 使用者已將滑鼠游標放在子視窗上方, 並按一下滑鼠右鍵。

*lParam*<br/>
如果*message*的事件 (低序位字組) 為 WM_CREATE 或 WM_DESTROY, *lParam*會指定子視窗的視窗控制碼;否則, *lParam*會包含游標的 x 和 y 座標。 X 座標是低序位字組, 而 y 座標則是高序位單字。

### <a name="remarks"></a>備註

建立子視窗時, 系統會在建立視窗的`OnParentNotify` [Create](#create)成員函式之前呼叫。 當子視窗被終結時, 系統會在進行`OnParentNotify`任何處理之前呼叫, 以終結視窗。

`OnParentNotify`會針對子視窗的所有上階視窗呼叫, 包括最上層視窗。

除了具有[WS_EX_NOPARENTNOTIFY](../../mfc/reference/styles-used-by-mfc.md#extended-window-styles)樣式的所有子視窗外, 會將此訊息傳送至其父視窗。 根據預設, 對話方塊中的子視窗會有 WS_EX_NOPARENTNOTIFY 樣式, 除非您藉由呼叫[CreateEx](#createex)成員函式, 而不使用此樣式來建立子視窗。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onpowerbroadcast"></a>  CWnd::OnPowerBroadcast

當電源管理事件發生時, 架構會呼叫這個成員函式。

```
afx_msg UINT OnPowerBroadcast(
    UINT nPowerEvent,
    UINT nEventData);
```

### <a name="parameters"></a>參數

|參數|說明|
|---------------|-----------------|
|*nPowerEvent*|在電源管理事件。|
|*nEventData*|在事件特定的資料。|

### <a name="return-value"></a>傳回值

如果事件是要求, 則傳回 TRUE 以授與要求, 或 BROADCAST_QUERY_DENY 拒絕要求。

### <a name="remarks"></a>備註

這個方法會接收[WM_POWERBROADCAST](/windows/desktop/Power/wm-powerbroadcast)訊息, 如 Windows SDK 中所述。

*NPowerEvent*參數指定的事件如電池電力偏低、電源狀態已變更、要求或拒絕暫停作業的許可權、作業會在事件之後自動繼續、系統暫停作業, 或暫止之後正在繼續作業。 通常不會使用*nEventData*參數。 如需詳細資訊, 請參閱[WM_POWERBROADCAST](/windows/desktop/Power/wm-powerbroadcast)訊息的*wParam*和*lParam*參數。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onquerydragicon"></a>  CWnd::OnQueryDragIcon

架構會透過未針對其類別定義圖示的最小化 (iconic) 視窗來呼叫這個成員函式。

```
afx_msg HCURSOR OnQueryDragIcon();
```

### <a name="return-value"></a>傳回值

包含低序位字之游標或圖示控制碼的雙字數值。 游標或圖示必須與顯示器驅動程式的解析度相容。 如果應用程式傳回 Null, 系統會顯示預設資料指標。 預設的傳回值為 Null。

### <a name="remarks"></a>備註

系統會發出此呼叫來取得要顯示 當使用者拖曳最小化的視窗的游標。 如果應用程式傳回圖示或游標的控制碼, 系統就會將它轉換成黑白。 如果應用程式傳回控制碼, 則控制碼必須識別與顯示器驅動程式解析度相容的單色游標或圖示。 應用程式可以呼叫[CWinApp:: LoadCursor](../../mfc/reference/cwinapp-class.md#loadcursor)或[CWinApp:: LoadIcon](../../mfc/reference/cwinapp-class.md#loadicon)成員函式, 從其可執行檔的資源載入資料指標或圖示, 並取得此控制碼。

##  <a name="onqueryendsession"></a>  CWnd::OnQueryEndSession

當使用者選擇結束 Windows 會話時, 或當應用程式呼叫[ExitWindows](/windows/desktop/api/winuser/nf-winuser-exitwindows) Windows 函式時, 架構會呼叫這個成員函式。

```
afx_msg BOOL OnQueryEndSession();
```

### <a name="return-value"></a>傳回值

如果可以方便地關閉應用程式, 則為非零。否則為0。

### <a name="remarks"></a>備註

如果有任何應用程式傳回 0, 則 Windows 會話不會結束。 只要有一個`OnQueryEndSession`應用程式傳回 0, Windows 就會停止呼叫, 並針對任何已傳回非零的應用程式, 傳送參數值為 FALSE 的[WM_ENDSESSION](#onendsession)訊息。

##  <a name="onquerynewpalette"></a>  CWnd::OnQueryNewPalette

當`CWnd`物件即將收到輸入焦點時, 架構會呼叫這個成員函`CWnd`式, 讓您有機會在收到焦點時實現其邏輯調色板。

```
afx_msg BOOL OnQueryNewPalette();
```

### <a name="return-value"></a>傳回值

如果`CWnd`要實現其邏輯調色板, 則為非零, 否則為0。

##  <a name="onqueryopen"></a>  CWnd::OnQueryOpen

當`CWnd`物件最小化, 且使用者要求還原至其 preminimized 的`CWnd`大小和位置時, 架構會呼叫這個成員函式。

```
afx_msg BOOL OnQueryOpen();
```

### <a name="return-value"></a>傳回值

如果可以開啟圖示, 則為非零, 否則為 0, 以防止開啟圖示。

### <a name="remarks"></a>備註

在中`OnQueryOpen`, `CWnd`不應執行任何會導致啟用或焦點變更的動作 (例如, 建立對話方塊)。

##  <a name="onqueryuistate"></a>  CWnd::OnQueryUIState

呼叫以擷取視窗的使用者介面 (UI) 狀態。

```
afx_msg UINT OnQueryUIState();
```

### <a name="return-value"></a>傳回值

如果焦點指標和鍵盤快捷按鍵可見, 則傳回值為 Null。 否則, 傳回值可以是下列一個或多個值:

- UISF_HIDEFOCUS 焦點指標會隱藏起來。

- UISF_HIDEACCEL 鍵盤快捷按鍵已隱藏。

- UISF_ACTIVE Windows XP:控制項應以用於現用控制項的樣式繪製。

### <a name="remarks"></a>備註

此成員函式會模擬[WM_QUERYUISTATE](/windows/desktop/menurc/wm-queryuistate)訊息的功能, 如 Windows SDK 中所述。

##  <a name="onrawinput"></a>  CWnd::OnRawInput

當目前的視窗取得原始輸入時, 架構會呼叫這個成員函式。

```
afx_msg void OnRawInput(
    UINT nInputCode,
    HRAWINPUT hRawInput);
```

### <a name="parameters"></a>參數

|參數|描述|
|---------------|-----------------|
|*nInputCode*|在輸入代碼, 指出應用程式是否在前景時是否發生輸入。 不論是哪一種情況, 應用程式都必須呼叫[CWnd::D efwindowproc](#defwindowproc) , 讓系統可以執行清除。<br /><br /> 這個參數可以是下列其中一個值:<br /><br /> -RIM_INPUT-當應用程式在前景時, 就會發生輸入。<br />-RIM_INPUTSINK-當應用程式不在前景時, 就會發生輸入。|
|*hRawInput*|在[RAWINPUT](/windows/desktop/api/winuser/ns-winuser-tagrawinput)結構的控制碼, 其中包含來自裝置的原始輸入。|

### <a name="remarks"></a>備註

這個方法會接收[WM_INPUT](/windows/desktop/inputdev/wm-appcommand)通知, 如 Windows SDK 中所述。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onrbuttondblclk"></a>  CWnd::OnRButtonDblClk

當使用者按兩下滑鼠右鍵時, 架構會呼叫這個成員函式。

```
afx_msg void OnRButtonDblClk(
    UINT nFlags,
    CPoint point);
```

### <a name="parameters"></a>參數

*nFlags*<br/>
指出各種虛擬機器碼是否已關閉。 這個參數可以是下列值的任意組合:

- 如果 CTRL 鍵已關閉, 則為 MK_CONTROL 設定。

- 如果左滑鼠按鍵已關閉, 則為 MK_LBUTTON 設定。

- 如果中間滑鼠按鍵已關閉, 則為 MK_MBUTTON 設定。

- 如果滑鼠右鍵已關閉, 則為 MK_RBUTTON 設定。

- 如果 SHIFT 鍵已關閉, 則為 MK_SHIFT 設定。

*point*<br/>
指定游標的 x 和 y 座標。 這些座標一律相對於視窗的左上角。

### <a name="remarks"></a>備註

只有具有 CS_DBLCLKS [WNDCLASS](/windows/desktop/api/winuser/ns-winuser-tagwndclassa)樣式的視窗可以接收`OnRButtonDblClk`呼叫。 這是 MFC 程式庫內的 windows 預設值。 當使用者`OnRButtonDblClk`按下、放開, 然後在系統的按兩下時間限制內, 再次按下滑鼠右鍵時, Windows 就會呼叫。 按兩下滑鼠右鍵, 實際上會產生四個事件:[WM_RBUTTONDOWN](#onrbuttondown)和[WM_RBUTTONUP](#onrbuttonup) `OnRButtonDblClk`訊息、呼叫, 以及釋放按鈕時的另一個 WM_RBUTTONUP 訊息。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onrbuttondown"></a>  CWnd::OnRButtonDown

當使用者按下滑鼠右鍵時, 架構會呼叫這個成員函式。

```
afx_msg void OnRButtonDown(
    UINT nFlags,
    CPoint point);
```

### <a name="parameters"></a>參數

*nFlags*<br/>
指出各種虛擬機器碼是否已關閉。 這個參數可以是下列值的任意組合:

- 如果 CTRL 鍵已關閉, 則為 MK_CONTROL 設定。

- 如果左滑鼠按鍵已關閉, 則為 MK_LBUTTON 設定。

- 如果中間滑鼠按鍵已關閉, 則為 MK_MBUTTON 設定。

- 如果滑鼠右鍵已關閉, 則為 MK_RBUTTON 設定。

- 如果 SHIFT 鍵已關閉, 則為 MK_SHIFT 設定。

*point*<br/>
指定游標的 x 和 y 座標。 這些座標一律相對於視窗的左上角。

### <a name="remarks"></a>備註

架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onrbuttonup"></a>  CWnd::OnRButtonUp

當使用者放開滑鼠右鍵時, 架構會呼叫這個成員函式。

```
afx_msg void OnRButtonUp(
    UINT nFlags,
    CPoint point);
```

### <a name="parameters"></a>參數

*nFlags*<br/>
指出各種虛擬機器碼是否已關閉。 這個參數可以是下列值的任意組合:

- 如果 CTRL 鍵已關閉, 則為 MK_CONTROL 設定。

- 如果左滑鼠按鍵已關閉, 則為 MK_LBUTTON 設定。

- 如果中間滑鼠按鍵已關閉, 則為 MK_MBUTTON 設定。

- 如果 SHIFT 鍵已關閉, 則為 MK_SHIFT 設定。

*point*<br/>
指定游標的 x 和 y 座標。 這些座標一律相對於視窗的左上角。

### <a name="remarks"></a>備註

架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onregisteredmousewheel"></a>  CWnd::OnRegisteredMouseWheel

當使用者旋轉滑鼠滾輪並遇到滾輪的下一個凹槽時, 架構會呼叫這個成員函式。

```
afx_msg LRESULT OnRegisteredMouseWheel(
    WPARAM wParam,
    LPARAM lParam);
```

### <a name="parameters"></a>參數

*wParam*<br/>
指標的水準位置。

*lParam*<br/>
指標的垂直位置。

### <a name="return-value"></a>傳回值

目前沒有意義。 一律為零。

### <a name="remarks"></a>備註

除非予以覆`OnRegisteredMouseWheel`寫, 否則會將訊息路由至適當的視窗 (具有焦點的父視窗), 並呼叫該視窗的[WM_MOUSEWHEEL](/windows/desktop/inputdev/wm-mousewheel)處理常式。

覆寫此成員函式以提供您自己的訊息路由, 或改變滑鼠滾輪的滾動行為。

> [!NOTE]
> `OnRegisteredMouseWheel`處理 Windows 95/98 和 Windows NT 3.51 的訊息。 對於 Windows NT 4.0 訊息處理, 請使用[OnMouseWheel](#onmousewheel)。

##  <a name="onrenderallformats"></a>  CWnd::OnRenderAllFormats

當擁有者應用`OnRenderAllFormats`程式遭到終結時, 架構會呼叫剪貼簿擁有者的成員函式。

```
afx_msg void OnRenderAllFormats();
```

### <a name="remarks"></a>備註

剪貼簿擁有者應該會以能夠產生的所有格式來轉譯資料, 並藉由呼叫[SetClipboardData](/windows/desktop/api/winuser/nf-winuser-setclipboarddata) Windows 函式, 將每個格式的資料控制碼傳遞至剪貼簿。 這可確保即使轉譯資料的應用程式已終結, 剪貼簿還是包含有效的資料。 應用程式應該在呼叫[SetClipboardData](/windows/desktop/api/winuser/nf-winuser-setclipboarddata) Windows 函式之前呼叫[OpenClipboard](#openclipboard)成員函式, 然後在之後呼叫[CloseClipboard](/windows/desktop/api/winuser/nf-winuser-closeclipboard) Windows 函式。

##  <a name="onrenderformat"></a>  CWnd::OnRenderFormat

當需要呈現具有`OnRenderFormat`延遲轉譯的特定格式時, 架構會呼叫剪貼簿擁有者的成員函式。

```
afx_msg void OnRenderFormat(UINT nFormat);
```

### <a name="parameters"></a>參數

*nFormat*<br/>
指定剪貼簿格式。

### <a name="remarks"></a>備註

接收者應會以該格式轉譯資料, 並藉由呼叫[SetClipboardData](/windows/desktop/api/winuser/nf-winuser-setclipboarddata) Windows 函式將它傳遞至剪貼簿。

請勿從中`OpenClipboard` `CloseClipboard` 呼叫`OnRenderFormat`成員函式或 Windows 函式。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onsessionchange"></a>  CWnd::OnSessionChange

架構會呼叫這個成員函式, 以通知應用程式會話狀態的變更。

```
afx_msg void OnSessionChange(
    UINT nSessionState,
    UINT nId);
```

### <a name="parameters"></a>參數

|參數|描述|
|---------------|-----------------|
|*nSessionState*|在狀態碼會描述會話狀態變更。|
|*nId*|在會話識別碼。|

### <a name="remarks"></a>備註

這個方法會接收[WM_WTSSESSION_CHANGE](/windows/desktop/TermServ/wm-wtssession-change)通知, 如 Windows SDK 中所述。

*NSessionState*參數指定會話已連接或中斷與主控台或遠端終端機機、使用者登入或關閉、會話已鎖定或解除鎖定, 或會話已變更為遠端控制狀態。 如需詳細資訊, 請參閱[WM_WTSSESSION_CHANGE](/windows/desktop/TermServ/wm-wtssession-change)訊息的*wParam*參數。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onsetcursor"></a>  CWnd::OnSetCursor

如果未捕捉到滑鼠輸入, 而且滑鼠導致游標在`CWnd`物件內移動, 則此架構會呼叫這個成員函式。

```
afx_msg BOOL OnSetCursor(
    CWnd* pWnd,
    UINT nHitTest,
    UINT message);
```

### <a name="parameters"></a>參數

*pWnd*<br/>
指定包含游標之視窗的指標。 該指標可能是暫時性的，因此不應該儲存供日後使用。

*nHitTest*<br/>
指定[點擊測試區域程式](#onnchittest)代碼。 點擊測試會判斷游標的位置。

*message*<br/>
指定滑鼠的訊息編號。

### <a name="return-value"></a>傳回值

非零以停止進一步處理, 或0以繼續。

### <a name="remarks"></a>備註

預設的實值會在處理前`OnSetCursor`呼叫父視窗的。 如果父視窗傳回 TRUE, 則會暫停進一步的處理。 呼叫父視窗可讓父視窗控制子視窗中的游標設定。

預設的執行會將游標設定為箭號 (如果它不在工作區中) 或已註冊的類別資料指標 (如果它是)。

如果*nHitTest*是 HTERROR, 而*message*是滑鼠按鍵向下`MessageBeep`訊息, 則會呼叫成員函式。

進入功能表模式時`CWnd` , 訊息參數為0。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onsetfocus"></a>  CWnd::OnSetFocus

架構會在取得輸入焦點之後呼叫這個成員函式。

```
afx_msg void OnSetFocus(CWnd* pOldWnd);
```

### <a name="parameters"></a>參數

*pOldWnd*<br/>
包含失去`CWnd`輸入焦點的物件 (可能是 Null)。 該指標可能是暫時性的，因此不應該儲存供日後使用。

### <a name="remarks"></a>備註

若要顯示插入號`CWnd` , 應該在此位置呼叫適當的插入號函式。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onsettingchange"></a>  CWnd::OnSettingChange

當 Win32 SystemParametersInfo `OnSettingChange`函式變更整個系統的設定時, 架構會呼叫所有最上層視窗。

```
afx_msg void OnSettingChange(
    UINT uFlags,
    LPCTSTR lpszSection);
```

### <a name="parameters"></a>參數

*uFlags*<br/>
當系統以`SystemParametersInfo`呼叫的結果傳送訊息時, 這個參數會是一個旗標, 指出已變更的系統參數。 如需值清單, 請參閱 Windows SDK 中的[SystemParametersInfo](/windows/desktop/api/winuser/nf-winuser-systemparametersinfoa) 。 當應用程式傳送訊息時, 這個參數必須是0。

*lpszSection*<br/>
指向字串, 指定已變更之區段的名稱。 (此字串不包含用來括住區段名稱的方括弧)。

### <a name="remarks"></a>備註

應用程式應將訊息傳送至所有最上層視窗，當它變更系統參數，而 Windows 會傳送訊息，如果使用者變更透過 控制台設定。

ON_WM_SETTINGCHANGE 訊息與 ON_WM_WININICHANGE 訊息類似, 但有下列差異:

- 當執行 Windows NT 4.0 或更新版本中，或 Windows 95/98 下，請使用 ON_WM_SETTINGCHANGE。

- 執行 Windows NT 3.51 或更舊版本時, 請使用 ON_WININICHANGE。 此訊息現在已過時。

您的訊息對應中應該只有其中一個宏。 若要撰寫可同時適用于 Windows 95/98 和 Windows NT 4.0 的程式, 請撰寫 ON_WM_SETTINGCHANGE 的處理常式。 在 Windows NT 3.51 底下, 您的處理常式將`OnSettingChange`由和*uFlags*呼叫, 而且一律為零。

##  <a name="onshowwindow"></a>  CWnd::OnShowWindow

當`CWnd`物件即將隱藏或顯示時, 架構會呼叫這個成員函式。

```
afx_msg void OnShowWindow(
    BOOL bShow,
    UINT nStatus);
```

### <a name="parameters"></a>參數

*bShow*<br/>
指定是否要顯示視窗。 如果要顯示視窗, 則為 TRUE;如果視窗正在隱藏中, 則為 FALSE。

*nStatus*<br/>
指定要顯示之視窗的狀態。 如果因為`ShowWindow`成員函式呼叫而傳送訊息, 則為 0, 否則*nStatus*為下列其中一項:

- SW_PARENTCLOSING 父視窗正在關閉 (進行 iconic), 或正在隱藏快顯視窗。

- SW_PARENTOPENING 父視窗正在開啟 (顯示), 或正在顯示快顯視窗。

### <a name="remarks"></a>備註

當`ShowWindow`呼叫成員函式、將重迭視窗最大化或還原, 或是關閉 (進行 iconic) 或開啟重迭或快顯視窗 (顯示在螢幕上) 時, 就會隱藏或顯示視窗。 當重迭視窗關閉時, 與該視窗相關聯的所有快顯視窗都會隱藏起來。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onsize"></a>  CWnd::OnSize

架構會在視窗的大小變更後呼叫這個成員函式。

```
afx_msg void OnSize(
    UINT nType,
    int cx,
    int cy);
```

### <a name="parameters"></a>參數

*nType*<br/>
指定要求調整大小的類型。 這個參數可以是下列其中一個值:

- 已將 SIZE_MAXIMIZED 視窗最大化。

- SIZE_MINIMIZED 視窗已最小化。

- SIZE_RESTORED 視窗已調整大小, 但不會套用 SIZE_MINIMIZED 和 SIZE_MAXIMIZED。

- 當其他視窗最大化時, SIZE_MAXHIDE 訊息會傳送至所有快顯視窗。

- 當其他視窗已還原為其先前的大小時, SIZE_MAXSHOW 訊息會傳送至所有快顯視窗。

*cx*<br/>
指定工作區的新寬度。

*cy*<br/>
指定工作區的新高度。

### <a name="remarks"></a>備註

如果從`bRedraw` `CWnd` `SetScrollPos` `MoveWindow`  `OnSize`呼叫子視窗的[SetScrollPos](#setscrollpos)或 [MoveWindow](#movewindow) 成員函式, 或的參數應為非零值, 使重新繪製。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#109](../../mfc/reference/codesnippet/cpp/cwnd-class_50.cpp)]

##  <a name="onsizeclipboard"></a>CWnd:: OnSizeClipboard

剪貼簿擁有者`OnSizeClipboard`的成員函式是由剪貼簿包含`CF_OWNERDISPLAY`屬性的資料, 以及 [剪貼簿-檢視器] 視窗的工作區大小變更時所呼叫。

```
afx_msg void OnSizeClipboard(
    CWnd* pClipAppWnd,
    HGLOBAL hRect);
```

### <a name="parameters"></a>參數

*pClipAppWnd*<br/>
識別 [剪貼簿-應用程式] 視窗。 指標可能是暫時性的, 不應儲存。

*hRect*<br/>
識別全域記憶體物件。 Memory 物件包含矩形資料結構, 可指定剪貼簿擁有者要繪製的區域。

### <a name="remarks"></a>備註

當剪貼簿應用程式即將終結或最小化時, 會使用 null 矩形 (0, 0, 0, 0) 來呼叫成員函式,做為新的大小。`OnSizeClipboard` 這允許剪貼簿擁有者釋放其顯示資源。

在`OnSizeClipboard`中, 應用程式必須使用[GlobalLock](/windows/desktop/api/winbase/nf-winbase-globallock) Windows 函數來鎖定包含 RECT 資料結構的記憶體。 讓應用程式在產生或傳回控制項之前, 使用[GlobalUnlock](/windows/desktop/api/winbase/nf-winbase-globalunlock) Windows 函式解除鎖定該記憶體。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onsizing"></a>  CWnd::OnSizing

架構會呼叫這個成員函式, 以表示使用者正在調整矩形的大小。

```
afx_msg void OnSizing(
    UINT nSide,
    LPRECT lpRect);
```

### <a name="parameters"></a>參數

*nSide*<br/>
要移動的視窗邊緣。

*lpRect*<br/>
將包含專案座標的[CRect](../../atl-mfc-shared/reference/crect-class.md)或[RECT 結構](/windows/desktop/api/windef/ns-windef-tagrect)的位址。

### <a name="remarks"></a>備註

藉由處理此訊息, 應用程式可以監視拖曳矩形的大小和位置, 並視需要變更其大小或位置。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#110](../../mfc/reference/codesnippet/cpp/cwnd-class_51.cpp)]

##  <a name="onspoolerstatus"></a>  CWnd::OnSpoolerStatus

每當有作業加入或從列印管理員佇列中移除時, 此架構就會從列印管理員呼叫這個成員函式。

```
afx_msg void OnSpoolerStatus(
    UINT nStatus,
    UINT nJobs);
```

### <a name="parameters"></a>參數

*nStatus*<br/>
指定 SP_JOBSTATUS 旗標。

*nJobs*<br/>
指定列印管理員佇列中剩餘的作業數。

### <a name="remarks"></a>備註

此呼叫僅供資訊參考之用。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onstylechanged"></a>  CWnd::OnStyleChanged

架構會在[SetWindowLong](/windows/desktop/api/winuser/nf-winuser-setwindowlonga)函式變更一個或多個視窗樣式之後, 呼叫這個成員函式。

```
afx_msg void OnStyleChanged(
    int nStyleType,
    LPSTYLESTRUCT lpStyleStruct);
```

### <a name="parameters"></a>參數

*nStyleType*<br/>
指定視窗的延伸或 nonextended 樣式是否已變更。 這個參數可以是下列值的組合:

- GWL_EXSTYLE 視窗的延伸樣式已經變更。

- GWL_STYLE 視窗的 nonextended 樣式已經變更。

*lpStyleStruct*<br/>
指向包含視窗新樣式的[STYLESTRUCT](/windows/desktop/api/winuser/ns-winuser-stylestruct)結構。 應用程式可以檢查樣式, 但不能變更它們。

### <a name="remarks"></a>備註

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onstylechanging"></a>CWnd:: OnStyleChanging

當[SetWindowLong](/windows/desktop/api/winuser/nf-winuser-setwindowlonga)函數即將變更一個或多個視窗樣式時, 架構會呼叫這個成員函式。

```
afx_msg void OnStyleChanging(
    int nStyleType,
    LPSTYLESTRUCT lpStyleStruct);
```

### <a name="parameters"></a>參數

*nStyleType*<br/>
指定視窗的延伸或 nonextended 樣式是否已變更。 這個參數可以是下列值的組合:

- GWL_EXSTYLE 視窗的延伸樣式已經變更。

- GWL_STYLE 視窗的 nonextended 樣式已經變更。

*lpStyleStruct*<br/>
指向包含視窗新樣式的[STYLESTRUCT](/windows/desktop/api/winuser/ns-winuser-stylestruct)結構。 應用程式可以檢查樣式並加以變更。

### <a name="remarks"></a>備註

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onsyschar"></a>  CWnd::OnSysChar

如果`CWnd`具有輸入焦點, 而且[WM_SYSKEYUP](#onsyskeyup)和[WM_SYSKEYDOWN](#onsyskeydown)訊息已轉譯, 則架構會呼叫這個成員函式。

```
afx_msg void OnSysChar(
    UINT nChar,
    UINT nRepCnt,
    UINT nFlags);
```

### <a name="parameters"></a>參數

*nChar*<br/>
指定控制項功能表鍵的 ASCII 字元按鍵碼。

*nRepCnt*<br/>
指定重複計數 (擊鍵因使用者按住按鍵而重複出現的次數)。

*nFlags*<br/>
*NFlags*參數可以有下列值:

|值|意義|
|-----------|-------------|
|0-15|指定重複計數。 這個值是使用者按住索引鍵時, 重複擊鍵的次數。|
|16-23|指定掃描程式碼。 此值取決於原始設備製造商 (OEM)|
|24|指定索引鍵是否為延伸的索引鍵, 例如在增強的101或102鍵鍵盤上出現的右 ALT 和 CTRL 鍵。 如果它是擴充索引鍵, 則值為 1;否則, 它是0。|
|25-28|由 Windows 在內部使用。|
|29|指定內容代碼。 如果在按下按鍵時按住 ALT 鍵, 則此值為 1;否則, 此值為0。|
|30|指定先前的索引鍵狀態。 如果在傳送訊息之前, 金鑰已關閉, 此值為 1, 如果索引鍵已啟動, 則為0。|
|31|指定轉換狀態。 如果要釋放金鑰, 此值為 1, 如果按下按鍵則為0。|

### <a name="remarks"></a>備註

它會指定控制項功能表鍵的虛擬按鍵代碼。 (如需標準虛擬按鍵代碼的清單, 請參閱 Winuser)。

當內容代碼為0時, WM_SYSCHAR 可以將[WM_SYSCHAR](/windows/desktop/menurc/wm-syschar)訊息傳遞至[TranslateAccelerator](/windows/desktop/api/winuser/nf-winuser-translateacceleratora) Windows 函式, 這將會處理它, 就好像它是一般的索引鍵訊息, 而不是系統字元按鍵。 這允許在使用中視窗中使用快速鍵, 即使使用中視窗沒有輸入焦點也一樣。

針對 IBM 增強的101和102金鑰鍵盤, 增強式金鑰是鍵盤主要區段上的右 ALT 和右 CTRL 鍵;數位鍵臺上左邊的叢集中的 INS、DEL、HOME、END、PAGE UP、PAGE DOWN 和方向鍵;和斜線 (/), 然後在數位鍵臺上輸入按鍵。 有些其他鍵盤可能支援*nFlags*中的延伸金鑰位。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onsyscolorchange"></a>  CWnd::OnSysColorChange

在系統色彩設定中進行變更時, 架構會針對所有最上層視窗呼叫這個成員函式。

```
afx_msg void OnSysColorChange();
```

### <a name="remarks"></a>備註

任何受`OnSysColorChange`系統色彩變更影響之視窗的 Windows 呼叫。

具有使用現有系統色彩之筆刷的應用程式應該刪除這些筆刷, 並使用新的系統色彩重新建立。

##  <a name="onsyscommand"></a>  CWnd::OnSysCommand

使用者控制項 功能表中選取命令時，或在使用者選取最大化或最小化按鈕時，架構會呼叫此成員函式。

```
afx_msg void OnSysCommand(
    UINT nID,
    LPARAM lParam);
```

### <a name="parameters"></a>參數

*nID*<br/>
指定所要求的系統命令類型。 這個參數可以是下列任何一個值:

- SC_CLOSE 關閉`CWnd`物件。

- SC_HOTKEY 啟用與`CWnd`應用程式指定的熱鍵相關聯的物件。 *LParam*的低序位單字會識別要啟動之視窗的 HWND。

- SC_HSCROLL 水準滾動。

- SC_KEYMENU 透過按鍵來抓取功能表。

- SC_MAXIMIZE (或 SC_ZOOM) 最大化`CWnd`物件。

- SC_MINIMIZE (或 SC_ICON) 最小`CWnd`化物件。

- SC_MOUSEMENU 透過按一下滑鼠來抓取功能表。

- SC_MOVE 移動`CWnd`物件。

- SC_NEXTWINDOW 移至下一個視窗。

- SC_PREVWINDOW 移至上一個視窗。

- 將 [SC_RESTORE 還原] 視窗設為正常的位置和大小。

- SC_SCREENSAVE 會執行系統的 [boot] 區段中指定的螢幕保護裝置應用程式。INI 檔案。

- SC_SIZE 會調整`CWnd`物件的大小。

- SC_TASKLIST 執行或啟動 Windows 工作管理員應用程式。

- SC_VSCROLL 會垂直捲動。

*lParam*<br/>
如果使用滑鼠選擇功能表命令, 則*lParam*會包含游標座標。 低序位字組包含 x 座標, 而高序位單字包含 y 座標。 否則, 就不會使用這個參數。

- SC_HOTKEY 啟用與應用程式指定的熱鍵關聯的視窗。 *LParam*的低序位字組會識別要啟動的視窗。

- SC_SCREENSAVE 執行在 [控制台] 的 [桌面] 區段中指定的螢幕-儲存應用程式。

### <a name="remarks"></a>備註

根據預設, `OnSysCommand`會針對上表中指定的預先定義動作執行 [控制功能表] 要求。

在 WM_SYSCOMMAND 訊息中, Windows 會在內部使用*nID*參數的四個低序位位。 當應用程式測試*nid*的值時, 它必須使用位 and 運算子來結合值0XFFF0 與*nid*值, 以取得正確的結果。

您可以使用`GetSystemMenu`、 `AppendMenu`、 `InsertMenu`和`ModifyMenu`成員函式來修改 [控制] 功能表中的功能表項目。 修改 [控制] 功能表的應用程式必須處理 WM_SYSCOMMAND 的訊息, 而且應用程式未處理的任何 WM_SYSCOMMAND 訊息都必須`OnSysCommand`傳遞到。 應用程式所加入的任何命令值都必須由應用程式處理, 而且無法傳遞`OnSysCommand`至。

應用程式可以透過將 WM_SYSCOMMAND 訊息傳遞至`OnSysCommand`, 隨時執行任何系統命令。

定義用來從 [控制] 功能表中選取專案的快速鍵 (快捷方式) 按鍵`OnSysCommand`會轉譯成呼叫; 所有其他快速鍵按鍵都會轉譯成[WM_COMMAND](#oncommand)的訊息。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onsysdeadchar"></a>  CWnd::OnSysDeadChar

如果呼叫[OnSysKeyUp](#onsyskeyup)或[OnSysKeyDown](#onsyskeydown)成員函式`CWnd`時, 此架構會呼叫這個成員函式的輸入焦點。

```
afx_msg void OnSysDeadChar(
    UINT nChar,
    UINT nRepCnt,
    UINT nFlags);
```

### <a name="parameters"></a>參數

*nChar*<br/>
指定失效索引鍵的字元值。

*nRepCnt*<br/>
指定重複計數。

*nFlags*<br/>
指定掃描碼、金鑰轉換程式碼、先前的金鑰狀態和內容程式碼, 如下列清單所示:

|值|意義|
|-----------|-------------|
|0-7|掃描程式碼 (OEM 相依值)。 高序位單字的低位元組。|
|8|擴充索引鍵, 例如數位鍵臺上的函式金鑰或索引鍵 (如果它是擴充索引鍵, 則為 1), 否則為0。|
|9-10|未使用。|
|11-12|由 Windows 在內部使用。|
|13|內容代碼 (如果在按下按鍵時, 會按住 ALT 鍵, 則為 1, 否則為 0)。|
|14|先前的索引鍵狀態 (1, 如果金鑰在呼叫前關閉, 則為 0, 如果索引鍵已啟動)。|
|15|轉換狀態 (如果正在釋放索引鍵, 則為 1, 如果按下按鍵則為 0)。|

### <a name="remarks"></a>備註

它會指定失效金鑰的字元值。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onsyskeydown"></a>  CWnd::OnSysKeyDown

如果物件具有輸入焦點`OnSysKeyDown` , 則當使用者按住 ALT 鍵, 然後按下另一個按鍵時, 架構會呼叫成員函式。 `CWnd`

```
afx_msg void OnSysKeyDown(
    UINT nChar,
    UINT nRepCnt,
    UINT nFlags);
```

### <a name="parameters"></a>參數

*nChar*<br/>
指定所按下按鍵的虛擬按鍵碼。 如需標準虛擬按鍵代碼的清單, 請參閱 Winuser。

*nRepCnt*<br/>
指定重複計數。

*nFlags*<br/>
指定掃描碼、金鑰轉換程式碼、先前的金鑰狀態和內容程式碼, 如下列清單所示:

|值|意義|
|-----------|-------------|
|0-7|掃描程式碼 (OEM 相依值)。 高序位單字的低位元組。|
|8|擴充索引鍵, 例如數位鍵臺上的函式金鑰或索引鍵 (如果它是擴充索引鍵, 則為 1), 否則為0。|
|9-10|未使用。|
|11-12|由 Windows 在內部使用。|
|13|內容代碼 (如果 ALT 鍵在按下按鍵時保持關閉, 則為 1, 否則為 0)。|
|14|先前的索引鍵狀態 (1, 如果金鑰在傳送訊息之前已關閉, 則為 0, 如果金鑰已啟動)。|
|15|轉換狀態 (如果正在釋放索引鍵, 則為 1, 如果按下按鍵則為 0)。|

對於`OnSysKeyDown`呼叫, 金鑰轉換位 (位 15) 為0。 如果 ALT 鍵在按下按鍵時關閉, 則內容代碼位 (位 13) 為 1;如果訊息傳送到使用中視窗, 則為 0, 因為沒有視窗具有輸入焦點。

### <a name="remarks"></a>備註

如果目前沒有任何視窗具有輸入焦點, 則會呼叫活動`OnSysKeyDown`視窗的成員函式。 接收`CWnd`訊息的物件可以藉由檢查中`nFlags`的內容程式碼來區分這兩個內容。

當內容代碼為0時, 所接收`OnSysKeyDown`的 WM_SYSKEYDOWN 訊息可以傳遞至[TranslateAccelerator](/windows/desktop/api/winuser/nf-winuser-translateacceleratora) Windows 函式, 這將會處理它, 就如同它是一般的索引鍵訊息, 而不是系統金鑰訊息。 這允許在使用中視窗中使用快速鍵, 即使使用中視窗沒有輸入焦點也一樣。

因為有`OnSysKeyDown`自動重複的情況, 所以在收到[WM_SYSKEYUP](#onsyskeyup)訊息之前, 可能會發生多個呼叫。 先前的索引鍵狀態 (位 14) 可以用來判斷`OnSysKeyDown`呼叫是否表示第一個向下轉換或重複的向下轉換。

針對 IBM 增強的101和102金鑰鍵盤, 增強式金鑰是鍵盤主要區段上的右 ALT 和右 CTRL 鍵;數位鍵臺上左邊的叢集中的 INS、DEL、HOME、END、PAGE UP、PAGE DOWN 和方向鍵;和斜線 (/), 然後在數位鍵臺上輸入按鍵。 有些其他鍵盤可能支援*nFlags*中的延伸金鑰位。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onsyskeyup"></a>  CWnd::OnSysKeyUp

如果物件具有焦點, 則當使用者`OnSysKeyUp`放開按住 ALT 鍵時所按下的按鍵時, 架構會呼叫成員函式。 `CWnd`

```
afx_msg void OnSysKeyUp(
    UINT nChar,
    UINT nRepCnt,
    UINT nFlags);
```

### <a name="parameters"></a>參數

*nChar*<br/>
指定所按下按鍵的虛擬按鍵碼。 如需標準虛擬按鍵代碼的清單, 請參閱 Winuser。

*nRepCnt*<br/>
指定重複計數。

*nFlags*<br/>
指定掃描碼、金鑰轉換程式碼、先前的金鑰狀態和內容程式碼, 如下列清單所示:

|值|意義|
|-----------|-------------|
|0-7|掃描程式碼 (OEM 相依值)。 高序位單字的低位元組。|
|8|擴充索引鍵, 例如數位鍵臺上的函式金鑰或索引鍵 (如果它是擴充索引鍵, 則為 1), 否則為0。|
|9-10|未使用。|
|11-12|由 Windows 在內部使用。|
|13|內容代碼 (如果 ALT 鍵在按下按鍵時保持關閉, 則為 1, 否則為 0)。|
|14|先前的索引鍵狀態 (1, 如果金鑰在傳送訊息之前已關閉, 則為 0, 如果金鑰已啟動)。|
|15|轉換狀態 (如果正在釋放索引鍵, 則為 1, 如果按下按鍵則為 0)。|

對於`OnSysKeyUp`呼叫, 金鑰轉換位 (位 15) 是1。 如果 ALT 鍵在按下按鍵時關閉, 則內容代碼位 (位 13) 為 1;如果訊息傳送到使用中視窗, 則為 0, 因為沒有視窗具有輸入焦點。

### <a name="remarks"></a>備註

如果目前沒有任何視窗具有輸入焦點, 則會呼叫活動`OnSysKeyUp`視窗的成員函式。 接收`CWnd`呼叫的物件可以藉由檢查*nFlags*中的內容程式碼來區分這兩個內容。

當內容代碼為0時, 所接收`OnSysKeyUp`的 WM_SYSKEYUP 訊息可以傳遞至[TranslateAccelerator](/windows/desktop/api/winuser/nf-winuser-translateacceleratora) Windows 函式, 這將會處理它, 就如同它是一般的索引鍵訊息, 而不是系統金鑰訊息。 這可讓快速鍵 (快捷方式) 索引鍵與使用中視窗搭配使用, 即使使用中視窗沒有輸入焦點也一樣。

針對 IBM 增強的101和102金鑰鍵盤, 增強式金鑰是鍵盤主要區段上的右 ALT 和右 CTRL 鍵;數位鍵臺上左邊的叢集中的 INS、DEL、HOME、END、PAGE UP、PAGE DOWN 和方向鍵;和斜線 (/), 然後在數位鍵臺上輸入按鍵。 有些其他鍵盤可能支援*nFlags*中的延伸金鑰位。

適用于非美國。增強的 102-按鍵鍵盤, 右 ALT 鍵會以 CTRL + ALT 鍵組合的方式處理。 以下顯示訊息的順序, 以及當使用者按下並釋放此金鑰時所產生的呼叫:

|序列|已存取函數|訊息已通過|
|--------------|-----------------------|--------------------|
|1.|[WM_KEYDOWN](#onkeydown)|VK_CONTROL|
|2.|[WM_KEYDOWN](#onkeydown)|VK_MENU|
|3.|[WM_KEYUP](#onkeyup)|VK_CONTROL|
|4.|[WM_SYSKEYUP](/windows/desktop/inputdev/wm-syskeyup)|VK_MENU|

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="ontcard"></a>  CWnd::OnTCard

當使用者按一下 [可設計] 按鈕時, 架構會呼叫這個成員函式。

```
afx_msg void OnTCard(
    UINT idAction,
    DWORD dwActionData);
```

### <a name="parameters"></a>參數

*idAction*<br/>
表示使用者已採取的動作。 這個參數可以是下列其中一個值:

- IDABORT 使用者按一下 [可設計中止] 按鈕。

- IDCANCEL 使用者按一下可設計的 [取消] 按鈕。

- IDCLOSE 使用者已關閉訓練卡。

- IDHELP 使用者按一下可設計的 Windows [說明] 按鈕。

- IDIGNORE 使用者按一下 [可設計忽略] 按鈕。

- IDOK 使用者按一下 [可設計確定] 按鈕。

- IDNO 使用者按下可設計沒有 按鈕。

- IDRETRY 使用者按一下可設計的重試 按鈕。

- HELP_TCARD_DATA 使用者按一下 [可設計] 按鈕。 *DwActionData*參數包含說明作者所指定的長整數。

- HELP_TCARD_NEXT 使用者按一下可設計的下一步 按鈕。

- HELP_TCARD_OTHER_CALLER 另一個應用程式已要求訓練卡。

- IDYES 使用者按一下 [可設計是] 按鈕。

*dwActionData*<br/>
如果*idAction*指定 HELP_TCARD_DATA, 這個參數就是說明作者所指定的長整數。 否則, 此參數為零。

### <a name="remarks"></a>備註

只有在應用程式已起始含有 Windows 說明的訓練卡時, 才會呼叫此函式。 應用程式會藉由在對[WinHelp](../../mfc/reference/cwinapp-class.md#winhelp)函式的呼叫中指定 HELP_TCARD 命令來起始定型卡。

##  <a name="ontimechange"></a>  CWnd::OnTimeChange

架構會在系統時間變更之後呼叫這個成員函式。

```
afx_msg void OnTimeChange();
```

### <a name="remarks"></a>備註

若有任何應用程式變更系統時間, 請將此訊息傳送至所有最上層視窗。 若要將 WM_TIMECHANGE 訊息傳送至所有最上層視窗, 應用程式可以使用[SendMessage](/windows/desktop/api/winuser/nf-winuser-sendmessage) windows 函數, 並將其*hwnd*參數設定為 HWND_BROADCAST。

##  <a name="ontimer"></a>  CWnd::OnTimer

架構會在用來安裝計時器的[SetTimer](#settimer)成員函式中指定的每個間隔之後, 呼叫這個成員函式。

```
afx_msg void OnTimer(UINT_PTR nIDEvent);
```

### <a name="parameters"></a>參數

*nIDEvent*<br/>
指定計時器的識別碼。

### <a name="remarks"></a>備註

當應用程式的訊息佇列中沒有其他訊息時, [DispatchMessage](/windows/desktop/api/winuser/nf-winuser-dispatchmessage) Windows 函數會傳送[WM_TIMER](/windows/desktop/winmsg/wm-timer)訊息。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

### <a name="example"></a>範例

  請參閱[CWnd:: SetTimer](#settimer)中的範例。

##  <a name="ontoolhittest"></a>  CWnd::OnToolHitTest

架構會呼叫這個成員函式, 以判斷某個點是否在指定之工具的周框中。

```
virtual INT_PTR OnToolHitTest(
    CPoint point,
    TOOLINFO* pTI) const;
```

### <a name="parameters"></a>參數

*point*<br/>
指定游標的 x 和 y 座標。 這些座標一律相對於視窗的左上角

*pTI*<br/>
[TOOLINFO](/windows/desktop/api/commctrl/ns-commctrl-tagtoolinfoa)結構的指標。 預設會設定下列結構值:

-  = 視窗的 hwnd`m_hWnd`控制碼

-  = 子視窗的 uId`(UINT)hWndChild`控制碼

- *uFlags*&#124;= 工具的 TTF_IDISHWND 控制碼

- *lpszText* = 要在指定的視窗中顯示之字串的 LPSTR_TEXTCALLBACK 指標

### <a name="return-value"></a>傳回值

如果找到工具提示控制項, 則為視窗控制項識別碼。 如果找不到工具提示控制項, 則為-1。

### <a name="remarks"></a>備註

如果點位於矩形中, 它會抓取工具的相關資訊。

如果與工具提示相關聯的區域不是按鈕, `OnToolHitTest`會將結構旗標設定為 TTF_NOTBUTTON 和 TTF_CENTERTIP。

覆`OnToolHitTest`寫以提供與預設所提供不同的資訊。

如需結構的詳細資訊, 請參閱 Windows SDK 中的[TOOLINFO](/windows/desktop/api/commctrl/ns-commctrl-tagtoolinfoa)。

##  <a name="ontouchinput"></a>  CWnd::OnTouchInput

處理來自 Windows 觸控的單一輸入。

```
virtual BOOL OnTouchInput(
    CPoint pt,
    int nInputNumber,
    int nInputsCount,
    PTOUCHINPUT pInput);
```

### <a name="parameters"></a>參數

*pt*<br/>
觸及螢幕的點 (以工作區座標表示)。

*nInputNumber*<br/>
觸控輸入的數目。

*nInputsCount*<br/>
觸控輸入的總次數。

*pInput*<br/>
TOUCHINPUT 結構的指標。

### <a name="return-value"></a>傳回值

如果應用程式處理 Windows 觸控輸入, 則為 TRUE;否則為 FALSE。

### <a name="remarks"></a>備註

##  <a name="ontouchinputs"></a>  CWnd::OnTouchInputs

處理來自 Windows touch 的輸入。

```
virtual BOOL OnTouchInputs(
    UINT nInputsCount,
    PTOUCHINPUT pInputs);
```

### <a name="parameters"></a>參數

*nInputsCount*<br/>
Windows 觸控輸入的總數。

*pInputs*<br/>
TOUCHINPUT 的陣列。

### <a name="return-value"></a>傳回值

如果應用程式處理 Windows 觸控輸入, 則為 TRUE;否則為 FALSE。

### <a name="remarks"></a>備註

##  <a name="onunichar"></a>  CWnd::OnUniChar

當按下按鍵時, 架構會呼叫這個成員函式。 也就是說, 目前視窗具有鍵盤焦點, 而[WM_KEYDOWN](/windows/desktop/inputdev/wm-keydown)訊息則是由[TranslateMessage](/windows/desktop/api/winuser/nf-winuser-translatemessage)函數轉譯。

```
afx_msg void OnUniChar(
    UINT nChar,
    UINT nRepCnt,
    UINT nFlags);
```

### <a name="parameters"></a>參數

|參數|描述|
|---------------|-----------------|
|*nChar*|在指定按下之按鍵的字元碼。|
|*nRepCnt*|在指定目前訊息的重複計數。 這個值是使用者按住按鍵後, autorepeated 按鍵的次數。 如果按鍵夠長, 就會傳送多則訊息。 不過, 重複計數不是累計的。|
|*nFlags*|在指定掃描碼、擴充金鑰、內容代碼、先前的索引鍵狀態和轉換狀態的旗標, 如下表所示:<br /><br /> **0-7:** 指定掃描程式碼。 此值取決於原始設備製造商 (OEM)。<br /><br /> **8**指定擴充的索引鍵, 例如在增強的101或102鍵鍵盤上出現的右 ALT 和 CTRL 鍵。 如果索引鍵是擴充的索引鍵, 則旗標為 1;否則, 它是0。<br /><br /> **9-12:** 由 Windows 在內部使用。<br /><br /> **十三**指定內容代碼。 如果在按下按鍵時, 會按住 ALT 鍵, 則旗標為 1;否則, 此值為0。<br /><br /> **14**指定先前的索引鍵狀態。 如果金鑰在傳送訊息之前已關閉, 則旗標為 1, 如果索引鍵已啟動, 則為0。<br /><br /> **次**指定轉換狀態。 如果要釋放金鑰, 旗標會是 1, 如果按下按鍵則為0。|

### <a name="remarks"></a>備註

這個方法會接收[WM_UNICHAR](/windows/desktop/inputdev/wm-unichar)通知, 如 Windows SDK 中所述。 [WM_UNICHAR](/windows/desktop/inputdev/wm-unichar)訊息是設計用來將 Unicode 字元傳送或張貼到 ANSI 視窗。 它相當於[WM_CHAR](/windows/desktop/inputdev/wm-char)訊息, 但使用 Unicode 轉換格式-32 編碼 (UTF-32), 而[WM_CHAR](/windows/desktop/inputdev/wm-char)訊息使用 utf-16。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onuninitmenupopup"></a>  CWnd::OnUnInitMenuPopup

當下拉功能表或子功能表被終結時, 架構會呼叫這個成員函式。

```
afx_msg void OnUnInitMenuPopup(
    CMenu* pPopupMenu,
    UINT nFlags);
```

### <a name="parameters"></a>參數

|參數|描述|
|---------------|-----------------|
|*pMenu*|在代表功能表或子功能表之[CMenu](../../mfc/reference/cmenu-class.md)物件的指標。|
|*nFlags*|在已損毀的功能表。 目前, 它只能是 [視窗] 功能表 [MF_SYSMENU]。|

### <a name="remarks"></a>備註

這個方法會接收[WM_UNINITMENUPOPUP](/windows/desktop/menurc/wm-uninitmenupopup)通知, 如 Windows SDK 中所述。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onupdateuistate"></a>  CWnd::OnUpdateUIState

呼叫以變更指定的視窗及其所有子視窗的使用者介面 (UI) 狀態。

```
afx_msg void OnUpdateUIState(
    UINT nAction,
    UINT nUIElement);
```

### <a name="parameters"></a>參數

*nAction*<br/>
指定要執行的動作。 可為下列其中一個值：

- UIS_CLEAR UI state 元素 (由*nUIElement*指定) 應該隱藏起來。

- UIS_INITIALIZE UI state 元素 (由*nUIElement*指定) 應該根據最後一個輸入事件來變更。 如需詳細資訊, 請參閱[WM_UPDATEISTATE](/windows/desktop/menurc/wm-updateuistate)的「**備註**」一節。

- UIS_SET UI state 元素 (由*nUIElement*指定) 應該是可見的。

*nUIElement*<br/>
指定受影響的 UI 狀態元素或控制項的樣式。 可為下列其中一個值：

- UISF_HIDEACCEL 鍵盤快速鍵。

- UISF_HIDEFOCUS 焦點指標。

- UISF_ACTIVE Windows XP:控制項應以用於現用控制項的樣式繪製。

### <a name="remarks"></a>備註

此成員函式會模擬[WM_UPDATEUISTATE](/windows/desktop/menurc/wm-updateuistate)訊息的功能, 如 Windows SDK 中所述。

##  <a name="onuserchanged"></a>CWnd:: OnUserChanged

架構會在使用者登入或關閉之後, 針對所有視窗呼叫這個成員。

```
afx_msg void OnUserChanged();
```

### <a name="remarks"></a>備註

這個方法會接收[WM_USERCHANGED](/windows/desktop/winmsg/wm-userchanged)通知訊息, 如 Windows SDK 中所述。 當使用者登入或關閉時, 作業系統會更新使用者特定的設定。 系統會在更新設定之後立即傳送此訊息。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onvkeytoitem"></a>  CWnd::OnVKeyToItem

如果物件擁有具有 [LBS_WANTKEYBOARDINPUT](../../mfc/reference/styles-used-by-mfc.md#list-box-styles) 樣式的清單方塊, 則清單方塊會傳送 WM_VKEYTOITEM 訊息以回應 WM_KEYDOWN 訊息。`CWnd`

```
afx_msg int OnVKeyToItem(
    UINT nKey,
    CListBox* pListBox,
    UINT nIndex);
```

### <a name="parameters"></a>參數

*nKey*<br/>
指定使用者按下之金鑰的虛擬按鍵碼。 如需標準虛擬按鍵代碼的清單, 請參閱 Winuser。

*pListBox*<br/>
指定清單方塊的指標。 該指標可能是暫時性的，因此不應該儲存供日後使用。

*nIndex*<br/>
指定目前的插入號位置。

### <a name="return-value"></a>傳回值

指定應用程式為了回應訊息而執行的動作。 傳回值-2 表示應用程式已處理選取專案的所有層面, 而且清單方塊不需要進一步的動作。 傳回值-1 表示清單方塊應執行預設動作以回應按鍵。 傳回值為0或更大, 會指定清單方塊中專案以零為起始的索引, 並指出清單方塊應該對指定專案上的擊鍵執行預設動作。

### <a name="remarks"></a>備註

只有具有[LBS_HASSTRINGS](../../mfc/reference/styles-used-by-mfc.md#list-box-styles)樣式的清單方塊, 才會呼叫這個成員函式。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onvscroll"></a>  CWnd::OnVScroll

當使用者按一下視窗的垂直捲動條時, 架構會呼叫這個成員函式。

```
afx_msg void OnVScroll(
    UINT nSBCode,
    UINT nPos,
    CScrollBar* pScrollBar);
```

### <a name="parameters"></a>參數

*nSBCode*<br/>
指定指出使用者的滾動要求的捲軸程式碼。 這個參數可以是下列其中一項:

- SB_BOTTOM 向下滾動。

- SB_ENDSCROLL 結束捲軸。

- SB_LINEDOWN 向下滾動一行。

- SB_LINEUP 向上滾動一行。

- SB_PAGEDOWN 向下滾動一頁。

- SB_PAGEUP 向上滾動一頁。

- SB_THUMBPOSITION 會滾動到絕對位置。 目前的位置是在*nPos*中提供。

- SB_THUMBTRACK 將捲動方塊拖曳至指定的位置。 目前的位置是在*nPos*中提供。

- SB_TOP 向上滾動。

*nPos*<br/>
如果捲軸程式碼為 SB_THUMBPOSITION 或 SB_THUMBTRACK, 則包含目前的捲動方塊位置。否則不會使用。 視初始捲軸範圍而定, *nPos*可能是負值, 而且應該在必要時轉換成**int** 。

*pScrollBar*<br/>
如果捲軸訊息來自捲軸控制項, 則會包含控制項的指標。 如果使用者已按下視窗的捲軸, 則此參數為 Null。 該指標可能是暫時性的，因此不應該儲存供日後使用。

### <a name="remarks"></a>備註

`OnVScroll`通常是由在拖曳捲動方塊時提供一些意見反應的應用程式所使用。

如果`OnVScroll`滾動`CWnd`物件的內容, 它也必須使用[SetScrollPos](#setscrollpos)成員函式重設捲動方塊的位置。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onvscrollclipboard"></a>  CWnd::OnVScrollClipboard

剪貼簿擁有者`OnVScrollClipboard`的成員函式會在剪貼簿資料具有 CF_OWNERDISPLAY 格式, 而且剪貼簿檢視器的垂直捲動條中有事件時, 由剪貼簿檢視器呼叫。

```
afx_msg void OnVScrollClipboard(
    CWnd* pClipAppWnd,
    UINT nSBCode,
    UINT nPos);
```

### <a name="parameters"></a>參數

*pClipAppWnd*<br/>
指定 剪貼簿檢視器視窗的指標。 該指標可能是暫時性的，因此不應該儲存供日後使用。

*nSBCode*<br/>
指定下列其中一個捲軸值:

- SB_BOTTOM 向下滾動。

- SB_ENDSCROLL 結束捲軸。

- SB_LINEDOWN 向下滾動一行。

- SB_LINEUP 向上滾動一行。

- SB_PAGEDOWN 向下滾動一頁。

- SB_PAGEUP 向上滾動一頁。

- SB_THUMBPOSITION 會滾動到絕對位置。 目前的位置是在*nPos*中提供。

- SB_TOP 向上滾動。

*nPos*<br/>
如果捲軸程式碼為 SB_THUMBPOSITION, 則包含捲動方塊位置。否則不會使用*nPos* 。

### <a name="remarks"></a>備註

擁有者應該滾動剪貼簿影像、使適當的區段失效, 並更新捲軸值。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onwindowmaximizedchanged"></a>CWnd:: OnWindowMaximizedChanged

當目前的視窗最大化時, 架構會呼叫這個成員, 而此視窗是由桌面視窗管理員 (DWM) 所組成。

```
afx_msg void OnWindowMaximizedChanged(BOOL bIsMaximized);
```

### <a name="parameters"></a>參數

|參數|描述|
|---------------|-----------------|
|*bIsMaximized*|在如果目前的視窗最大化, 則為 TRUE, 否則為 FALSE。|

### <a name="remarks"></a>備註

這個方法會接收[WM_DWMWINDOWMAXIMIZEDCHANGE](/windows/desktop/dwm/wm-dwmwindowmaximizedchange)通知訊息, 如 Windows SDK 中所述。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onwindowposchanged"></a>  CWnd::OnWindowPosChanged

當大小、位置或迭置順序因呼叫[SetWindowPos](/windows/desktop/api/winuser/nf-winuser-setwindowpos)成員函式或其他視窗管理功能而變更時, 架構會呼叫這個成員函式。

```
afx_msg void OnWindowPosChanged(WINDOWPOS* lpwndpos);
```

### <a name="parameters"></a>參數

*lpwndpos*<br/>
指向[WINDOWPOS](/windows/desktop/api/winuser/ns-winuser-tagwindowpos)資料結構, 其中包含視窗新大小和位置的相關資訊。

### <a name="remarks"></a>備註

預設的執行會將[WM_SIZE](/windows/desktop/winmsg/wm-size)和[WM_MOVE](/windows/desktop/winmsg/wm-move)訊息傳送至視窗。 如果應用程式在`OnWindowPosChanged`未呼叫其基類的情況下處理呼叫, 則不會傳送這些訊息。 在呼叫`OnWindowPosChanged`期間執行任何移動或大小變更處理, 而不需要呼叫其基類, 會更有效率。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onwindowposchanging"></a>CWnd:: OnWindowPosChanging

當大小、位置或迭置順序即將因呼叫[SetWindowPos](/windows/desktop/api/winuser/nf-winuser-setwindowpos)成員函式或其他視窗管理功能而變更時, 架構會呼叫這個成員函式。

```
afx_msg void OnWindowPosChanging(WINDOWPOS* lpwndpos);
```

### <a name="parameters"></a>參數

*lpwndpos*<br/>
`WINDOWPOS`指向資料結構, 其中包含視窗新大小和位置的相關資訊。

### <a name="remarks"></a>備註

應用程式可以藉由在[WINDOWPOS](/windows/desktop/api/winuser/ns-winuser-tagwindowpos)結構的**flags**成員中設定或清除適當的位, 來防止變更視窗。

針對具有[WS_OVERLAPPED](styles-used-by-mfc.md#window-styles)或[WS_THICKFRAME](styles-used-by-mfc.md#window-styles)樣式的視窗, 預設的執行會將[WM_GETMINMAXINFO](/windows/desktop/winmsg/wm-getminmaxinfo)訊息傳送至視窗。 這是為了驗證視窗的新大小和位置, 以及強制執行 CS_BYTEALIGNCLIENT 和 CS_BYTEALIGN 用戶端樣式而完成。 應用程式可以藉由不呼叫其基類來覆寫這項功能。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onwininichange"></a>  CWnd::OnWinIniChange

架構會在對 Windows 初始化檔進行變更之後呼叫這個成員函式, WIN.INI.

```
afx_msg void OnWinIniChange(LPCTSTR lpszSection);
```

### <a name="parameters"></a>參數

*lpszSection*<br/>
指向字串, 指定已變更之區段的名稱。 (此字串不包含用來括住區段名稱的方括弧)。

### <a name="remarks"></a>備註

在應用程式使用函`OnWinIniChange`式來變更 WIN 中的設定之後, [SystemParametersInfo](/windows/desktop/api/winuser/nf-winuser-systemparametersinfoa) Windows 函數會呼叫。INI 檔案。

若要將 WM_WININICHANGE 訊息傳送至所有最上層視窗, 應用程式可以使用[SendMessage](/windows/desktop/api/winuser/nf-winuser-sendmessage) windows 函數, 並將其*hwnd*參數設定為 HWND_BROADCAST。

如果應用程式變更 WIN 中的許多不同區段。INI 時, 應用程式應該傳送一個 WM_WININICHANGE 訊息, 並將*lpszSection*設定為 Null。 否則, 應用程式應該在每次進行變更時傳送 WM_WININICHANGE.INI.

如果應用程式接收`OnWinIniChange`到*lpszSection*設定為 Null 的呼叫, 應用程式應該檢查 WIN 中的所有區段。會影響應用程式的 INI。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onwndmsg"></a>  CWnd::OnWndMsg

這個成員函式是由`WindowProc`所呼叫, 或在訊息反映期間呼叫。

```
virtual BOOL OnWndMsg(
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    LRESULT* pResult);
```

### <a name="parameters"></a>參數

*message*<br/>
指定要傳送的訊息。

*wParam*<br/>
指定與訊息相關的其他資訊。

*lParam*<br/>
指定與訊息相關的其他資訊。

*pResult*<br/>
[WindowProc](#windowproc)的傳回值。 視訊息而定。可能是 Null。

### <a name="return-value"></a>傳回值

如果已處理訊息, 則為 TRUE;否則為 FALSE。

### <a name="remarks"></a>備註

`OnWndMsg`判斷訊息類型, 並呼叫適當的架構函式 (例如, WM_COMMAND 的[OnCommand](#oncommand) ), 或在訊息對應中尋找適當的訊息。

如需訊息反映的詳細資訊, 請參閱[處理反映的訊息](../../mfc/handling-reflected-messages.md)。

##  <a name="onxbuttondblclk"></a>  CWnd::OnXButtonDblClk

當使用者按兩下 XBUTTON1 或 XBUTTON2, 而游標位於視窗的工作區時, 架構會呼叫這個成員函式。

```
afx_msg void OnXButtonDblClk(
    UINT nFlags,
    UINT nButton,
    CPoint point);
```

### <a name="parameters"></a>參數

|參數|描述|
|---------------|-----------------|
|*nFlags*|在旗標的位元組合 (OR), 指出所按的輔助按鍵。 例如, MK_CONTROL 旗標表示已按下 CTRL 鍵。|
|*nButton*|在如果按兩下第一個 Microsoft 的 [全選] X 按鈕, 則為 XBUTTON1 的值, 如果按兩下第二個 X 按鈕, 則為 XBUTTON2。|
|*point*|在[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)物件, 指定相對於工作區左上角之游標的*x*和*y*座標。|

### <a name="remarks"></a>備註

這個方法會接收[WM_XBUTTONDBLCLK](/windows/desktop/inputdev/wm-xbuttondblclk)通知, 如 Windows SDK 中所述。 如果未捕捉到滑鼠, 訊息就會張貼到游標下方的視窗中。 否則, 訊息就會張貼到已捕獲滑鼠的視窗中。

*NFlags*參數可以是下表所列輔助按鍵的組合。 如需詳細資訊, 請參閱[關於滑鼠輸入](/windows/desktop/inputdev/about-mouse-input)。

|輔助按鍵|描述|
|------------------|-----------------|
|MK_CONTROL|CTRL 鍵已按下。|
|MK_LBUTTON|滑鼠左鍵已按下。|
|MK_MBUTTON|按下滑鼠鍵。|
|MK_RBUTTON|滑鼠右鍵已按下。|
|MK_SHIFT|SHIFT 鍵已按下。|
|MK_XBUTTON1|Microsoft 智慧按鈕的 [XBUTTON1 滑鼠] 按鈕已按下。|
|MK_XBUTTON2|Microsoft 智慧按鈕的 [XBUTTON2 滑鼠] 按鈕已按下。|

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onxbuttondown"></a>  CWnd::OnXButtonDown

當使用者按下 XBUTTON1 或 XBUTTON2, 而游標位於視窗的工作區時, 架構會呼叫這個成員函式。

```
afx_msg void OnXButtonDown(
    UINT nFlags,
    UINT nButton,
    CPoint point);
```

### <a name="parameters"></a>參數

|參數|說明|
|---------------|-----------------|
|*nFlags*|在旗標的位元組合 (OR), 指出所按的輔助按鍵。 例如, MK_CONTROL 旗標表示已按下 CTRL 鍵。|
|*nButton*|在如果已按下第一個 Microsoft 的 [滑鼠] [X] 按鈕, 則為 XBUTTON1 的值, 如果按一下第二個 X 按鈕, 則為 XBUTTON2。|
|*point*|在[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)物件, 指定相對於工作區左上角之游標的*x*和*y*座標。|

### <a name="remarks"></a>備註

這個方法會接收[WM_XBUTTONDOWN](/windows/desktop/inputdev/wm-xbuttondown)通知, 如 Windows SDK 中所述。 如果未捕捉到滑鼠, 訊息就會張貼到游標下方的視窗中。 否則, 訊息就會張貼到已捕獲滑鼠的視窗中。

*NFlags*參數可以是下表所列輔助按鍵的組合。 如需詳細資訊, 請參閱[關於滑鼠輸入](/windows/desktop/inputdev/about-mouse-input)。

|輔助按鍵|描述|
|------------------|-----------------|
|MK_CONTROL|CTRL 鍵已按下。|
|MK_LBUTTON|滑鼠左鍵已按下。|
|MK_MBUTTON|按下滑鼠鍵。|
|MK_RBUTTON|滑鼠右鍵已按下。|
|MK_SHIFT|SHIFT 鍵已按下。|
|MK_XBUTTON1|Microsoft 智慧按鈕的 [XBUTTON1 滑鼠] 按鈕已按下。|
|MK_XBUTTON2|Microsoft 智慧按鈕的 [XBUTTON2 滑鼠] 按鈕已按下。|

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onxbuttonup"></a>  CWnd::OnXButtonUp

當使用者釋放 XBUTTON1 或 XBUTTON2, 而游標位於視窗的工作區時, 架構會呼叫這個成員函式。

```
afx_msg void OnXButtonUp(
    UINT nFlags,
    UINT nButton,
    CPoint point);
```

### <a name="parameters"></a>參數

|參數|描述|
|---------------|-----------------|
|*nFlags*|在旗標的位元組合 (OR), 指出所按的輔助按鍵。 例如, MK_CONTROL 旗標表示已按下 CTRL 鍵。|
|*nButton*|在如果按兩下第一個 Microsoft 的 [全選] X 按鈕, 則為 XBUTTON1 的值, 如果按兩下第二個 X 按鈕, 則為 XBUTTON2。|
|*point*|在[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)物件, 指定相對於工作區左上角之游標的*x*和*y*座標。|

### <a name="remarks"></a>備註

這個方法會接收[WM_XBUTTONUP](/windows/desktop/inputdev/wm-xbuttonup)通知, 如 Windows SDK 中所述。 如果未捕捉到滑鼠, 訊息就會張貼到游標下方的視窗中。 否則, 訊息就會張貼到已捕獲滑鼠的視窗中。

*NFlags*參數可以是下表所列輔助按鍵的組合。 如需詳細資訊, 請參閱[關於滑鼠輸入](/windows/desktop/inputdev/about-mouse-input)。

|輔助按鍵|描述|
|------------------|-----------------|
|MK_CONTROL|CTRL 鍵已按下。|
|MK_LBUTTON|滑鼠左鍵已按下。|
|MK_MBUTTON|按下滑鼠鍵。|
|MK_RBUTTON|滑鼠右鍵已按下。|
|MK_SHIFT|SHIFT 鍵已按下。|
|MK_XBUTTON1|Microsoft 智慧按鈕的 [XBUTTON1 滑鼠] 按鈕已按下。|
|MK_XBUTTON2|Microsoft 智慧按鈕的 [XBUTTON2 滑鼠] 按鈕已按下。|

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="openclipboard"></a>CWnd:: OpenClipboard

開啟剪貼簿。

```
BOOL OpenClipboard();
```

### <a name="return-value"></a>傳回值

如果透過開啟剪貼簿，則為非零`CWnd`，或 0，如果另一個應用程式或視窗有 剪貼簿開啟。

### <a name="remarks"></a>備註

在呼叫[CloseClipboard](/windows/desktop/api/winuser/nf-winuser-closeclipboard) Windows 函數之前, 其他應用程式將無法修改剪貼簿。

在呼叫`CWnd` [EmptyClipboard](/windows/desktop/api/winuser/nf-winuser-emptyclipboard) Windows 函數之前, 目前的物件將不會成為剪貼簿的擁有者。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#111](../../mfc/reference/codesnippet/cpp/cwnd-class_52.cpp)]

##  <a name="operator_hwnd"></a>CWnd:: operator HWND

使用這個運算子取得`CWnd`物件的控制碼。

```
operator HWND() const;
```

##  <a name="operator_neq"></a>CWnd:: operator! =

比較兩`CWnd`個物件, 判斷它們是否沒有相同的[m_hWnd](#m_hwnd)。

```
BOOL operator!=(const CWnd& wnd) const;
```

### <a name="parameters"></a>參數

*wnd<>*<br/>
對 `CWnd` 物件的參考。

### <a name="return-value"></a>傳回值

如果等於則為非零值;否則為0。

##  <a name="operator_eq_eq"></a>CWnd:: operator = =

比較兩`CWnd`個物件, 以判斷它們是否具有相同的[m_hWnd](#m_hwnd)。

```
BOOL operator==(const CWnd& wnd) const;
```

### <a name="parameters"></a>參數

*wnd<>*<br/>
對 `CWnd` 物件的參考。

### <a name="return-value"></a>傳回值

如果等於則為非零值;否則為0。

##  <a name="paintwindowlesscontrols"></a>  CWnd::PaintWindowlessControls

在控制項容器上繪製無視窗控制項。

```
BOOL PaintWindowlessControls(CDC* pDC);
```

### <a name="parameters"></a>參數

*pDC*<br/>
要在其上繪製無視窗控制項的裝置內容。

### <a name="return-value"></a>傳回值

如果有控制項容器, 而且已成功繪製無視窗控制項, 則傳回 TRUE, 否則傳回 FALSE。

##  <a name="postmessage"></a>  CWnd::PostMessage

將訊息放在視窗的訊息佇列中, 然後傳回而不等待對應的視窗處理訊息。

```
BOOL PostMessage(
    UINT message,
    WPARAM wParam = 0,
    LPARAM lParam = 0);
```

### <a name="parameters"></a>參數

*message*<br/>
指定要張貼的訊息。

*wParam*<br/>
指定其他訊息資訊。 此參數的內容取決於要張貼的訊息。

*lParam*<br/>
指定其他訊息資訊。 此參數的內容取決於要張貼的訊息。

### <a name="return-value"></a>傳回值

如果訊息已張貼, 則為非零值;否則為0。

### <a name="remarks"></a>備註

訊息佇列中的訊息是透過呼叫[GetMessage](/windows/desktop/api/winuser/nf-winuser-getmessage)或[PeekMessage](/windows/desktop/api/winuser/nf-winuser-peekmessagea) Windows 函數來抓取。

Windows [PostMessage](/windows/desktop/api/winuser/nf-winuser-postmessagea)函數可用來存取另一個應用程式。

### <a name="example"></a>範例

  請參閱[AfxGetMainWnd](../../mfc/reference/application-information-and-management.md#afxgetmainwnd)的範例。

##  <a name="postncdestroy"></a>  CWnd::PostNcDestroy

在終結視窗之後, 由預設的[OnNcDestroy](#onncdestroy)成員函式呼叫。

```
virtual void PostNcDestroy();
```

### <a name="remarks"></a>備註

衍生類別可以將此函式用於自訂清除, 例如刪除**this**指標。

##  <a name="precreatewindow"></a>  CWnd::PreCreateWindow

在建立附加至這個`CWnd`物件的 Windows 視窗之前, 由架構呼叫。

```
virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
```

### <a name="parameters"></a>參數

*cs*<br/>
[CREATESTRUCT](/windows/desktop/api/winuser/ns-winuser-tagcreatestructa)結構。

### <a name="return-value"></a>傳回值

如果應該繼續建立視窗, 則為非零值;0表示建立失敗。

### <a name="remarks"></a>備註

> [!WARNING]
> `CWnd::PreCreateWindow`現在, 如果功能表為 Null, 且樣式包含 WS_CHILD, 則將*cs*的 hMenu 成員指派給**this**指標。 如需適當的功能, 請確定您的對話方塊控制項具有不是 Null 的識別碼。
>
> 這項變更會修正 managed/原生 interop 案例中的損毀。 中`CWnd::Create`的追蹤語句會警示問題的開發人員。

永遠不要直接呼叫此函式。

此函式的預設實作用會檢查 Null 視窗類別名稱, 並替代適當的預設值。 覆寫這個成員函式, `CREATESTRUCT`以在建立視窗之前修改結構。

衍生自`CWnd`的每個類別都會將自己的功能加入`PreCreateWindow`其覆寫。 根據設計, 這些衍生的`PreCreateWindow`並未記載。 若要判斷適用于每個類別的樣式, 以及樣式之間的相互相關性, 您可以檢查應用程式基類的 MFC 原始程式碼。 如果您選擇覆寫`PreCreateWindow,` , 您可以判斷應用程式的基類中使用的樣式是否提供您使用從 MFC 原始程式碼收集的資訊所需的功能。

如需變更視窗樣式的詳細資訊, 請參閱[變更 MFC 所建立之視窗的樣式](../../mfc/changing-the-styles-of-a-window-created-by-mfc.md)。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#112](../../mfc/reference/codesnippet/cpp/cwnd-class_53.cpp)]

##  <a name="presubclasswindow"></a>  CWnd::PreSubclassWindow

此成員函式是由架構呼叫, 以允許其他必要子類別化, 然後再子類別化視窗。

```
virtual void PreSubclassWindow();
```

### <a name="remarks"></a>備註

覆寫這個成員函式可讓控制項的動態子類別化。 它是一個先進的可覆寫。

##  <a name="pretranslatemessage"></a>  CWnd::PreTranslateMessage

[CWinApp](../../mfc/reference/cwinapp-class.md) 類別用來轉譯分派至 [TranslateMessage](/windows/desktop/api/winuser/nf-winuser-translatemessage) 和 [DispatchMessage](/windows/desktop/api/winuser/nf-winuser-dispatchmessage) Windows 函式之前的視窗訊息。

```
virtual BOOL PreTranslateMessage(MSG* pMsg);
```

### <a name="parameters"></a>參數

*pMsg*<br/>
指向包含要處理之訊息的[MSG](/windows/desktop/api/winuser/ns-winuser-tagmsg)結構。

### <a name="return-value"></a>傳回值

如果訊息已轉譯而不應分派, 則為非零值;如果訊息未轉譯且應分派, 則為0。

##  <a name="print"></a>  CWnd::Print

呼叫這個成員函式, 在指定的裝置內容中繪製目前的視窗, 最常見的是印表機裝置內容。

```
void Print(
    CDC* pDC,
    DWORD dwFlags) const;
```

### <a name="parameters"></a>參數

*pDC*<br/>
裝置內容的指標。

*dwFlags*<br/>
指定繪圖選項。 這個參數可以是下列其中一個或多個旗標:

- PRF_CHECKVISIBLE 只有在可見時才繪製視窗。

- PRF_CHILDREN 繪製所有可見的子視窗。

- PRF_CLIENT 繪製視窗的工作區。

- PRF_ERASEBKGND 會先清除背景, 再繪製視窗。

- PRF_NONCLIENT 繪製視窗的非工作區。

- PRF_OWNED 繪製所有擁有的視窗。

### <a name="remarks"></a>備註

[CWnd::D efwindowproc](#defwindowproc)函數會根據指定的繪製選項來處理此訊息:

- 如果已指定 PRF_CHECKVISIBLE, 而且沒有顯示視窗, 則不執行任何動作。

- 如果指定 PRF_NONCLIENT, 請在指定的裝置內容中繪製非工作區。

- 如果指定 PRF_ERASEBKGND, 請將[WM_ERASEBKGND](/windows/desktop/winmsg/wm-erasebkgnd)訊息傳送給視窗。

- 如果指定 PRF_CLIENT, 請將[WM_PRINTCLIENT](/windows/desktop/gdi/wm-printclient)訊息傳送給視窗。

- 如果已設定 PRF_CHILDREN, 請將[WM_PRINT](/windows/desktop/gdi/wm-print)訊息傳送給每個可見的子視窗。

- 如果已設定 PRF_OWNED, 則傳送每個可見的擁有視窗 WM_PRINT 訊息。

##  <a name="printclient"></a>  CWnd::PrintClient

呼叫這個成員函式可在指定的裝置內容中繪製任何視窗 (通常是印表機裝置內容)。

```
void PrintClient(
    CDC* pDC,
    DWORD dwFlags) const;
```

### <a name="parameters"></a>參數

*pDC*<br/>
裝置內容的指標。

*dwFlags*<br/>
指定繪圖選項。 這個參數可以是下列其中一個或多個旗標:

- PRF_CHECKVISIBLE 只有在可見時才繪製視窗。

- PRF_CHILDREN 繪製所有可見的子視窗。

- PRF_CLIENT 繪製視窗的工作區。

- PRF_ERASEBKGND 會先清除背景, 再繪製視窗。

- PRF_NONCLIENT 繪製視窗的非工作區。

- PRF_OWNED 繪製所有擁有的視窗。

##  <a name="printwindow"></a>  CWnd::PrintWindow

將視覺視窗複製到指定的裝置內容，通常是印表機 DC。

```
BOOL PrintWindow(
    CDC* pDC,
    UINT nFlags) const;
```

### <a name="parameters"></a>參數

*pDC*<br/>
要列印到之裝置內容的指標。

*nFlags*<br/>
指定繪圖選項。 如需可能值的清單, 請參閱[PrintWindow](/windows/desktop/api/winuser/nf-winuser-printwindow)。

### <a name="return-value"></a>傳回值

如果函式成功則為非零值，否則為 0。

### <a name="remarks"></a>備註

此成員函式會模擬函數[PrintWindow](/windows/desktop/api/winuser/nf-winuser-printwindow)的功能, 如 Windows SDK 中所述。

##  <a name="redrawwindow"></a>  CWnd::RedrawWindow

更新給定視窗的工作區中指定的矩形或區域。

```
BOOL RedrawWindow(
    LPCRECT lpRectUpdate = NULL,
    CRgn* prgnUpdate = NULL,
    UINT flags = RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE);
```

### <a name="parameters"></a>參數

*lpRectUpdate*<br/>
指向包含更新矩形座標的[矩形結構](/windows/desktop/api/windef/ns-windef-tagrect)。 如果*prgnUpdate*包含有效的區域控制碼, 則會忽略這個參數。

*prgnUpdate*<br/>
識別更新區域。 如果*prgnUpdate*和*LPRECTUPDATE*都是 Null, 則會將整個工作區新增至更新區域。

*flags*<br/>
下列旗標用來使視窗失效:

- RDW_ERASE 會在重新繪製視窗時, 讓視窗接收[WM_ERASEBKGND](/windows/desktop/winmsg/wm-erasebkgnd)訊息。 您也必須指定 RDW_INVALIDATE 旗標;否則 RDW_ERASE 不會有任何作用。

- RDW_FRAME 會使視窗中非工作區的任何部分與更新區域相交, 以接收[WM_NCPAINT](/windows/desktop/gdi/wm-ncpaint)訊息。 您也必須指定 RDW_INVALIDATE 旗標;否則 RDW_FRAME 不會有任何作用。

- 無論視窗是否包含不正確區域, RDW_INTERNALPAINT 都會使[WM_PAINT](/windows/desktop/gdi/wm-paint)訊息張貼至視窗。

- RDW_INVALIDATE 會使*lpRectUpdate*或*prgnUpdate*失效 (只有一個可能不是 Null)。 如果兩者都是 Null, 則整個視窗都會失效。

下列旗標是用來驗證視窗:

- RDW_NOERASE 會隱藏任何暫止的 WM_ERASEBKGND 訊息。

- RDW_NOFRAME 會隱藏任何暫止的 WM_NCPAINT 訊息。 這個旗標必須與 RDW_VALIDATE 搭配使用, 而且通常與 RDW_NOCHILDREN 搭配使用。 此選項應謹慎使用, 因為它可能會使視窗的部分無法正確繪製。

- RDW_NOINTERNALPAINT 會隱藏任何暫止的內部 WM_PAINT 訊息。 此旗標不會影響因無效區域而產生的 WM_PAINT 訊息。

- RDW_VALIDATE 會驗證*lpRectUpdate*或*prgnUpdate* (只有一個可能不是 Null)。 如果兩者都是 Null, 則會驗證整個視窗。 此旗標不會影響內部 WM_PAINT 訊息。

發生重新繪製時的下列旗標控制項。 除非指定了其中一個位`RedrawWindow` , 否則函數不會執行繪製。

- RDW_ERASENOW 會在函式傳回之前, 讓受影響的視窗 (如 RDW_ALLCHILDREN 和 RDW_NOCHILDREN 旗標所指定) 接收 WM_NCPAINT 和 WM_ERASEBKGND 訊息。 WM_PAINT 訊息會延遲。

- RDW_UPDATENOW 會在函式傳回之前, 讓受影響的視窗 (如 RDW_ALLCHILDREN 和 RDW_NOCHILDREN 旗標所指定) 接收 WM_NCPAINT、WM_ERASEBKGND 和 WM_PAINT 訊息。

根據預設, 受函式影響`RedrawWindow`的 windows 取決於指定的視窗是否具有 WS_CLIPCHILDREN 樣式。 WS_CLIPCHILDREN 視窗的子視窗不受影響。 不過, WS_CLIPCHILDREN 視窗以外的視窗會以遞迴方式進行驗證或失效, 直到遇到 WS_CLIPCHILDREN 視窗為止。 下列旗標可控制哪些視窗會受到`RedrawWindow`函數影響:

- RDW_ALLCHILDREN 包含重新繪製作業中的子視窗 (如果有的話)。

- RDW_NOCHILDREN 會從重新繪製作業排除子視窗 (如果有的話)。

### <a name="return-value"></a>傳回值

如果已成功重新繪製視窗, 則為非零;否則為0。

### <a name="remarks"></a>備註

當成員函式用來使部分的桌面視窗失效時, 該視窗不會收到 [WM_PAINT](/windows/desktop/gdi/wm-paint) 訊息。`RedrawWindow` 若要重新繪製桌面, 應用程式應該使用[CWnd:: ValidateRgn](#validatergn)、 [Cwnd:: InvalidateRgn](#invalidatergn)、 [CWnd:: UpdateWindow](#updatewindow)或[RedrawWindow](/windows/desktop/api/winuser/nf-winuser-redrawwindow)

##  <a name="reflectchildnotify"></a>CWnd:: ReflectChildNotify

此訊息函式是由[OnChildNotify](#onchildnotify)的架構所呼叫。

```
BOOL ReflectChildNotify(
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    LRESULT* pResult);
```

### <a name="parameters"></a>參數

*message*<br/>
指定要反映的訊息。

*wParam*<br/>
指定與訊息相關的其他資訊。

*lParam*<br/>
指定與訊息相關的其他資訊。

*pResult*<br/>
子視窗所產生的結果, 由父視窗傳回。 可以是 Null。

### <a name="return-value"></a>傳回值

如果已反映訊息, 則為 TRUE;否則為 FALSE。

### <a name="remarks"></a>備註

它是可反映*訊息*至其來源的 helper 函式。

反映的訊息會直接傳送至[CWnd:: OnWndMsg](#onwndmsg)或[CCmdTarget:: OnCmdMsg](../../mfc/reference/ccmdtarget-class.md#oncmdmsg)。

如需訊息反映的詳細資訊, 請參閱[處理反映的訊息](../../mfc/handling-reflected-messages.md)。

##  <a name="reflectlastmsg"></a>  CWnd::ReflectLastMsg

此成員函式是由架構呼叫, 以反映最後一則訊息到子視窗。

```
static BOOL PASCAL ReflectLastMsg(
    HWND hWndChild,
    LRESULT* pResult = NULL);
```

### <a name="parameters"></a>參數

*hWndChild*<br/>
子視窗的控制碼。

*pResult*<br/>
子視窗所產生的結果, 由父視窗傳回。 可以是 Null。

### <a name="return-value"></a>傳回值

如果已處理訊息, 則為非零。否則為0。

### <a name="remarks"></a>備註

如果*hWndChild*所識別的視窗是永久對應中的 OLE 控制項或視窗, 則此成員函式會呼叫[SendChildNotifyLastMsg](#sendchildnotifylastmsg) 。

如需訊息反映的詳細資訊, 請參閱[處理反映的訊息](../../mfc/handling-reflected-messages.md)。

##  <a name="releasedc"></a>  CWnd::ReleaseDC

釋放裝置內容, 釋放它供其他應用程式使用。

```
int ReleaseDC(CDC* pDC);
```

### <a name="parameters"></a>參數

*pDC*<br/>
識別要釋放的裝置內容。

### <a name="return-value"></a>傳回值

如果成功則為非零；否則為 0。

### <a name="remarks"></a>備註

`ReleaseDC`成員函式的效果取決於裝置內容類型。

應用程式必須在每`ReleaseDC`次呼叫[GetWindowDC](#getwindowdc)成員函式, 以及每次呼叫[GetDC](#getdc)成員函式時, 呼叫成員函式。

##  <a name="repositionbars"></a>CWnd:: RepositionBars

呼叫以在視窗的工作區中重新置放和調整控制列的大小。

```
void RepositionBars(UINT nIDFirst,
    UINT nIDLast,
    UINT nIDLeftOver,
    UINT nFlag = reposDefault,
    LPRECT lpRectParam = NULL,
    LPCRECT lpRectClient = NULL,
    BOOL bStretch = TRUE) ;
```

### <a name="parameters"></a>參數

*nIDFirst*<br/>
要重新置放和調整大小之控制列範圍中第一個的識別碼。

*nIDLast*<br/>
要重新置放和調整大小之控制列範圍中最後一個的識別碼。

*nIDLeftOver*<br/>
指定用來填滿其餘的工作區 窗格的識別碼。

*nFlag*<br/>
可以具有下列其中一個值:

- `CWnd::reposDefault`執行控制列的版面配置。 不使用*lpRectParam* , 而且可以是 Null。

- `CWnd::reposQuery`控制列的配置不會完成;相反地, *lpRectParam*會使用工作區的大小進行初始化, 如同已實際完成配置一樣。

- `CWnd::reposExtra`將*lpRectParam*的值加入至*nIDLast*的工作區, 也會執行版面配置。

*lpRectParam*<br/>
指向[矩形結構](/windows/desktop/api/windef/ns-windef-tagrect);的使用方式取決於*nFlag*的值。

*lpRectClient*<br/>
指向包含可用工作區的[矩形結構](/windows/desktop/api/windef/ns-windef-tagrect)。 如果是 Null, 則會使用視窗的工作區。

*bStretch*<br/>
指出是否要將橫條延展到框架的大小。

### <a name="remarks"></a>備註

*NIDFirst*和*nIDLast*參數會定義要在工作區中重新置放的控制列識別碼範圍。 *NIDLeftOver*參數會指定子視窗 (通常是視圖) 的識別碼, 它會重新置放和調整大小, 以填滿控制列未填滿的工作區的其餘部分。

##  <a name="runmodalloop"></a>  CWnd::RunModalLoop

呼叫這個成員函式來抓取、轉譯或分派訊息, 直到[ContinueModal](#continuemodal)傳回 FALSE 為止。

```
int RunModalLoop(DWORD dwFlags = 0);
```

### <a name="parameters"></a>參數

*dwFlags*<br/>
指定要傳送的 Windows 訊息。 可為下列其中一個值：

- MLF_NOIDLEMSG 不會將[WM_ENTERIDLE](/windows/desktop/dlgbox/wm-enteridle)訊息傳送到父系。

- MLF_NOKICKIDLE 不會將 WM_KICKIDLE 訊息傳送至視窗。

- MLF_SHOWONIDLE 會在訊息佇列閒置時顯示視窗。

### <a name="return-value"></a>傳回值

指定傳遞給[EndModalLoop](#endmodalloop)成員函式的*n 結果*參數值, 然後用它來結束強制回應迴圈。

### <a name="remarks"></a>備註

根據預設, `ContinueModal`會在呼叫`EndModalLoop`之後傳回 FALSE。 傳回提供給`EndModalLoop`的*n 結果*值。

##  <a name="screentoclient"></a>CWnd:: ScreenToClient

將畫面上指定的點或矩形的螢幕座標，轉換為用戶端座標。

```
void ScreenToClient(LPPOINT lpPoint) const;  void ScreenToClient(LPRECT lpRect) const;
```

### <a name="parameters"></a>參數

*lpPoint*<br/>
指向[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)物件或[點結構](/windows/desktop/api/windef/ns-windef-tagpoint), 其中包含要轉換的螢幕座標。

*lpRect*<br/>
指向[CRect](../../atl-mfc-shared/reference/crect-class.md)物件或[矩形結構](/windows/desktop/api/windef/ns-windef-tagrect), 其中包含要轉換的螢幕座標。

### <a name="remarks"></a>備註

此`ScreenToClient`成員函式會以用戶端座標取代*lpPoint*或*lpRect*中所指定的螢幕座標。 新的座標會相對於`CWnd`工作區的左上角。

### <a name="example"></a>範例

  請參閱[CListCtrl:: GetItemRect](../../mfc/reference/clistctrl-class.md#getitemrect)的範例。

##  <a name="scrollwindow"></a>  CWnd::ScrollWindow

滾動目前`CWnd`物件之工作區的內容。

```
void ScrollWindow(
    int xAmount,
    int yAmount,
    LPCRECT lpRect = NULL,
    LPCRECT lpClipRect = NULL);
```

### <a name="parameters"></a>參數

*xAmount*<br/>
指定水準滾動的數量 (以裝置為單位)。 這個參數必須是負數值, 才能向左滾動。

*yAmount*<br/>
指定垂直捲動的數量 (以裝置為單位)。 這個參數必須是要向上滾動的負值。

*lpRect*<br/>
指向[CRect](../../atl-mfc-shared/reference/crect-class.md)物件或[RECT 結構](/windows/desktop/api/windef/ns-windef-tagrect), 指定要滾動的工作區部分。 如果*lpRect*為 Null, 則會滾動整個工作區。 如果游標矩形與捲軸矩形相交, 插入號就會重新置放。

*lpClipRect*<br/>
指向物件或`RECT`結構, 指定要滾動的裁剪矩形。 `CRect` 只有這個矩形內的位會進行滾動。 這個矩形外的位不會受到影響, 即使它們位於*lpRect*矩形中也一樣。 如果*lpClipRect*為 Null, 則不會在捲軸矩形上執行任何裁剪。

### <a name="remarks"></a>備註

如果插入號是在滾動`CWnd`中, 會`ScrollWindow`自動隱藏插入號, 以防止它被清除, 然後在捲軸完成後還原插入號。 插入號位置會據以調整。

`ScrollWindow`成員函式所發現的區域不會重新繪製, 而是會合並`CWnd`到目前物件的更新區域。 應用程式最後會收到[WM_PAINT](/windows/desktop/gdi/wm-paint)訊息, 通知它該區域需要重新繪製。 若要在完成滾動時重新繪製未發現的區域, 請在呼叫 `ScrollWindow`之後立即呼叫 [UpdateWindow](#updatewindow) 成員函式。

如果*lpRect*為 Null, 則視窗中任何子視窗的位置都會以*xAmount*和*yAmount*所指定的數量來位移, 而且中的`CWnd`任何無效 (未上色) 區域也會位移。 `ScrollWindow`當*lpRect*為 Null 時, 會更快。

如果*lpRect*不是 Null, 則不會變更子視窗的位置, 而且中`CWnd`的無效區域也不會位移。 若要在*lpRect*不是 Null 時避免更新問題, `UpdateWindow`請在呼叫`ScrollWindow`之前`CWnd`呼叫成員函式以重新繪製。

##  <a name="scrollwindowex"></a>  CWnd::ScrollWindowEx

滾動視窗的工作區內容。

```
int ScrollWindowEx(
    int dx,
    int dy,
    LPCRECT lpRectScroll,
    LPCRECT lpRectClip,
    CRgn* prgnUpdate,
    LPRECT lpRectUpdate,
    UINT flags);
```

### <a name="parameters"></a>參數

*dx*<br/>
指定水準滾動的數量 (以裝置為單位)。 這個參數的值必須是負值, 才能向左移動。

*dy*<br/>
指定垂直捲動的數量 (以裝置為單位)。 這個參數的值必須是負值, 才能向上滾動。

*lpRectScroll*<br/>
指向[矩形結構](/windows/desktop/api/windef/ns-windef-tagrect), 指定要滾動的工作區部分。 如果此參數為 Null, 則會滾動整個工作區。

*lpRectClip*<br/>
`RECT`指向結構, 指定要滾動的裁剪矩形。 這個結構優先于*lpRectScroll*所指向的矩形。 只有這個矩形內的位會進行滾動。 這個矩形外的位不會受到影響, 即使它們位於*lpRectScroll*矩形中也一樣。 如果此參數為 Null, 則不會在捲軸矩形上執行任何裁剪。

*prgnUpdate*<br/>
識別已修改的區域, 藉由滾動來將區域保留為無效。 這個參數可以是 Null。

*lpRectUpdate*<br/>
指向`RECT`結構, 其會透過捲軸來接收不正確矩形界限。 這個參數可以是 Null。

*flags*<br/>
可以具有下列其中一個值:

- 使用 SW_INVALIDATE 指定 SW_ERASE 時, 會將[WM_ERASEBKGND](/windows/desktop/winmsg/wm-erasebkgnd)訊息傳送至視窗, 以清除新的無效區域。

- SW_INVALIDATE 會使*prgnUpdate*在滾動後所識別的區域失效。

- SW_SCROLLCHILDREN 會將所有與所指向之矩形相交的子視窗, 以*dx*和*dy*中指定的圖元數目來進行滾動。 Windows 會將[WM_MOVE](/windows/desktop/winmsg/wm-move)訊息傳送到與*lpRectScroll*相交的所有子視窗, 即使沒有移動也一樣。 當子視窗滾動時, 插入號會重新置放, 而游標矩形會與滾動矩形相交。

### <a name="return-value"></a>傳回值

如果函式成功, 則傳回值為 SIMPLEREGION (矩形不正確區域)、COMPLEXREGION (非矩形的無效區域; 重迭的矩形) 或 NullREGION (沒有不正確區域)。否則傳回值為 ERROR。

### <a name="remarks"></a>備註

此函式與[ScrollWindow](/windows/desktop/api/winuser/nf-winuser-scrollwindow)函式類似, 還有一些額外的功能。

如果未指定[SW_INVALIDATE](/windows/desktop/api/winuser/nf-winuser-scrollwindowex)和[SW_ERASE](/windows/desktop/api/winuser/nf-winuser-scrollwindowex) , 則`ScrollWindowEx`成員函式不會使從外滾動的區域無效。 如果設定了其中一個旗標, `ScrollWindowEx`會使此區域失效。 除非應用程式呼叫[UpdateWindow](/windows/desktop/api/winuser/nf-winuser-updatewindow)成員函式、呼叫[RedrawWindow](/windows/desktop/api/winuser/nf-winuser-redrawwindow)成員函式 (指定[RDW_UPDATENOW](/windows/desktop/api/winuser/nf-winuser-redrawwindow)或[RDW_ERASENOW](/windows/desktop/api/winuser/nf-winuser-redrawwindow)), 或從中抓取[WM_PAINT](/windows/desktop/gdi/wm-paint)訊息, 否則此區域不會更新。應用程式佇列。

如果視窗具有[WS_CLIPCHILDREN](/windows/desktop/api/winuser/nf-winuser-createwindowa)樣式, *prgnUpdate*和*lpRectUpdate*所指定的傳回區域就會代表必須更新之滾動視窗的總區域, 包括需要更新之子視窗中的任何區域。

如果指定了[SW_SCROLLCHILDREN](/windows/desktop/api/winuser/nf-winuser-scrollwindowex)旗標, Windows 將不會在子視窗的一部分滾動時, 適當地更新畫面。 位於來源矩形外之滾動子視窗的部分不會被清除, 而且不會在其新的目的地中正確地重新繪製。 您可以使用[DeferWindowPos](/windows/desktop/api/winuser/nf-winuser-deferwindowpos) Windows 函式來移動未完全落在*lpRectScroll*矩形內的子視窗。 如果已設定 SW_SCROLLCHILDREN 旗標, 且插入號矩形與捲軸矩形相交, 則游標會重新置放。

所有的輸入和輸出座標 (針對*lpRectScroll*、 *lpRectClip*、 *lpRectUpdate*和*prgnUpdate*) 都會假設為在用戶端座標中, 不論視窗是否具有 CS_OWNDC 或 CS_CLASSDC 類別樣式。 如有需要, 請使用[LPtoDP](/windows/desktop/api/wingdi/nf-wingdi-lptodp)和[DPtoLP](/windows/desktop/api/wingdi/nf-wingdi-dptolp) Windows 函式來轉換為邏輯座標。

##  <a name="sendchildnotifylastmsg"></a>  CWnd::SendChildNotifyLastMsg

此成員函式是由架構呼叫, 以提供通知訊息給子視窗, 從父視窗, 讓子視窗可以處理工作。

```
BOOL SendChildNotifyLastMsg(LRESULT* pResult = NULL);
```

### <a name="parameters"></a>參數

*pResult*<br/>
子視窗所產生的結果, 由父視窗傳回。

### <a name="return-value"></a>傳回值

如果子視窗已處理傳送至其父系的訊息, 則為非零值;否則為0。

### <a name="remarks"></a>備註

`SendChildNotifyLastMsg`如果訊息是反映的訊息, 請將目前的訊息傳送至來源。

如需訊息反映的詳細資訊, 請參閱[處理反映的訊息](../../mfc/handling-reflected-messages.md)。

##  <a name="senddlgitemmessage"></a>  CWnd::SendDlgItemMessage

將訊息傳送至控制項。

```
LRESULT SendDlgItemMessage(
    int nID,
    UINT message,
    WPARAM wParam = 0,
    LPARAM lParam = 0);
```

### <a name="parameters"></a>參數

*nID*<br/>
指定將接收訊息之對話方塊控制項的識別碼。

*message*<br/>
指定要傳送的訊息。

*wParam*<br/>
指定與訊息相關的其他資訊。

*lParam*<br/>
指定與訊息相關的其他資訊。

### <a name="return-value"></a>傳回值

指定控制項的視窗程式所傳回的值; 如果找不到控制項, 則為0。

### <a name="remarks"></a>備註

在`SendDlgItemMessage`處理訊息之前, 成員函式不會傳回。

使用`SendDlgItemMessage`等同于`CWnd`取得指定控制項的 * 並呼叫[SendMessage](#sendmessage)成員函式。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#113](../../mfc/reference/codesnippet/cpp/cwnd-class_54.cpp)]

##  <a name="sendmessage"></a>  CWnd::SendMessage

將指定的訊息傳送到這個視窗。

```
LRESULT SendMessage(
    UINT message,
    WPARAM wParam = 0,
    LPARAM lParam = 0);
```

### <a name="parameters"></a>參數

*message*<br/>
指定要傳送的訊息。

*wParam*<br/>
指定與訊息相關的其他資訊。

*lParam*<br/>
指定與訊息相關的其他資訊。

### <a name="return-value"></a>傳回值

訊息處理的結果;其值取決於傳送的訊息。

### <a name="remarks"></a>備註

此`SendMessage`成員函式會直接呼叫視窗程式, 而不會傳回, 直到該視窗程式處理訊息為止。 這與[PostMessage](#postmessage)成員函式相反, 它會將訊息放入視窗的訊息佇列中, 並立即傳回。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#101](../../mfc/reference/codesnippet/cpp/cwnd-class_41.cpp)]

##  <a name="sendmessagetodescendants"></a>  CWnd::SendMessageToDescendants

呼叫這個成員函式, 將指定的 Windows 訊息傳送至所有子系視窗。

```
void SendMessageToDescendants(
    UINT message,
    WPARAM wParam = 0,
    LPARAM lParam = 0,
    BOOL bDeep = TRUE,
    BOOL bOnlyPerm = FALSE);
```

### <a name="parameters"></a>參數

*message*<br/>
指定要傳送的訊息。

*wParam*<br/>
指定與訊息相關的其他資訊。

*lParam*<br/>
指定與訊息相關的其他資訊。

*bDeep*<br/>
指定要搜尋的層級。 若為 TRUE, 則以遞迴方式搜尋所有子系;如果為 FALSE, 則只搜尋直接子系。

*bOnlyPerm*<br/>
指定訊息是否將由暫存視窗接收。 若為 TRUE, 則暫存視窗可以接收訊息;如果為 FALSE, 則只有永久的視窗會接收訊息。 如需有關暫存視窗的詳細資訊, 請參閱[技術提示 3](../../mfc/tn003-mapping-of-windows-handles-to-objects.md)。

### <a name="remarks"></a>備註

如果*bDeep*為 FALSE, 則訊息只會傳送至視窗的直屬子系;否則, 訊息會傳送至所有子系視窗。

如果*bDeep*和*bOnlyPerm*為 TRUE, 則搜尋會繼續放在暫存視窗底下。 在此情況下, 只有在搜尋期間遇到的永久性 windows 才會收到訊息。 如果*bDeep*為 FALSE, 則訊息只會傳送至視窗的直屬子系。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#114](../../mfc/reference/codesnippet/cpp/cwnd-class_55.cpp)]

##  <a name="sendnotifymessage"></a>  CWnd::SendNotifyMessage

將指定的訊息傳送至視窗。

```
BOOL SendNotifyMessage(
    UINT message,
    WPARAM wParam,
    LPARAM lParam);
```

### <a name="parameters"></a>參數

*message*<br/>
指定要傳送的訊息。

*wParam*<br/>
指定與訊息相關的其他資訊。

*lParam*<br/>
指定與訊息相關的其他資訊。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

如果視窗是由呼叫執行緒所建立, `SendNotifyMessage`則會呼叫視窗的視窗程式, 而不會傳回, 直到視窗程式處理訊息為止。 如果視窗是由不同的執行緒所建立, `SendNotifyMessage`則會將訊息傳遞至視窗程式並立即傳回, 而不會等候視窗程式完成訊息處理。

##  <a name="setactivewindow"></a>  CWnd::SetActiveWindow

建立`CWnd`使用中視窗。

```
CWnd* SetActiveWindow();
```

### <a name="return-value"></a>傳回值

先前使用中的視窗。

傳回的指標可能是暫時性的, 不應該儲存以供稍後使用。

### <a name="remarks"></a>備註

`SetActiveWindow`成員函式應謹慎使用, 因為它可讓應用程式任意接管使用中視窗和輸入焦點。 一般來說, Windows 會負責所有啟用。

##  <a name="setcapture"></a>  CWnd::SetCapture

不論游標的位置為何, 都會將所有後續的`CWnd`滑鼠輸入傳送至目前的物件。

```
CWnd* SetCapture();
```

### <a name="return-value"></a>傳回值

先前收到所有滑鼠輸入之 window 物件的指標。 如果沒有這種視窗, 則為 Null。 傳回的指標可能是暫時性的, 不應該儲存以供稍後使用。

### <a name="remarks"></a>備註

當`CWnd`不再需要所有的滑鼠輸入時, 應用程式應該呼叫[ReleaseCapture](/windows/desktop/api/winuser/nf-winuser-releasecapture)函數, 讓其他視窗可以接收滑鼠輸入。

當系統捕捉到滑鼠輸入時, 不會將任何 WM_NCHITTEST 或 WM_SETCURSOR 訊息傳送到使用中視窗。

##  <a name="setcaretpos"></a>  CWnd::SetCaretPos

設定插入號的位置。

```
static void PASCAL SetCaretPos(POINT point);
```

### <a name="parameters"></a>參數

*point*<br/>
指定插入號的新 x 和 y 座標 (以工作區座標表示)。

### <a name="remarks"></a>備註

`SetCaretPos`成員函式只有在目前工作中的視窗擁有時, 才會移動插入號。 `SetCaretPos`不論插入號是否隱藏, 都會移動插入號。

插入號是共用資源。 如果不擁有插入號, 視窗就不應移動插入號。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#115](../../mfc/reference/codesnippet/cpp/cwnd-class_56.cpp)]

##  <a name="setclipboardviewer"></a>  CWnd::SetClipboardViewer

每當剪貼簿的內容變更時, 就會將此視窗加入通知的視窗鏈 (透過 WM_DRAWCLIPBOARD 訊息)。

```
HWND SetClipboardViewer();
```

### <a name="return-value"></a>傳回值

如果成功, 則為剪貼簿-檢視器鏈中下一個視窗的控制碼。 應用程式應該儲存此控制碼 (可以儲存為成員變數), 並在回應剪貼簿-檢視器鏈訊息時使用。

### <a name="remarks"></a>備註

視窗的剪貼簿檢視器鏈結的一部分必須回應[WM_DRAWCLIPBOARD](#ondrawclipboard)， [WM_CHANGECBCHAIN](#onchangecbchain)，和[WM_DESTROY](#ondestroy)訊息，並將訊息傳遞至下一步鏈結中的視窗。

此成員函式會將 WM_DRAWCLIPBOARD 訊息傳送至視窗。 由於尚未傳回剪貼簿-檢視器鏈中下一個視窗的控制碼, 因此應用程式不應傳遞在呼叫`SetClipboardViewer`期間所收到的 WM_DRAWCLIPBOARD 訊息。

若要從剪貼簿-檢視器鏈中移除本身, 應用程式必須呼叫[ChangeClipboardChain](#changeclipboardchain)成員函式。

##  <a name="setdlgctrlid"></a>  CWnd::SetDlgCtrlID

將視窗的視窗識別碼或控制項 ID 設定為新的值。

```
int SetDlgCtrlID(int nID);
```

### <a name="parameters"></a>參數

*nID*<br/>
要為控制項的識別碼設定的新值。

### <a name="return-value"></a>傳回值

如果成功, 則為視窗的先前識別碼;否則為0。

### <a name="remarks"></a>備註

此視窗可以是任何子視窗, 而不只是對話方塊中的控制項。 視窗不可以是最上層視窗。

##  <a name="setdlgitemint"></a>  CWnd::SetDlgItemInt

將對話方塊中特定控制項的文字, 設定為指定整數值的字串表示。

```
void SetDlgItemInt(
    int nID,
    UINT nValue,
    BOOL bSigned = TRUE);
```

### <a name="parameters"></a>參數

*nID*<br/>
指定要變更之控制項的整數識別碼。

*nValue*<br/>
指定用來產生專案文字的整數值。

*bSigned*<br/>
指定整數值是否為帶正負號或不帶正負號。 如果此參數為 TRUE, 則*n 值*會經過簽署。 如果此參數為 TRUE 且*n 值*小於 0, 則負號會放在字串中的第一個數位之前。 如果此參數為 FALSE, 則表示*n 值*不帶正負號。

### <a name="remarks"></a>備註

`SetDlgItemInt`將[WM_SETTEXT](/windows/desktop/winmsg/wm-settext)訊息傳送至指定的控制項。

### <a name="example"></a>範例

  請參閱[CWnd:: SetDlgItemText](#setdlgitemtext)的範例。

##  <a name="setdlgitemtext"></a>  CWnd::SetDlgItemText

設定視窗或對話方塊所擁有之控制項的標題或文字。

```
void SetDlgItemText(
    int nID,
    LPCTSTR lpszString);
```

### <a name="parameters"></a>參數

*nID*<br/>
識別要設定其文字的控制項。

*lpszString*<br/>
指向[CString](../../atl-mfc-shared/reference/cstringt-class.md)物件或以 null 終止的字串, 其中包含要複製到控制項的文字。

### <a name="remarks"></a>備註

`SetDlgItemText`將[WM_SETTEXT](/windows/desktop/winmsg/wm-settext)訊息傳送至指定的控制項。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#116](../../mfc/reference/codesnippet/cpp/cwnd-class_57.cpp)]

##  <a name="setforegroundwindow"></a>  CWnd::SetForegroundWindow

將建立視窗的執行緒放置到前景並啟動視窗。

```
BOOL SetForegroundWindow();
```

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

鍵盤輸入會導向至視窗, 而使用者會變更各種視覺提示。 前景視窗是使用者目前正在使用的視窗。 前景視窗僅適用于最上層視窗 (框架視窗或對話方塊)。

### <a name="example"></a>範例

  請參閱[CWnd:: FindWindow](#findwindow)的範例。

##  <a name="setfocus"></a>  CWnd::SetFocus

宣告輸入焦點。

```
CWnd* SetFocus();
```

### <a name="return-value"></a>傳回值

先前具有輸入焦點的 window 物件指標。 如果沒有這種視窗, 則為 Null。 傳回的指標可能是暫時性的, 不應儲存。

### <a name="remarks"></a>備註

輸入焦點會將所有後續鍵盤輸入導向此視窗。 任何先前具有輸入焦點的視窗都會失去它。

成員函式會將[WM_KILLFOCUS](/windows/desktop/inputdev/wm-killfocus)訊息傳送到失去輸入焦點的視窗, 並將 [WM_SETFOCUS](/windows/desktop/inputdev/wm-setfocus) 訊息傳送至接收輸入焦點的視窗。`SetFocus` 它也會啟用視窗或其父系。

如果目前的視窗作用中, 但沒有焦點 (也就是沒有任何視窗具有焦點), 則任何按下的按鍵都會產生[WM_SYSCHAR](#onsyschar)、 [WM_SYSKEYDOWN](#onsyskeydown)或[WM_SYSKEYUP](#onsyskeyup)訊息。

##  <a name="setfont"></a>  CWnd::SetFont

將 WM_SETFONT 訊息傳送至視窗, 以使用指定的字型。

```
void SetFont(
    CFont* pFont,
    BOOL bRedraw = TRUE);
```

### <a name="parameters"></a>參數

*pFont*<br/>
指向 `CFont` 物件的指標。

*bRedraw*<br/>
TRUE 表示視窗在處理 WM_SETFONT 訊息之後立即重繪;否則為 FALSE。

### <a name="remarks"></a>備註

除非視窗處理 WM_SETFONT 訊息, 否則此方法不會有任何作用。 許多衍生自`CWnd`的 MFC 類別會處理此訊息, 因為它們會附加至預先定義的視窗類別, 其中包含 WM_SETFONT 訊息的訊息處理常式。 若要使用這個方法, 您衍生自`CWnd`的類別必須定義 WM_SETFONT 訊息的方法處理常式。

##  <a name="seticon"></a>  CWnd::SetIcon

呼叫這個成員函式, 將控制碼設定為特定的圖示, 如*hIcon*所識別。

```
HICON SetIcon(
    HICON hIcon,
    BOOL bBigIcon);
```

### <a name="parameters"></a>參數

*hIcon*<br/>
上一個圖示的控制碼。

*bBigIcon*<br/>
若為 TRUE, 則指定32圖元 (依32圖元圖示)。如果為 FALSE, 則指定16圖元 x 16 圖元圖示。

### <a name="return-value"></a>傳回值

圖示的控制碼。

### <a name="remarks"></a>備註

註冊視窗類別時, 它會選取一個圖示。

### <a name="example"></a>範例

  請參閱[CWnd:: GetSystemMenu](#getsystemmenu)的範例。

##  <a name="setlayeredwindowattributes"></a>  CWnd::SetLayeredWindowAttributes

設定分層視窗的不透明和透明色鍵。

```
BOOL SetLayeredWindowAttributes(
    COLORREF crKey,
    BYTE bAlpha,
    DWORD dwFlags);
```

### <a name="parameters"></a>參數

*crKey*<br/>
COLORRE光圈值的指標, 指定撰寫分層視窗時要使用的透明度色彩索引鍵。 視窗在此色彩中繪製的所有圖元都是透明的。 若要產生 COLORREF, 請使用 RGB 宏。

*bAlpha*<br/>
用來描述分層視窗之不透明度的 Alpha 值。 如需詳細資訊, 請`SourceConstantAlpha`參閱[BLENDFUNCTION](/windows/desktop/api/wingdi/ns-wingdi-blendfunction)結構的成員。 當*bAlpha*為0時, 視窗會完全透明。 當*bAlpha*為255時, 視窗是不透明的。

*dwFlags*<br/>
指定要採取的動作。 這個參數可以是下列一個或多個值。 如需可能值的清單, 請參閱[setlayeredwindowattributes 簡單](/windows/desktop/api/winuser/nf-winuser-setlayeredwindowattributes)。

### <a name="return-value"></a>傳回值

如果函式成功則為非零值，否則為 0。

### <a name="remarks"></a>備註

此成員函式會模擬函數[setlayeredwindowattributes 簡單](/windows/desktop/api/winuser/nf-winuser-setlayeredwindowattributes)的功能, 如 Windows SDK 中所述。

##  <a name="setmenu"></a>  CWnd::SetMenu

將目前的功能表設定為指定的功能表。

```
BOOL SetMenu(CMenu* pMenu);
```

### <a name="parameters"></a>參數

*pMenu*<br/>
識別新的功能表。 如果此參數為 Null, 則會移除目前的功能表。

### <a name="return-value"></a>傳回值

如果功能表已變更, 則為非零值;否則為0。

### <a name="remarks"></a>備註

會重新繪製視窗以反映功能表變更。

`SetMenu`將不會損毀上一個功能表。 應用程式應該呼叫[CMenu::D estroymenu](../../mfc/reference/cmenu-class.md#destroymenu)成員函式來完成這項工作。

### <a name="example"></a>範例

  請參閱[CMenu:: LoadMenu](../../mfc/reference/cmenu-class.md#loadmenu)的範例。

##  <a name="setowner"></a>  CWnd::SetOwner

將目前視窗的擁有者設定為指定的 window 物件。

```
void SetOwner(CWnd* pOwnerWnd);
```

### <a name="parameters"></a>參數

*pOwnerWnd*<br/>
識別視窗物件的新擁有者。 如果此參數為 Null, 則視窗物件沒有擁有者。

### <a name="remarks"></a>備註

然後, 這個擁有者就可以從目前的視窗物件接收命令訊息。 根據預設, 目前視窗的父系是其擁有者。

在與視窗階層無關的視窗物件之間建立連接通常會很有用。 例如, [CToolBar](../../mfc/reference/ctoolbar-class.md)會將通知傳送給其擁有者, 而不是傳送至其父系。 這可讓工具列成為一個視窗 (例如 OLE 容器應用程式視窗) 的子系, 同時將通知傳送至另一個視窗 (例如就地框架視窗)。 此外, 當您在就地編輯期間停用或啟用伺服器視窗時, 框架視窗所擁有的任何視窗都會隱藏或顯示。 這個擁有權是透過呼叫來`SetOwner`明確設定。

此功能的擁有權概念與[GetWindow](/windows/desktop/api/winuser/nf-winuser-getwindow)的擁有權概念不同。

##  <a name="setparent"></a>  CWnd::SetParent

變更子視窗的父視窗。

```
CWnd* SetParent(CWnd* pWndNewParent);
```

### <a name="parameters"></a>參數

*pWndNewParent*<br/>
識別新的父視窗。

### <a name="return-value"></a>傳回值

如果成功, 則為先前父視窗物件的指標。 傳回的指標可能是暫時性的, 不應該儲存以供稍後使用。

### <a name="remarks"></a>備註

如果子視窗可見, Windows 就會執行適當的重繪和重新繪製。

##  <a name="setproperty"></a>  CWnd::SetProperty

呼叫這個成員函式, 以設定*dwDispID*所指定的 OLE 控制項屬性。

```
void AFX_CDECL SetProperty(
    DISPID dwDispID,
    VARTYPE vtProp, ...);
```

### <a name="parameters"></a>參數

*dwDispID*<br/>
識別要設定的屬性。

*vtProp*<br/>
指定要設定的屬性類型。 如需可能的值，請參閱 [COleDispatchDriver::InvokeHelper](../../mfc/reference/coledispatchdriver-class.md#invokehelper)的＜備註＞一節。

*...*<br/>
*VtProp*所指定之類型的單一參數。

### <a name="remarks"></a>備註

> [!NOTE]
> 此函式只能在代表 OLE 控制項`CWnd`的物件上呼叫。

如需搭配使用這個成員函式與 OLE 控制項容器的詳細資訊, [請參閱 ActiveX 控制項容器:在 ActiveX 控制項容器](../../mfc/programming-activex-controls-in-a-activex-control-container.md)中程式設計 activex 控制項。

##  <a name="setredraw"></a>  CWnd::SetRedraw

應用程式會`SetRedraw`呼叫以允許重新繪製變更, 或防止重新繪製變更。

```
void SetRedraw(BOOL bRedraw = TRUE);
```

### <a name="parameters"></a>參數

*bRedraw*<br/>
指定重繪旗標的狀態。 如果此參數為 TRUE, 則會設定重繪旗標;如果為 FALSE, 則表示旗標已清除。

### <a name="remarks"></a>備註

此成員函式會設定或清除重繪旗標。 清除重繪旗標時, 不會在每次變更後更新內容, 而且在設定重繪旗標之前不會重新繪製。 例如, 需要將數個專案新增至清單方塊的應用程式可以清除重繪旗標、新增專案, 然後設定重繪旗標。 最後, 應用程式可以呼叫 [[無效](#invalidate)] 或 [ [InvalidateRect](#invalidaterect) ] 成員函式, 讓清單方塊重新繪製。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#117](../../mfc/reference/codesnippet/cpp/cwnd-class_58.cpp)]

##  <a name="setscrollinfo"></a>  CWnd::SetScrollInfo

呼叫這個成員函式, 以設定`SCROLLINFO`結構維護捲軸的相關資訊。

```
BOOL SetScrollInfo(
    int nBar,
    LPSCROLLINFO lpScrollInfo,
    BOOL bRedraw = TRUE);
```

### <a name="parameters"></a>參數

*nBar*<br/>
指定捲軸是否為控制項或視窗非工作區的一部分。 如果它是非工作區的一部分, nBar 也會指出捲軸是以水準、垂直或兩者的方式放置。 它必須是下列其中一項:

- SB_CTL 包含捲軸控制項的參數。 `m_hWnd`資料成員必須是捲軸控制項的控制碼。

- SB_HORZ 指定視窗是水準捲軸。

- SB_VERT 指定視窗是垂直捲動條。

*lpScrollInfo*<br/>
[SCROLLINFO](/windows/win32/api/winuser/ns-winuser-scrollinfo)結構的指標。 如需此結構的詳細資訊, 請參閱 Windows SDK。

*bRedraw*<br/>
指定是否應該重新繪製捲軸以反映新的位置。 如果*bRedraw*為 TRUE, 則會重新繪製捲軸。 如果為 FALSE, 則不會重新繪製。 預設會重新繪製捲軸。

### <a name="return-value"></a>傳回值

如果成功, 則傳回為 TRUE。 否則為 FALSE。

### <a name="remarks"></a>備註

[SCROLLINFO](/windows/win32/api/winuser/ns-winuser-scrollinfo)結構包含捲軸的相關資訊, 包括最小和最大的滾動位置、頁面大小, 以及捲動方塊的位置 (thumb)。 如需`SCROLLINFO`變更結構預設值的詳細資訊, 請參閱 Windows SDK 中的結構主題。

指出捲軸位置[CWnd:: OnHScroll](#onhscroll)和[CWnd:: OnVScroll](#onvscroll)的 MFC Windows 訊息處理常式, 只提供16個位的位置資料。 [GetScrollInfo](#getscrollinfo)並`SetScrollInfo`提供32位的捲軸位置資料。 因此, 應用程式可以在`GetScrollInfo` `CWnd::OnHScroll`處理或`CWnd::OnVScroll`時呼叫, 以取得32位的捲軸位置資料。

> [!NOTE]
> [CWnd:: GetScrollInfo](#getscrollinfo)可讓應用程式使用32位的捲軸位置。

##  <a name="setscrollpos"></a>  CWnd::SetScrollPos

設定捲動方塊的目前位置, 並在要求時重新繪製捲軸, 以反映捲動方塊的新位置。

```
int SetScrollPos(
    int nBar,
    int nPos,
    BOOL bRedraw = TRUE);
```

### <a name="parameters"></a>參數

*nBar*<br/>
指定要設定的捲軸。 這個參數可以是下列其中一項:

- SB_HORZ 會在視窗的水準捲軸中設定捲動方塊的位置。

- SB_VERT 會在視窗的垂直捲動條中設定捲動方塊的位置。

*nPos*<br/>
指定捲動方塊的新位置。 它必須在滾動範圍內。

*bRedraw*<br/>
指定是否應該重新繪製捲軸以反映新的捲動方塊位置。 如果此參數為 TRUE, 則會重新繪製捲軸;如果為 FALSE, 則不會重新繪製捲軸。

### <a name="return-value"></a>傳回值

捲動方塊的先前位置。

### <a name="remarks"></a>備註

當後續呼叫另一個函式時, 將*bRedraw*設定為 FALSE 會很有用。

##  <a name="setscrollrange"></a>  CWnd::SetScrollRange

設定給定捲軸的最小和最大位置值。

```
void SetScrollRange(
    int nBar,
    int nMinPos,
    int nMaxPos,
    BOOL bRedraw = TRUE);
```

### <a name="parameters"></a>參數

*nBar*<br/>
指定要設定的捲軸。 這個參數可以是下列其中一個值:

- SB_HORZ 設定視窗水準捲軸的範圍。

- SB_VERT 設定視窗垂直捲動條的範圍。

*nMinPos*<br/>
指定最小的滾動位置。

*nMaxPos*<br/>
指定最大的滾動位置。

*bRedraw*<br/>
指定是否應該重新繪製捲軸以反映變更。 如果*bRedraw*為 TRUE, 則會重新繪製捲軸;如果為 FALSE, 則不會重新繪製捲軸。

### <a name="remarks"></a>備註

它也可以用來隱藏或顯示標準捲軸。

應用程式不應該呼叫此函式, 在處理捲軸通知訊息時隱藏捲軸。

如果呼叫`SetScrollRange`緊接在呼叫[SetScrollPos](#setscrollpos)成員函式之後, `SetScrollPos`成員函式中的*bRedraw*參數應為 0, 以防止捲軸繪製兩次。

標準捲軸的預設範圍為0到100。 捲軸控制項的預設範圍是空的 ( *nMinPos*和*nMaxPos*值都是 0)。 *NMinPos*和*nMaxPos*所指定的值之間的差異, 不得大於 INT_MAX。

##  <a name="settimer"></a>  CWnd::SetTimer

安裝系統計時器。

```
UINT_PTR SetTimer(
    UINT_PTR nIDEvent,
    UINT nElapse,
    void (CALLBACK* lpfnTimer)(HWND,
    UINT,
    UINT_PTR,
    DWORD));
```

### <a name="parameters"></a>參數

*nIDEvent*<br/>
指定非零的計時器識別碼。 如果計時器識別碼是唯一的, 則會傳回這個相同的`SetTimer`值。 否則, `SetTimer`會判斷新的唯一值, 並傳回它。 對於視窗計時器 (具有 Null 回呼函式), 只有與目前視窗相關聯的其他 windows 計時器值才必須是唯一的。 針對回呼計時器, 所有進程中的所有計時器的值都必須是唯一的。 因此, 當您建立回呼計時器時, 傳回的值可能會與您指定的值不同。

*nElapse*<br/>
指定超時值或間隔 (以毫秒為單位)。

*lpfnTimer*<br/>
指定應用程式提供`TimerProc`的回呼函式的位址, 該函數會處理[WM_TIMER](/windows/desktop/winmsg/wm-timer)的訊息。 如果此參數為 Null, 則 WM_TIMER 訊息會放在應用程式的訊息佇列中, 並由`CWnd`物件處理。

### <a name="return-value"></a>傳回值

如果函式成功, 則為新計時器的計時器識別碼。 這個值不一定等於透過*nIDEvent*參數傳入的值。 應用程式應該一律將傳回值傳遞給[KillTimer](#killtimer)成員函式, 以終止計時器。 如果成功, 則為非零;否則為0。

### <a name="remarks"></a>備註

系統會指定間隔值, 而且每次間隔結束時, 系統會將 WM_TIMER 訊息張貼到安裝應用程式的安裝訊息佇列, 或將訊息傳遞至應用程式定義`TimerProc`的回呼函式。

*LpfnTimer*回呼函式不需要命名`TimerProc`, 但必須宣告為靜態, 並定義如下。

```
void CALLBACK TimerProc(
    HWND hWnd,   // handle of CWnd that called SetTimer
    UINT nMsg,   // WM_TIMER
    UINT_PTR nIDEvent,   // timer identification
    DWORD dwTime    // system time);
```

### <a name="example"></a>範例

這個範例會`CWnd::SetTimer`使用`CWnd::OnTimer`、和`CWnd::KillTimer`來處理 WM_TIMER 訊息。 第一個計時器設定為每隔2秒`OnStartTimer`就會將 WM_TIMER 訊息傳送到主框架視窗。 `OnTimer`事件處理常式會處理主框架視窗的 WM_TIMER 訊息。 此方法會使電腦說話者每2秒發出嗶聲。 第二個計時器每隔3.75 秒就會將訊息傳送至回呼函式。 `OnStopTimer`會藉由呼叫`CWnd::KillTimer`每個計時器識別碼來停止這兩個計時器。

[!code-cpp[NVC_MFCWindowing#118](../../mfc/reference/codesnippet/cpp/cwnd-class_59.cpp)]

##  <a name="setwindowcontexthelpid"></a>  CWnd::SetWindowContextHelpId

呼叫這個成員函式, 讓說明內容識別碼與指定的視窗產生關聯。

```
BOOL SetWindowContextHelpId(DWORD dwContextHelpId);
```

### <a name="parameters"></a>參數

*dwContextHelpId*<br/>
說明內容識別碼。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

如果子視窗沒有說明內容識別碼, 它會繼承其父視窗的識別碼。 同樣地, 如果擁有的視窗沒有說明內容識別碼, 它會繼承其擁有者視窗的識別碼。 此繼承的說明內容識別碼可讓應用程式設定 對話方塊的單一識別項和所有控制項。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#119](../../mfc/reference/codesnippet/cpp/cwnd-class_60.cpp)]

##  <a name="setwindowplacement"></a>CWnd:: SetWindowPlacement

設定視窗的顯示狀態和一般 (還原)、最小化和最大化位置。

```
BOOL SetWindowPlacement(const WINDOWPLACEMENT* lpwndpl);
```

### <a name="parameters"></a>參數

*lpwndpl*<br/>
指向指定新顯示狀態和位置的[WINDOWPLACEMENT](/windows/desktop/api/winuser/ns-winuser-tagwindowplacement)結構。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

##  <a name="setwindowpos"></a>  CWnd::SetWindowPos

變更子系、快顯視窗和最上層視窗的大小、位置和迭置順序。

```
BOOL SetWindowPos(
    const CWnd* pWndInsertAfter,
    int x,
    int y,
    int cx,
    int cy,
    UINT nFlags);
```

### <a name="parameters"></a>參數

*pWndInsertAfter*<br/>
以迭置順序識別要在此`CWnd`物件前面 (高於) 的物件。`CWnd` 這個參數可以是的指標`CWnd` , 或是下列其中一個值的指標:

- `wndBottom`將視窗放在迭置順序的底部。 如果這`CWnd`是最上層的視窗, 視窗會失去其最上層狀態; 系統會將視窗放在所有其他視窗的底部。

- `wndTop`將視窗放在迭置順序的頂端。

- `wndTopMost`將視窗放在所有非最上層視窗的上方。 視窗會維持其最上層的位置, 即使它已停用也一樣。

- `wndNoTopMost`將視窗重新置放至所有非最上層視窗的頂端 (也就是在所有最上層視窗後方)。 如果視窗已經是非最上層的視窗, 這個旗標沒有任何作用。

如需有關如何使用此參數的規則, 請參閱本主題的「備註」一節。

*x*<br/>
指定視窗左側的新位置。

*y*<br/>
指定視窗頂端的新位置。

*cx*<br/>
指定視窗的新寬度。

*cy*<br/>
指定視窗的新高度。

*nFlags*<br/>
指定調整大小和位置選項。 這個參數可以是下列旗標的組合:

- SWP_DRAWFRAME 會在視窗周圍繪製框架 (在建立視窗時定義)。

- SWP_FRAMECHANGED 會將 WM_NCCALCSIZE 訊息傳送至視窗, 即使視窗的大小並未變更也一樣。 如果未指定此旗標, 只有在變更視窗的大小時, 才會傳送 WM_NCCALCSIZE。

- SWP_HIDEWINDOW 會隱藏視窗。

- SWP_NOACTI加值稅E 不會啟動視窗。 如果未設定此旗標, 則會啟動視窗, 並將其移至最上層或非最上層群組的頂端 (視*pWndInsertAfter*參數的設定而定)。

- SWP_NOCOPYBITS 會捨棄工作區的整個內容。 如果未指定此旗標, 則會在視窗大小或重新置放後, 將工作區的有效內容儲存並複製回工作區。

- SWP_NOMOVE 會保留目前的位置 (忽略*x*和*y*參數)。

- SWP_NOOWNERZORDER 不會變更擁有者視窗在迭置順序中的位置。

- SWP_NOREDRAW 不會重新繪製變更。 如果設定此旗標, 則不會重新繪製任何類型。 這適用于工作區、非工作區 (包括標題和捲軸), 以及因移動視窗而被視為的父視窗的任何部分。 設定此旗標時, 應用程式必須明確地使必須重新繪製的視窗和父視窗的任何部分失效或重繪。

- SWP_NOREPOSITION 與 SWP_NOOWNERZORDER 相同。

- SWP_NOSENDCHANGING 會防止視窗接收 WM_WINDOWPOSCHANGING 訊息。

- SWP_NOSIZE 會保留目前的大小 (忽略*cx*和*cy*參數)。

- SWP_NOZORDER 會保留目前的順序 (忽略*pWndInsertAfter*)。

- SWP_SHOWWINDOW 會顯示視窗。

### <a name="return-value"></a>傳回值

如果函式成功, 則為非零;否則為0。

### <a name="remarks"></a>備註

視窗會根據其迭置順序在畫面上排序;位於 Z 順序頂端的視窗會顯示在順序中的所有其他視窗之上。

子視窗的所有座標都是用戶端座標 (相對於父視窗工作區的左上角)。

視窗可以移到疊置順序的頂端設定*pWndInsertAfter*參數 **& wndTopMost**並確保未設定 SWP_NOZORDER 旗標，或設定視窗的疊置順序，其值高於任何現有的最上層視窗。 當非最上層的視窗設為最上層時, 其擁有的視窗也會成為最上層。 其擁有者不會變更。

如果最上方的視窗重新置放至迭置順序的底部 ( **& wndBottom**), 或在任何非最上層視窗之後, 就不再是最上層。 當最上層的視窗設為非最上層時, 其所有擁有者及其擁有的視窗也會成為非最上層視窗。

如果未指定 SWP_NOACTI加值稅E 或 SWP_NOZORDER (也就是當應用程式要求同時啟用視窗並以指定的迭置順序) 時, 就只會在下列情況下使用*pWndInsertAfter*中指定的值。具體

- 不會在*pWndInsertAfter*參數中指定 **& wndTopMost** , 也不會 **& wndNoTopMost** 。

- 這個視窗不是使用中視窗。

應用程式無法啟動非作用中視窗, 也不會將它帶入迭置順序的頂端。 應用程式可以變更已啟用視窗的迭置順序, 而不會有任何限制。

非最上層的視窗可能會擁有最上層的視窗, 而不是反之亦然。 最上層視窗所擁有的任何視窗 (例如對話方塊) 本身都會成為最上層的視窗, 以確保所有擁有的視窗都維持在其擁有者的上方。

在 Windows 版本3.1 和更新版本中, windows 可以移到迭置順序的頂端, 並藉由設定其 WS_EX_TOPMOST 樣式來鎖定。 這種最上層的視窗會維持其最上層的位置, 即使停用也一樣。 例如, 選取 [WinHelp Always On Top] 命令會將 [說明] 視窗放在最上層, 然後在您返回應用程式時保持可見。

若要建立最上層視窗, `SetWindowPos`請呼叫, 並使用等於 **& wndTopMost**的*pWndInsertAfter*參數, 或在建立視窗時設定 WS_EX_TOPMOST 樣式。

如果迭置順序包含任何具有 WS_EX_TOPMOST 樣式的視窗, 則以 **& wndTopMost**值移動的視窗會放在所有非最上層視窗的頂端, 但在任何最上層視窗的下方。 當應用程式啟動不含 WS_EX_TOPMOST 位的非作用中視窗時, 視窗會移至所有非最上層視窗, 但在任何最上層視窗的上方。

如果`SetWindowPos`在*pWndInsertAfter*參數 **& wndBottom**時呼叫, 而且`CWnd`是最頂端的視窗, 視窗會失去其最上層狀態 (WS_EX_TOPMOST 已清除), 而系統會將視窗放在迭置順序。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#120](../../mfc/reference/codesnippet/cpp/cwnd-class_61.cpp)]

##  <a name="setwindowrgn"></a>  CWnd::SetWindowRgn

呼叫此成員函式以設定視窗的區域。

```
int SetWindowRgn(
    HRGN hRgn,
    BOOL bRedraw);
```

### <a name="parameters"></a>參數

*hRgn*<br/>
區域的控制碼。

*bRedraw*<br/>
若為 TRUE, 則作業系統會在設定區域之後重新繪製視窗;否則, 就不會這麼做。 一般來說, 如果視窗是可見的, 則將*bRedraw*設定為 TRUE。 如果設定為 TRUE, 系統就會將 WM_WINDOWPOSCHANGING 和 WM_WINDOWPOSCHANGED 訊息傳送至視窗。

### <a name="return-value"></a>傳回值

如果函式成功, 則傳回值為非零。 如果此函式失敗，則傳回值為零。

### <a name="remarks"></a>備註

視窗的視窗區域座標相對於視窗的左上角, 而不是視窗的工作區。

在成功呼叫`SetWindowRgn`之後, 作業系統會擁有區域控制碼*hRgn*所指定的區域。 作業系統不會建立區域的複本, 因此不會對此區域控制碼進行任何進一步的函式呼叫, 也不會關閉此區域控制碼。

##  <a name="setwindowtext"></a>  CWnd::SetWindowText

將視窗的標題設定為指定的文字。

```
void SetWindowText(LPCTSTR lpszString);
```

### <a name="parameters"></a>參數

*lpszString*<br/>
指向[CString](../../atl-mfc-shared/reference/cstringt-class.md)物件或以 null 終止的字串, 做為新的標題或控制項文字。

### <a name="remarks"></a>備註

如果視窗是控制項, 則會設定控制項內的文字。

此函式會將[WM_SETTEXT](/windows/desktop/winmsg/wm-settext)訊息傳送到這個視窗。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#121](../../mfc/reference/codesnippet/cpp/cwnd-class_62.cpp)]

##  <a name="showcaret"></a>CWnd:: ShowCaret

在螢幕上的插入號目前位置上顯示插入號。

```
void ShowCaret();
```

### <a name="remarks"></a>備註

顯示後，插入號會開始自動閃爍。

`ShowCaret`成員函式只有在有目前的圖形, 且未連續重複兩次或多次時, 才會顯示插入號。 如果插入號不是此視窗的擁有者, 則不會顯示插入號。

隱藏插入號是累計的。 如果已多次呼叫[HideCaret](#hidecaret)成員函式, `ShowCaret`則必須呼叫五次以顯示插入號。

插入號是共用資源。 只有當視窗具有輸入焦點或為作用中時, 才會顯示插入號。

### <a name="example"></a>範例

  請參閱[CWnd:: CreateCaret](#createcaret)的範例。

##  <a name="showownedpopups"></a>CWnd:: ShowOwnedPopups

顯示或隱藏此視窗所擁有的所有快顯視窗。

```
void ShowOwnedPopups(BOOL bShow = TRUE);
```

### <a name="parameters"></a>參數

*bShow*<br/>
指定是否要顯示或隱藏快顯視窗。 如果此參數為 TRUE, 則會顯示所有隱藏的快顯視窗。 如果此參數為 FALSE, 則會隱藏所有可見的快顯視窗。

### <a name="example"></a>範例

  請參閱[CWnd:: SetWindowPos](#setwindowpos)的範例。

##  <a name="showscrollbar"></a>CWnd:: ShowScrollBar

顯示或隱藏捲軸。

```
void ShowScrollBar(
    UINT nBar,
    BOOL bShow = TRUE);
```

### <a name="parameters"></a>參數

*nBar*<br/>
指定捲軸是否為控制項或視窗非工作區的一部分。 如果它是非工作區的一部分, *nBar*也會指出捲軸是以水準、垂直或兩者的方式放置。 它必須是下列其中一項:

- SB_BOTH 指定視窗的水準和垂直捲動條。

- SB_HORZ 指定視窗是水準捲軸。

- SB_VERT 指定視窗是垂直捲動條。

*bShow*<br/>
指定 Windows 是否要顯示或隱藏捲軸。 如果此參數為 TRUE, 則會顯示捲軸;否則會隱藏捲軸。

### <a name="remarks"></a>備註

在處理捲軸通知`ShowScrollBar`訊息時, 應用程式不應呼叫來隱藏捲軸。

##  <a name="showwindow"></a>  CWnd::ShowWindow

設定視窗的可見度狀態。

```
BOOL ShowWindow(int nCmdShow);
```

### <a name="parameters"></a>參數

*nCmdShow*<br/>
指定要如何`CWnd`顯示。 它必須是下列其中一個值:

- SW_HIDE 會隱藏此視窗, 並將啟用傳遞至另一個視窗。

- SW_MINIMIZE 會將視窗最小化, 並啟用系統清單中的最上層視窗。

- SW_RESTORE 會啟用並顯示視窗。 如果視窗最小化或最大化, Windows 就會將它還原成原始大小和位置。

- SW_SHOW 會啟動視窗, 並以其目前的大小和位置顯示。

- SW_SHOWMAXIMIZED 會啟用視窗, 並將它顯示為最大化的視窗。

- SW_SHOWMINIMIZED 會啟用視窗, 並將它顯示為圖示。

- SW_SHOWMINNOACTIVE 會將視窗顯示為圖示。 目前作用中的視窗仍為使用中狀態。

- SW_SHOWNA 會將視窗顯示為目前狀態。 目前作用中的視窗仍為使用中狀態。

- SW_SHOWNOACTI加值稅E 會將視窗顯示在其最新的大小和位置。 目前作用中的視窗仍為使用中狀態。

- SW_SHOWNORMAL 會啟用並顯示視窗。 如果視窗最小化或最大化, Windows 就會將它還原成原始大小和位置。

### <a name="return-value"></a>傳回值

如果視窗先前為可見, 則為非零;如果先前已`CWnd`隱藏, 則為0。

### <a name="remarks"></a>備註

`ShowWindow`針對具有[CWinApp:: m_nCmdShow](../../mfc/reference/cwinapp-class.md#m_ncmdshow)的主視窗, 每個應用程式都只能呼叫一次。 後續對的`ShowWindow`呼叫必須使用上述其中一個值, 而不是所`CWinApp::m_nCmdShow`指定的值。

### <a name="example"></a>範例

  請參閱[CWnd:: CalcWindowRect](#calcwindowrect)的範例。

##  <a name="subclassdlgitem"></a>CWnd:: SubclassDlgItem

呼叫這個成員函式以「動態子類別化」從對話方塊範本建立的控制項, 並將`CWnd`它附加到這個物件。

```
BOOL SubclassDlgItem(
    UINT nID,
    CWnd* pParent);
```

### <a name="parameters"></a>參數

*nID*<br/>
控制項的識別碼。

*pParent*<br/>
控制項的父系 (通常是對話方塊)。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

當控制項動態子類別化時, windows 訊息會透過`CWnd`的訊息對應來路由傳送, 並先`CWnd`在的類別中呼叫訊息處理常式。 傳遞至基類的訊息會傳遞至控制項中的預設訊息處理常式。

此成員函式會將 Windows 控制項附加`CWnd`至物件, 並取代控制項`WndProc`的`AfxWndProc`和函式。 函式會將舊`WndProc`的儲存在`GetSuperWndProcAddr`成員函式所傳回的位置。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#122](../../mfc/reference/codesnippet/cpp/cwnd-class_63.cpp)]

##  <a name="subclasswindow"></a>CWnd:: Subclasswindow 前允許

呼叫這個成員函式以「動態子類別化」視窗, 並將`CWnd`它附加到這個物件。

```
BOOL SubclassWindow(HWND hWnd);
```

### <a name="parameters"></a>參數

*hWnd*<br/>
視窗的控制碼。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

當視窗以動態方式子類別化時, windows 訊息會`CWnd`透過的訊息對應來路由傳送, 並`CWnd`先在的類別中呼叫訊息處理常式。 傳遞至基類的訊息會傳遞至視窗中的預設訊息處理常式。

此成員函式會將 Windows 控制項附加`CWnd`至物件, 並取代視窗`WndProc`的`AfxWndProc`和函式。 函式會將指標儲存至`WndProc` `CWnd`物件中的舊。

> [!NOTE]
> 呼叫此函式時, 視窗必須尚未附加至 MFC 物件。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#123](../../mfc/reference/codesnippet/cpp/cwnd-class_64.cpp)]

##  <a name="unlockwindowupdate"></a>  CWnd::UnlockWindowUpdate

呼叫這個成員函式可將鎖定`CWnd::LockWindowUpdate`的視窗解除鎖定。

```
void UnlockWindowUpdate();
```

### <a name="remarks"></a>備註

一次只能使用`LockWindowUpdate`一個視窗來鎖定。 如需有關鎖定視窗的詳細資訊, 請參閱[CWnd:: LockWindowUpdate](#lockwindowupdate)或 Win32 函數[LockWindowUpdate](/windows/desktop/api/winuser/nf-winuser-lockwindowupdate) 。

##  <a name="unsubclasswindow"></a>CWnd:: UnsubclassWindow

呼叫這個成員函式, `WndProc`將設定回其原始值, 並將 HWND 所識別的視窗`CWnd`從物件卸離。

```
HWND UnsubclassWindow();
```

### <a name="return-value"></a>傳回值

Unsubclassed 視窗的控制碼。

### <a name="example"></a>範例

  請參閱[CWnd:: subclasswindow 前允許](#subclasswindow)的範例。

##  <a name="updatedata"></a>  CWnd::UpdateData

呼叫這個成員函式以初始化對話方塊中的資料, 或是抓取和驗證對話資料。

```
BOOL UpdateData(BOOL bSaveAndValidate = TRUE);
```

### <a name="parameters"></a>參數

*bSaveAndValidate*<br/>
指出對話方塊是否正在初始化 (FALSE) 或正在抓取資料的旗標 (TRUE)。

### <a name="return-value"></a>傳回值

如果作業成功, 則為非零;否則為0。 如果*bSaveAndValidat*e 為 TRUE, 則傳回值為非零表示已成功驗證資料。

### <a name="remarks"></a>備註

在預設的`UpdateData` [CDialog:: OnInitDialog](../../mfc/reference/cdialog-class.md#oninitdialog)執行中建立強制回應對話方塊時, 架構會自動呼叫, 並將*bSaveAndValidate*設為 FALSE。 呼叫會在對話方塊可見前發生。 [CDialog:: OnOK](../../mfc/reference/cdialog-class.md#onok)的預設實值會呼叫這個成員函式, 並將*BSAVEANDVALIDATE*設為 TRUE 來抓取資料, 如果成功, 將會關閉對話方塊。 (如果在對話方塊中按一下 [取消] 按鈕, 則會關閉對話方塊, 而不會抓取資料)。

##  <a name="updatedialogcontrols"></a>  CWnd::UpdateDialogControls

呼叫這個成員函式可在使用[ON_UPDATE_COMMAND_UI](message-map-macros-mfc.md#on_update_command_ui)回呼機制的對話方塊或視窗中, 更新對話方塊按鈕和其他控制項的狀態。

```
void UpdateDialogControls(
    CCmdTarget* pTarget,
    BOOL bDisableIfNoHndler);
```

### <a name="parameters"></a>參數

*pTarget*<br/>
指向 應用程式的主框架視窗，並用於路由更新訊息。

*bDisableIfNoHndler*<br/>
旗標, 指出沒有更新處理常式的控制項是否應該自動顯示為停用。

### <a name="remarks"></a>備註

如果子控制項沒有處理常式, 而且*bDisableIfNoHndler*為 TRUE, 則會停用子控制項。

架構會在應用程式的閒置處理過程中, 針對對話方塊列或工具列中的控制項呼叫這個成員函式。

##  <a name="updatelayeredwindow"></a>  CWnd::UpdateLayeredWindow

更新分層視窗的位置、大小、形狀、內容和透明度。

```
BOOL UpdateLayeredWindow(
    CDC* pDCDst,
    POINT* pptDst,
    SIZE* psize,
    CDC* pDCSrc,
    POINT* pptSrc,
    COLORREF crKey,
    BLENDFUNCTION* pblend,
    DWORD dwFlags);
```

### <a name="parameters"></a>參數

*pDCDst*<br/>
螢幕之裝置內容的指標。 當視窗內容更新時, 它會用於調色板色彩比對。 如果*pDCDst*為 Null, 則會使用預設的調色板。

如果*pDCSrc*為 null, 則*PDCDST*必須是 null。

*pptDst*<br/>
`POINT`結構的指標, 指定分層視窗的新螢幕位置。 如果目前的位置並未變更, *pptDst*可以是 Null。

*psize*<br/>
`SIZE`結構的指標, 指定分層視窗的新大小。 如果視窗的大小沒有變更, *psize*可以是 Null。

如果*pDCSrc*為 null, 則*PSIZE*必須是 null。

*pDCSrc*<br/>
定義分層視窗之介面的 DC 指標。 如果視窗的圖形和視覺化內容未變更, 則*pDCSrc*可以是 Null。

*pptSrc*<br/>
`POINT`結構的指標, 指定裝置內容中的圖層位置。

如果*pDCSrc*為 Null, *PPTSRC*應該是 null。

*crKey*<br/>
COLORRE光圈值的指標, 指定撰寫分層視窗時要使用的透明度色彩索引鍵。 視窗在此色彩中繪製的所有圖元都是透明的。 若要產生 COLORREF, 請使用 RGB 宏。

*pblend*<br/>
[BLENDFUNCTION](/windows/desktop/api/wingdi/ns-wingdi-blendfunction)結構的指標, 指定撰寫分層視窗時要使用的透明度值。

*dwFlags*<br/>
指定要採取的動作。 這個參數可以是下列一個或多個值。 如需可能值的清單, 請參閱[UpdateLayeredWindow](/windows/desktop/api/winuser/nf-winuser-updatelayeredwindow)。

### <a name="return-value"></a>傳回值

如果函式成功則為非零值，否則為 0。

### <a name="remarks"></a>備註

此成員函式會模擬函數[UpdateLayeredWindow](/windows/desktop/api/winuser/nf-winuser-updatelayeredwindow)的功能, 如 Windows SDK 中所述。

##  <a name="updatewindow"></a>  CWnd::UpdateWindow

如果更新區域不是空的, 則藉由傳送[WM_PAINT](/windows/desktop/gdi/wm-paint)訊息來更新工作區。

```
void UpdateWindow();
```

### <a name="remarks"></a>備註

`UpdateWindow`成員函式會直接傳送 WM_PAINT 訊息, 略過應用程式佇列。 如果更新區域是空的, 則不會傳送 WM_PAINT。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#124](../../mfc/reference/codesnippet/cpp/cwnd-class_65.cpp)]

##  <a name="validaterect"></a>  CWnd::ValidateRect

藉由從視窗的更新區域移除矩形, 驗證給定矩形內的工作區。

```
void ValidateRect(LPCRECT lpRect);
```

### <a name="parameters"></a>參數

*lpRect*<br/>
指向[CRect](../../atl-mfc-shared/reference/crect-class.md)物件或[RECT 結構](/windows/desktop/api/windef/ns-windef-tagrect), 其中包含要從更新區域中移除之矩形的用戶端座標。 如果*lpRect*為 Null, 則會驗證整個視窗。

### <a name="remarks"></a>備註

[BeginPaint](#beginpaint)成員函式會自動驗證整個工作區。 如果需要驗證更新區域的一部分, 才會下一次產生[WM_PAINT](/windows/desktop/gdi/wm-paint) , 則不應呼叫 或 [ValidateRgn](#validatergn) 成員函`ValidateRect`式。

Windows 會繼續產生 WM_PAINT 訊息, 直到驗證目前的更新區域為止。

##  <a name="validatergn"></a>  CWnd::ValidateRgn

藉由從視窗目前的更新區域移除區域, 驗證給定區域內的工作區。

```
void ValidateRgn(CRgn* pRgn);
```

### <a name="parameters"></a>參數

*pRgn*<br/>
[CRgn](../../mfc/reference/crgn-class.md)物件的指標, 識別定義要從更新區域中移除之區域的區域。 如果此參數為 Null, 則會移除整個工作區。

### <a name="remarks"></a>備註

指定的區域必須已經由區域函式建立。 區域座標會假設為用戶端座標。

[BeginPaint](#beginpaint)成員函式會自動驗證整個工作區。 既不[ValidateRect](#validaterect)和`ValidateRgn`應該呼叫成員函式，如果必須在下一步 之前進行驗證的更新區域一部分[WM_PAINT](/windows/desktop/gdi/wm-paint)會產生訊息。

##  <a name="windowfrompoint"></a>  CWnd::WindowFromPoint

抓取包含指定點的視窗;*點*必須指定螢幕上某個點的螢幕座標。

```
static CWnd* PASCAL WindowFromPoint(POINT point);
```

### <a name="parameters"></a>參數

*point*<br/>
指定[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)物件或[點](/windows/desktop/api/windef/ns-windef-tagpoint)資料結構, 其定義要檢查的點。

### <a name="return-value"></a>傳回值

點所在的視窗物件指標。 如果指定的點上沒有視窗存在, 則為 Null。 傳回的指標可能是暫時性的, 不應該儲存以供稍後使用。

### <a name="remarks"></a>備註

`WindowFromPoint`不會抓取隱藏或停用的視窗, 即使該點位於視窗內也一樣。 應用程式應該使用[ChildWindowFromPoint](#childwindowfrompoint)成員函式來進行限制性搜尋。

##  <a name="windowproc"></a>  CWnd::WindowProc

提供`CWnd`物件的 Windows 程式`WindowProc`()。

```
virtual LRESULT WindowProc(
    UINT message,
    WPARAM wParam,
    LPARAM lParam);
```

### <a name="parameters"></a>參數

*message*<br/>
指定要處理的 Windows 訊息。

*wParam*<br/>
提供用來處理訊息的其他資訊。 參數值取決於訊息。

*lParam*<br/>
提供用來處理訊息的其他資訊。 參數值取決於訊息。

### <a name="return-value"></a>傳回值

傳回值取決於訊息。

### <a name="remarks"></a>備註

它會透過視窗的訊息對應來分派訊息。

##  <a name="winhelp"></a>  CWnd::WinHelp

呼叫以初始化 WinHelp 應用程式。

```
virtual void WinHelp(
    DWORD_PTR dwData,
    UINT nCmd = HELP_CONTEXT);
```

### <a name="parameters"></a>參數

*dwData*<br/>
指定其他資料。 使用的值取決於*nCmd*參數的值。

*nCmd*<br/>
指定要求的說明類型。 如需可能值的清單, 以及它們對*dwData*參數的影響, 請參閱 Windows SDK 中的[WinHelp](/windows/desktop/api/winuser/nf-winuser-winhelpa) Windows 函式。

### <a name="remarks"></a>備註

如需詳細資訊, 請參閱[CWinApp:: WinHelp](../../mfc/reference/cwinapp-class.md#winhelp) 。

##  <a name="registertouchwindow"></a>  CWnd::RegisterTouchWindow

註冊或取消註冊 Windows touch 支援。

```
BOOL RegisterTouchWindow(
    BOOL bRegister = TRUE,
    ULONG ulFlags = 0);
```

### <a name="parameters"></a>參數

*bRegister*<br/>
TRUE 表示註冊 Windows touch 支援;否則為 FALSE。

*ulFlags*<br/>
指定選擇性修改的一組位旗標。 此欄位可包含0或下列其中一個值:TWF_FINETOUCH, TWF_WANTPALM.

### <a name="return-value"></a>傳回值

如果成功，則為 TRUE，否則為 FALSE。

### <a name="remarks"></a>備註

##  <a name="resizedynamiclayout"></a>  CWnd::ResizeDynamicLayout

如果已啟用視窗的動態配置，則會在視窗大小變更以調整子視窗的版面配置時由架構呼叫。

```
virtual void ResizeDynamicLayout();
```

### <a name="remarks"></a>備註

## <a name="see-also"></a>另請參閱

[CCmdTarget 類別](../../mfc/reference/ccmdtarget-class.md)<br/>
[階層架構圖表](../../mfc/hierarchy-chart.md)<br/>
[CFrameWnd 類別](../../mfc/reference/cframewnd-class.md)<br/>
[CView 類別](../../mfc/reference/cview-class.md)
