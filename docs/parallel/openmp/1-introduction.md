---
title: 1. 簡介
ms.date: 01/16/2019
ms.assetid: c42e72bc-0e31-4b1c-b670-cd82673c0c5a
ms.openlocfilehash: 60a5090814b722cc0d9f6e51ab9038e697a4ed2a
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 07/27/2020
ms.locfileid: "87231646"
---
# <a name="1-introduction"></a>1.簡介

本檔指定編譯器指示詞、程式庫函式和環境變數的集合，您可以用來在 C 和 c + + 程式中指定共用記憶體平行處理。 本檔中所述的功能統稱為*OpenMP C/c + + 應用程式介面（API）*。 此規格的目標是要提供平行程式設計的模型，讓您可以在不同廠商的共用記憶體架構之間進行移植。 許多廠商的編譯器都支援 OpenMP C/c + + API。 如需 OpenMP 的詳細資訊（包括*Openmp Fortran 應用程式介面*），請參閱下列網站：

[https://www.openmp.org](https://www.openmp.org)

本檔中所定義的指示詞、程式庫函式和環境變數，可讓您建立和管理平行程式，同時允許可攜性。 指示詞會使用單一程式多個資料（SPMD）結構、工作共用結構和同步處理結構來擴充 C 和 c + + 順序程式設計模型。 它們也支援共用和私有化資料。 支援 OpenMP C 和 c + + API 的編譯器包含命令列選項，可讓編譯器啟動並允許解讀所有 OpenMP 編譯器指示詞。

## <a name="11-scope"></a>1.1 範圍

此規格僅涵蓋使用者導向的平行處理，您可以在其中明確定義編譯器和執行時間系統以平行方式執行程式所採取的動作。 不需要 OpenMP C 和 c + + 實作為檢查相依性、衝突、鎖死、競爭條件，或造成程式執行不正確的其他問題。 您必須負責確保使用 OpenMP C 和 c + + API 結構的應用程式正確執行。 編譯器為編譯器產生的自動平行處理和指示詞，可協助這類平行處理不涵蓋在本檔中。

## <a name="12-definition-of-terms"></a>1.2 詞彙的定義

本檔中使用下列詞彙：

- barrier

  小組中所有線程都必須達到的同步處理點。  每個執行緒都會等到小組中的所有線程到達此時間點。 透過指示詞和由執行所建立的隱含屏障來識別明確的障礙。

- 建構

  結構是語句。 其中包含一個指示詞，後面接著結構化的區塊。 有些指示詞不是結構的一部分。 （請參閱[附錄 C](c-openmp-c-and-cpp-grammar.md)中*的 openmp*指示詞）。

- 指示詞

  C 或 c + + `#pragma` ，後面接著 `omp` 識別碼、其他文字和新行。 指示詞會指定程式列為。

- 動態範圍

  在*詞法範圍*中的所有語句，加上在詞法範圍內執行語句所執行之函式內的任何語句。 動態範圍也稱為「*區域*」。

- 詞法範圍

  在*結構化區塊*中的語句。

- 主要執行緒

  在輸入*平列區域*時建立小組的執行緒。

- 平列區域

  系結至 OpenMP 平行結構，且可由許多執行緒執行的語句。

- private

  私用變數會為建立參考的執行緒，命名唯一的儲存區。 有數種方式可指定變數為私用：在平列區域、指示詞 `threadprivate` 、 `private` 、 `firstprivate` 、或子句中的定義 `lastprivate` `reduction` ，或在緊接于或指示詞之後，將變數當做迴圈 **`for`** 中的迴圈控制變數使用 **`for`** `for` `parallel for` 。

- region

  動態範圍。

- 序欄區域

  只有在任何*平列區域*的動態範圍外，*主要執行緒*才會執行語句。

- serialize

  若要使用下列方式執行平行結構：

  - 由只有單一線程（這是該平行結構的主要執行緒）組成的執行緒小組，

  - 結構化區塊內語句的執行序列順序（與區塊不屬於平行結構的順序相同），以及

  - 不會影響所傳回的值 `omp_in_parallel()` （除了任何嵌套平行結構的效果外）。

- 共用

  共用變數會將單一儲存體區塊命名為。 小組中存取此變數的所有線程也會存取此單一儲存區塊。

- 結構化區塊

  結構化區塊是具有單一專案和單一結束的語句（單一或複合）。 如果跳出或跳出語句，該語句就是結構化的區塊。 （此規則包含對的呼叫 `longjmp`（3C）或使用 `throw` ，雖然允許對的呼叫 `exit` 。）如果它的執行一律從開頭開始， `{` 而且一律在結束時結束 `}` ，複合陳述式就是結構化區塊。 運算式語句、選取語句、反覆運算語句或 **`try`** 區塊是結構化的區塊，如果對應的複合陳述式是以的方式包含在中，則會是 `{` `}` 結構化的區塊。 跳躍語句、標記的語句或宣告語句不是結構化的區塊。

- 小組

  一或多個執行緒在執行結構時協同合作。

- 執行緒

  執行實體具有控制項的序列流程、一組私用變數和共用變數的存取權。

- 變動

  識別碼（選擇性地以命名空間名稱限定），其名稱為物件。

## <a name="13-execution-model"></a>1.3 執行模型

OpenMP 會使用平行執行的分叉聯結模型。 雖然這個分叉聯結模型有助於解決各種問題，但它是針對大型陣列型應用程式量身打造的。 OpenMP 的目的是要支援以平行程式（許多執行中的執行緒和完整的 OpenMP 支援程式庫）正確執行的程式。 這也適用于依序執行的程式（已忽略的指示詞，以及簡單的 OpenMP 存根程式庫）。 不過，在循序執行時，可以並允許開發不正確行為的程式。 此外，由於數值運算關聯的變更，不同程度的平行處理原則可能會產生不同的數值結果。 例如，序列新增縮減的加法關聯模式可能與平行縮減不同。 這些不同的關聯可能會變更浮點加法的結果。

以 OpenMP C/c + + API 撰寫的程式會開始執行，做為單一執行緒的執行，稱為「*主要執行緒*」。 主要執行緒會在序欄區域中執行，直到遇到第一個平行結構為止。 在 OpenMP C/c + + API 中，指示詞 `parallel` 構成平行結構。 遇到平行結構時，主要執行緒會建立執行緒的小組，而主伺服器會成為小組的主伺服器。 小組中的每個執行緒都會執行平列區域的動態範圍中的語句，但工作共用結構除外。 小組中的所有線程都必須以相同的順序遇到工作共用的結構，而且有一或多個執行緒會在相關聯的結構化區塊中執行語句。 `nowait`小組中的所有線程都會執行不含子句的工作共用結構結尾所隱含的屏障。

如果執行緒修改共用物件，它不僅會影響其本身的執行環境，也會影響程式中其他執行緒的工作。 只有在物件宣告為 volatile 時，才會從另一個執行緒的觀點來看，修改會在下一個序列點（如基礎語言中所定義）中完成。 否則，修改會保證在第一次修改執行緒之後才會完成。 接著，另一個執行緒（或同時） `flush` 會看到指定物件（隱含或明確）的指示詞。 當其他 OpenMP 指示詞所隱含的指示詞 `flush` 不保證副作用的正確順序時，程式設計人員必須負責提供其他明確的指示詞 `flush` 。

當平行結構完成時，小組中的執行緒會在隱含的屏障進行同步處理，而且只有主要執行緒會繼續執行。 可以在單一程式中指定任意數目的平行結構。 因此，程式可能會在執行期間分叉和聯結許多次。

OpenMP C/c + + API 可讓程式設計人員在平行結構中呼叫的函式中使用指示詞。 不會出現在平行結構的詞法範圍中，但可能位於動態範圍中的指示詞稱為「*孤立*的指示詞」。 透過孤立的指示詞，程式設計人員可以平行執行程式的主要部分，只對順序程式進行最小的變更。 透過這項功能，您可以在程式呼叫樹狀結構的最上層撰寫平行結構，並使用指示詞來控制任何被呼叫函式中的執行。

對 C 和 c + + 輸出函式的未同步呼叫若寫入相同的檔案，可能會導致輸出，由不同執行緒所寫入的資料會以不具決定性的順序出現。 同樣地，從相同檔案讀取之輸入函式的未同步呼叫，可能會以不具決定性的順序讀取資料。 非同步使用的 i/o，讓每個執行緒存取不同的檔案時，會產生與 i/o 函式序列執行相同的結果。

## <a name="14-compliance"></a>1.4 符合標準

如第1章、第2、3、4和附錄 C 所述，OpenMP C/c + + API 的執行符合並保留此規格所有元素的語義，這是*openmp 相容*的。附錄 A、B、D、E 和 F 僅供資訊之用，而不是規格的一部分。 只包含 API 子集的實作為不符合 OpenMP 規範。

OpenMP C 和 c + + API 是實作為基底語言的延伸模組，可支援它。 如果基底語言不支援本檔中所顯示的語言結構或延伸模組，則不需要 OpenMP 執行來支援它。

所有標準 C 和 c + + 程式庫函式和內建函數（也就是編譯器具有特定知識的函數）必須是安全線程。 平列區域內不同執行緒未同步使用安全線程函式，並不會產生未定義的行為。 不過，行為可能不會與序欄區域中的相同。 （亂數字產生函式是一個範例）。

OpenMP C/c + + API 會指定特定行為是*實作為定義的。* 若要在這些情況下定義和記錄其行為，必須要有符合規範的 OpenMP 執行。 如需執行定義的行為清單，請參閱[附錄 E](e-implementation-defined-behaviors-in-openmp-c-cpp.md)。

## <a name="15-normative-references"></a>1.5 規範參考

- ISO/IEC 9899:1999，*資訊技術-程式設計語言-C*。此 OpenMP API 規格將 ISO/IEC 9899:1999 視為 C99。

- ISO/IEC 9899:1990，*資訊技術-程式設計語言-C*。此 OpenMP API 規格將 ISO/IEC 9899:1990 視為 C90。

- ISO/IEC 14882:1998，*資訊技術-程式設計語言-c + +*。 此 OpenMP API 規格將 ISO/IEC 14882:1998 視為 c + +。

當此 OpenMP API 規格參考 C 時，會對該實作為支援的基底語言。

## <a name="16-organization"></a>1.6 組織

- [執行階段程式庫函式](3-run-time-library-functions.md)
- [環境變數](4-environment-variables.md)
- [OpenMP C/C++ 中的實作定義行為](e-implementation-defined-behaviors-in-openmp-c-cpp.md)
- [OpenMP C/c + + 版本2.0 中的新功能](f-new-features-and-clarifications-in-version-2-0.md)
