---
title: 迭代器
ms.date: 11/04/2016
helpviewer_keywords:
- iterator conventions
- C++ Standard Library, iterator conventions
ms.assetid: 2f746be7-b37d-4bfc-bf05-be4336ca982f
ms.openlocfilehash: c3bb2825ec6ad98f523fa4c3a616d0807eac50a8
ms.sourcegitcommit: 5ef9697b4cb1947bec9669be57bc920d2c4d82a6
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/06/2020
ms.locfileid: "87870148"
---
# <a name="iterators"></a>迭代器

迭代器是一種物件，可逐一查看「C++ 標準程式庫」容器中的元素，並提供個別元素的存取途徑。 「C++ 標準程式庫」容器都有提供迭代器，因此演算法能以標準方式存取其元素，而不需要考慮元素儲存所在容器的類型。

您可以使用成員和全域函式（如和） `begin()` `end()` 和運算子（例如 `++` 和） `--` 來向前或向後移動，以明確地使用反覆運算器。 您也可以使用反覆運算器，以隱含的範圍 for 迴圈，或 () 注標運算子的某些 iterator 類型 `[]` 。

在「C++ 標準程式庫」中，序列或範圍的開頭是第一個元素。 序列或範圍的結尾一律定義為最後一個元素之後的元素。 全域函式 `begin` ，並將反覆運算器傳回 `end` 至指定的容器。 一般明確迭代器會以迴圈方式處理容器中的所有元素，如下所示：

```cpp
vector<int> vec{ 0,1,2,3,4 };
for (auto it = begin(vec); it != end(vec); it++)
{
    // Access element using dereference operator
    cout << *it << " ";
}
```

使用 range-for 迴圈：

```cpp
for (auto num : vec)
{
    // no dereference operator
    cout << num << " ";
}
```

迭代器有五種分類。 為了增加能力，在這裡將分類為：

- **輸出**。 *輸出反覆運算器* `X` 可以使用運算子來逐一查看序列 `++` ，而且只能使用運算子來寫入元素一次 __`*`__ 。

- **輸入**。 *輸入反覆運算器* `X` 可以使用運算子，逐一查看序列上的 `++` ，而且可以使用運算子，以任意次數來讀取元素 `*` 。 您可以使用和運算子來比較輸入反覆運算器 `==` `!=` 。 在您遞增輸入反覆運算器的任何複本之後，就不能安全地比較、解除引用，或之後再增加任何複本。

- **轉寄**。 *正向反覆運算器* `X` 可以使用 + + 運算子逐一查看序列，並且可以使用運算子來讀取任何專案，或以任意次數寫入非 const 元素 `*` 。 您可以使用運算子來存取元素成員 `->` ，並使用和運算子來比較正向反覆運算器 `==` `!=` 。 您可以建立正向迭代器的多個複本，每個都可以取值 (Dereference)，而且獨立遞增。 未參考任何容器而初始化的正向反覆運算器，稱為*null 正向反覆運算器*。 Null 正向迭代器一律會以相等方式比較。

- **雙向**。 *雙向反覆運算器* `X` 可以取代正向反覆運算器。 不過，您也可以遞減雙向反覆運算器，如同 `--X` 、 `X--` 或 `(V = *X--)` 。 您可以使用與正向迭代器相同的方式來存取元素成員，以及比較雙向迭代器。

- **隨機存取**。 *隨機存取反覆運算器* `X` 可以取代雙向反覆運算器。 使用隨機存取反覆運算器，您可以使用注標運算子 `[]` 來存取元素。 您可以使用 `+` 、 `-` `+=` 和運算子， `-=` 向前或向後移動指定的專案數，並計算反覆運算器之間的距離。 您可以使用、、、、和來比較雙向反覆運算器 `==` `!=` `<` `>` `<=` `>=` 。

所有迭代器可以指派或複製。 它們會假設為輕量物件，而且通常會以傳值方式傳遞和傳回，而不是依參考。 另請注意，當在有效的迭代器上執行時，上述的作業均無法擲回例外狀況。

可以藉由顯示三個序列來摘要迭代器分類的階層。 對於序列的唯寫存取，您可以使用任一項：

> 輸出反覆運算器 \
> -> 正向反覆運算器 \
> -> 雙向反覆運算器 \
> -> 隨機存取反覆運算器

向右箭號表示「可以取代」。 舉例來說，任何需要輸出迭代器的演算法應該都可與正向迭代器妥善地搭配運作，但是反之則「不」** 然。

對於序列的唯讀存取，您可以使用任一項：

> 輸入反覆運算器 \
> -> 正向反覆運算器 \
> -> 雙向反覆運算器 \
> -> 隨機存取反覆運算器

在此案例中，輸入迭代器是所有分類中最薄弱的。

最後，對於序列的讀取/寫入存取，您可以使用任一項：

> 正向反覆運算器 \
> -> 雙向反覆運算器 \
> -> 隨機存取反覆運算器

物件指標一律可以當做隨機存取迭代器，所以如果它對於指定的序列支援讀取/寫入存取，則可以做為任何分類的迭代器。

物件指標以外的迭代器 `Iterator` 也必須定義特製化 `iterator_traits<Iterator>` 所需的成員類型。 藉由 `Iterator` 從公用基類[反覆運算器](../standard-library/iterator-struct.md)衍生，即可符合這些需求。

請務必瞭解每個反覆運算器分類的承諾和限制，以查看 c + + 標準程式庫中的容器和演算法如何使用反覆運算器。

> [!NOTE]
> 您可以透過使用 range-for 迴圈來避免使用迭代器。 如需詳細資訊，請參閱[以範圍為基礎的 for 語句](../cpp/range-based-for-statement-cpp.md)。

Microsoft c + + 現在提供已檢查的反覆運算器和偵錯工具反覆運算器，以確保您不會覆寫容器的界限。 如需詳細資訊，請參閱[已檢查的迭代器](../standard-library/checked-iterators.md)和[偵錯迭代器支援](../standard-library/debug-iterator-support.md)。

## <a name="see-also"></a>另請參閱

[C + + 標準程式庫參考](../standard-library/cpp-standard-library-reference.md)\
[C + + 標準程式庫中的執行緒安全](../standard-library/thread-safety-in-the-cpp-standard-library.md)
